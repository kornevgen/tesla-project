\section{Обзор работ по системному функциональному тестированию
микропроцессоров}

В настоящее время в практике тестирования микропроцессоров
распространены следующие подходы к построению тестовых программ:
\begin{itemize}
\item \emph{ручная разработка тестовых программ} хоть и практически неприменима
для полного тестирования микропроцессора, всё же может применяться
для тестирования особых, крайних случаев.
\item \emph{тестирование с использованием кросс-компиляции} применяется часто
из-за невысокой сложности его проведения: после согласования
спецификации микропроцессора можно начинать делать кросс-компилятор,
а код, предназначенный для кросс-компиляции, уже готов. Однако
гарантировать полноту такое тестирование не может.
\item \emph{случайная генерация тестовых программ} применяется так же часто в
силу простоты автоматизации. Такие тестовые программы позволяют
быстро обнаружить простые ошибки, однако опять же не гарантируют
полноты тестирования. Разрабатываются и более хитрые варианты
случайной генерации~\cite{muGP}.
\item \emph{случайная генерация тестовых программ на основе тестовых
шаблонов} предполагает разделение процесса генерации тестовой
программы на два этапа: на первом подготавливаются \emph{тестовые
шаблоны} -- абстрактные представления тестовых программ (вместо
указания конкретных параметров инструкций в тестовых шаблонах
указывается ограничения на параметры) -- а на втором этапе по
тестовым шаблонам генерируются тестовые программы. Второй этап
включает в себя \emph{генерацию тестовых данных}, т.е. генерацию
начальных значений регистров, ячеек кэш-памяти, строк TLB и т.д.
\end{itemize}

В решении задачи генерации тестовых данных можно выделить следующие
подходы:
\begin{itemize}
\item комбинаторные техники;
\item с использованием решения задачи ATPG;
\item с использованием разрешения ограничений.
\end{itemize}

\emph{Комбинаторные техники} применимы в случае простых тестовых
шаблонов. Ограничениями на переменные в таких тестовых шаблонах
являются указания домена. Все значения в домене равноправны и могут
появиться в тестовой программе. Однако данная техника требует
доведения всех ограничений в тестовом шаблоне до простой формы
(ограничение домена переменной), что удается сделать не всегда. В
работе исследователей из Fujitsu Lab.~\cite{TSE} предлагается
описывать тестовые программы в виде выражений (Test Specification
Expressions, TSE) и описывать инструкции микропроцессора на языке
ISDL. Специальный генератор строит тестовые программы,
удовлетворяющие TSE. Kohno и Matsumoto~\cite{mVpGen} рассматривают
задачу верификации конвейерных микропроцессоров, сводя ее к
генерации тестовых программ. В процессе своей работы генератор
строит тестовый шаблон, к которому применяются также комбинаторные
техники. Доменами переменных являются множество регистров и
множество констант, допустимых в качестве значений параметров
инструкций.

Исследователи из Politecnico di Milano~\cite{toATPG} предложили
генеровать тестовые данные с использованием \emph{ техник решения
задачи ATPG} (Automatic Test Pattern Generation). ATPG -- задача
поиска значений входных сигналов (<<векторов>>) схемы с целью поиска
ее некорректного поведения. ATPG чаще применяется для модульного
тестирования, если известна RTL-модель микропроцессора. Задача ATPG
известна давно и для ее решения существуют (в том числе
коммерческие) инструменты. Для применения ATPG при генерации
тестовых программ необходимо, чтобы RTL-модель микропроцессора была
готова к моменту генерации тестовых данных. Кроме того,
использование такой методики именно для функционального тестирования
ограничено, поскольку тесты на функционирование микропроцессора
приходится строить с учетом модели спроектированного
микропроцессора, которая сама же при этом будет и тестироваться.

Наиболее впечатляющих результатов достигают инструменты,
использующие для генерации тестовых данных \emph{разрешение
ограничений}. Ограничение с логической точки зрения то же, что и
предикат, а задача разрешения ограничений -- то же, что и задача
выполнимости системы предикатов, но для решения этой задачи
применяются специальные алгоритмы~\cite{ConstrProp}. В
работе~\cite{MAATG} исследователей из Китайского Национального
Университета технологий безопасности описывается инструмент MAATG.
Тестовый шаблон для него может содержать лишь ограничения равенства
или неравенства значений и указание области значений переменной. Для
задания архитектуры микропроцессора используется описание на языке
EXPRESSION. Другой инструмент -- Genesys-Pro~\cite{GenesysPro2004}
-- позиционируется компанией IBM как разработка, впитавшая лучшее из
разработок последних 20 лет. Тестовые шаблоны позволяют задавать
тестовые программы переменной длины. Для любой инструкции в тестовом
шаблоне может быть указана эвристика для выбора значений
параметров~\cite{GenesysPro2004Innovations}. Среди возможных
эвристик есть и эвристики на события в кэш-памяти и при трансляции
адресов. Однако в известных работах не раскрывается содержание таких
эвристик, что не дает возможности понять эффективность генерации
программ, нацеленных на тестирование памяти. Система команд
микропроцессора должна быть описана в виде ограничений (constraint
net) на операнды, код операции, что не является естественным
описанием поведения инструкции, особенно если в рамках нее
выполняется несколько последовательных вычислений на основе
параметров инструкции. Для генерации параметров очередной инструкции
Genesys-Pro использует уже построенную тестовую программу и
состояние микропроцессора, которое известно полностью. Этот подход
обеспечил масштабируемость на большие тестовые шаблоны, но и привел
к необходимости использования механизма возврата (backtracking),
если выбрать параметры для очередной инструкции невозможно.

%Кроме того инструмент не использует """функциональные связи"""
%разных команд, а генерирует значения параметров очередной команды,
%исходя из уже построенной части тестовой программы до этой команды.
%Иными словами, тестовая программа строится по-командно, что может
%отрицательно сказаться на эффективности работы Genesys-Pro на
%больших тестовых шаблонах.

% по большому счету Genesys-Pro лишь строит параметры очередной команды,
% а я ставлю более сложную задачу - кроме параметров сгенерировать и
% начальное состояние! В IBM поступают хитрее: самое сложное - начальное
% состояние уже известно (в т.ч. все сеты), а генератор просто "выбирает".
% сравните: cache = [ set1:0,5,10; set2:2,4,7 ], select(set,tag: cache miss)
% -> задача: set isin {1,2}, tag ~isin cache(set). Решаем сначала первый предикат,
% затем второй. Получаем set = 1, tag = 1. Всё просто.
% И сравните это с тем, что у меня: (set,tag): cache miss,.... И все!
% тут надо описать, что такое miss.

В данной работе при решении задачи генерации тестовых данных также
используется разрешение ограничений. В отличие от MAATG тестовые
шаблоны могут содержать не просто ограничения равенства или
неравенства, а более сложные ограничения, например, кэш-промах. А по
сравнению с Genesys-Pro в данной статье делается попытка
транслировать тестовый шаблон в ограничения
целиком~\footnote{Известно, что задача разрешения ограничений (т.е.
задача выполнимости) NP-полна. Это означает, что для больших
тестовых шаблонов предлагаемый в данной статье метод может быть не
столь эффективным. Однако действительно длинные тестовые шаблоны в
практике тестирования микропроцессоров применяются редко.}. При этом
отпадает необходимость в механизме возврата~\footnote{Из-за этого
качественно меняется разрешаемая система ограничений. Genesys-Pro
сводит общую задачу к множеству задач, на порядок меньшей сложности.
Кроме того, в данной статье предлагается более технологичный метод
построения тестовых данных: описание архитектуры микропроцессора
может быть получено из стандарта архитектуры микропроцессора и
представляет собой понятное для человека императивное задание.}.
Особенностью тестовых шаблонов, получаемых в рамках~\cite{kamkin},
является фиксация для каждой инструкции регистров-параметров. Для
таких шаблонов Genesys-Pro будет работать крайне неэффективно,
поскольку теряется возможность с помощью выбора параметров
<<подогнать>> исполнение очередной инструкции под заданные в
тестовом шаблоне для нее события. На тестовых шаблонах
из~\cite{kamkin} Genesys-Pro будет работать следующим образом:
выберет некоторое начальное состояние микропроцессора, начнет
исполнять тестовый шаблон (поскольку начальное состояние ему
известно), но как только дойдет до инструкции, которая будет
исполнена не так, как требуется в шаблоне, Genesys-Pro сделает
возврат в самое начало, а именно ему придется выбрать другое
начальное состояние микропроцессора и весь процесс запустить заново.
Такой процесс генерации тестовых данных слишком неэффективен. Для
задания схемы трансляции адресов в Genesys-Pro предлагается
использовать подход DeepTrans~\cite{DeepTrans}. Однако по имеющимся
работам невозможно сделать вывод о том, как такая схема трансляции
адресов отображается в ограничения~\footnote{Авторы статьи
используют при описании способа трансляции адреса элементы массива
Memory с неизвестными индексами. Известно, что попытки построения
ограничений, описывающих работу с элементами массива при неизвестных
индексах, приводит к очень сложным ограничениям, разрешимость
которых за приемлимое время можно поставить под сомнение.}. Кроме
того попытка наивного переноса идей из представленных в обзоре
инструментов (кодирование изменений состояния каждого регистра и
зависимостей между ними в виде ограничений) для инструкций работы с
памятью приводит к очень сложным ограничениям%~\footnote{Даже без
%учета трансляции адресов для кодирования состояния микропроцессора
%можно использовать формулу длиной порядка размера памяти ($mem_0 =
%var0 \wedge mem_1 = var1 \wedge ...$); каждое изменение производится
%по неизвестному индексу, поэтому при записи нового состояния
%микропроцессора приходится перебирать все возможные варианты
%($mem[i] := x$ приводит к формуле $(i = 0 \wedge mem_0 = x \wedge
%mem_1 = var1 \wedge ...) \vee (i = 1 \wedge mem_0 = var0 \wedge
%mem_1 = x \wedge ...) \vee ...$), а если таких изменений несколько,
%то приходится рассматривать все возможные варианты значений
%индексов. Получающаяся формула имеет размер порядка $|L| \cdot 2^n$,
%где $|L|$ -- размер памяти, а $n$ -- количество изменений памяти. В
%данной работе предложен метод кодирования изменений, приводящий к
%формуле размера порядка $|L| + n$.}
, которые не удается разрешить за приемлемое время.

% отличия от Genesys-Pro:
% 1) другой алгоритм обработки тестового шаблона:
%    тестовый шаблон рассматривается целиком, а не по одной команде
% 2) задача построения тестовых данных (особенно, начального состояния)
%    выражена более логично. Genesys-Pro не ищет их, а выбирает просто числа
%    наобум. Если нельзя выбрать, откат. А у меня именно поиск.
% 3) используются более логичное описание тестовых ситуаций.
%    Не ограничения, а императив.
% 4) ниже сложность написания модели тестовых ситуаций, поскольку они уже
%    описаны в документации на стандарт архитектуры :)
% 5) Genesys-Pro на тестовых шаблонах, где нет возможности что-то подобрать
%   (как, например, в Сашиных шаблонах), будет работать крайне неэффективно,
%   ибо эффективность работы Genesys-Pro достигается и за счет того, что он сам
%   может выбирать аргументы, например, регистры, если в шаблоне нет указания,
%   какой это должен быть регистр. На Сашиных шаблонах Genesys-Pro предположит
%   некоторое начальное состояние микропроцессора, а затем начнет просто исполнять
%   шаблон (поскольку в Сашиных шаблонах все регистры уже выбраны). Можно выбирать
%   значения констант - на этом может сыграть Genesys-Pro. И вот если при исполнении
%   тестового шаблона не происходит указанных тестовых ситуаций, Genesys-Pro
%   откатится к самому началу и выберет другое начальное состояние. Опять исполнит
%   тестовый шаблон. Если не получилось, снова возврат и снова подбор начального значения.
%   Такая схема неэффективна в нашей постановке задачи!
