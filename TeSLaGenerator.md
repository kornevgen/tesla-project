# Цель проекта #

Дать возможность использовать TeSLa людям, не знакомым (или не хотящим знакомиться) с особенностями языка описания тестовых ситуаций. В таком случае тестовые ситуации могут быть описаны на подмножестве языка Java с использованием некоторого framework'а, а запуск написанного Java-кода даст набор TeSLa-описаний тестовых ситуаций.

# Прагматика и сущность проекта #

Вместо Java+framework=>TeSLa можно было пойти другим путем - пользователь пишет на известном ему языке "спецификацию", описание тестовой ситуации, а специальный транслятор анализирует это описание **статически**, т.е. как последовательность символов. И на основании этой последовательности символов строит исходный TeSLa-текст. Однако при таком **статическом** методе возникает проблема поиска подходящего языка спецификации:
  * с наличием возможности описать функцию без побочного эффекта
  * однако с передачей параметров **по ссылке** (обычные функциональные языки передают параметры по значению и этот момент принципиальный)
  * с наличием (или возможность получить из них) битовых операций получения бита, диапазона бит, битовой конкатенацией (поэтому не подходит обычная Java)
  * с возможностью запретить рекурсию в вызовах методов
  * с возможностью выделить специальные методы (LoadMemory, StoreMemory, AddressTranslation)
  * с возможностью нескольких возвращаемых значений (поэтому не подходят стандартные императивные языки).

По причине отсутствия подходящего языка был применен иной, **динамический** подход: код на Java с использованием специального framework'а в результате своей работы строит набор TeSLa-определений, описывающих осуществляемые проверки. При этом решено использовать конструкции управления из языка Java:
  * последовательность
  * условный оператор
  * оператор цикла - только for с константными ограничениями! (посмотреть возможность трансляции других в TeSLa)
  * вызовы методов (?)
но иные структуры данных (нежели скалярные типы, массивы и произвольные объекты в Java).

Чем-то такие описания (и сам "динамический" метод их генерации) напоминает аналогичный в Genesys-Pro, где тестовый шаблон анализируется не статически (как у меня), а динамически, и для каждой очередной сгенерированной "инструкции" генерируются тестовые данные. "Динамический" метод применяется также, например, в JUnit. Напрямую "динамический" метод используется в инструменте Java PathFinder: Java-код исполняется на специальной виртуальной Java-машине, которая кроме исполнения программы генерирует дополнительные тексты на PROMELA и запускает SPIN.