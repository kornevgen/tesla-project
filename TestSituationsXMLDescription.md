// TODO! убрать процедуры и добавить операторы hit-miss

# Формат #
Тестовая ситуация задается в виде последовательности операторов декларативного типа. Оператор присваивания отсутствует. Вместо этого предлагается объявлять имена для выражений и затем использовать эти имена (это называется _связыванием_).

Корнем является `situation`. Атрибутов нет.
Возможные сыновья:
  * `argument` (аргумент-формальный параметр)
  * `let` (оператор let)
  * `assume` (оператор assume)
  * `procedure` (вызов процедуры)

## Аргумент ##
Корнем является `argument`. Сыновей нет.
Атрибуты:
  * `name` - имя формального параметра (текст), обязательный
  * `length` - битовая длина параметра (число), обязательный
  * `state` - статус параметра (два возможных значения: `result`, если в результате выполнения инструкции значение соотв.фактического параметра должно измениться, и `readonly`, если не должно измениться), обязательный
Пример:
```
<argument name="rt" state="result" length="64" />
<argument name="base" state="readonly" length="64" />
```

## Оператор let ##
Оператор служит для введения нового имени (синонима для некоторого значения) и/или идентификатора, чтобы иметь возможность обратиться к этому значению за пределами тестовой ситуации на уровне тестового шаблона.

Корнем является `let`.
Атрибуты:
  * `name` - новое имя (текст), опциональный
  * `id` - идентификатор объявляемого имени (текст), опциональный
Семантические ограничения:
  * "новое имя" не должно встречаться среди аргументов и предыдущих объявленных имен в тестовой ситуации
  * идентификатор не должен встречаться среди идентификаторов предыдущих объявленных имен
  * должен быть указан как минимум 1 атрибут
Сын единственный -- числовое выражение (о способах задания выражения см.ниже).
Примеры:
```
<let name="vAddr" id="virtual">
   <sum>
	<sign_extend size="64"><var>offset</var></sign_extend>
	<var>base</var>
   </sum>
</let>
...
<let id="physical"><var>pAddr</var></let>
```

## Оператор assume ##
Оператор служит для задания отношений на переменных.

Корнем является `assume`. Атрибутов нет. Сын обязательный и единственный - логическое выражение (о способах задания выражения см.ниже).
Пример:
```
<assume>
   <eq>
	<bits end="1" start="0"><var>vAddr</var></bits>
	<constant length="2">0</constant>
   </eq>
</assume>
```

## Вызов процедуры ##
Набор процедур не фиксируется языком и зависит от используемого генератора ограничений (он анализирует описание тестовой ситуации и решает, как транслировать вызовы процедур).

Корнем является `procedure`. Атрибут обязательный и единственный - имя процедуры (текст). Сыновьями являются аргументы.

Аргумент вызова процедуры задается узлом `argument` с единственным (опциональным, но рекомендуемым) атрибутом `id` -- идентификатор, который может использоваться для задания семантики аргумента, по таким идентификаторам удобно при построении ограничений выделять среди аргументов нужный. Телом узла аргумента может быть
  * символьная константа
  * числовое выражение
  * узел `new` c атрибутом `length` (битовая длина) и телом -- именем переменной (этот узел служит для пометки новых объявляемых имен в результате вызова процедуры)

Пример:
```
<procedure name="AddressTranslation">
	<argument id="physical"><new length="64">pAddr</new></argument>
	<argument id="virtual"><var>vAddr</var></argument>
	<argument id="points_to">DATA</argument>
	<argument id="points_for">LOAD</argument>
</procedure>
```

## Числовые выражения ##
  * переменная
```
<var>base</var>
```
  * константа (обязательно указать не только значение, но и битовую длину)
```
<constant length="2">0</constant>
```
  * выделение одного бита
```
<bits index="10">числовое выражение</bit>
```
  * выделение последовательности бит
```
<bits end="1" start="0">числовое выражение</bits>
```
  * битовая конкатенация
```
<concat>
	числовое выражение1
	числовое выражение2
	. . .
</concat>
```
  * битовая степень
```
<power index="5">числовое выражение</power>
```
  * сумма по модулю 2^битовая длина (битовые длины сыновей должны совпадать)
```
<sum>
	числовое выражение1
	числовое выражение2
	. . .
</sum>
```
  * знаковое расширение
```
<sign_extend size="64">числовое выражение</sign_extend>
```

## Логические выражения ##
  * равенство
```
<eq>
	числовое выражение1
	числовое выражение2
</eq>
```
  * неравенство
```
<noteq>
	числовое выражение1
	числовое выражение2
</noteq>
```
  * конъюнкция
```
<and>
	логическое выражение1
	логическое выражение2
	. . .
</and>
```
  * дизъюнкция
```
<or>
	логическое выражение1
	логическое выражение2
	. . .
</or>
```
  * предикат
```
<predicate name="имя предиката">
	числовое выражение1
	числовое выражение2
	. . .
</predicate>
```
Пока поддерживается только предикат `wordvalue`, хотя можно добавить и другие:
```
<predicate name="wordvalue">числовое выражение</predicate>
```

# Пример #
```
<!--
последовательность действий:
1) подготовить физический адрес данных
2) загрузить из памяти двойное слово, в состав которого входят требуемые данные
3) выделить из двойного слова нужные данные (в данном случае, 4 байта из 8 байт)
-->
<situation>
	<argument name="rt" state="result" length="64" />
	<argument name="base" state="readonly" length="64" />
	<argument name="offset" state="readonly" length="16" />
	
	<let name="vAddr" id="virtual">
		<sum>
			<sign_extend size="64"><var>offset</var></sign_extend>
			<var>base</var>
		</sum>
	</let>
	
	<assume>
		<eq>
			<bits end="1" start="0"><var>vAddr</var></bits>
			<constant length="2">0</constant>
		</eq>
	</assume>
	
	<procedure name="AddressTranslation">
			<argument id="physical"><new length="64">pAddr</new></argument>
			<argument id="virtual"><var>vAddr</var></argument>
			<argument id="points_to">DATA</argument>
			<argument id="points_for">LOAD</argument>
	</procedure>

	<let id="physical"><var>pAddr</var></let>   <!-- приписывание переменной идентификатора -->
	
	<let name="dwByteOffset">
		<bits end="2" start="0"><var>vAddr</var></bits>
	</let>
	
	<!-- dwByteOffset can be changed according to BigEndian/LittleEndian -->
	
	<procedure name="LoadMemory">
        	<argument id="data"><new length="64">memdoubleword</new></argument>
        	<argument id="size">WORD</argument>
        	<argument id="physical"><var>pAddr</var></argument>
        	<argument id="virtual"><var>vAddr</var></argument>
        	<argument id="points_to">DATA</argument>
        </procedure>

	<procedure name="BytesSelect">
		<argument id="type">WORD</argument>
		<argument id="from"><new length="32">data</new></argument>
		<argument id="content"><var>memdoubleword</var></argument>
		<argument id="index"><var>dwByteOffset</var></argument>
	</procedure>
	
	<assume>
		<eq>
			<var>rt</var>
			<sign_extend size="64"><var>data</var></sign_extend>
		</eq>
	</assume>
</situation>
```

# Семантические правила языка описания тестовых ситуаций #
  1. количество указанных для команды аргументов должно совпадать с количеством указанных переменных RESULT и READONLY (в сумме) в описании тестовой ситуации
  1. количество указанных для команды дополнительных аргументов не должно превышать количество указанных переменных OPTIONAL в описании тестовой ситуации
  1. битовые длины указанных для команды аргументов и дополнительных аргументов должны совпадать с битовыми длинами соответствующих переменных в описании тестовой ситуации
  1. имена аргументов команды, соответствующих переменным-результатам тестовой ситуации (т.е. помеченным словом RESULT), должны быть разными (для одного элемента тестового шаблона)
  1. переменные не могут менять свои битовые длины - битовая длина переменной, возникающей в операторе присваивания, вычисляется по битовой длине присваиваемого выражения
  1. переменная, помеченная в сигнатуре статусом READONLY, не может быть изменена оператором присваивания
  1. переменная, помеченная в сигнатуре статусом RESULT, считается изменяемой, даже если это не сказано явно
  1. битовые длины сравниваемых, складываемых, умножаемых выражений должны совпадать - битовая длина результата сложения и вычитания равна битовой длине выражений-операндов
  1. в операторе получения битового диапазона левая константа не должна быть меньше правой константы

# Замечания по языку описания тестовых ситуаций #
  1. каждая необъявленная явно переменная получает свое определение (имя и размер) при первом присваивании и не меняет их в течение всей тестовой ситуации (значение она менять может)
  1. отсутствует логический оператор отрицания
  1. отсутствуют логические константы
  1. числа представляются в виде списка битовых частей числа (конкатенация которых дает полное число) - все битовые части имеют одинаковый размер, что является параметром работы решателя; известен пример семейства схем тестовых воздействий, все схемы в котором разных размеров, на котором подмножество успешно решаемых схем зависит от размера битовой части в представлении чисел! Из-за конструктивных особенностей системы ECLiPSe этот размер не может превышать 51.
  1. сложение чисел выполняется в модульной арифметике по модулю 2^битовая длина операндов
  1. умножение выполняется точно (полностью)
  1. нет лексического способа задать константу с отрицательным значением; однако ее можно получить операцией вычитания
  1. процедура получения случайного значения из множества возможных не всегда дает ответ за приемлимое время; встроенная в ECLiPSe процедура получения всегда одного значения работает быстрее, но при разных запусках дает одно и то же значение