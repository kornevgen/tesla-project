Язык описания схем тестовых программ
====================================

REGISTER x : 32 ;
CONST offset : 16 ;

ADD x, y, z @ overflow
LW x, y, z @ addressException
SW x, y, z @ noexception{ LoadMemory: Hit(1,_,_), Miss(2,p,_,_) }
LD x, y, z @ noexception{ AddressTranslation: Traslate( v, p1 ) }
p, p1 @ equals

LoadMemory[t1, t2, t3]: Hit(1,t1,_), Miss(2,t2,p,_)
t1,t2,t3 - те теги, которые должны быть "вычислены" в теле предиката, описывающего тестовую ситуацию
по одному тегу на уровень кэша
ведь кроме тегов, к которым происходят обрашения, в тестовой ситуации вычислить нельзя...

нет, t_i будут вычисляться с проверкой, что на один уровень не сформулировано более одного hit/miss'а

кроме простого определения того, какой тег выгонять, надо определить, куда этот адрес попадет!
например, Miss( 1, t1, p1, _ ), Hit( 2, t2, p2, _ )
после l1Miss не просто t1 разместится в кэше, но и вытесненный "p1+_" (адрес) должен кого-то вытеснить в l2, т.е. должен быть Miss(2, t2, p2, _), но это должно произойти потом => это можно описать следующей (неявной) "командой"
LW x, y, z @ noexception{ LoadMemory: Miss( 1, t1, p1, s1 ), Hit( 2, t2, p2, s2 ) }
null p1, s1, p3, s3 @ sameaddress
null @ dummy{ LoadMemory: Miss( 2, p3, p4, s3 ) }
эта часть схемы тестовой программы описывает то, что происходит с вытесненным тегом:
	1) sameaddress - вычисляет p1||s1||0 = p3||s3||0, но битовые размеры p3 и s3 берутся уже из параметров кэша другого уровня
	2) собственно описание того, что добавляется p3, s3 и выгоняется p4 из сета s3.
	3) ... можно продолжать описывать эффект на других уровнях
Основное ограничение - невозможность описать более одной тестовой операции на один уровень кэша

TODO:
не забыть в задаче на сеты учитывать возможные зависимости на сетах-переменных из параметров тестовых ситуаций
LoadMemory: Hit(1, t1, S1) - "S1" - переменная-сет!


Инструмент выдаст для каждого уровня кэша, к каким адресам и в каком порядке надо обратиться,
чтобы достичь нужное для тестирования состояние кэша. Для кэша первого уровня достаточно
сделать обращения к выданным адресам. Но для кэша второго уровня так просто уже
не получится достичь нужного состояния...... как быть?
нужен хитрый setConditions, который опишет связи состояний разных уровней кэша?