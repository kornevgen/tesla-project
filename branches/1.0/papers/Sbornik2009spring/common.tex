\section{Построение ограничений для генерации тестовых данных}\label{common_algorithm}

В данной работе предлагается алгоритм построения тестовых данных
(т.е. начальных значений регистров, ячеек кэш-памяти, буфера
трансляции адресов, ячеек ОЗУ и пр.) для тестовых шаблонов. Ключевой
технологией в предлагаемом алгоритме будет разрешение ограничений
над целыми числами и конечными множествами целых
чисел~\cite{ConstrProp}. Таким образом, по тестовому шаблону будет
построена система ограничений, затем она будет разрешена, в
результате чего будут получены тестовые данные.

В соответствие с основными подсистемами микропроцессора, которые
принимают участие в исполнении операций над регистрами и памятью, в
системе ограничений будут следующие переменные:
\begin{itemize}
\item индексы строк TLB для каждой инструкции тестового шаблона
\item начальные значения регистров, задействованных в шаблоне
\item константы тестового шаблона
\item виртуальные адреса для каждой инструкции тестового шаблона
\item поля строк TLB, задействованных в тестовой программе (а именно
поля <<r>>, <<vpn/2>>, <<mask>>, <<g>>, <<asid>>, флаги)
\item поля физических адресов для каждой инструкции тестового
шаблона (а именно, тег, сет, индекс в строке кэш-памяти)
\end{itemize}

Алгоритм не моделирует подсистемы микропроцессора целиком, а лишь те
части, которые действительно задействованы в тестовой программе. Это
позволяет значительно уменьшить размер системы ограничений.

Алгоритм можно представить в виде следующей последовательности
шагов:
\begin{enumerate}
\item\label{alg_indextlb} вычисление индексов строк TLB для каждой инструкции тестового
шаблона на основе тестовых ситуаций в буфере TLB (TLB-промахов или
TLB-попаданий)
\item\label{alg_testsit} выделение ограничений на начальные значения регистров, исходя
из тестовых ситуаций инструкций, не работающих с памятью
\item\label{alg_virtual} выделение ограничений-определений виртуальных адресов по
значениям регистров для инструкций, работающих с памятью
\item\label{alg_virtonerow} выделение ограничений на виртуальные адреса, соответствующие в
тестовом шаблоне одной строке TLB
\item\label{alg_tlbconsist} выделение ограничений на поля задействованных в тестовом шаблоне
строк TLB, описывающих свойства согласованности TLB (каждый
виртуальные адрес может соответствовать не более одной строке TLB)
\item\label{alg_physonerow} выделение ограничений на поля физических адресов для
инструкций, обращающихся в одну строку TLB
\item\label{alg_cache} выделение ограничений, исходя из тестовых ситуаций в
кэш-памяти (кэш-промахов и кэш-попаданий)
\item\label{alg_ozu} выделение ограничений на виртуальные адреса и значения
регистров, описывающих работу с ОЗУ (совпадение считанных значений
инструкций при совпадении физических адресов)
\end{enumerate}

Преимуществом алгоритма является то, что в виде ограничений
кодируются <<относительные связи>> переменных в отличие от того, как
себя ведет, например, Genesys-Pro: вместо того, чтобы на каждом шаге
(т.е. для каждой очередной инструкции) вычислять значения адресов,
регистров, констант (с которыми эти инструкции работают),
формулируются связи этих значений со значениями адресов, регистров,
констант других инструкций.

Шаг~\ref{alg_indextlb}. Его цель -- вычислить номера строк TLB, к
которым обращаются инструкции работы с памятью в тестовом шаблоне. В
рамках этого шага будут составлены и разрешены ограничения.
Ограничения составляются на основе тестовых ситуаций в буфере TLB,
указанных в шаблоне. Поскольку буфер ведет себя как один сет кэша,
генерация ограничений на этом шаге совпадает с генерацией
ограничений на шаге~\ref{alg_cache}. Об этом будет рассказано в
разделе~\ref{eqs} данной статьи. Если полученные в результате
разрешения ограничений номера строк не приведут в дальнейшем к
разрешимой системе ограничений на виртуальные адреса и регистры,
будет совершен возврат и выбор других номеров строк TLB.

Следующий шаг~\ref{alg_testsit}. Его цель -- выделить ограничений на
начальные значения регистров, исходя из тестовых ситуаций
инструкций, не работающих с памятью (например, арифметические
переполнения, деления на ноль). На этом шаге следует обращаться к
описанию соответствующей тестовой ситуации и транслировать его в
набор ограничений так, как это делается для императивных программ.

Шаг~\ref{alg_virtual}. В результате этого шага должны выделиться
ограничения, связывающие переменные-виртуальные адреса инструкций и
переменные-значения регистров. Ограничение строится на основе
описания тестовой ситуации инструкции, где виртуальный адрес
выступает одним из параметров процедуры AddressTranslation. Зачастую
виртуальные адреса представляют из себя сумму значения регистра,
являющегося одним из параметров инструкции, и непосредственного
значения, являющегося другим параметром инструкции.

Очередной шаг~\ref{alg_virtonerow}. В рамках этого шага для каждой
задействованной в тестовом шаблоне строки TLB выбираются все
виртуальные адреса инструкций, работающих с этой строкой.
Виртуальные адреса всех таких инструкций обладают следующими
свойствами:
\begin{enumerate}
\item биты, соответствующие полю <<r>> строки TLB, виртуальных
адресов совпадают
\item биты, соответствующие полю <<vpn/2>> строки TLB, разрешенные
полем <<mask>> строки TLB, совпадают
\end{enumerate}

Шаг~\ref{alg_tlbconsist} призван выделить ограничения на поля
задействованных в шаблоне строк TLB с целью описать свойства
согласованности TLB (а именно, что каждый виртуальные адрес может
соответствовать не более одной строке TLB): у любых двух инструкций,
работающих с разными строками TLB, либо различаются биты полей
<<r>>, либо различаются биты полей <<vpn/2>>, разрешенные полями
<<mask>> строк TLB.

На следующем шаге~\ref{alg_physonerow} начинается выделение
ограничений на поля физических адресов инструкций.
\begin{enumerate}
\item определяются сеты физических адресов -- согласно способу
трансляции адресов они являются полями виртуальных адресов
\item определяются индексы в строках кэш-памяти физических адресов --
согласно способу трансляции адресов они являются полями виртуальных
адресов
\item свойства физических адресов инструкций, обращающихся в одну
строку TLB: теги физических адресов совпадают тогда и только тогда,
когда совпадают биты четности физической страницы виртуальных
адресов.
\end{enumerate}

Шаг~\ref{alg_cache} призван добавить ограничения на теги физических
адресов, исходя из тестовых ситуаций в кэш-памяти. На этом этапе
известно, в какие сеты обращаются все инструкции тестового шаблона.
Алгоритм выбирает инструкции, обращающиеся в один сет, и выделяет
для них ограничения так, как это будет описано в разделе~\ref{eqs}.

Заключительный шаг~\ref{alg_ozu} ставит целью выделить ограничения
на виртуальные адреса и значения регистров, исходя из следующего
свойства оперативной памяти: значения, считываемые по одинаковым
адресам, совпадают, если между этими чтениями по этому адресу не
было записи; если запись была, берется последнее перед чтение
записанное значение. Более четко (<<$LOAD~x, a$>> -- любая инструкция
чтения из памяти, где $х$ -- считанное значение, $а$ -- физический
адрес; <<$STORE~x, a$>> -- любая инструкция записи в память, где $x$ --
записываемое значение, $а$ -- физический адрес):

\parbox{\textwidth}{
для каждой $LOAD~x, a_1$ из шаблона

\hspace{0.5cm}для каждой предыдущей $LOAD~y, a_2$ из шаблона

\hspace{0.5cm}\hspace{0.5cm}пусть $a_3, a_4, ..., a_n$ -- адреса в $STORE$ между ними:

\hspace{0.5cm}\hspace{0.5cm}добавить ограчение $a_1 \in \{a_2\}\setminus\{a_3,a_4,...a_n\} \Rightarrow x = y$

\hspace{0.5cm}для каждой предыдущей $STORE~y, a_2$ из шаблона

\hspace{0.5cm}\hspace{0.5cm}пусть $a_3, a_4, ..., a_n$ -- адреса в $STORE$ между ними:

\hspace{0.5cm}\hspace{0.5cm}добавить ограчение $a_1 \in \{a_2\}\setminus\{a_3,a_4,...a_n\} \Rightarrow x = y$
}
