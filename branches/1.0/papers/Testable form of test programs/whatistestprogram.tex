\section{Что такое тестовая программа}
Тестовая программа является программой на языке ассемблера
микропроцессора, т.е. последовательность возможно помеченных команд
с аргументами (констант, имен регистров и меток). Причем такая
программа нацелена на определенное исполнение, т.е. каждой команде
сопоставлен набор происходящих при ее исполнении событий.

\subsection{Тестовый шаблон}
Одной из частей тестовой программы является \emph{тестовый шаблон}
-- последовательность команд (без учета их конкретных аргументов).
Пример тестового шаблона - \texttt{add, sub, lw, sw}. Тестовый
шаблон можно задавать явно или неявно. Явное задание предполагает
указание конкретной последовательность команд (их кодов операций).
Неявное задание определяет множество явных заданий. В
сгенерированное тестовой программе может быть представлен как одна
возможный явный тестовый шаблон по заданному неявному, так и их
некоторое количество. При этом выбор явных тестовых шаблонов может
быть сделан таким, какой удобен инструменту-генератору тестовой
программы.

Явные тестовые шаблоны генерирует и использует в процессе своей
работы инструмент \textsc{mVpGen}~\cite{mVpGen}. Этот инструмент по
спецификации конвейера строит тестовые программы для тестирования
ситуаций простаивания конвейера. Пример тестового шаблона,
генерируемого этим инструментом (в паре к команде идет команда
ко-процессору):
\begin{verbatim}
ldcp assign (cpr0:CPR, gpr0:GPR) + cnop ;
nop + cmac refer (cpr0:CPR) ;
alu refer (gpr0:GPR) + calu ;
\end{verbatim}

Неявные тестовые шаблоны позволяет задавать инструмент
\textsc{Genesys-Pro}~\cite{GenesysPro2004}, разрабатываемый в
компании IBM. Выразительные возможности языка тестовых шаблонов,
встроенного в этот инструмент, позволяют задать конкретную
последовательность, некоторую перестановку данной
последовательности, выбор одной команды из данной
последовательности, повтор данной последовательности до наступления
заданного условия и параллельное исполнение заданных
последовательностей команд. Пример:
\begin{verbatim}
Variable: addr = 0x100
Variable: reg

Instruction: Store R5 -> ?
Repeat (addr < 0x200 )
    Instruction: Load reg <- addr
    Select
        Instruction: Add ? <- reg + ?
        Instruction: Sub ? <- ? - ?
    addr = addr + 0x10
\end{verbatim}

Другой проект, в котором использованы неявные тестовые шаблоны,
проводился в Национальном Университете Технологий Безопасности в
Китае -- MA$^2$TG~\cite{MAATG}. Выразительные возможности языка
тестовых шаблонов этого инструмента позволяют задать некоторые
инструкции в тестовой программе, остальные инструкции могут быть
любыми. Кроме того, можно задать процент некоторых конструкций во
всей тестовой программе. Пример:
\begin{verbatim}
requirement:
    instructnumber in [8-10];
    ADD = 15%;
    reg r1, r2, r3, rt8;
    imm imm1;
    insbegin :
        index = 1 => ADD { AdsD = r1, AdsS1 = r2, };
        index = 4 => ALU { AdsD = r3, , AdsS2 = imm1 };
    insend;
endrequirement;
\end{verbatim}

У каждого представления есть свои преимущества и недостатки. Неявное
задание применяется в проектах с большей долей ручной работы. В
проектах с большей автоматизацией процесса тестирования достаточно и
явного задания, которые можно генерировать автоматически. Кроме
того, практика тестирования микропроцессоров такова, что наибольшее
употребление имеют относительно короткие тестовые программы (до
десятка команд). Длинные же тестовые программы нужны крайне редко.

\subsection{Зависимости между инструкциями}
Обычно тестовые программы составляются не из независимых команд, а
из набора команд, связанных некоторыми условиями. Это могут быть
совпадение используемых регистров между командами или, наоборот,
несовпадение, вытеснение одной командой строки кэша, которая
использована некоторой предыдущей командой и пр. Поэтому языки
описания тестовых программ должны обеспечивать средства для описания
таких зависимостей. Представленные выше инструменты
\textsc{Genesys-Pro} и \textsc{MAATG} обладают такими средствами.
Они позволяют дать имена аргументам команд и отдельно дать
зависимости между этими именами в виде предикатов.
\textsc{Genesys-Pro} позволяет в тестовом шаблоне дать указание,
задействовать разные зависимости между регистрами (запись-чтение,
чтение-чтение, чтение-запись, запись-запись) и зависимости между
адресами, которые используют разные команды.

Пример зависимости между двумя инструкциями по регистрам:
\begin{verbatim}
add x, y, z
div z, y, x
\end{verbatim}
По регистру $x$ есть зависимость вида <<запись-чтение>>, по регистру
$y$ - зависимость вида <<чтение-чтение>> и по регистру $z$ - вида
<<чтение-запись>>.

\subsection{Тестовые ситуации}
Происходящие при исполнении команды события составляют
\emph{тестовую ситуацию}. Целью генерации тестовой программы как раз
и является достижение тестовой ситуации. Если эта тестовая ситуация
относится к какой-то определенной команде, то такую команду в
тестовом шаблоне можно пометить идентификатором, отвечающим тестовой
ситуации. Рассмотренные ранее инструменты \textsc{Genesys-Pro} и
\textsc{MAATG} поступают именно таким образом.

В некоторым случаях может быть не так важно, при исполнении какой
команды произойдет нужное событие. Тогда генерируют тестовую
программу целиком так, чтобы эта тестовая ситуация \emph{на
программу} произошла~\cite{Mishra}. Однако в таких работах тестовый
шаблон не задается, а генерируется под тестовую ситуацию, поэтому
далее такие инструменты рассматриваться не будут.

Кроме отметки в тестовом шаблоне, необходимо дать определение самой
тестовой ситуации, описать поведение в ней процессора. Определение
тестовой ситуации относится к определению характеристик исполнения
команды - на каком состоянии микропроцессора нужно команду
запустить, с какими аргументами эту программу надо исполнить.
Тестовая ситуация команды -- это по сути предусловие работы этой
команды. Поэтому и средства задания тестовых ситуаций могут быть
такими, какие могли бы применяться для определения предусловий
параметрических систем, работающих в среде. Самый простой способ --
предусловие как предикат. Для этого достаточно предъявить логическое
выражение на аргументах команды (аналоги формальных параметров
процедур в языках программирования) и состояние микропроцессора. В
состояние микропроцессора входит состояние всех его блоков, на
которые нацеливается тестирование: состояние уровней кэша инструкций
и кэша данных, состояние конвейера и пр. В инструменте
\textsc{Genesys-Pro} тестовая ситуация задается семейством
ограничений (constraint network), которые по сути представляют из
себя логические выражения. Как обстоят дела с MAATG? Как в языке ADL
задаются исключительные ситуации?

Более выразительным способом задания предусловия может быть
процедура на некотором языке программирования, возвращающая
логический результат истины в том и только в том случае, если
предусловие выполнено. Инструменты: ...

Кроме того, тестовая ситуация может быть частью архитектуры - как
там она описывается?
