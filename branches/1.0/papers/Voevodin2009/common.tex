\section{Общий случай}

\begin{figure}[h]
\centering
\includegraphics[width=2.5in]{common}
\caption{Кэш общего вида} \label{common_cache}
\end{figure}

Предлагаемый алгоритм построения ограничений для тестового шаблона
основывается на следующих свойствах вытесняемых адресов:
\begin{enumerate}
\item вытесняемый адрес был добавлен ранее одной из инструкций
тестового шаблона (или находился среди адресов начального состояния
кэш-памяти);
\item между вытеснением адреса и кэш-промахом к нему происходят
кэш-попадания ко всем остальным адресам кэша в данном регионе (в
этом смысле FIFO немного напоминает другую стратегию вытеснения --
LRU, Least Recently Used).
\end{enumerate}

Алгоритм строит ограничения на следующие переменные:
\begin{enumerate}
\item $\alpha_1, \alpha_2, \alpha_3,...$ --  адреса начального
состояния кэш-памяти (их количество равно ассоциативности
кэш-памяти);
\item адреса, при обращении к которым происходят кэш-попадания (их
количество равно количеству инструкций, при обращении к которым
происходят кэш-попадания);
\item адреса, при обращении к которым происходят кэш-промахи (их
количество равно количеству инструкций, при обращении к которым
происходят кэш-промахи);
\item $L_0, L_1, ...$ -- переменные-состояния кэш-памяти
(их количество -- на единицу больше количества инструкций, при
обращении к которым происходят кэш-промахи).
\end{enumerate}

Для построения ограничений кэш-памяти общего вида так же будет
использоваться функциональный символ $R(x)$, причем ровно в том же
смысле, какой он имел для кэш-памяти прямого отображения.

Итак, каждая инструкция, при обращении к которой происходит
кэш-попадание, порождает 1 новую переменную; каждая инструкция, при
обращении к которой происходит кэш-промах порождает 1
переменную-состояние кэш-памяти, 1 переменную-вытесняющий адрес и 1
переменную-вытесняемый адрес. Алгоритм формирует ограничения для
каждой очередной инструкции следующим образом ($N$ --
ассоциативность кэш-памяти):
\begin{enumerate}

\item <<начальные ограничения>> генерируются для любого шаблона один раз:
$L_0 = \{ \alpha_1, \alpha_2,..., \alpha_N\}$, $|L_0| = N$ (или,
по-другому, все числа $\alpha_1, \alpha_2,..., \alpha_N$ разные);

\item <<ограничения кэш-попадания>> генерируются для каждой инструкции,
при обращении к которой происходит кэш-попадание: $x \in L$, где $x$
-- адрес в инструкции, $L$ -- текущая переменная-состояние
кэш-памяти;

\item <<ограничения кэш-промаха>> генерируются для каждой
инструкции, при обращении к которой происходит кэш-промах ($x$ --
вытесняющий адрес, $y$ -- вытесняемый адрес, $L$ -- текущая
переменная-состояние кэш-памяти): $y \in L, x \notin L, L' = L \cup
\{x\} \setminus \{y\}, R(x) = R(y), fifo(y)$, $L'$ становится
текущей переменной-состояния кэш-памяти для следующей инструкции.
\end{enumerate}

Ограничение $fifo(y)$ описывает свойство, что $y$ является
вытесненным адресом.

\begin{figure}[h]
\centering
\includegraphics[width=2.5in]{fifo}
\caption{fifo(y3)} \label{fifo_picture}
\end{figure}

Ограничение $fifo(y)$ представляется дизъюнкцией ограничений,
соответствующих всевозможным местам кэш-промаха с вытесняющим
адресом $y$. Каждый дизъюнкт к кэш-промаху адреса $x$ одной из
предыдущих инструкций (или к адресу из начального состояния кэша,
если все предыдущие инструкции не подходят) фиксирует конъюнкцию
двух свойств:
\begin{enumerate}
\item $x = y$
\item $(\{ x_1, x_2, ..., x_n \})\cap R(y) = (L \setminus \{y\})\cap R(y)$, где $x_1, x_2, ...,
x_n$ -- все адреса, к которым происходят обращения \emph{c
кэш-промахами} между обращением к $x$ и вытеснением $y$.
\end{enumerate}

Последнее ограничение можно упростить, используя следующую лемму:
\begin{lemma}
Для любых конечных множеств $X$, $Y$ и $Z$ если существует $y$
такой, что $y \in Y \cap Z$ и $y \notin X$, то $X \cap Y = (Z
\setminus \{y\}) \cap Y \Leftrightarrow Y \cap ( Z \setminus X ) =
\{ y \}$.
\end{lemma}
\begin{IEEEproof}[Доказательство]
$X \cap Y = (Z \setminus \{y\}) \cap Y \Leftrightarrow X \cap Y = Z
\cap Y \cap \overline{\{y\}}$.

Обозначим $A = Z \cap Y$, $B = X \cap Y$. По условию $y \notin B$ и
$y \in A$. Кроме того $B = A \setminus \{y\}$. Значит, $A = B \sqcup
\{y\}$, отсюда $A \setminus B = \{y\}$. Осталось показать, что $A
\setminus B = (Z \setminus X ) \cap Y$ : $A \setminus B = A \cap
\overline{B} = Z \cap Y \cap \overline{X \cap Y} = Z \cap Y \cap
(\overline{X} \cup \overline{Y}) = (Z \cap Y \cap \overline{X}) \cup
(Z \cap Y \cap \overline{Y}) = Z \cap \overline{X} \cap Y = (Z
\setminus X ) \cap Y$.
\end{IEEEproof}

Таким образом, ограничение $fifo(y)$ представляется дизъюнкцией по
предыдущим вытесняющим адресам и адресам начального состояния кэша
$x$ конъюнкций вида:

$x = y$

$\wedge$

$R(y) \cap (L \setminus \{ x_1, x_2, ..., x_n \}) = \{y\}$, где
$x_1, x_2, ..., x_n$ -- все адреса, к которым происходят обращения
\emph{c кэш-промахами} между обращением к $x$ и вытеснением $y$.


Рассмотрим тот же тестовый шаблон для памяти из 3-х регионов ($R(x)
= R(y) \leftrightarrow 3 | (x-y)$) и 2-х ассоциативной кэш-памяти:

LOAD x, y @ Hit

STORE u, z @ Miss

LOAD z, y @ Hit

Вводим аналогично двум предыдущим случаям версии переменных и
фиктивную переменную $z'_0$:

LOAD $x_1, y_0$ @ Hit

STORE $u_0, z_0$ @ Miss $\rightarrow z'_0$

LOAD $z_1, y_0$ @ Hit

Введем переменные для начального состояния кэша: $\alpha_1,
\alpha_2$ для первого региона, $\beta_1, \beta_2$ для второго
региона, $\gamma_1, \gamma_2$ для третьего. Сама система ограничений
будет иметь следующий вид:

$y_0 \in \{ \alpha_1, \alpha_2, \beta_1, \beta_2, \gamma_1, \gamma_2
\}$,

$z'_0 \in \{ \alpha_1, \alpha_2, \beta_1, \beta_2, \gamma_1,
\gamma_2 \}$,

$z_0 \notin \{ \alpha_1, \alpha_2, \beta_1, \beta_2, \gamma_1,
\gamma_2 \} \cap R(z'_0)$,

$y_0 \in \{ \alpha_1, \alpha_2, \beta_1, \beta_2, \gamma_1, \gamma_2
\} \cup \{z_0\} \setminus \{z'_0\}$,

$R(z_0) = R(z'_0)$,

$\alpha_1, \alpha_2, \beta_1, \beta_2, \gamma_1, \gamma_2$ -- все
разные,

$R(\alpha_1) = R(\alpha_2)$,

$R(\beta_1) = R(\beta_2)$,

$R(\gamma_1) = R(\gamma_2)$,

$R(\alpha_1), R(\beta_1), R(\gamma_1)$ -- все разные

И дизъюнкция, описывающая $fifo(z'_0)$ (достаточно одного дизъюнкта
для получения решения):

$z'_0 = \gamma_1 \wedge R(z'_0) \cap (\{ \alpha_1, \alpha_2,
\beta_1, \beta_2, \gamma_1, \gamma_2 \}\setminus \{\gamma_2\}) =
\{z'_0\}$

$\vee$

...

Упрощаем полученную систему ограничений:

$y_0 \in \{ \alpha_1, ..., \gamma_2 \}$,

$z'_0 \in \{ \alpha_1, ..., \gamma_2 \}$,

$z_0 \notin \{ \alpha_1, ..., \gamma_2 \} \cap R(z'_0)$,

$y_0 \in \{ \alpha_1, ..., \gamma_2, z_0 \} \setminus \{z'_0 \}$,

$R(z_0) = R(z'_0)$,

$z'_0 = \gamma_1$,

$R(\gamma_1) \cap \{ \gamma_1 \} = \{ \gamma_1\}$

$\alpha_1, \alpha_2, \beta_1, \beta_2, \gamma_1, \gamma_2$ -- все
разные,

$R(\alpha_1) = R(\alpha_2)$,

$R(\beta_1) = R(\beta_2)$,

$R(\gamma_1) = R(\gamma_2)$,

$R(\alpha_1), R(\beta_1), R(\gamma_1)$ -- все разные

И окончательное упрощение:

$z'_0 = \gamma_1$,

$y_0 = \gamma_2$,

$z_0 \notin \{ \gamma_1, \gamma_2 \}$,

$R(z_0) = R(\gamma_2)$,

$\alpha_1, \alpha_2, \beta_1, \beta_2, \gamma_1, \gamma_2$ -- все
разные,

$R(\alpha_1) = R(\alpha_2)$,

$R(\beta_1) = R(\beta_2)$,

$R(\gamma_1) = R(\gamma_2)$,

$R(\alpha_1), R(\beta_1), R(\gamma_1)$ -- все разные

Получено решение с минимальным количеством задействованных регионов
(задействован только регион, в котором находятся адреса $\gamma_1$ и
$\gamma_2$).

Разрешая эти ограничения для 8-битных адресов, можно получить такое
решение:

$\alpha_1 = 0, \alpha_2 = 3$,

$\beta_1 = 1, \beta_2 = 4$,

$\gamma_1 = 2, \gamma_2 = 5$,

$x_0 = 0, y_0 = 5, z_0 = 8, u_0 = 0$ .

В общем случае для символьного решения подобного рода систем
ограничений (с операциями над множествами) могут применяться
специальные алгоритмы разрешения на основе того, что все множества
конечные (достаточно рассматривать $R(x)$ как множество лишь тех
адресов, к которым обращаются инструкции тестового шаблона).
