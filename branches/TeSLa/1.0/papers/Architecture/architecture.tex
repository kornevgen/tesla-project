\documentclass{article}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{pscyr}

\title{Архитектура систем генерации тестовых данных}
\author{}
\date{}

\textwidth=17cm \oddsidemargin=0cm

\begin{document}
\maketitle

\large

\section*{Общая структура}
Система генерации тестовых данных состоит из четырех основных
компонент:
\begin{enumerate}
\item генератор шаблона теста
\item генератор описания тестовой ситуации
\item транслятор описаний тестовой ситуации
\item решатель
\end{enumerate}

Тестируемая система управляется с помощью параметрических операций.
Тестирование такой системы проводится с использованием комплекта
тестов (таким образом, это системное тестирование). Каждый тест есть
последовательность операций тестируемой системы с конкретными
данными в качестве параметров. Тестов такого вида достаточно для
проведения некоторых видов тестирования. \emph{Шаблон теста} - это
последовательность операций, но на месте параметров могут появляться
переменные величины. При этом в шаблоне теста каждая операция
снабжается указанием, в какой тестовой ситуации исполняется эта
операция в тесте. Тестовую ситуацию можно понимать как отношение на
параметрах операции (и состоянии системы) перед исполнением
операции.

Пример. Рассмотрим систему, занимающуюся простейшими вычислениями
над целыми числами. Ее операции - сложить(x,y) и умножить(x,y). У
каждой операции два параметра. Тогда тестом может быть такая
последовательность:
\begin{verbatim}
сложить(0, 0)
умножить(1, -10)
умножить(12354, -375647839)
\end{verbatim}

Операция сложить(,) может иметь такие тестовые ситуации:
<<сумманоль>> -- оба параметра равны 0, <<разныезнаки>> -- оба
параметра имеют разные знаки, <<разныйпорядок>> -- параметры имеют
разный десятичный порядок. Предположим, что у операции умножить(,)
те же тестовые ситуации. Тогда шаблоном теста может быть такая
последовательность:
\begin{verbatim}
сложить(x, y) @ сумманоль
умножить(u, v) @ разныйпорядок
умножить(s, t) @ разныезнаки /\ разныйпорядок
\end{verbatim}

Структура шаблона теста фиксирована -- это последовательность.
Структура тестовой ситуации не фиксируется и может быть подобрана
под тестируемую систему. Например, при тестировании трансляторов
тестовая ситуация может представлять из себя часть синтаксического
дерева разбора.

Тест будем считать \emph{соответствующим} шаблону теста, если тест
заканчивается той же последовательностью операций, которая
представлена в шаблоне теста, причем для каждой операции выполнены
указанные в шаблоне тестовые ситуации. Например, представленные выше
тест и шаблон теста соответствуют друг другу.

Другой важный пример тестовой ситуации -- путь в графе потока
управления некоторой операции императивной программы. Если шаблон
теста содержит операцию с такой тестовой ситуацией, то при
исполнении соответствующего теста будут покрыты как минимум ветви
функциональности, которые включены в путь-тестовую ситуацию. Пример:
\begin{verbatim}
procedure f( int x, int y )
{
    switch
        case x + y < 10 : mark "First": ... ;
        case x * y != 0 : mark "Second": .... ;
        default: mark "Default": ... ;
    end switch
}
\end{verbatim}
Для такой программы тестовой ситуацией может быть указание пути -
First, Second или Default.

Работает вся эта система следующим образом (для нее уже определен
список операций и тестовых ситуаций тестируемой системы). Сначала
генератор шаблона теста операция за операцией генерирует шаблон
теста. Каждая операция помечается некоторой тестовой ситуацией.
Затем генератор описания тестовой ситуации для каждой
задействованной тестовой ситуации генерирует описание. Затем
транслятор по шаблону теста и описаниям тестовой ситуации генерирует
задачу для решателя (задача в ограничениях, графовая задача и т.п.).
И, наконец, решатель по построенной задаче генерирует значения
параметров операций шаблона теста и начальное состояние системы.

Таким образом, если генератор шаблона теста будет некоторым
систематическим образом перебирать операции, их тестовые ситуации и
зависимости между операциями, генератор тестовой ситуации будет
получать описания тестовой ситуации из некоторого представления
автоматически, то вся система генерации тестовых данных будет
работать автоматически.

Цель примеров, которым посвящена оставшаяся часть документа, не
столько продемонстрировать реально работающие генераторы тестовых
данных, сколько показать возможность организации их архитектуры в
соответствие с представленной здесь обобщенной архитектурой системы
генерации тестовых данных.

\section*{Генератор тестовых данных для тестирования
микропроцессоров}

Тестируемая система -- микропроцессор. Задача -- осуществить
системное функциональное тестирование микропроцессора.

Операции -- команды (инструкции) микропроцессора (например, ADD,
MUL, LW). Тестовые данные -- параметры команд микропроцессора и
состояние памяти. Генератор шаблона теста может систематически
перебирать команды, зависимости на параметры и тестовые ситуации для
команд.

Если в описании стандарта архитектуры микропроцессора присутствует
описание поведения команд, то тестовые ситуации можно получать
автоматически как ветви функциональности описаний поведения команд.
Пример -- описание команды ADD:
\begin{verbatim}
ASSERT WordValue(GPR[rs]) AND WordValue(GPR[rt]) ;
temp <- ( GPR[rs]_31 || GPR[rs]_{31..0} )
      + ( GPR[rt]_31 || GPR[rt]_{31..0} )
IF temp_32 # temp_31 THEN
    SignalException( IntegerOverflow )
ELSE
    GPR[rd] <- sign_extend( temp_{31..0} )
ENDIF
\end{verbatim}

Это описание имеет две ветви функциональности : первая приводит к \\
$SignalException(IntegerOverflow)$, вторая -- к изменению $GPR[rd]$.
Таким образом, получается две тестовые ситуации, которые можно
закодировать идентификатором: первая тестовая ситуация --
$overflow$:
\begin{verbatim}
VAR RESULT rd : 64 ;
VAR READONLY rs : 64 ;
VAR READONLY rt : 64 ;
ASSERT WordValue( rs ) AND WordValue( rt );
temp <- rs[31]||rs[31..0] + rt[31]||rt[31..0];
ASSERT temp[32] # temp[31];
\end{verbatim}
и вторая тестовая ситуация -- $noexception$:
\begin{verbatim}
VAR RESULT rd : 64 ;
VAR READONLY rs : 64 ;
VAR READONLY rt : 64 ;
ASSERT WordValue( rs ) AND WordValue( rt );
temp <- rs[31]||rs[31..0] + rt[31]||rt[31..0];
ASSERT temp[32] = temp[31];
rd <- (64)temp[31..0];
\end{verbatim}

В качестве решателя можно использовать логический интерпретатор с
ограничениями, а транслятор описания тестовой ситуации будет
преобразовывать каждое описание тестовой ситуации в набор
ограничений (constraint). Согласно шаблону теста транслятор
последовательно преобразует описание очередной тестовой ситуации из
шаблона теста в набор ограничений. Результирующий набор ограничений
подается на вход логическому интерпретатору с ограничениями, который
строит значения параметров и начальное состояние памяти. Поскольку
сам шаблон теста есть последовательность, описание тестовой ситуации
есть последовательность, задача для логического интерпретатора будет
построена за конечное время. Битовые операции над числами (в
терминах которых записано описание тестовой ситуации) также
эффективно транслируются в наборы ограничений.

Это описание содержит вызов функций WordValue. Описание других
команд содержит вызовы функций, которые, возможно, крайне сложно
описать в виде, пригодном для работы решателя. Пример такой функции
-- $LoadMemory$, осуществляющую загрузку данных из памяти по
заданному адресу с учетом кэш-памяти. При осуществлении тестирования
могут понадобиться тестовые ситуации, не выражающиеся ветвями
функциональности псевдокода, описающего поведение команды, а
являющиеся по сути ветвями функциональности и вызываемых функций
(например, функции $LoadMemory$). Например, такие ветви могут
соответствовать различным тестовым ситуациям в кэше (кэш-промах или
кэш-попадание). Исходя из этой идеи, тестовую ситуацию для команды
можно расширить, добавив в нее кроме идентификатора ветви
функциональности псевдокода тестовую ситуацию для вызываемых
функций. Например, если на ветви $noexception$ команды вызывается
функция $LoadMemory$ и эта функций имеет тестовую ситуацию $L1Miss$,
то тестовая ситуация для этой команды может иметь вид
<<$noexception(LoadMemory(1):L1Miss)$>>. Это позволит транслятору
описания тестовой ситуации построить задачу для решателя, с которой
решатель успешно справится.

//вынесенные зависимости между параметрами
//механизм <<дополнительных параметров>>

Пример шаблона теста:
\begin{verbatim}
REGISTER rs : 64 ;
REGISTER rt : 64 ;
CONST of : 16 ;
...
ADD rt, rs, rs @ overflow
SUB rs, rt, rs @ noexception
LW rs, rt, of @ noexception( LoadMemory: l1Hit )
\end{verbatim}

\section*{Генератор тестовых данных для тестирования императивных
программ}

Тестируемая система -- программа на императивном языке
программирования. Генерируется тест из вызовов процедур этой
программы. Задача -- построить тестовые данные -- значения
глобальных переменных перед исполнением теста и значения параметров
процедур -- так, чтобы достигнуть максимального покрытия ветвей
функциональности этой программы. Таким образом, операции --
процедуры данной программы. Генератор шаблона теста может
систематически перебирать процедуры с зависимостями на параметры и
тестовые ситуации.

Тестовая ситуация -- путь в графе потока управления процедуры от
точки входа в процедуру до некоторой вершины внутри процедуры. Если
процедура будет исполнена в заданной тестовой ситуации, то ее
исполнение пройдет точно по заданному пути, что будет означать
покрытие ветвей функциональности, задействованных в данном пути.

В качестве решателя можно использовать логический интерпретатор с
ограничениями. Согласно шаблону теста транслятор последовательно
преобразует описание очередной тестовой ситуации из шаблона теста в
набор ограничений. Операции над скалярными данными обычно есть в
языке логического интерпретатора, а операции над ссылочными данными
можно реализовать в виде скалярных операций (см. мой диплом).
Результирующий набор ограничений подается на вход логическому
интерпретатору с ограничениями, который строит значения параметров и
начальные значения глобальных переменных.

Пример шаблона теста:
\begin{verbatim}
var x, y : integer; z : struct;
begin
    f( x, y ) @ A
    g( z ) @ B
end;
\end{verbatim}
$A$ и $B$ -- некоторые пути в графе потока управления процедур $f$ и
$g$ соответственно.

\section*{Генератор тестовых данных для сценариев UniTesK}

Тестируемая система понимается так же, как она понимается в
технологии UniTesK. Тест -- сценарный метод UniTesK, состоящий из
последовательности вызовов медиаторных операций. Задача --
сгенерировать значения параметров медиаторных операций в сценарном
методе (состояние модельного объекта перед исполнением сценарного
метода может быть задано или генерируется также наряду с другими
тестовыми данными). Таким образом, операция -- медиаторная операция.
Генератор шаблона теста может систематически перебирать вызовы
медиаторных операций с зависимостями на параметры и тестовые
ситуации.

Тестовая ситуация -- путь в графе потока управления
пред-пост-условия (функция, составленная вначале из предусловия, а
затем из постусловия -- по сути импликация из предусловия в
постусловие). Этот путь можно кодировать именем конструкции branch,
которая однозначно кодирует этот путь. Если тестовые данные будут
сгенерированы согласно таким тестовым ситуациям, то при тестировании
будет достигнуто покрытие по branch.

В качестве решателя можно использовать логический интерпретатор с
ограничениями. Согласно шаблону теста транслятор последовательно
преобразует описание очередной тестовой ситуации из шаблона теста в
набор ограничений. Результирующий набор ограничений подается на вход
логическому интерпретатору с ограничениями, который строит значения
параметров (и состояние модельного объекта перед исполнением
сценарного метода).

Пример шаблона теста:
\begin{verbatim}
Spec objectUnderTest;
scenario s()
{
    var int x, y ; var int z ;
    objectUnderTest.f( x, y ) @ Overflow
    objectUnderTest.g( z ) @ Noexception
}
\end{verbatim}
$Overflow$ и $Noexception$ -- имена конструкций branch в методах $f$
и $g$ соответственно.

\section*{Генератор тестовых данных для тестирования конечных автоматов}

Тестируемая система -- конечный автомат с операциями (например,
такие автоматы появляются в системах-трансляторах). Тест --
последовательность операций этого конечного автомата. Задача --
сгенерировать значения параметров операций. Генератор шаблона теста
может систематически перебирать операции с зависимостями на
параметры и тестовые ситуации.

Тестовая ситуация -- подавтомат данного конечного автомата. Идея
этого примера -- показать, что решатель не обязательно есть
логический решатель, а может быть система работы с графами.

\section*{Генератор тестовых данных для тестирования графического
интерфейса программ}

Тестируемая система -- пользовательский интерфейс программы (с
кнопками, элементами для ввода, надписями и всякими другими
элементами графических интерфейсов). Тест -- последовательность
действий пользователя с интерфейсом программы. Скриптовые системы
работы с интерфейсами (AutoIt, Windmill Testing Framework) как раз
работают с такими тестами. Задача -- сгенерировать значения
параметров операций для данного шаблона теста. Например, это
название ссылки, на которую надо щелкнуть, интервал времени, который
надо подождать, текст, который надо написать, окно, на которое надо
переключиться и т.п. Генератор шаблона теста может систематически
перебирать операции с зависимостями на параметры и тестовые
ситуации.

Тестовая ситуация задает ответную реакцию на операцию: появление или
исчезновение нового графического элемента, звуковое уведомление.
Описание тестовой ситуации может браться из диаграмм, описывающих
требования на тестируемую систему.

\end{document}
