%Задача тестирования микросхем стала актуальна практически сразу, как
%появились сами микросхемы. Но сначала такие методы были чисто
%электротехническими. Настоящие программные методы появились тогда,
%когда мощность вычислительной техники достигла нужного уровня.
Chip testing problem became an actual problem when chips appeared.
The first methods of chip testing were pure electrotechnical
methods. Instant software-based methods of chip testing appeared
only when computers became more powerful.

%Одна и та же микросхема может быть представлена различными
%способами. От способа представления зависят и алгоритмы, которые
%можно использовать для нахождения тестовых данных. Первым
%представлением были структурные схемы (графическое изображение в
%виде совокупности частей, на которые ее можно разделить по
%определенным признакам, и связей между частями с указанием
%направления передачи воздействий). Первое упоминание о задаче
%тестирования таких микросхем было проведено в 1959 году Ричардом
%Элдредом~\cite{ATPG}. Задача была названа \textsc{ATPG} (Automatic
%Test Pattern Generation). Все методы решения этой задачи можно
%поделить на функциональные и структурные. В функциональных методах
%решения схема рассматривается как черный ящик или, математически,
%лишь как функция значений на выходных портах от значений на входных
%портах. Структурные методы наоборот рассматривают схему как белый
%ящик. В них пытаются создать тесты так, чтобы задействовать все
%составляющие схемы (<<провода>>). Исторически первым алгоритмом
%\textsc{ATPG} был \textsc{D}-алгоритм, в котором строились тестовые
%последовательности для нахождения <<константных ошибок>> (т.е.
%случаев, когда в некотором месте схемы вместо правильного всегда
%генерировалось константное значение - ноль или единица). Ошибка
%распространялась к входам и к выходам, постепенно формируя тестовые
%значения на входе и выходе. Другие методы решения задачи
%\textsc{ATPG} используют \textsc{SAT}-инструменты (SATisfiability) и
%алгоритмы работы с \textsc{BDD} (Binary Decision Diagram). Задача
%тестирования плат оказала влияние даже на их проектирование: был
%разработан набор требований к структуре платы -- DFT (Design For
%Test), призванный облегчить ее тестирование.
Testing methods depend on
chip representation. The first chip representation was a circuit
diagram. Chip testing problem appeared in Richards Eldred's
article~\cite{IEEEhowto:ATPG} in 1959. He named this problem as
\textsc{ATPG} (Automatic Test Pattern Generation). All
\textsc{ATPG}-methods may be divided into 2 groups such as
functional and structural. A functional methods work with a chart as
with a function between input and output. It is a black-box method.
A structural method is a white-box method. A structural method deals
with wires of circuit diagram. The first \textsc{ATPG}-algorithm was
"\textsc{D}-algorithm". "\textsc{D}-algorithm" was used for look for
"constant errors" (element always generates constant when it should
generate different values). "\textsc{D}-algorithm" spreads an error
to the inputs and outputs and generates test data (on input) and
output. Another methods use \textsc{SAT}-tools (SATisfiability),
work with \textsc{BDD} (Binary Decision Diagram), etc. Chip testing
problem has influenced even to chip design: there are requirements
to chip design DFT (Design For Test) for more powerful its testing.

%Другое представление микросхемы -- \textsc{RTL}-модель (Register
%Transfer Language). Первое упоминание о таких моделях относится к
%1980 году~\cite{RTL}. Использование этих моделей обусловлено
%возможностью синтеза схем на их основе. Таким образом можно
%выполнять все тестирование на \textsc{RTL}-модели и в результате
%сгенерировать схему, не содержащую ошибок, не потеряв при этом
%нужных свойств модели и не изменив функциональности. Группа
%исследователей из Университета Корсики~\cite{PathOriented}
%предложила использовать для поиска тестовых данных выделение путей в
%графе потока управления и применения к ним логических систем
%программирования с ограничениями (CLP~\cite{CLP}). Этот метод
%применялся и к программам на языках высокого уровня, но большие
%выразительные возможности таких программ становились препятствиями
%на пути эффективного применения этих идей. Исследователи из Англии
%предложили использовать \textsc{SAT} для решения задачи генерации
%тестовых данных прямо на основе \textsc{RTL}-модели~\cite{SAT-HDL}.
%Группа итальянских исследователей предложила для этой же задачи
%использовать генетические алгоритмы~\cite{GA-HDL}.
Another chip representation is \textsc{RTL}-model (Register Transfer
Language). The first mention of \textsc{RTL}-models was in
1980~\cite{IEEEhowto:RTL}. A \textsc{RTL}-model may be translated to
the circuit diagram without functionality loss. Researchers from
Corsica University proposed to select paths from \textsc{RTL}-model
and generate a test data by constraint logical
interpreter~\cite{IEEEhowto:CLP} applying to this
path~\cite{IEEEhowto:PathOriented}. This method applied to the
high-level programs also but great expressive capabilities of high-level programming languages prevented
its effective using. Researchers from England proposed to use
\textsc{SAT} for this problem~\cite{IEEEhowto:SAT-HDL}. Italian
researchers proposed to use genetic
algorithms~\cite{IEEEhowto:GA-HDL}.

%И, наконец, третье представление -- программная модель. Она не имеет
%прямого отношения к микросхеме, но описывает на языке достаточно
%высокого уровня ее функциональность. Именно такое представление
%используется в данной работе. Это направление развивается не так
%сильно. Можно отметить работу немецких исследователей, которые
%попытались применить целочисленное линейное программирование к
%задаче верификации~\cite{LinearProg}. Применить этот метод в нашем
%случае не удастся, потому что он не предполагает операции умножения
%над числами (умножение не является линейной операцией) и не
%гарантирует получение результата за приемлемое время.

And the third chip representation uses pseudocode for functionality description.
Pseudocode is the most similar to programs on a high-level programming language. It
describes chip functionality but not chip structure. This
representation is used in this article. However this representations is
used not so often. German researchers proposed to use integer linear
programming to the verification problem~\cite{IEEEhowto:LinearProg}.
But standard of architecture \textsc{MIPS64} uses multiplication
which is non-linear operations. Moreover integer linear programming
methods don't guarantee its finishing for acceptable time.
