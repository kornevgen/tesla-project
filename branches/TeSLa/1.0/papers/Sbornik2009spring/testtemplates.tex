\section{Описание тестовых шаблонов}\label{scheme}

Тестовый шаблон задает свойства будущей тестовой программы. Как и
тестовая программа, в тестовом шаблоне указывается
последовательность команд тестовой программы. Каждый элемент такой
последовательности содержит указание кода операции, параметров и
\emph{тестовой ситуации} -- связи значений операндов и состояния
микропроцессора (ячейки кэш-памяти, регистры, другие подсистемы)
перед началом выполнения инструкции. В качестве параметров команды в
тестовом шаблоне могут выступать переменные величины -- регистры,
непосредственные значения, адреса. Отдельно могут быть зафиксированы
в тестовой программе зависимости (предикаты) между переменными
величинами. Подробнее см.~\cite{kamkin}.

Для возможности автоматического построения тестовых данных каждую
тестовую ситуацию предлагается описать на простом императивном языке
с единственным типом -- целым числом заданной битовой
длины~\cite{mysyrcose, myisp}. Каждое описание тестовой ситуации
представляет собой последовательность операторов присваивания и
операторов утверждения (assert), выражая соотношения между
аргументами команды данной тестовой ситуации и состоянием
микропроцессора.

Пример описания тестового шаблона :
\begin{verbatim}
REGISTER ax : 32;
REGISTER bx : 32;
CONST offset : 16;
ADD ax, bx, bx @ overflow
LW ax, bx, offset @ noexception( l1Miss, l2Hit )
XOR bx, ax, bx @ noexc
\end{verbatim}
В этом тестовом шаблоне три команды - ADD, LW и XOR. Шаблон
начинается с объявления переменных с указанием их битовых длин.
Модификатор (REGISTER или CONST) указывает семантику использования
переменной. Тестовая ситуация указывается после знака <<@>>:
тестовая ситуация первой команды - <<overflow>>, второй команды -
<<noexception( l1Miss, l2Hit )>> и третьей - <<noexc>>. Тестовая
ситуация для второй команды содержит аргументы - они более детально
описывают тестовую ситуацию. Каждой из трех задействованных тестовых
ситуаций должно быть предоставлено описание. Описание первой
тестовой ситуации - overflow - может быть таким (в описании
используется операция битовой конкатенации <<||>> и отношение
неравенства <<\#>>):
\begin{verbatim}
VAR RESULT x : 32;
VAR READONLY y : 32;
VAR READONLY z : 32;
temp <- y[31]||y + z[31]||z;
ASSERT temp[32] # temp[31];
\end{verbatim}
Сначала идут объявления переменных с указанием семантики их
использования. В частности, для представленного выше тестового
шаблона переменная тестовой ситуации $x$ соответствует переменной
шаблона $ax$, а переменные тестовой ситуации $y$ и $z$ соответствуют
переменной шаблона $bx$. Затем идет оператор присваивания - в
присваиваемом выражении использованы битовые операции конкатенации и
взятия бита по номеру и арифметическая операция сложения. И
завершает описание оператор утверждения, который сравнивает на
неравенство 32й и 31й биты значения переменной $temp$.

Описание второй тестовой ситуации - noexception - может быть таким:
\begin{verbatim}
VAR RESULT x : 32;
VAR READONLY y : 32;
VAR READONLY c : 16;
address <- y + c;
AddressTranslation( phys, address, DATA );
LoadMemory( x, phys, DATA );
\end{verbatim}
В отличие от предыдущего описания добавились вызовы процедур
LoadMemory и AddressTranlation. Указание на то, как должны себя
вести эти процедуры, даются вместе с указанием тестовой ситуации
инструкции. В такое описание включается список идентификаторов с
фиксированной семантикой (например, для LoadMemory <<l1Miss>> --
указание на то, что при загрузке из памяти должен произойти промах в
кэш-памяти первого уровня)~\cite{kamkin}.

Наиболее часто описание тестовой ситуации для инструкции работы с
памятью состоит из следующих шагов:
\begin{enumerate}
\item вычисление виртуального адреса (обычно один аргумент означает
регистр, в котором хранится часть адреса, а другой аргумент в виде
числовой константы задает другую часть адреса)
\item трансляция виртуального адреса в физический с помощью TLB
(младшие биты виртуального адреса без изменений становятся младшими
битами физического адреса (т.н. смещение внутри страницы), а для
старших бит виртуального адреса в TLB подбирается соответствующая
старшая часть физического адреса; TLB содержит лишь ограниченное
количество таких преобразований, поэтому если для виртуального
адреса невозможно подобрать преобразование, генерируется
соответствующее исключение)
\item обращение в кэшированную оперативную память по физическому
адресу (кэш-память обладает иерархией - делится на уровни, поиск в
кэш-памяти начинается с первого уровня и при неуспехе (т.н.
кэш-промахе) поиск продолжается в следующем уровне), при этом
физический адрес делится на три диапазона бит: старшие биты называют
\emph{тегом} физического адреса, средние биты называют \emph{сетом}
физического адреса, а младшие биты называют \emph{индексом в строке
кэш-памяти}; поиск тега на каждом уровне осуществляется среди
фиксированного количества закэшированных тегов (их количество равно
ассоциативности кэш-памяти), все такие теги соответствуют сету
физического адреса
\end{enumerate}
