\section{Алгоритм построения тестовой программы по схеме тестовой программы}

Ключевой технологией в предлагаемом подходе генерации тестовых
данных является использование логического программирования с
ограничениями (constraint logic programming). Сначала по схеме
тестовой программы следует построить логическую программу, в которой
тестовые данные будут аргументами некоторого предиката, и затем с
использованием логического интерпретатора получить значения
аргументов этого предиката, на котором он истинен. Предикат будет
описывать все зависимости значений регистров и состояния
микропроцессора в процессе работы тестовой программы,
соответствующей схеме тестовой программы.

Каждое изменение значение регистра будет преобразовано в логической
программе в предикат, в котором значение регистра до изменения и
значение регистра после изменения будут двумя логическими
переменными. Говоря более обще, при трансляции изменений будет
использоваться \emph{механизм версионности}.

Схема тестовой программы представляет собой последовательность
преобразований значений регистров (и состояния кэша и других
подсистем). Причем каждое очередное преобразование задается с
помощью тестовой ситуации. В предлагаемом подходе еще одной ключевой
особенностью является требование \emph{описать каждую тестовую
ситуацию} в формальном виде. Каждое описание тестовой ситуации
должно представлять из себя последовательность утверждений и
присваиваний. Утверждение фиксирует истинность некоторого предиката.
Присваивание понимается так же, как и во всех языках
программирования. Утверждения и присваивания из описания очередной
тестовой ситуации последовательно транслируются, наполняя логическую
программу (не забывая про механизм версионности). Для описания
предикатов в утверждениях и присваиваемых выражений предлагается
использовать арифметические операции (сложение, умножение), битовые
операции (битовый диапазон, конкатенация), логические операции
(конъюнкция, дизъюнкция) и вызовы функций или предикатов.

Как было сказано ранее, тестовые ситуации команд берутся из описания
стандарта архитектуры микропроцессора. В таких описаниях встречаются
вызовы специальных функций. В стандарте архитектуры для них дается
лишь сигнатура и описании. В операциях с памятью используются 3
такие функции -- LoadMemory, StoreMemory и AddressTranslation. Эти
функции уточняют тестовую ситуацию команды. Например, тестовая
ситуация команды, вызывающей LoadMemory, (это команда загрузки из
памяти) может содержать указание на то, какая происходит тестовая
ситуация в кэше (кэш-промах или кэш-попадание). По сути общая
тестовая ситуация для такой команды есть опять же ограничение на
параметры команды и на состояние микропроцессора, но только более
хитрое. А именно некоторый адрес, формируемый из параметров команды,
должен находиться в кэше или нет. Кроме того необходимо учесть
механизм работы кэша -- могут появиться дополнительные ограничения
на адреса, которые находятся в кэше (например, что некоторый адрес
должен подходить под условия вытеснения). Для выражения таких
сложных ограничений предлагается совершить некоторую дополнительную
работу по упрощению этих ограничений. Далее будет показано, что эти
ограничения сводятся к равенству-неравенству адресов, что проще,
чем, например, ограничение, что адрес является последним
неиспользуемым в данный момент (если кэш поддерживает политику
кэширования last recently used). Преобразование необходимо проводить
до трансляции схемы тестовой программы в логическую программу.

Рассмотрим этот момент подробнее. Функции LoadMemory и StoreMemory
предназначены для указания обращения в память. Причем это обращение
в память выполняется согласно механизмам работы с кэш-памятью:
сначала идет попытка обнаружить запрашиваемый адрес в кэш-памяти;
если попытка удачная (эта ситуация называется кэш-попаданием),
возвращаются данные по этому адресу из кэша; если же попытка
оказалась неуспешной и запрашиваемый адрес отсутствует в кэше,
первым делается обращение за адресом (куда -- это отдельный вопрос),
затем из кэша вытесняется некоторый адрес и на освободившееся место
помещается искомый адрес. Исходя даже из такого описания, можно
сформулировать ситуации кэш-промаха и кэш-попадания в виде
ограничений на некоторые элементы структуры, моделирующей кэш. Но
для начала надо рассмотреть, что из себя представляет эта структура.

Выделяют \emph{кэш данных} и \emph{кэш инструкций}. C структурной
точки зрения они очень похожи, поэтому далее они будут
рассматриваться под общим названием <<кэш-память>>. Вся кэш-память
делится на блоки (\emph{уровни кэша}), структурная организация
которых одинаковая за исключением количественных характеристик.
Каждый уровень кэша представляется двумя структурами -- \emph{кэш
данных} и \emph{кэш адресов данных}. Кэш данных представляет собой
индексированную последовательность \emph{кэш-строк}. ||тут нужна
картинка структуры кэша|| Одна кэш-строка соответствует непрерывной
части памяти, начальный адрес которой выровнен некоторым образом.
Оставшая старшая часть начального адреса кэш-строки задается в кэше
адресов данных. Она делится на две части: старшую -- \emph{тег} -- и
младшую -- \emph{номер сета}. Кэш данных (и кэш адресов данных)
можно логически разбить на части одинакового размера. Каждая часть
кодируется номером сета. Например, если на номер сета отведено 3
бита, то кэш данных разделен на $2^3 = 8$ сетов. В одном сете
находятся кэш-строки в количестве, равном отношению их общего
количества в кэш-памяти на количество сетов. Каждое обращение в
кэш-память начинается с выделения номера сета и тега. Затем делается
поиск этого тега среди тегов в сете с полученным номером сета.
Успешный результат поиска означает ситуацию кэш-попадания. Тогда по
индексу ячейки кэша адресов данных (он же индекс ячейки кэша данных)
процессор получает данные из кэша по заданному адресу. Неуспешный
результат поиска означает ситуацию кэш-промаха. Обычно количество
различных тегов в одном сете (равное <<2 в степени битовый размер
тега>>) больше, чем количество кэш-строк в одном сете. Тогда среди
тегов в заданном сете выбирается кандидат на вытеснение (согласно
политике кэширования, например, это может быть самый последний
неиспользуемый тег) и заменяется данным тегом вместе с обновлением и
кэша данных. Таким образом, ситуации в операциях с кэш-памятью --
это ситуации в кэше адресов данных.

Для представления кэш-памяти адресов данных более удобной будет
структура типа <<таблица>> -- отображение из номера сета в множество
тегов. Она удобна тем, что, найдя номер сета, можно формулировать
ситуацию не на всей кэш-памяти, а лишь на тегах этого сета. Учитывая
большой размер кэш-памяти и обозримый размер сета, это соображение
становится очень важным. Кроме того, работа с одним сетом происходит
независимо от другого сета, что является еще одним доводом в пользу
такой модели кэш-памяти. И, наконец, такая организация позволит
учесть принцип локальности программ, который заключается в том, что
программа работает с небольшим объемом данных, а остальные данные
остаются такими как есть и их можно даже исключить из структуры и
хранить только те сеты, к которым действительно есть обращения.

Таким образом, требуется преобработка схемы тестовой программы для
выяснения, с каким сетом будет работать та или иная команда. Это
упрощает выражение тестовой ситуации в кэше, но это выражение можно
сделать еще проще. Оказывается, можно выразить все ограничения
тестовых ситуаций в кэше в виде более простых зависимостей
(принадлежности адреса текущей версии кэша (помним про механизм
версионности -- на модель кэша он также распространяется),
непринадлежности адреса текущей версии кэша, равенство и неравенство
адресов). Для этого нужно сделать еще одну преобработку схемы
тестовой программы перед построением логической программы после
преобработки, которая распределяет команды по сетам.

Итак, общий алгоритм работы генератора тестовых данных следующий:
\begin{enumerate}
\item распределить элементы тестового шаблона по сетам
\item в каждом сете преобразовать указания промахов/попаданий в виде более простых ограничений
\item странслировать каждую тестовую ситуацию в единую логическую программу
\item исполнить построенную программу и получить тестовые данные
\end{enumerate}
