\section{Тестовые шаблоны (схемы тестовых программ)}\label{scheme}
||опять это переписанное из Сашиной статьи - надо написать нечто
аналогичное|| Тестовые программы имеют вид $\Pi = \pi_{start} \cdot
{\langle \pi_i, x_i(D_i, S_i)\rangle}_{i=1,n} \cdot\pi_{stop}$, где:
\begin{itemize}
\item $\pi_{start}$ —- \emph{инициализирующая программа}: содержит вспомогательные
инструкции, предназначенные для инициализации микропроцессора;
\item $\langle \pi_i, x_i(D_i, S_i)\rangle$ —- \emph{тестовый случай} (i = 1, …, n):
    \begin{itemize}
    \item $\pi_i$ —- \emph{программа подготовки тестового воздействия}:
последовательность инструкций, осуществляющая инициализацию
операндов тестируемых инструкций и подготовку состояния
микропроцессора перед выполнением тестового воздействия;
    \item $x_i(D_i, S_i)$ —- \emph{тестовое воздействие}:
     тестируемая последовательность инструкций:
между инструкциями определены зависимости $D_i$, а значения
операндов инструкций и состояние микропроцессора (содержимое
регистров, кэш-памяти и других подсистем) удовлетворяют ограничениям
$S_i$;
    \end{itemize}
\item $\pi_{stop}$ —- \emph{завершающая программа}: содержит вспомогательные
инструкции, предназначенные для завершения работы микропроцессора;
\item $n$ —- \emph{размер тестовой программы}: параметр генерации, указывающий
число тестовых воздействий в одной тестовой программе.
\end{itemize}

Вадным понятием является понятие \emph{тестового воздействия}.
Тестовое воздействие характеризуется \emph{тестовым шаблоном}
(тестируемой последовательностью инструкций), \emph{зависимостями
между инструкциями} (как операнды разных инструкций связаны между
собой) и \emph{тестовыми ситуациями} (ограничениями на значения
операндов инструкций и состояние микропроцессора).

\emph{Тестовым шаблоном} называется тестируемая последовательность
инструкций без указания конкретных значений операндов. Задача
тестового шаблона зафиксировать порядок инструкций в тестовом
воздействии. Ниже приведен пример тестового шаблона, состоящий из
двух инструкций: инструкции сложения ADD и инструкции вычитания SUB:
\begin{verbatim}
add ... // тестовый шаблон фиксирует порядок инструкций
sub ... // тестовый шаблон не определяет значений операндов
\end{verbatim}

\subsection{Зависимости между инструкциями}
Использование различных тестовых шаблонов, как правило, не является
достаточным условием качественного тестирования микропроцессора.
Важным моментом является то, какие \emph{зависимости между
инструкциями} использовались в тестах. Выделяют два основных типа
зависимостей между инструкциями: \emph{зависимости по регистрам} и
\emph{зависимости по адресам}. Зависимости по регистрам выражаются в
совпадении регистров, использующихся в качестве операндов разных
инструкций тестового воздействия. Зависимости по адресам определены
для инструкций работы с памятью, таких как инструкции загрузки и
сохранения регистров (load/store instructions). Зависимости по
адресам являются частным случаем так называемых \emph{зависимостей
по содержимому}, которые определяются не на основе совпадения или
несовпадения используемых регистров, а с помощью ограничений на
значения пары входных параметров (зависимого и определяющего). Будут
использоваться две разновидности зависимостей по регистрам:
\emph{зависимости типа определение-использование} (define-use
dependencies), когда выходной регистр одной инструкции является
входным регистром следующей за ней инструкции, и \emph{зависимости
типа определение-определение} (define-define dependencies), когда
выходной регистр одной инструкции также является выходным регистром
следующей за ней инструкции3. Возможны и другие типы зависимостей,
например, зависимости типа использование-использование (use-use
dependencies), но такие зависимости обычно не влияют на логику
работы микропроцессора.

Для иллюстрации зависимостей по регистрам рассмотрим два простых
примера. В первом примере показана зависимость типа
определение-использование:
\begin{verbatim}
add r1, r2, r3 // определение регистра r1
sub r4, r1, r5 // использование регистра r1
\end{verbatim}

Инструкция ADD складывает содержимое регистров $r2$ и $r3$ и
сохраняет результат в регистре $r1$. Следующая за ней инструкция SUB
использует содержимое регистра $r1$ —- она вычитает из содержимого
регистра $r1$ содержимое регистра $r5$ и сохраняет результат в
регистре $r4$.

В следующем примере проиллюстрирована зависимость типа
определение-определение:
\begin{verbatim}
add r1, r2, r3 // определение регистра r1
sub r1, r4, r5 // переопределение регистра r1
\end{verbatim}

В этом примере инструкция SUB сохраняет свой результат в том же
самом регистре $r1$, что и предшествующая ей инструкция ADD.

Зависимости по адресам определяются структурой памяти
микропроцессора. Выделяют \emph{зависимости по виртуальным адресам}
и \emph{зависимости по физическим адресам}. В качестве примеров
зависимостей по адресам можно привести следующие: совпадение
виртуальных адресов, используемых различными инструкциями;
совпадение физических адресов при несовпадающих виртуальных адресах;
попадание в одну и ту же запись буфера трансляции адресов; попадание
в одну и ту же строку кэш-памяти.

\subsection{Тестовые ситуации}

Как правило, инструкции микропроцессора имеют несколько \emph{ветвей
функциональности}, то есть в зависимости от значений входных
операндов и состояния микропроцессора ведут себя по-разному. Для
инструкций, вызывающих исключения, примерами ветвей функциональности
являются ситуации, в которых возникает то или иное исключение. Далее
вместо термина \emph{ветвь функциональности} будет использоваться
более общий термин \emph{тестовая ситуация}.

Под \emph{тестовой ситуацией} для инструкции понимается ограничение
на значения входных операндов и состояние микропроцессора перед
началом выполнения инструкции. Если рассматривать не отдельную
инструкцию, а их последовательность (тестовый шаблон), можно
определить тестовую ситуацию для шаблона в целом как набор тестовых
ситуаций для входящих в него инструкций. Тестовые ситуации
выявляются на основе анализа описания архитектуры микропроцессора и
его системы команд. Особое внимание при этом уделяется ветвям
функциональности, в частности, условиям на исключения. Рассмотрим
пример описания инструкции ADD из системы команд MIPS64:
\begin{verbatim}
ASSERT WordValue(GPR[rs]) AND WordValue(GPR[rt]) ;
temp <- ( GPR[rs]_31 || GPR[rs]_{31..0} )
      + ( GPR[rt]_31 || GPR[rt]_{31..0} )
IF temp_32 # temp_31 THEN
    SignalException( IntegerOverflow )
ELSE
    GPR[rd] <- sign_extend( temp_{31..0} )
ENDIF
\end{verbatim}

Предикат $temp_{32} \# temp_{31}$ определяет ветвь функциональности,
соответствующую исключению $IntegerOverflow$; другая ветвь
соответствует нормальному выполнению инструкции.
