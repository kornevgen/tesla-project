\section{Алгоритм преобразования тестовых ситуаций в кэше
    в равенство-неравенство адресов}\label{eqs}

Исходными данным для алгоритма является последовательность тестовых
ситуаций в кэш-памяти, относящиеся к одному сету. Алгоритм
транслирует тестовые ситуации в кэш-памяти в ограничения
<<равенство-неравенство>> на целочисленных переменных (адресах). Для
работы алгоритма принципиально то, что все тестовые ситуации,
относящиеся к одному сету, рассматриваются вместе.

Введем ряд обозначений:
\begin{itemize}
\item \emph{hit(p)} -- <<кэш-попадание>>. Означает, что тег $p$
должен быть среди тегов, находящихся в данный момент в сете.
\item \emph{miss(p) $\rightarrow$ p1} -- <<кэш-промах>>. Означает, что тег $p$ не
присутствует среди тегов, находящихся в данный момент в сете, но
будет присутствовать среди тегов, находящихся в следующий момент в
сете, а тег $p1$, наоборот, присутствует среди тегов, находящихся в
данный момент в сете, но не будет присутствовать среди тегов,
находящихся в следующий момент в сете. В остальным сет в следующий
не меняется. Кроме того, тег $p1$ попадает под \emph{условие
вытеснения} (например, lru).
\end{itemize}

Выразим каждую тестовую ситуацию в виде предиката и составим из их
последовательность систему. Получится система с переменными,
выражающими теги. Решением такой системы будет информация о
равенстве тега одной команды тегу другой команды.

Сначала после каждого $miss(p) \rightarrow p1$ вставим $hit(p)$.

Первый набор предикатов в систему получается из условий на $hit(p)$:
тег $p$ должен лежать в сете в данный момент. Это можно записать в
виде принадлежности $p \in L$. $L$ есть множество тегов, хранящихся
в данный момент в сете. $L$ меняется при осуществлении $miss$:
вытесняемый тег оттуда удаляется, заданный тег добавляется ($L' = (L
\setminus \{ p1 \} ) \cup { p } $). Значение $L$ перед исполнением
тестового воздействие берется из начального состояния кэша. Зная
размер сета $n$, можно задать начальное значение $L = \{ x_1, x_2,
..., x_n \}$. В систему надо добавить, что все теги начального
значения $L$ различные.

Следующий набор предикатов в систему получается из условий на
$miss(p) \rightarrow p1$. Первое условие, что $p \notin L$. В
противном случае тег $p$ находился бы в сете перед тестовой
ситуацией, что противоречило бы ситуации <<кэш-промах>>. Еще одно
условие, что $p1 \in L$, ведь вытесняемый тег должен лежать в сете
до вытеснения. Теперь надо выразить условие вытеснения на тег $p1$.
Такие стратегии вытеснения, как LRU, MRU описываются техникой,
приведенной далее. Будем рассматривать LRU, как более сложный
случай. Согласно стратегии кэширования LRU (Least Recently Used)
будет вытеснен тег, к которому дольше всех не было обращений. Иными
словами, с момента последнего обращения к этому тегу (последнего к
нему $hit(p1)$) до момента вытеснения происходят обращения ко всем
остальным тегам сета (назовем последовательность операторов между
последним обращением и вытеснением \emph{диапазоном вытеснения}
тега). Таким образом, в алгоритме необходимо выделить последнее
обращение (например, если это обращение $hit(q)$, то надо добавить,
как вариант, условие $p1 = q$) и добавить условие, что множество
тегов, к которым происходят обращения между $hit(q)$ и $miss(p)
\rightarrow p1$, равно $L \setminus \{ p1 \}$, где $L$ -- сет в
момент перед $miss$ (назовем эти условия <<условиями диапазона
вытеснения>>). Для определения последнего обращения к тегу $p1$
можно использовать перебор всех $hit$ в схеме тестовой программы.
Однако такой перебор дает систему очень большого размера. Для
сокращения можно заметить:
\begin{enumerate}
\item между последним обращением к $p1$ и его вытеснением должно
быть не менее $N - 1$ обращений к тегам, где $N$ -- размер сета. Это
позволяет начать перебор обращений на некотором расстоянии от места
вытеснения
\item диапазоны вытеснения разных тегов не могут быть вложены. Они
либо не пересекаются, либо пересекаются, но без вложения. Если бы
один диапазон вытеснения был вложен в другой диапазон вытеснения, то
нарушилось бы требование осуществления обращения ко всем без
исключения тегам в сете на протяжении всего диапазона вытеснения.
\end{enumerate}

Из-за второго соображения можно сделать вывод, что появляющийся в
диапазоне вытеснения другой $miss$ не влияет на форму условия.

Пример последовательности ситуаций в кэше и соответствующая система:
\begin{verbatim}
 hit x1
 hit x2
 hit x3                L = { x1, x2, x3, x4 }
 hit x4
[ miss x5 -> x6 ]
 hit x5   // добавленный hit
 hit x7                L1 = ( { x1, x2, x3, x4 } \ { x6 } ) \/ { x5 }
[ miss x8 -> x9 ]
\end{verbatim}
и система для 4-х ассоциативной кэш-памяти (ассоциативность равна
размеру сета):
$$
\left\{
    \begin{aligned}
        x1 \notin \{x2, x3, x4\}, x2 \notin \{x3, x4\}, x3 \neq x4\\
        x6 \in L\\
        x5 \notin L\\
        \{x7, x9\} \subseteq L1\\
        x8 \notin L1\\
        \\
        \left[
            \begin{aligned}
                \left\{
                    \begin{aligned}
                        x9 = x3\\
                        \{x4, x5, x7\} = L1 \setminus \{ x9 \}\\
                        x6 = x1\\
                        \{x2, x3, x4\} = L \setminus \{ x6 \}\\
                    \end{aligned}
                \right. \\
                \left\{
                    \begin{aligned}
                        x9 = x2\\
                        \{x3, x4, x5, x7\} = L1 \setminus \{ x9 \}\\
                        x6 = x1\\
                        \{x2, x3, x4\} = L \setminus \{ x6 \}\\
                    \end{aligned}
                \right. \\
            \end{aligned}
        \right.
    \end{aligned}
\right.
$$
Решением такой системы могут быть следующие зависимости между
тегами:
$$
\left\{
    \begin{aligned}
    \{ x1, x2, x3, x4, x5 \} - \text{ все разные }\\
    x6 = x1\\
    x7 = x2\\
    x9 = x3\\
    x8 \neq x2, x8 \neq x3, x8 \neq x4, x8 \neq x5\\
    \end{aligned}
\right.
$$
или
$$
\left\{
    \begin{aligned}
    \{ x1, x2, x3, x4, x5 \} - \text{ все разные }\\
    x6 = x1\\
    x7 = x3\\
    x9 = x2\\
    x8 \neq x2, x8 \neq x3, x8 \neq x4, x8 \neq x5\\
    \end{aligned}
\right.
$$
или
$$
\left\{
    \begin{aligned}
    \{ x1, x2, x3, x4, x5 \} - \text{ все разные }\\
    x6 = x1\\
    x7 = x4\\
    x9 = x2\\
    x8 \neq x2, x8 \neq x3, x8 \neq x4, x8 \neq x5\\
    \end{aligned}
\right.
$$
или
$$
\left\{
    \begin{aligned}
    \{ x1, x2, x3, x4, x5 \} - \text{ все разные }\\
    x6 = x1\\
    x7 = x5\\
    x9 = x2\\
    x8 \neq x2, x8 \neq x3, x8 \neq x4, x8 \neq x5\\
    \end{aligned}
\right.
$$

Для учета начального состояния сета ( $\{x1, x2, x3, x4\}$ ) перед
ситуациями из схемы тестовой программы добавлены четыре ситуации
$hit$ в порядке, обратном их положению согласно принципу lru.
Возможна ситуация, когда для успешного разрешения ограничений
необходимо иметь начальное значение сета отличным от начального
значения, заданного для всей схемы тестовой программы. В таком
случае следует по возможности выбирать начальное состояние сета
таким, чтобы программа его инициализации была минимальной (это
уменьшит возможный побочный эффект программы инициализации).

Если схема тестовой программы начинается с последовательности
кэш-промахов, то несложно просчитать без разрешения ограничений,
чему равны вытесняемые теги. Это позволит еще уменьшить размер
системы.

Подводя итог, приведем более сжатое описание алгоритма построения
системы для стратегии LRU:  ||нужно привести псевдокод?..||
\begin{enumerate}
\item просчитать кэш-промахи до первого кэш-попадания
    и убрать их из схемы ; тем самым сформируется
        <<начальное состояние сета>>
\item добавить перед схемой hit(x) для каждого х из
    <<начального состояния сета>> в порядке, соответствующем
    статистике lru
\item сгенерировать пустую общую систему
\item добавить в общую систему
условия, что все теги из
    <<начального состояния сета>> разные
\item вставить в схему тестовой программы после каждого
    miss(p)->q  новую ситуацию hit(p)
\item между каждыми двумя соседними miss построить
    <<формулу состояния сета>> $L_i$
\item для каждого hit(p) добавить в общую систему условие
    $p \in L_i$ , где $L_i$ - формула состояния сета
    там, где встретился этот hit
\item для каждого miss(p)->q добавить в общую систему условия
    $p \in L_i$ и $q \notin L_i$
\item распределить <<диапазоны вытеснения>> для всех вытесняемых
    тегов ; в результате получится серия диапазонов ; одна
    серия соответствует одному диапазону для каждого
    вытесняемого тега
\item для каждой серии диапазонов построить систему <<условий
    диапазонов вытеснения>>
\item добавить в общую систему совокупность сгенерированных на
    предыдущем шаге систем
\item решить построенную общую систему
\end{enumerate}

Для решения построенной общей системы можно применить систему
разрешения ограничений над множествами целых чисел или другой
подобный алгоритм.
