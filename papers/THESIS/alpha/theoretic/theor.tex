\documentclass{article}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{pscyr}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amssymb}

\title{Основная теоретическая часть диссертации}
\author{}
\date{}

\textwidth=16cm \oddsidemargin=0cm

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}

\begin{document}
\maketitle

Введение: Исходная постановка задачи -- последовательность тестовых
ситуаций + что надо вычислить. Типы кэш-памяти: полностью
ассоциативный, прямого отображения и наборно-ассоциативный.

\section{Использование уравнений на множества для описания тестовых
ситуаций в кэш-памяти}\label{cache_sets}

\begin{abstract}
В этом разделе идет речь о том, как решать задач генерации тестовых данных
для последовательности тестовых ситуаций в кэш-памяти. Раздел содержит
новые результаты по формальному представлению тестовой ситуации в
кэш-памяти, новый алгоритм генерации уравнений для их описания и
новое исследование этих уравнений. 
\end{abstract}

Общая идея решения поставленной задачи -- по тестовому шаблону
построить систему уравнений и решить ее. Поскольку решением задачи
является начальное состояние микропроцессора (значения регистров
перед началом исполнения тестового шаблона, значения ячеек
кэш-памяти и других подсистем микропроцессора перед началом
исполнения тестового шаблона), то в системе в качестве свободных
переменных будут представлены элементы начального состояния
микропроцессора.

Рассмотрим идеи, исходя из которых предлагается строить систему
уравнений. Каждая инструкция может поменять значение регистров или
содержимое кэш-памяти и других подсистем. Значения регистров будут
представляться <<скалярными>> переменными. Содержимое кэш-памяти
будет представляться \emph{множеством ячеек} кэш-памяти. Содержимое
кэш-памяти можно разделить на две структуры -- структура для
хранения кэшированных данных и структура для хранения тегов адресов
кэшированных данных. Для моделирования тестовых ситуаций в
кэш-памяти будет использоваться только структура для хранения тегов.

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{mpset}\\
  \caption{Представление состояния микропроцессора}\label{mpset}
\end{figure}

Теперь можно подходить ближе к тому, как эту систему составлять. Но
перед этим напомню тестовые ситуации инструкций, работающих с
кэш-памятью (для описания будут использоваться следующие переменные:
$L$ -- текущее состояние кэш-памяти (множество тегов), $x$ --
(физический) адрес данных в инструкции):
\begin{itemize}
\item \emph{кэш-попадание} происходит в том случае, когда данные по
данному адресу присутствуют в кэш-памяти; по такой тестовой ситуации
предлагается строить уравнение $x \in L$;
\item \emph{кэш-промах} происходит в случае, когда данные по данному
адресу не присутствуют в кэш-памяти; для этой тестовой ситуации
составляется уравнение $x \notin L$.
\end{itemize}

Физический адрес данных в инструкции ($x$) может быть составлен из
аргументов инструкции (обычно регистров). При этом следует
использовать значения регистров в момент данной инструкции
(применить для регистров Static single assignment form,
SSA).

Рассмотрим, как составить выражение для $L$ в каждой инструкции
методом индукции. $L$ для первой инструкции есть начальное
содержимое кэш-памяти, это переменная величина в системе уравнений.
Пусть выражение для очередной инструкции $L$, а для следующей --
$L'$. Тогда если очередная инструкция -- кэш-попадание, то $L'
\equiv L$ (так как содержимое не меняется), а если очередная
инструкция -- кэш-промах с адресом $x$, то $L' \equiv (L \setminus
\{x'\} \cup \{x\})$ (так как в кэш-память при промахе добавляются
данные по нужному адресу, а некоторые данные вытесняются, $x'$ есть
адрес вытесняемых данных). Для новой переменной $x'$ добавим в
систему такие уравнения: $x' \in L \wedge displaced(x') \wedge R(x)
= R(x')$, новый предикат $displaced$ описывает \emph{стратегию
вытеснения}, т.е. правило, по которому в кэш-памяти выбираются
данные, которые следует удалить, а на их место поместить данные,
вызвавшие промах. Для кэш-памяти прямого отображения общезначимо
утверждение $(R(x) = R(x')) \rightarrow displaced(x')$, поэтому для
такого типа кэш-памяти уравнение $displaced(x')$ убирается из
системы. Функциональный символ $R$ используется для задания набора,
которому относится адрес, в кэш-памяти прямого отображения и
наборно-ассоциативной кэш-памяти. Возможна такая семантика этого
символа -- $R(x)$ это множество адресов, которые потенциально могут
находиться в том же наборе, что и набор адреса $x$ (верно
утверждение, что адрес не может соответствовать более чем одному
набору и не соответствовать никакому набору вообще, одному набору
могут соответствовать разные адреса). Или такая семантика -- $R(x)$
это номер набора адреса $x$. Для составления уравнений может быть
выбрана любая семантика. Для полностью-ассоциативной кэш-памяти
уравнение $R(x) = R(x')$ является тождественной истиной, поскольку в
нем все адреса соответствуют одному набору.

Следующая теорема описывает выражение для $L$ без использования
индукции и составление ограничений для тестовых ситуаций в
кэш-памяти:
\begin{lemma}
Пусть $L$ -- выражение для текущего состояния кэш-памяти, $L_0$ --
множество адресов данных, расположенных в кэш-памяти перед
исполнением инструкций тестового шаблона, $\{x_i\}$ -- множество
адресов данных в инструкциях с кэш-промахами, расположенными до
текущей инструкции в том же порядке, что и в тестовом шаблоне,
$\{x'_i\}$ -- множество адресов вытесняемых данных в инструкциях с
кэш-промахами, расположенными до текущей инструкции в том же
порядке, что и в тестовом шаблоне. Тогда
$$L = L_0 \setminus \bigcup_{i} \{x'_i\} \cup \bigcup_{i} ( \{x_i\} \setminus \cup_{j > i} \{x'_j\}).$$
\end{lemma}
\begin{proof}
//TODO

Например, если перед данной инструкцией располагается 3 инструкции с
кэш-промахом, то $L = L_0 \setminus \{x'_1, x'_2, x'_3\} \cup
(\{x_1\} \setminus \{x'_2, x'_3\}) \cup (\{x_2\} \setminus \{x'_3\})
\cup \{x_3\}$.
\end{proof}

\begin{theorem}
Пусть $L_0$ -- множество адресов данных, расположенных в кэш-памяти
перед исполнением инструкций тестового шаблона, $\{x_i\}$ --
множество адресов данных в инструкциях с кэш-промахами,
расположенными до текущей инструкции в том же порядке, что и в
тестовом шаблоне, $\{x'_i\}$ -- множество адресов вытесняемых данных
в инструкциях с кэш-промахами, расположенными до текущей инструкции
в том же порядке, что и в тестовом шаблоне. Тогда
\begin{itemize}
\item для инструкции с кэш-попаданием адреса $x$ следует добавить
следующую совокупность уравнений:
$$
\left[
   \begin{array}{l}
    x \in L_0 \wedge x \notin \{x'_1, x'_2, ..., x'_n\} \\
    x = x_1 \wedge x \notin \{x'_2, ..., x'_n\} \\
    x = x_2 \wedge x \notin \{x'_3, ..., x'_n\} \\
    ...\\
    x = x_{n-1} \wedge x \notin \{x'_n\} \\
    x = x_n \\
   \end{array}
  \right.
$$

\item для инструкции с кэш-промахом адреса $x$ (и адресом
вытесненных данных $x'$) следует добавить следующую систему
уравнений:
$$
\left\{
   \begin{array}{l}

  \left[
   \begin{array}{l}
    x \notin L_0 \wedge x \notin \{x_1, x_2, ..., x_n\} \\
    x = x'_1 \wedge x \notin \{x_2, ..., x_n\} \\
    x = x'_2 \wedge x \notin \{x_3, ..., x_n\} \\
    ...\\
    x = x'_{n-1} \wedge x \notin \{x_n\} \\
    x = x'_n \\
   \end{array}
  \right. \\

  { }\\

  \left[
   \begin{array}{l}
    x' \in L_0 \wedge x \notin \{x'_1, x'_2, ..., x'_n\} \\
    x' = x_1 \wedge x \notin \{x'_2, ..., x'_n\} \\
    x' = x_2 \wedge x \notin \{x'_3, ..., x'_n\} \\
    ...\\
    x' = x_{n-1} \wedge x \notin \{x'_n\} \\
    x' = x_n \\
   \end{array}
  \right. \\

  { }\\

  displaced(x')\\

  { }\\

  R(x) = R(x')\\

  \end{array}
\right.
$$

\end{itemize}
\end{theorem}
\begin{proof}
//TODO
\end{proof}

Заметьте, что получившиеся ограничения для кэш-попадания и
кэш-промаха получились очень похожими, хотя изначально у них было
два совершенно противоположных представления. Теперь надо выразить
стратегию вытеснения в виде уравнений на множества тегов.

\subsection{Методика выделения ограничений для описания тестовых
ситуаций с помощью уравнений на множества}

Итак, есть тестовый шаблон, в тестовом шаблоне для некоторой
инструкции добавлена переменная для вытесняемого тега, и для этой
переменной надо записать условие, при котором она будет вытеснена в
данной инструкции. Это условие предлагается записывать в виде
системы (возможно, с дизъюнкциями) уравнений на множества тегов,
которые можно получить, учитывая следующие правила:

\begin{enumerate}
\item переменные не кодируют порядок элементов, только содержимое
кэша;
\item порядок элементов определяется на основе порядка
инструкций, только порядком инструкций (т.е. порядком адресов, к
которым происходит обращение) можно пользоваться для кодирования
различных механизмов упорядочения; рекомендуется использовать то
определение стратегии вытеснение, в котором порядок используется
меньше всего;
\item введение термина \emph{диапазон вытеснения} -- той части
тестового шаблона, которая непосредственно влияет на вытеснение; у
диапазона есть начало на некоторой инструкции или элементе
начального состояния кэш-памяти; конец диапазона вытеснения есть
инструкция, вытесняющая нужный тег; система ограничений может
содержать дизъюнкцию условий, каждое соответствует некоторому
диапазону вытеснения;
\item \emph{(эвристика невложенных диапазонов)} если согласно
выбранному принципу выбора диапазоны вытеснения не могут быть
вложены, скорее всего вы на правильном пути;
\item \emph{(эвристика полноты)} зачастую реальные стратегии
вытеснения основаны на неком свойстве полноты некоторой группы
элементов; эта полнота может быть полезна при формулировании
уравнений;
\item возможно использование функциональных символов
(например, как это сделано с $R$);
\item ориентирование на символьное решение системы уравнений на
множества.
\end{enumerate}

\subsection{Уравнения для некоторых стратегий вытеснения}

Здесь будет представлено, как приведенная выше методика была
применена для выделения уравнений, описывающих следующие стратегии
вытеснения, наиболее часто использующиеся в микропроцессорах -- это
LRU (Least Recently Used), FIFO (First-In First-Out) и Pseudo-LRU.
Стратегия вытеснения Random не рассматривается, ввиду ее
недетерминированности и детерминированности системы уравнений.

\subsubsection{LRU -- Least Recently Used}

LRU (Least Recently Used) -- это стратегия вытеснения, определяющая
вытесняемые данные как наименее используемые. Она эффективна для
алгоритмов, обладающих свойством локальности данных, т.е. чаще
использующих те данные, к которым недавно происходило обращение. Эта
стратегия используется, например, в микропроцессорах архитектуры MIPS~\cite{mips64_II}.

Стратегия вытеснения LRU обычно определяется с использованием
счетчиков обращений. Более подробно, для каждого элемента кэш-памяти
вводится счетчик обращений к нему. Каждое обращение увеличивает
счетчик. Вытесняемым будет элемент с минимальным счетчиком. Однако
описание в виде уравнений на множества изменений значений счетчиков
будет слишком громоздким.

Другой способ описания LRU основан на введении порядка на элементах
набора (т.е. набор представляется списком элементов). После каждой
инструкции элементы переупорядочиваются согласно следующим правилам
(см.рис.~\ref{lru1}):
\begin{itemize}
\item при кэш-попадании элемент, соответствующий адресу инструкции,
перемещается в начало, остальные элементы от первого до данного
сдвигаются на одну позицию;
\item при кэш-промахе вытесняется последний элемент, в начало
вставляется элемент, вызвавший промах.
\end{itemize}

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{lru1}\\
  \caption{Стратегия вытеснения LRU (w - ассоциативность кэш-памяти)}\label{lru1}
\end{figure}

Однако и это описание не подходит, потому как оно существенно
использует порядок элементов.

Третий способ описания LRU основан на выборе последнего обращения к
вытесняемому элементу: чтобы элементу был вытеснен, необходимо и
достаточно, чтобы между последним обращением к нему и вытеснением
были обращения ко всем элементам текущего состояния кэш-памяти,
кроме него. Инструкции от последнего обращения к вытеснению образуют
диапазон вытеснения (см. рис.~\ref{lru-ranges}).

\begin{figure}[h] \center
  \includegraphics[width=0.4\textwidth]{lru}\\
  \caption{LRU и диапазоны вытеснения}\label{lru-ranges}
\end{figure}

Запишем в виде уравнений на множества эту логику. Предикат
$displaced(x')$ будет представлен дизъюнкцией уравнений -- каждый
элемент дизъюнкции соответствует некоторому диапазону вытеснения.
Тогда для диапазона вытеснения к инструкции, обращающейся к адресу
$y$ надо составить такую систему уравнений ($x_1, x_2, ..., x_n$ --
множество адресов, к которым происходят обращения внутри диапазона
вытеснения (как с кэш-попаданиями, так и с кэш-промахами), $L$ --
выражение для состояния кэш-памяти для инструкции, вытесняющей
$x'$):
$$
\left\{
   \begin{array}{l}
    x' = y \\
    \{x_1, x_2, ..., x_n\} \cap R(y) = (L \setminus \{y\}) \cap R(y)\\
   \end{array}
  \right.
$$

Функциональный символ $R$ используется в смысле множества адресов
того же региона. С использованием следующей леммы упростим эту
систему:
\begin{lemma}\label{LRU_simplification}
Для любых конечных множеств $X$, $Y$ и $Z$ таких, что $X \cap Y
\subseteq Z$, если существует $y$ такой, что $y \in (Y \cap
Z)\setminus X$, то $X \cap Y = (Z \setminus \{y\}) \cap Y
\Leftrightarrow Y \cap ( Z \setminus X ) = \{ y \}$.
\end{lemma}
\begin{proof}
Необходимость. По определению вычитания множеств и коммутативности
операции пересечения множеств $X \cap Y = (Z \setminus \{y\}) \cap Y
\Leftrightarrow X \cap Y = Z \cap Y \cap \overline{\{y\}}$.
Обозначим $A = Z \cap Y$, $B = X \cap Y$. Следовательно, $B = A
\setminus \{y\}$. По условию $y \notin B$ и $y \in A$. Значит, $A =
B \sqcup \{y\}$. Отсюда $A \setminus B = \{y\}$. Осталось показать,
что $A \setminus B = (Z \setminus X ) \cap Y$ : $A \setminus B = A
\cap \overline{B} = Z \cap Y \cap \overline{X \cap Y} = Z \cap Y
\cap (\overline{X} \cup \overline{Y}) = (Z \cap Y \cap \overline{X})
\cup (Z \cap Y \cap \overline{Y}) = Z \cap \overline{X} \cap Y = (Z
\setminus X ) \cap Y$.

Достаточность. Обозначим $A = Z \cap Y$, $B = X \cap Y$. С
использованием определений операций над множествами и их свойств
получаем $X \cap Y \subseteq Z \Leftrightarrow (X \cap Y) \setminus
Z = \varnothing \Leftrightarrow X \cap Y \cap \overline{Z} =
\varnothing \Leftrightarrow X \cap Y \cap (\overline{Z} \cup
\overline{Y}) = \varnothing \Leftrightarrow B \setminus A =
\varnothing$. Кроме того, по условию $A \setminus B = \{y\}$.
Следовательно, $A = (A \setminus B) \cup (A \cup B) = \{y\} \cup (B
\setminus (B \setminus A)) = \{y\} \cup (B \setminus \varnothing) =
\{y\} \cup B$. Таким образом, $A = B \cup \{y\}$. Кроме того, $y
\notin B$, значит, $A = B \sqcup \{y\}$, следовательно, $B = A
\setminus \{y\}$. Подставляя определения множеств $A$ и $B$,
получаем: $X \cap Y = (Z \cap Y) \setminus \{y\} = Z \cap Y \cap
\overline{\{y\}} = (Z \setminus \{y\}) \cap Y$.
\end{proof}

\begin{lemma}[Отсутствие вложенных диапазонов]\label{includedranges}
//TODO
\end{lemma}
\begin{proof}
//TODO
\end{proof}

\begin{lemma}[О выполнимости условий
леммы~\label{LRU_simplification} для диапазонов вытеснения] $L
\supseteq \{x_1, x_2, ..., x_n\} \cap R(y)$
\end{lemma}
\begin{proof}[\proofname~(от противного)]
Пусть среди $x_1, x_2, ..., x_n$ есть $x_i$ такой, что $x_i \notin L
\wedge x_i \in R(y)$. Пусть $L_{i+1}$ -- состояние кэш-памяти после
обращения к $x_i$. Верно, что $x_i \in L_{i+1}$, но $x_i \notin L$,
следовательно, $x_i$ был вытеснен между $x_{i+1}$ и $x_n$. Иными
словами, среди $x_1, x_2, ..., x_n$ есть элемент, чей диапазон
вытеснения вложен в диапазон вытеснения $y$. Но согласно
лемме~\ref{includedranges} это невозможно. Противоречие.
\end{proof}

Таким образом, можно применить лемму~\ref{LRU_simplification} для
упрощения уравнения для lru. В результате получаем, что для каждого
диапазона вытеснения можно записать следующую систему уравнений:
$$
\left\{
   \begin{array}{l}
    x' = y \\
    R(y) \cap (L \setminus \{x_1, x_2, ..., x_n\} ) = \{y\}\\
   \end{array}
  \right.
$$

\begin{theorem}
Определения LRU через диапазоны вытеснения и через списки
эквивалентны.
\end{theorem}
\begin{proof}
//TODO

Показать, что согласно лемме~\ref{includedranges} можно использовать
$L$ перед концом диапазона.
\end{proof}

\subsubsection{FIFO -- First-In First-Out}

FIFO (First-In First-Out) -- это стратегия вытеснения, определяющая
вытесняемые данные согласно принципу очереди FIFO. ///ГДЕ ИСПОЛЬЗУЕТСЯ???

Стратегия FIFO может быть описана на основе порядка на элементах
набора (т.е. набор представляется списком элементов). После каждой
инструкции элементы переупорядочиваются согласно следующим правилам
(см.рис.~\ref{fifo1}):
\begin{itemize}
\item при кэш-попадании порядок элементов не меняется;
\item при кэш-промахе вытесняется последний элемент, в начало
вставляется элемент, вызвавший промах.
\end{itemize}

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{fifo1}\\
  \caption{Стратегия вытеснения FIFO (w - ассоциативность кэш-памяти)}\label{fifo1}
\end{figure}

Отличие от LRU лишь в том, что при FIFO не происходит перестановки
элементов набора при возникновении кэш-попадания.

Это поведение может быть записано компактно с использованием
уравнений на множества. Определим диапазоны вытеснения для FIFO как
множество инструкций от внесения адреса в кэш-память до его
вытеснения. Причем исключим из него все инструкции с кэш-попаданиями
(они не играют никакой роли с точки зрения FIFO). Тогда \emph{FIFO
будет выполнено в том случае, когда в диапазоне встречаются все
адреса состояния кэш-памяти перед вытеснением без самого
вытесняемого адреса}.

Запишем в виде уравнений на множества эту логику. Предикат
$displaced(x')$ будет представлен дизъюнкцией уравнений -- каждый
элемент дизъюнкции соответствует некоторому диапазону вытеснения.
Тогда для диапазона вытеснения к инструкции, обращающейся к адресу
$y$ надо составить такую систему уравнений ($x_1, x_2, ..., x_n$ --
множество адресов, к которым происходят обращения внутри диапазона
вытеснения \textbf{с кэш-промахами}, $L$ -- выражение для состояния
кэш-памяти для инструкции, вытесняющей $x'$):
$$
\left\{
   \begin{array}{l}
    x' = y \\
    \{x_1, x_2, ..., x_n\} \cap R(y) = (L \setminus \{y\}) \cap R(y)\\
   \end{array}
  \right.
$$

Функциональный символ $R$ используется в смысле множества адресов
того же региона.

Для FIFO справедливы все леммы о диапазонах вытеснения,
сформулированные для LRU. В частности, с использованием их система
уравнений для диапазона вытеснения может быть переписана следующим
образом:
$$
\left\{
   \begin{array}{l}
    x' = y \\
    R(y) \cap (L \setminus \{x_1, x_2, ..., x_n\}) = \{y\}\\
   \end{array}
  \right.
$$

\begin{theorem}
Определения FIFO через диапазоны вытеснения и через списки
эквивалентны.
\end{theorem}
\begin{proof}
//TODO

Показать, что согласно лемме~\ref{includedranges} можно использовать
$L$ перед концом диапазона.
\end{proof}

\subsubsection{Pseudo-LRU}

//TODO

\pagebreak
\section{Разрешение уравнений, описывающих тестовые ситуации в
кэш-памяти; вопросы эффективности}

\begin{abstract}
Раздел содержит новый эффективный алгоритм для поиска тестовых данных
для реальных микропроцессоров. Рассматривается две формы задачи генерации
тестовых данных, отличающиеся результатом работы алгоритма. Показывается, что
составление системы уравнений не модульно, а совместно для кэш-памяти и TLB
существенно повышает эффективность ее решения. Дополнительно раздел дает
информацию о типах программ-solver'ов и эвристик выбора тех или иных в
зависимости от решаемой задачи.
\end{abstract}

Введение: что такое TLB.

\subsection{Особенности исполнения инструкций обращения к памяти
на современных микропроцессорах}

В инструкции обращения к памяти в современных микропроцессорах задействована
не одна подсистема. Исполнение инструкции обращения к памяти можно разбить на два этапа -- подготовка физического адреса и собственно обращение с памятью
(см.рис.~\ref{memoryAccess}).

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{instr}\\
  \caption{Модель исполнения инструкции обращения к памяти}\label{memoryAccess}
\end{figure}

Подготовка физического адреса включает в себя формирование виртуального адреса данных, с которыми необходимо выполнить операцию. Виртуальный адрес формируется на основе аргументов инстркции. Затем происходит формирование физического адреса на основе виртуального адреса с использованием TLB. По сути виртуальный адрес разбивается на номер виртуальной страницы и смещение внутри страницы, затем, используя TLB, физический адрес составляется из соответствующего номера физического кадра и того же смещения внутри страницы. TLB содержит некоторое количество пар, задающих соответствие номера страницы виртуальной памяти и физического кадра. Размер самой страницы в виртуальной памяти и физической памяти совпадает, поэтому смещение внутри страницы используется в физическом адресе без изменений по сравнению с виртуальным адресом.

Когда физический адрес готов, осуществляется обращение с памятью: загрузка данных из памяти или сохранение данных в памяти. При этом если данные по физическому адресу имеются в кэш-памяти, основная память может остаться неизмененной. Это сделано для повышения эффективности работы с основной памятью.

\subsection{Модульный алгоритм генерации тестовых данных}

На основе представленной модели инструкции обращения к памяти можно составить ограничения для каждого шага, получив тем самым \emph{модульный алгоритм} генерации тестовых данных. Более формально, пусть $\{(I_i, R_i, \{As\}_i, C_i, T_i)\}_{i=1, 2, ..., n}$ -- тестовый шаблон, $\{I_i\}_{i=1, 2, ..., n}$ -- последовательность инструкций, $R_i$ -- регистр с данными, $\{As\}_i$ -- параметры инструкции, задающие адрес в памяти, $\{C_i\}_{i=1, 2, ..., n}$ -- последовательность тестовых ситуаций в кэш-памяти, $\{T_i\}_{i=1, 2, ..., n}$ -- последовательность тестовых ситуаций в TLB. Поскольку TLB может содержать дополнительные буфера, ведущие себя как кэш-память, то в TLB также возможны кэш-попадания и кэш-промахи. Тогда инструкция может быть представлена в виде следующих уравнений для каждого $i$:
$$
\left\{
   \begin{array}{l}
    virtualAddress_i = CalculateVirtualAddress(\{As\}_i) \\
    AddressTranslation(T_i, physicalAddress_i, virtualAddress_i)\\
    CacheAccess(C_i, physicalAddress_i)\\
    MemoryAccess(I_i, R_i, physicalAddress_i)\\
   \end{array}
  \right.
$$
где $virtualAddress_i$ и $physicalAddress_i$ -- новые переменные, $CalculateVirtualAddress$ -- функция, вычисляющая виртуальный адрес на основе аргументов инструкции. $AddressTranslation$ -- предикат, описывающий трансляцию виртуального адреса в физический (здесь может быть задействован TLB). $CacheAccess, MemoryAccess$ -- предикаты, описывающие обращение в память (в первом может быть задействована кэш-память, во втором -- основная память).

Поскольку система уравнений для тестового шаблона составляется как конъюнкция систем для каждой инструкции, то система из предикатов может быть выделена в отдельные подзадачи (в этом проявляется модульность). Таким образом выделяются следующие подзадачи:
\begin{itemize}
\item \emph{задача на TLB}
$$
\left\{
   \begin{array}{l}
    AddressTranslation(T_1, physicalAddress_1, virtualAddress_1)\\
    AddressTranslation(T_2, physicalAddress_2, virtualAddress_2)\\
    ...\\
    AddressTranslation(T_n, physicalAddress_n, virtualAddress_n)\\
   \end{array}
  \right.
$$
\item \emph{задача на кэш-память}
$$
\left\{
   \begin{array}{l}
    CacheAccess(C_1, physicalAddress_1)\\
    CacheAccess(C_2, physicalAddress_2)\\
    ...\\
    CacheAccess(C_n, physicalAddress_n)\\
   \end{array}
  \right.
$$
\item \emph{задача на основную память}
$$
\left\{
   \begin{array}{l}
    MemoryAccess(I_1, R_1, physicalAddress_1)\\
    MemoryAccess(I_2, R_2, physicalAddress_2)\\
    ...\\
    MemoryAccess(I_n, R_n, physicalAddress_n)\\
   \end{array}
  \right.
$$
\end{itemize}

Как раз задаче на кэш-память был посвящен раздел~\ref{cache_sets}. В нем было показано, что для этой задачи достаточно ввести переменную с начальным содержимым кэш-памяти. Для выделения тегов адресов и номеров набора (например, в наборно-ассоциавной кэш-памяти) в ограничениях могут потребоваться битовые операции. Например, если ...............

Задача на основную память задает соответствие между значениями регистров, физическими адресами и значениями ячеек оперативной памяти. Если представить основную память в виде одномерного массива $memory$, индексация в котором идет по физическим адресам, то
\begin{itemize}
\item для инструкции, осуществляющей загрузку из памяти, $MemoryAccess$ можно представлять как $R_i := memory[physicalAddress_i]$;
\item для инструкции, осуществляющей сохранение в памяти, $MemoryAccess$ можно представлять как $memory[physicalAddress_i] := R_i$.
\end{itemize}
Таким образом, получается последовательность присваиваний, которая может быть преобразована в систему уравнений с помощью \emph{редукции Аккермана} (или \emph{аккерманизации})~\cite{Ackermann}. А именно,
\begin{itemize}
\item для каждой упорядоченной пары инструкций (не обязательно находящиеся подряд в тестовом шаблоне, но в том же порядке) $STORE(R_1, p_1)$ и $LOAD(R_2, p_2)$ создается ограничение
    $$ (p_1 = p_2 \wedge p_2 \notin \{ p_{(1)}, p_{(2)}, ..., p_{(k)}\}) \rightarrow R_1 = R_2$$
    где $p_{(1)}, p_{(2)}, ..., p_{(k)}$ -- физические адреса инструкций $STORE$, расположенных между двумя инструкциями этой пары;
\item для каждой упорядоченной пары инструкций (не обязательно находящиеся подряд в тестовом шаблоне, но в том же порядке) $LOAD(R_1, p_1)$ и $LOAD(R_2, p_2)$ создается ограничение
    $$ (p_1 = p_2 \wedge p_2 \notin \{ p_{(1)}, p_{(2)}, ..., p_{(k)}\}) \rightarrow R_1 = R_2$$
    где $p_{(1)}, p_{(2)}, ..., p_{(k)}$ -- физические адреса инструкций $STORE$, расположенных между двумя инструкциями этой пары.
\end{itemize}

Задача на TLB должна задавать в виде ограничений соответствие между начальным состоянием (содержимым) TLB, виртуальными адресами, физическими адресами и вносимыми в TLB соответствиями в случае промаха. Поскольку содержимое TLB также может быть рассмотрено в виде массива записей, то для задачи на TLB тоже применима аккерманизация. Кроме того, здесь также могут быть использованы методы построения уравнений на множества тегов для описания тестовых ситуаций на буферы, которые ведут себя как кэш-память, если таковые присутствуют в TLB.

Для разрешения полученных ограничений применяется решатель CSP (Constraint Satisfaction Problem)~\cite{CSP}. ......тут про то, что такое CSP, как решаются CSP, примеры систем, какие ограничения лучше решать с помощью CSP (интервалы) - переборная природа CSP.

Достоинством модульного алгоритма является простота построения ограничений. Другим достоинством является его гибкость по отношению к механизмам работы подсистем микропроцессора. Эти свойства сделали Genesys-Pro...\cite{GenesysPro},\cite{DeepTrans} Вся сложность - в создании решателя для таких ограничений........

Однако у модульного алгоритма есть 

\subsection{Немодульный алгоритм генерации тестовых данных: уровень 0}

\subsection{Немодульный алгоритм генерации тестовых данных более высоких уровней}

\pagebreak
\section{Выделение задач на кэш-память в архитектуре
микропроцессора}

\pagebreak
\bibliographystyle{plain}
\bibliography{theor}

\end{document}
