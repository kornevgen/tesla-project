Описание интерфейса TeSLa
=========================

Основная процедура для вызова решателя:
( new ru.teslaprj.Solver() ).solve( scheme, cacheLevels ) .
Для вызова необходимо построить параметры:
scheme - схема тестовой программы
cacheLevels - список уровней кэша
Возвращает эта процедура объект класса ru.teslaprj.Solver.Verdict . (см.ниже)

Задание схемы тестовой программы
================================

1. Создание пустой схемы тестовой программы:
ru.teslaprj.scheme.Scheme s = new ru.teslaprj.scheme.Scheme();

Схему можно наполнять определением регистров, констант, командами и зависимостями между переменными.

2. Каждый задействованный регистр должен иметь определение в схеме. Его определение добавляется так:
ru.teslaprj.scheme.Scheme s = ... ;
s.addDefinition( new ru.teslaprj.scheme.RegisterDefinition( "имя регистра", битовая-длина ) );
Например, s.addDefinition( new RegisterDefinition( "r1", 64 ) );
Определение можно добавлять в любое время, пока не вызван решатель. Определения разных регистров независимы друг от друга. Все регистры в рамках данной схемы должны иметь различные имена (в противном случае, при попытке добавить регистр с уже имеющимся именем будет сгенерирована исключительная ситуация).

3. Каждая задействованная константа (например, смещение адреса в команде обращения в память) должна быть определена в схеме. Ее определение добавляется так:
s.addDefinition( new ru.teslaprj.scheme.ConstDefinition( "имя константы", битовая длина ) );
Например, s.addDefinition( new ConstDefinition( "offset", 16 ) );
Определения можно добавлять в любое время, пока не вызван решатель. Определения разных констант независимы друг от друга. Все константы в рамках данной схемы должны иметь различные имена (в противном случае, при попытке добавить константу с уже имеющимся именем будет сгенерирована исключительная ситуация).
Имена регистров и констант не могут совпадать (в противном случае, при попытке добавить константу/регистр с уже известным в этой схеме именем будет сгенерирована исключительная ситуация).

4. Необходимо в заданном порядке наполнить схему командами.
Общий вид команды: КОП параметры [; доп.параметры] @ тестовая ситуация[( параметры тестовой ситуации )]
Примеры: 
ADD x, y, z @ noexception
LW r1, r2, r3 ; v, p, p1 @ noexception( LoadMemory: l1Miss, l2Hit ; AddressTranslation: mtlbHit )
ru.teslaprj.scheme.Command command = new ru.teslaprj.scheme.Command( КОП, параметры, доп.параметры, тестовая ситуация, параметры тестовой ситуации ); 
КОП - String - код операции (по сути, имя папки, где располагается описание тестовой ситуации на TeSLa); например, "LW"
параметры - List<String> - имена параметров в том порядке, в каком они должны идти в команде; каждый параметр должен иметь свое определение (см.пред.пункты); например, <"x", "y", "z">
доп.параметры - List<String> | null - имена доп.параметров в том порядке, в каком они должны идти в команде. Если доп.параметров нет, можно передать либо пустой список, либо null; например, <"v", "p", "p1">
тестовая ситуация - String - имя тестовой ситуации (по сути, имя файла с описанием тестовой ситуации на TeSLa); например, "noexception"
параметры тестовой ситуации - Map< String, Set<String> > - отображение имени операции (которая встречается в описании тестовой ситуации) в множество идентификаторов, задающих ее исполнение; например, < "LoadMemory" +> <"l1Miss", "l2Hit">, "AddressTranslation" +> <"mtlbHit"> >
Как только команда построена, ее можно добавлять в схему:
ru.teslaprj.scheme.Scheme s = ...; ...
s.addCommand( command );

5. Кроме команд, в схему можно добавлять произвольное количество ограничений на переменные, встретившиеся в качестве параметров команд или доп.параметров команд.
Общий вид ограничения: параметры @ имя ограничения
Примеры:
p, p1 @ sameSet
x, y @ less
ru.teslaprj.scheme.Assert asrt = new ru.teslaprj.scheme.Assert( параметры, имя ограничения );
параметры - List<String> - имена параметров в том порядке, в каком они нужны в ограничении; например, <"x", "y">
имя ограничения - String - имя файла с описанием ограничения на TeSLa; например, "less"

Вердикт работы решателя
=======================
Процедура solve возвращает объект класса ru.teslaprj.Solver.Verdict, который содержит результат его работы. Основные его методы:
	Map<Definition, Long> getDefinitionValues() ;
		- возвращает начальные значения имен, которым давались определения (т.е. значения констант и начальные значения регистров - "начальные" значит "перед исполнением тестовой программы"); например, < Definition("x",32) +> 20 , Definition("offset",16) +> -579 > 
		Значение константы достаточно просто встроить в команду при генерации тестовой программы. Начальное значение регистра надо преобразовать в команды загрузки значений в регистры и разместить их перед тестовой программой.

	List< Map<Long, List<Long>> > getCacheInitialization() ;
		- возвращает список (по уровням кэшей) отображений номеров set'ов в список тегов, которые в нем должны быть; например, < < 1 +> <56,80,174,20> > , <> >
		По этому объекту необходимо перед тестовой программой добавить несколько команд, дающих в указанных set'ах указанные теги (причем они отсортированы по lru)		

Язык TeSLa
==========

Системные требования (в том числе, на файловую систему)
========================================================
в дальнейшем можно избавить от доп.файлов для ECLiPSe... надо будет подумать