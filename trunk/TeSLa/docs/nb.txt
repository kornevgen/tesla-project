Особенности языка описания тестовых ситуаций
============================================

1. каждая переменная получает своё определение (имя и размер) 
при первом присваивании и не меняет их в течение всего времени

2. операнды сложения и вычитания должны иметь одинаковый размер;
эти операции возвращают результат того же размера, что и их аргументы;
таким образом эти операции выполняются в модульной арифметике

3. умножение выполняется всегда точно;
причем есть как беззнаковое, так и знаковое умножение

4. нет лексического способа задать отрицательную числовую константу.
Однако ничего не стоит написать операцию вычитания. Однако такое вычитание задаст размер этой отрицательной константы.
[[при введении отрицательных констант в лексику языка возникает проблема определения битовой длины этих чисел - она в большинстве случаев любая заданная :) - причем атрибутированными грамматиками эта проблема не решается]]

5. параметрами при вызове предиката могут быть только идентификаторы (а не любые выражения).
??это временное ограничение??

7. сейчас язык не поддерживает пользовательские функции над числами (этого вроде бы и не нужно в стандарте)
[[при введении функций нужен способ записи размера результата функции - в отдельном файле или особый синтаксис??]]

8. язык не поддерживает операцию NOT и логических констант (которые могут быть промоделированы выражениями 1 = 1 и 1 = 2, например)
[[оператор NOT не согласуется с методом резолюций]]

НОВОЕ
9. при указании фактических аргументов аргументы-результаты должны быть разными переменными

10. есть специальные тестовые ситуации, про которые генератор знает больше; имена таких тестовых ситуаций совпадают с отношениями: = # > >= и т.д.
пример (равенство сетов):
LW x, y, of @ noexc{ LoadMemory: Miss(1, s1, _ ) }
LW u, z, of @ noexc{ LoadMemory: Hit(1, s2, _ ) }
assert s1, s2 @ =

11. изменена семантика LoadMemory следующим образом:
в стандарте LoadMemory возвращает двойное слово (64 бита), а затем уже из него выделяется часть, соответствующая виртуальному адресу с учетом BigEndian (направление увеличения адресов)
+ LoadMemory выполняет проверку выравнивания виртуального адреса (если она не проходит, генерируется AddressTranslation)
* у меня LoadMemory не выполняет проверку выравнивания (обычно она и так проверяется до вызова LoadMemory)
* LoadMemory возвращает не 64 бита, а сразу нужное подслово (правда, пока не учитывается BigEndiadCPU!)

12. изменена семантика TLBRefill
когда происходит TLBRefill, исполнение инструкции просто прерывается

13. пока нет поддержки инструкций MFC0, MTC0, TLBR, TLBWI, нужных для управления регистром EntryHi

Особенности, связанные с ECLiPSe
================================
1. если при исполнении логической программы появляется ветвление, то первым делом будут выдаваться ответы, построенные по первой встретившейся ветке (их может быть как много, так и один единственный).
А чтобы перейти к другой ветке, нужно в ECLiPSe нажимать кнопку More (или надо это реализовать в функции solve...)

2. процедура rnd_result не всегда дает ответ за приемлимое время; встроенная в ECLiPSe процедура получения всегда одного значения работает быстрее, но при разных запусках дает одно и то же значение

Особенности, связанные с генератором
====================================
1. При создании объекта-схемы (Scheme) все объекты тестовых ситуаций должны быть разными, даже если они означают синонимичные ситуации (например, для L1Hit)
