Особенности языка описания тестовых ситуаций
============================================

1. каждая переменная получает своё определение (имя и размер) 
при первом присваивании и не меняет их в течение всего времени

2. операнды сложения и вычитания должны иметь одинаковый размер;
эти операции возвращают результат того же размера, что и их аргументы;
таким образом эти операции выполняются в модульной арифметике

3. умножение выполняется всегда точно;
причем есть как беззнаковое, так и знаковое умножение

4. нет лексического способа задать отрицательную числовую константу.
Однако ничего не стоит написать операцию вычитания. Однако такое вычитание задаст размер этой отрицательной константы.
[[при введении отрицательных констант в лексику языка возникает проблема определения битовой длины этих чисел - она в большинстве случаев любая заданная :) - причем атрибутированными грамматиками эта проблема не решается]]

5. параметрами при вызове предиката могут быть только идентификаторы (а не любые выражения).
??это временное ограничение??

6. параметрами битовых операций могут быть только битовые выражения (а не произвольные). (идентификатор и константа - тоже считаются битовыми выражениями)
??это временное ограничение??

7. сейчас язык не поддерживает пользовательские функции над числами (этого вроде бы и не нужно в стандарте)
[[при введении функций нужен способ записи размера результата функции - в отдельном файле или особый синтаксис??]]

8. язык не поддерживает операцию NOT и логических констант (которые могут быть промоделированы выражениями 1 = 1 и 1 = 2, например)
[[оператор NOT не согласуется с методом резолюций]]

НОВОЕ
9. при указании фактических аргументов аргументы-результаты должны быть разными переменными

10. есть специальные тестовые ситуации, про которые генератор знает больше; имена таких тестовых ситуаций совпадают с отношениями: = # > >= и т.д.
пример (равенство сетов):
LW x, y, of @ noexc{ LoadMemory: Miss(1, s1, _ ) }
LW u, z, of @ noexc{ LoadMemory: Hit(1, s2, _ ) }
assert s1, s2 @ =

Особенности, связанные с ECLiPSe
================================
1. если при исполнении логической программы появляется ветвление, то первым делом будут выдаваться ответы, построенные по первой встретившейся ветке (их может быть как много, так и один единственный).
А чтобы перейти к другой ветке, нужно в ECLiPSe нажимать кнопку More (или надо это реализовать в функции solve...)

2. процедура rnd_result не всегда дает ответ за приемлимое время; встроенная в ECLiPSe процедура получения всегда одного значения работает быстрее, но при разных запусках дает одно и то же значение
