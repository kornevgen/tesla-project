\section{Алгоритм построения тестовой программы по схеме тестовой
программы}\label{common_algorithm}

В данной работе предлагается алгоритм, который сводит задачу
генерации тестовых данных для тестирования микропроцессоров к задаче
разрешения специального набора ограничений над целыми числами. Как
было сказано ранее схема тестовой программы представляет собой
последовательность команд, каждой из которых сопоставлена тестовая
ситуация, т.е. по сути задана последовательность тестовых ситуаций.
Среди тестовых ситуаций можно выделить следующие группы:
\begin{enumerate}
\item описывающие лишь соотношения над целыми числами (такие
тестовые ситуации возникают для арифметических и логических команд)
\item обращения к памяти (такие тестовые ситуации содержат вызовы
функций-примитивов LoadMemory, StoreMemory,
AddressTranslation~\cite{mips64})
\end{enumerate}

Тестовые ситуации первой группы транслируются в ограничения
непосредственно. Не все системы разрешения ограничений могут
поддерживать битовые операции над целыми числами, которые удобны при
описании тестовых ситуаций. Однако битовые операции несложно
выражаются через общеупотребительные ограничения над целыми числами.
Пример: тестовая ситуация, описывающаяся следующим образом:
\begin{verbatim}
VAR x : 3;  // sizeof(x) = 3 bits
VAR y : 3;
temp <- x[2] + y;
ASSERT temp # x;
\end{verbatim}
может быть странслирована в следующий набор ограничений над целыми числами:
\begin{verbatim}
x >= 0, x =< 7,
y >= 0, y =< 7,
x2 >= 0, x2 =< 1,
x01 >= 0, x01 =< 3,
x = x2 * 4 + x01,
temp = x2 + y,
temp != x,
\end{verbatim}

Тестовые ситуации второй группы тоже будут транслироваться в
ограничения на целые числа. Указание поведения процедур LoadMemory,
StoreMemory и AddressTranslation транслируется в ограничение на
адреса, с которыми этим процедуры работают. Причем для некоторых
стратегий кэширования последовательные обращения этих процедур к
адресам одного сета связаны (сет -- множество адресов с одинаковой
битовой частью). Например, стратегия кэширования LRU (Least Recently
Used) формулируется в рамках сета: вытесняемый тег (тег -- тоже
битовая часть адреса) и вытесняющий лежат в одном сете, условие
вытеснение формулируется в рамках сета. Поэтому алгоритм сначала
будет выделять в схеме тестовой программы команды, относящиеся к
одному сету, и уже внутри этого сета формулировать ограничения на
адреса.

Итак, общий алгоритм транслятора схемы тестовой программы в
ограничения выглядит следующим образом:
\begin{enumerate}
\item распределить элементы тестового шаблона по сетам
\item странслировать каждую тестовую ситуацию в ограничения
\end{enumerate}

Первому этапу посвящена часть~\ref{sets}. Второй этап для тестовых
ситуаций первого типа уже описан, а для тестовых ситуаций второго
типа будет описан в части~\ref{eqs}.
