\section{Алгоритм построения тестовой программы по тестовому шаблону}\label{common_algorithm}

В данной работе предлагается алгоритм, который сводит задачу
генерации тестовых данных для тестирования микропроцессоров к хорошо
известной задаче разрешения ограничений над целыми
числами~\cite{ConstrProp}. Такие ограничения включают в себя
соотношения на начальные значения регистров микропроцессора,
значения констант тестового шаблона и начальные значения подсистем
микропроцессора (кэш-памяти, TLB). Генерация тестовых данных как раз
и состоит в поиске значений этих величин.

Как было сказано ранее тестовый шаблон представляет собой
последовательность команд, каждой из которых сопоставлена тестовая
ситуация, т.е. по сути задана последовательность тестовых ситуаций.
Среди тестовых ситуаций можно выделить следующие группы:
\begin{enumerate}
\item описывающие лишь соотношения над целыми числами (такие
тестовые ситуации возникают для арифметических и логических команд)
\item обращения к памяти (такие тестовые ситуации содержат вызовы
функций-примитивов LoadMemory, StoreMemory,
AddressTranslation~\cite{mips64})
\end{enumerate}

Тестовые ситуации первой группы транслируются в ограничения над
целыми чмслами непосредственно, поскольку в явном виде содержат
соотношения над ними. Не все системы разрешения ограничений могут
поддерживать битовые операции над целыми числами, которые удобны при
описании тестовых ситуаций. Однако битовые операции несложно
выражаются через общеупотребительные ограничения над целыми числами.
Пример: тестовая ситуация, описывающаяся следующим образом:
\begin{verbatim}
VAR x : 3;  // sizeof(x) = 3 bits
VAR y : 3;
temp <- x[2] + y;
ASSERT temp # x;
\end{verbatim}
может быть странслирована в следующий набор (линейных) ограничений
над целыми числами:
\begin{verbatim}
x >= 0, x =< 7,
y >= 0, y =< 7,
x2 >= 0, x2 =< 1,
x01 >= 0, x01 =< 3,
x = x2 * 4 + x01,
temp = x2 + y,
temp != x,
\end{verbatim}

Тестовые ситуации второй группы тоже будут транслироваться в
ограничения на целые числа. В тестовую ситуацию включяается и
указание поведения процедур LoadMemory, StoreMemory и
AddressTranslation в рамках данной тестовой ситуации (так
называемая, <<тестовая ситуация в кэш-памяти>>). Такие тестовые
ситуации формулируются в виде ограничений на адреса, с которыми
работают процедуры LoadMemory, StoreMemory. Но такие ограничения уже
не удается сформулировать, используя лишь саму тестовую ситуацию.
Для формулировки приходится использовать предшествующие в тестовом
шаблоне команды -- они должны обращаться в одну <<область памяти>>.
Эта область памяти задается значением заданного диапазона бит в
адресе (назовем такую область памяти \emph{сетом}; внутри сета
адреса определяются уникальным \emph{тегом}). Например, политика
замещения LRU (Least Recently Used) формулируется на сете:
вытесняемые и вытесняющий теги лежат в одном сете и вытесняемый тег
тот, к которому последнему дольше всего не было обращений. Поэтому
алгоритм сначала будет выделять в тестовом шаблоне команды,
относящиеся к одному сету, и уже внутри этого сета формулировать
ограничения на адреса.

Итак, общий алгоритм трансляции описания тестового шаблона в
ограничения выглядит следующим образом:
\begin{enumerate}
\item распределить инструкции обращения к памяти по сетам
\item странслировать каждую тестовую ситуацию в ограничения
\end{enumerate}

Первому этапу посвящена часть~\ref{sets}. Второй этап для тестовых
ситуаций первого типа уже описан, а для тестовых ситуаций второго
типа будет описан в части~\ref{eqs}.
