\section{Алгоритм построения тестовой программы по схеме тестовой
программы}\label{common_algorithm}

В данной работе предлагается алгоритм, который сводит задачу
генерации тестовых данных для тестирования микропроцессоров к задаче
разрешения специального набора ограничений над целыми числами. Как
было сказано ранее схема тестовой программы представляет
последовательность команд, каждой из которых сопоставлена тестовая
ситуация, т.е. по сути задана последовательность тестовых ситуаций.
Все тестовые ситуации можно разделить на следующие группы:
\begin{enumerate}
\item описывающие лишь соотношения над целыми числами (такие
тестовые ситуации возникают для арифметических и логических команд)
\item обращения с памятью (такие тестовые ситуации содержат вызовы
функций-примитивов LoadMemory, StoreMemory,
AddressTranslation~\cite{mips64})
\end{enumerate}

Тестовые ситуации первой группы транслируются в ограничения
непосредственно. Не все системы разрешения ограничений могут
поддерживать битовые операции над целыми числами, которые удобны при
описании тестовых ситуаций. Однако битовые операции несложно
выражаются через общеупотребительные ограничения над целыми числами.
Пример: тестовая ситуация, описывающаяся следующим образом:
\begin{verbatim}
VAR x : 3;  // sizeof(x) = 3 bits
VAR y : 3;
temp <- x[2] + y;
ASSERT temp # x;
\end{verbatim}
может быть странслирована в следующий набор ограничений над целыми числами:
\begin{verbatim}
x >= 0, x =< 7,
y >= 0, y =< 7,
x2 >= 0, x2 =< 1,
x01 >= 0, x01 =< 3,
x = x2 * 4 + x01,
temp = x2 + y,
temp != x,
\end{verbatim}

Для описания тестовых ситуаций обращения с памятью напомню структуру
кэш-памяти. Выделяют \emph{кэш данных} и \emph{кэш инструкций}.
Поскольку их структурная организация одинаковая, далее они будут
рассматриваться под общим названием <<кэш-память>>. Вся кэш-память
делится на блоки (\emph{уровни кэша}), структурная организация
которых одинаковая за исключением количественных характеристик.
Каждый уровень кэша представляется двумя структурами -- \emph{кэш
данных} и \emph{кэш адресов данных}. Кэш данных представляет собой
индексированную последовательность \emph{кэш-строк}. ||тут нужна
картинка структуры кэша?|| Одна кэш-строка соответствует непрерывной
части памяти, начальный адрес которой выровнен некоторым образом.
Оставшая (после отделения битов выравнивания) старшая часть
начального адреса кэш-строки задается в кэше адресов данных. Она
делится на две части: старшую -- \emph{тег} -- и младшую --
\emph{номер сета}. Кэш данных (и кэш адресов данных) можно логически
разбить на части одинакового размера. Каждая часть кодируется
номером сета. Например, если на номер сета отведено 3 бита, то кэш
данных разделен на $2^3 = 8$ сетов. В одном сете находятся
кэш-строки в количестве, равном отношению их общего количества в
кэш-памяти на количество сетов. Каждое обращение в кэш-память
начинается с выделения номера сета и тега. Затем делается поиск
этого тега среди тегов в сете с полученным номером сета. Успешный
результат поиска означает ситуацию \emph{кэш-попадания}. Тогда по
индексу ячейки кэша адресов данных (он же индекс ячейки кэша данных)
процессор получает данные из кэша по заданному адресу. Неуспешный
результат поиска означает ситуацию \emph{кэш-промаха}. Обычно
количество различных тегов в одном сете (равное <<2 в степени
битовый размер тега>>) больше, чем количество кэш-строк в одном
сете. Тогда среди тегов в заданном сете выбирается кандидат на
\emph{вытеснение} (согласно политике кэширования, например, это
может быть самый последний неиспользуемый тег) и заменяется данным
тегом вместе с обновлением и кэша данных. Таким образом, ситуации в
операциях с кэш-памятью -- это ситуации в кэше адресов данных.

Следовательно, алгоритм будет выделять адреса, к которым происходят
обращения, выделять из них тег и сет (это целые числа) и строить на
них ограничения, выражающие кэш-промах или кэш-попадание в
зависимости от того, что требуется. Для более точного определения
алгоритма нужно зафиксировать политику кэширования. Далее в работе
будет рассматриваться политика кэширования LRU (Least Recently
Used), согласно которой вытесняемый тег тот, который дольше всего не
использовался. Аналогичные рассуждения применимы и для некоторых
других политик кэширования (MRU). Определение вытесняемого тега
производится только среди тегов одного сета. Поэтому алгоритм
сначала будет выделять в схеме тестовой программы команды,
относящиеся к одному сету, и уже внутри него выражать требования
политики кэширования в виде ограничений над целыми числами (тегами).

Итак, общий алгоритм транслятора схемы тестовой программы в
ограничения выглядит следующим образом:
\begin{enumerate}
\item распределить элементы тестового шаблона по сетам
\item странслировать каждую тестовую ситуацию в ограничения
\end{enumerate}

Первому этапу посвящена часть~\ref{sets}. Второй этап для тестовых
ситуаций первого типа уже описан, а для тестовых ситуаций второго
типа будет описан в части~\ref{eqs}.
