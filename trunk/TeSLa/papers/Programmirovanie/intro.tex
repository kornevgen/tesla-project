\section{Введение}
С каждым годом все больше возрастает сложность задач, которые
приходится решать. Такие задачи характеризуются как большими
объемами данных, так и сложными алгоритмами вычислений.
Использование вычислительных систем стало неотъемлемой частью
процесса решения таких задач. Кроме того, вычислительные системы
играют все большую роль в процессах, от которых зависит здоровье и
жизнь людей. Поэтому необходимо, чтобы вычислительные системы
работали корректно. Основным компонентом многих вычислительных
систем являются микропроцессоры, выполняющие основные управляющие
функции. Тестирование таких систем является важной задачей, которой
и посвящена данная работа.

В данной работе микропроцессор рассматривается как система в целом,
входными данными для которой являются машинные программы,
загруженные в память (далее такие программы будут называться
\emph{тестовыми программами}). Эти программы исполняются, процесс
исполнения протоколируется и затем анализируется. Для
функционального тестирования (к которому относится данная статья)
важно лишь правильно ли исполнена загруженная программа. Кроме того,
такое тестирование можно проводить еще даже до выпуска
микропроцессора, с использованием симуляции его модели на языках
Verilog или VHDL.

Методы построения тестовых программ можно разделить на две группы. В
первую группу входят методы, основывающиеся при генерации тестовой
программы на ее абстрактной форме (\emph{схеме тестовой
программы})~\cite{GenesysPro2004, MAATG, mVpGen}. Вторую группу
составляют методы, не основывающиеся на ней (кросс-компиляция,
ручная разработка)~\cite{Mishra}. Схемы тестовых программ описывают
последовательность команд тестовой программы, а вместо конкретных
значений их параметров указывается набор ограничений, которым должны
удовлетворять эти параметры перед выполнением команды. Любой метод
первой группы построения тестовых программ можно представить в виде
двух больших этапов: на первом этапе подготавливается абстрактное
описание тестовой программы и на втором этапе по нему строится
тестовая программа. Однако для многих тестовых программах приходится
задавать довольно нетривиальные зависимости между данными
(регистрами, значениями ячеек кэша и т.п.). Практика показывает, что
при использовании штатных средств и алгоритмов удается строить
тестовые программы небольшого размера (одна-две команды), однако для
тестирования современных процессоров следовало бы использовать
тестовые программы большего размера. Например, при тестировании
конвейера приходится использовать тестовые программы, размер которых
сопоставим с размером конвейера, а это несколько десятков команд.

Многие исследователи при генерации тестовых программ для выполнения
системного тестирования микропроцессоров сталкиваются с задачей
генерации тестовых данных. В некоторых работах сложно выделить метод
генерации тестовых данных, который можно было бы обобщить на другие
микропроцессоры (это никак не сказывается на качестве тестирования в
этих работах). Многие методы генерации тестовых данных относятся к
семейству методов случайной генерации. В таких методах формулируются
простейшие ограничения на переменные величины (в основном, границы
значений), в рамках которых последовательно генерируются случайные
значения. Главный недостаток этого метода -- низкое качество
получающихся тестовых данных (мала вероятность генерации тестовых
данных для <<крайних>> случаев). В компании IBM уже не один десяток
лет ведутся разработки инструментов генерации тестовых данных для
тестирования микропроцессоров. Их инструмент
Genesys-Pro~\cite{GenesysPro2004} вполне справляется с этой задачей.
Однако архитектуру микропроцессора приходится задавать в виде
ограничений на элементы структуры инструкции (что не является
естественным описанием)~\cite{GenesysPro2004Innovations}. Кроме того
инструмент не использует функциональные связи разных команд, а
генерирует значения параметров очередной команды, исходя из уже
построенной части тестовой программы до этой команды. Иными словами,
тестовая программа строится по-командно, что может отрицательно
сказаться на его производительности.

В данной работе предлагается алгоритм сведения поставленной задачи к
задаче разрешения ограничений над целыми числами, которая известна
уже не один десяток лет и для которой разработаны эффективные
алгоритмы~\cite{ConstrProp}.

Данная работа выполнялась в проекте по тестированию микропроцессора,
в рамках которого создана система ||картинка||. Генератор тестовых
данных является ее подсистемой. Он получает на вход схему тестовой
программы и начальное состояние микропроцессора, а на выходе дает
тестовую программу.  [[стоит об этом писать?смотрится как-то
притянуто за уши...]]

О том, как предлагается описывать схему тестовой программы,
посвящена часть~\ref{scheme}.
Части~\ref{common_algorithm}~-~\ref{eqs} посвящены собственно тому,
как следует транслировать эти описания в набор ограничений. В конце
статьи приведены результаты апробации предложенного метода решения.
