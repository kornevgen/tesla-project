\section{Алгоритм распределения элементов тестового шаблона по
сетам}\label{sets}

Алгоритм должен распределить команды обращения в память данной схемы
тестовой программы по сетам, т.е. указать, какие команды обращаются
в один сет, а какие -- в разные. Командой обращения в память
считается такая команда, в тестовой ситуации которой присутствует
вызов функций LoadMemory или StoreMemory. Алгоритм будет стараться
максимизировать количество задействованных сетов (это упростит
дальнейшую генерацию тестовых данных для схемы тестовой программы).
Алгоритм будет заключаться в построении и разрешении набора ограничений
на переменные-числа. Среди этих переменных будут номера сетов.

Рассмотрим несколько примеров:
\begin{verbatim}
LW x, y, of @ noexception
LW z, y, of @ noexception
LW y, x, of2 @ noexception
LW y, z, of2 @ noexception
\end{verbatim}
здесь первые две команды обращаются в один сет, две последние -- в
другой сет. Причем хоть адреса последних двух команд выражаются
разными выражениями (<<x + of2>> и <<z + of2>>), сеты должны
совпадать, так как значения x и z совпадают.

Следующий пример:
\begin{verbatim}
LW x, y, of @ noexception
ADD u, x, x @ noexception
LW z, y, of @ noexception
LW y, x, of2 @ noexception
LW y, z, of2 @ noexception
\end{verbatim}
Здесь все то же, что и в предыдущем примере -- команда ADD не
оказывает влияния на работу с памятью.

Еще один пример:
\begin{verbatim}
LW x, y, of @ noexception
ADD u, x, x @ noexception
SW u, y, of @ noexception
LW z, y, of @ noexception
LW y, x, of2 @ noexception
LW y, z, of2 @ noexception
\end{verbatim}
Здесь хотя первые три обращения происходят к одному сету, последние
два обращения могут относиться к разным сетам! Дело в том, что здесь
уже значения x и z могут быть разными.

Таким образом, алгоритм будет генерировать к каждому обращению в
память новую переменную-число (считываемое/записываемое значение) и
среди этих переменных обнаруживать равные. Это позволит заменить все
команды обращения в память переменными-числами, на которых
сформулированы отношения равенства и неравенства. Эти переменные
могут участвовать во всех остальных командах схемы тестовой
программы. Поэтому в алгоритме следующим этапом будет генерация
набора ограничений для всей оставшейся схемы тестовой программы
(команды, не обращающиеся в память) с учетом зависимостей между
добавленными переменными с прошлого этапа.

Например, для последнего примера будут введены переменные для
первого обращения в память ($mem$ можно воспринимать как массив
ячеек виртуальной памяти) :
\begin{verbatim}
LW x, y, of @ noexception
    -> (mem[y+of]: m1_0) x = m1_0 , s1 = set(y+of)
ADD u, x, x @ noexception
    -> u = x + x (из того, что тест.ситуация noexception)
SW u, y, of @ noexception
    -> (mem[y+of] изменилось: m1_1) m1_1 = u , s2 = set(y+of)
LW z, y, of @ noexception
    -> (mem[y+of] : m1_1) z = m1_1, s3 = set(y+of)
LW y, x, of2 @ noexception
    -> (mem[x+of2]: m2_0) y_1 = m2_0, s4 = set(x+of2)
LW y, z, of2 @ noexception
    -> (mem[z+of2]: m3_0) y_2 = m3_0, s5 = set(z+of2)
\end{verbatim}
Получается следующая система ограничений на переменные-адреса
(считаем, что сет задается битами адреса с 6го по 4й):
$$
\left\{
    \begin{aligned}
        x = m1\_0\\
        u = x + x\\
        m1\_1 = u\\
        z = m1\_1\\
        y\_1 = m2\_0\\
        y\_2 = m3\_0\\
        s1 = (y+of)[6..4]\\
        s2 = (y+of)[6..4]\\
        s3 = (y+of)[6..4]\\
        s4 = (x+of2)[6..4]\\
        s5 = (z+of2)[6..4]\\
    \end{aligned}
\right.
$$
из которой получается, что $s1 = s2 = s3$, а остальные сеты могут
быть разными.

Подводя итог, приведем псевдокод алгоритма:
\begin{enumerate}
\item для каждой команды обращения в память сгенерировать переменную ;
если происходит обращение в ту же ячейку памяти, использовать
переменную предыдущей загрузки, если между ними нет изменения
значения, которое хранится в этой ячейке
\item начать генерировать систему ограничений
\item поочередно обрабатывается каждая тестовая ситуация схемы
тестовой программы:
    \begin{itemize}
        \item если в ней не встречаются вызовы LoadMemory или StoreMemory,
странслировать тестовую ситуацию в набор ограничений и добавить их к
системе (см. п.~\ref{common_algorithm})
        \item если встречается вызов LoadMemory или StoreMemory,
        добавить в систему ограчение равенства сгенерированной на первом шаге этого алгоритма переменной
        и переменной-первого аргумента команды загрузки из памяти
        (для функции LoadMemory необходимо изменить версию
        переменной-первого аргумента команды согласно механизму версионности)
    \end{itemize}
\item для каждой команды обращения в память сгенерировать переменные
для номеров сетов $s_i$
\item для каждой команды обращения в память добавить в систему
ограничение равенства $s_i$ и битового диапазона суммы двух
аргументов команды, задающих адрес, к которому происходит обращение
\item решить построенную систему ограничений, стараясь
максимизировать количество различных значений $s_i$
\end{enumerate}
