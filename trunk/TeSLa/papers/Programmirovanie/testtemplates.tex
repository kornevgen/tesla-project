\section{Схема тестовой программы}\label{scheme}

Cхема тестовой программы задает свойства будущей тестовой программы.
В схему тестовой программы входит \emph{тестовый шаблон} --
последовательность команд тестовой программы. Каждый элемент
тестового шаблона снабжен указанием \emph{тестовой ситуации} --
связи значений операндов и состояния микропроцессора (ячейки
кэш-памяти, регистры, другие подсистемы) перед началом выполнения
инструкции. В качестве параметров команды в схеме тестовой программы
могут выступать переменные величины -- регистры, непосредственные
значения, адреса. Отдельно могут быть зафиксированы в тестовой
программе зависимости (предикаты) между переменными величинами.
Подробнее см.~\cite{kamkin}.

Каждая используемая тестовая ситуация должна быть описана в виде
последовательности присваиваний и операторов утверждения (assert),
что приближает это описание к программе на простом императивном
языке программирования~\cite{mysyrcose, myisp}.

Пример схемы тестовой программы:
\begin{verbatim}
REGISTER ax : 32;
REGISTER bx : 32;
CONST offset : 16;
ADD ax, bx, bx @ overflow
LW ax, bx, offset @ noexception( l1Miss, l2Hit )
XOR bx, ax, bx @ noexc
\end{verbatim}
В этой тестовой программе три команды - ADD, LW и XOR. Перед
тестовым шаблоном идут объявления переменных с указанием битовых
длин. Модификатор (REGISTER или CONST) указывает семантику
использования переменной. Тестовая ситуация указывается после знака
<<@>>: тестовая ситуация первой команды - <<overflow>>, второй
команды - <<noexception( l1Miss, l2Hit )>> и третьей - <<noexc>>.
Тестовая ситуация для второй команды содержит аргументы - они более
детально описывают тестовую ситуацию. Каждой из трех задействованных
тестовых ситуаций должно быть предоставлено описание. Описание
первой тестовой ситуации - overflow - может быть таким (в описании
используется операция битовой конкатенации <<||>> и отношение
неравенства <<\#>>):
\begin{verbatim}
VAR RESULT x : 32;
VAR READONLY y : 32;
VAR READONLY z : 32;
temp <- y[31]||y + z[31]||z;
ASSERT temp[32] # temp[31];
\end{verbatim}
Сначала идут объявления переменных с указанием семантики их
использования. В частности, для представленной выше схемы тестовой
программы переменная тестовой ситуации $x$ соответствует переменной
схемы $ax$, а переменные тестовой ситуации $y$ и $z$ соответствуют
переменной схемы $bx$. Затем идет оператор присваивания - в
присваиваемом выражении использованы битовые операции конкатенации и
взятия бита по номеру и арифметическая операция сложения. И
завершает описание оператор утверждения, который сравнивает на
неравенство 32й и 31й биты значения переменной $temp$.

Описание второй тестовой ситуации - noexception - может быть таким:
\begin{verbatim}
VAR RESULT x : 32;
VAR READONLY y : 32;
VAR READONLY c : 16;
address <- y + c;
LoadMemory( x, address, DATA );
\end{verbatim}
В отличие от предыдущего описания добавился вызов процедуры
LoadMemory. Указание на то, как должна себя вести LoadMemory, дается
вместе с указанием тестовой ситуации инструкции. В частности, в
данной схеме тестовой программы LoadMemory должна работать с
<<l1Miss, l2Hit>>~\cite{kamkin} (т.е. так, чтобы в кэш-памяти
первого уровня произошел кэш-промах, а в кэш-памяти второго уровня
-- кэш-попадание).
