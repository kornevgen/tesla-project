\section{Построение ограничений для трансляции
адресов}\label{tlb}

\begin{figure}
\center
\includegraphics[width=0.8\textwidth]{tlb.eps}
\caption{Трансляция адреса в микропроцессорах стандарта
MIPS}\label{pic_tlb}
\end{figure}

Оставшиеся шаги алгоритма генерации тестовых данных включают
генерацию ограничений для механизма трансляции адресов, разрешение
получившихся ограничений и формирование начального состояния
подсистем микропроцессора. В статье рассматривается способ
трансляции адресов с помощью TLB (Translation Lookahead Buffer),
принятый в стандарте микропроцессоров MIPS~\cite{mips64_III}.
Процесс трансляции адресов и основные структуры показаны на
рис.~\ref{pic_tlb}.

Для генерации ограничений для трансляции адресов используется
тестовый шаблон и информация о сетах и тегах с этапа упрощения
тестовых ситуаций в кэш-памяти. Первым этапом генерации ограничений
является упрощение тестовых ситуаций в кэше TLB (это делается
аналогично тому, как описано в части~\ref{eqs} -- сет один и тот же,
в качестве тегов выступают индексы строк TLB). Затем для каждой пары
инструкций, обращающихся к одной строке TLB, выделяются ограничения
на их виртуальные адреса (выраженные в терминах параметров
инструкции):
\begin{itemize}
\item совпадение битов виртуальных адресов, отвечающих полю <<r>>
\item совпадение битов виртуальных адресов, отвечающих полю
<<vpn/2>> с учетом поля <<mask>> (например, если поле <<vpn/2>>
расположено с 40 по 13й биты, то $v_{40..13+m} = w_{40..13+m}$, где
$v$ и $w$ -- виртуальные адреса, а $m$ -- целочисленная форма поля
<<mask>>, а именно половина количества нулей в поле <<mask>>)
\item ограничение на поля <<g>> и <<asid>>
\item ограничения на бит четности номера виртуальной страницы,
например, если при трансляции адресов двух инструкций происходит
обращение к одной строке TLB, но физические адреса различаются (это
можно понять на основе равенства-неравенства тегов и сетов), то биты
четности разные
\end{itemize}

Затем для каждой задействованной строки TLB выбирается
соответствующая ей инструкция из тестового шаблона. Для нее
составляются ограничения с каждой инструкций из тестового шаблона,
которой соответствует другая строка TLB. Ограничение выражает факт
отличия строк TLB, а именно либо отличие бит виртуальных адресов,
соответствующих полю <<r>> или полю <<vpn/2>> (с учетом маски), или
бит <<g>> равен 0 с отличием поля <<asid>> от значения в регистре
EntryHi.


%Инструкция обращения в память в тестовом шаблоне может быть снабжена
%тестовой ситуацией трансляции адресов. В данной статье
%рассматривается трансляция адресов с помощью TLB (Translation
%Lookahead Buffer)~\cite{mips64_III}. Такая тестовая ситуация может
%указывать на попадание или промах в кэше TLB или свойства строки
%TLB, задействованной для трансляции адреса. Строка TLB состоит из
%следующих полей:
%\begin{itemize}
%\item маска -- целое число
%\item регион (r) -- 2 бита (диапазон бит виртуального адреса с rend до rstart)
%\item старшие биты номера виртуальной страницы (vpn2) (диапазон бит виртуального адреса с vend до vstart)
%\item флаг глобальности (g) -- 1 бит
%\item идентификатор адресного пространства (asid)
%\item номер физического сегмента (pfn) дважды для четной и нечетной
%виртуальной страницы (pfnend и pfnstart -- диапазон номеров бит физического адреса,
%в который при трансляции адресов помещается номер физического сегмента)
%\item другие флаги так же дважды для четной и нечетной виртуальной
%страницы
%\end{itemize}
%
%Все строки TLB индексированы. При успешном обращении к TLB должна
%подходить только одна строка.
%
%%Данный шаг алгоритма генерации тестовых данных состоит из следующих
%%этапов:
%%\begin{enumerate}
%%\item каждой инструкции в тестовом шаблоне сопоставляется индекс
%%строки TLB (которая будет задействована при трансляции адресов).
%%Затем аналогично алгоритму A из раздела~\ref{eqs} тестовые ситуации
%%на кэш TLB преобразуются в ограничения равенства-неравенства этих
%%индексов строк TLB (они являются пока переменными величинами),
%%сопоставленных инструкциям в тестовом шаблоне. Затем каждой такой
%%переменной величине сопоставляется число -- номер -- так, чтобы не
%%нарушались построенные ограничения.
%%\item для каждой пары инструкций в тестовом шаблоне выделяются
%%ограничения на основе соответствующих им индексов строк TLB по
%%следующим правилам (далее виртуальный адрес первой инструкции
%%обозначается $u$, а второй инструкции -- $v$):
%%    \begin{itemize}
%%    \item
%%    \end{itemize}
%%\end{enumerate}
%
%Следующий псевдокод описывает шаг формулирования ограничений из
%трансляции адресов общего алгоритма генерации тестовых данных. На
%вход он получает тестовый шаблон и информацию о
%равенстве-неравенстве тегов и сетов с предыдущего шага генерации
%тестовых данных. На выходе получается набор ограничений.
%Впоследствии он будет добавлен к ограничениям с предыдущего шага
%алгоритма генерации тестовых данных и к ограничениям тестовых
%ситуаций еще не задействованных инструкций (например, тестовых
%ситуаций арифметических инструкций). Ограничения, которые строит
%этот алгоритм, сформулированы не только на переменных-регистрах и
%константах тестового шаблона, но и на некоторых других (маски,
%некоторые поля строк TLB).
%
%Описанный в псевдокоде алгоритм B можно разбить на три
%последовательные части. В первой составляется и решается задача на
%(кэшируемые) индексы строк TLB (поскольку кэш TLB устроен так же,
%как кэш-память из одного сета), затем выявляются ограничения из
%тестовых ситуаций инструкций, работающих с одной и той же строкой
%TLB, и, наконец, выявляются ограничения, обозначающие правило
%согласованности TLB: при обращении к TLB не может подходить больше
%одной строки.
%
%В псевдокоде используются обозначения битовых операций:
%\begin{itemize}
%\item получение бита выражения $e$ с индексом $i$ -- $e_i$;
%\item получение диапазона бит выражения $e$ от индекса $i$ до индекса $j$
% -- $e_{i .. j}$;
%\item битовая конкатенация выражений $e1$ и $e2$ -- $e1 || e2$.
%\end{itemize}
%
%
%Для простоты псевдокод приведен для случая, когда в тестовом шаблоне
%не встречается инструкция прямой записи в TLB по индексу -- TLBWI --
%и инструкция изменения регистра EntryHi. Если такие инструкции
%встречаются, то при добавлении ограничений нужно аккуратно ввести
%новые переменные для измененных значений строк TLB и использовать их
%после инструкций записи в TLB.
%
%{ \tt \normalsize
%
%procedure B( $tt$ : test\_template\_memory\_only, $tags$ : инструкция $\mapsto$ тэг, $sets$ : инструкций $\mapsto$ сет )
%returns $C$ : constraint-set
%
%begin
%
%\hspace{0.5cm}var $va$: инструкция $\mapsto$ выражение;
%
%\hspace{0.5cm}var $mask$: инструкция $\mapsto$ переменная;
%
%\hspace{0.5cm}var $g$: инструкция $\mapsto$ переменная;
%
%\hspace{0.5cm}var $asid$: инструкция $\mapsto$ переменная;
%
%\hspace{0.5cm}var $idxs$: инструкция $\mapsto$ переменная;
%
%\hspace{0.5cm}var $EntryHi$: переменная;
%
%\hspace{0.5cm}var $Ci$ : constraint-set := A( тестовые\_ситуации\_на\_кэш\_TLB( $tt$ ) );
%
%\hspace{0.5cm}var $indexes$: инструкция $\mapsto$ Nat := resolve( $Ci$ );
%
%\hspace{0.5cm}$C$ := \{\};
%
%\hspace{0.5cm}для каждой( пары инструкций $ip$ и $iq$ из $tt$ : $indexes$[$ip$] = $indexes$[$iq$] )
%
%\hspace{0.5cm}begin
%
%\hspace{0.5cm}\hspace{0.5cm}var $vp$ := $va$[$ip$];
%
%\hspace{0.5cm}\hspace{0.5cm}var $vq$ := $va$[$iq$];
%
%\hspace{0.5cm}\hspace{0.5cm}добавить в $C$ ограничение $vp_{rend .. rstart} = vq_{rend .. rstart}$;
%
%\hspace{0.5cm}\hspace{0.5cm}var $m$ := $mask$[$ip$];
%\hspace{0.5cm}\hspace{0.5cm}/*что равно $mask$[$iq$], т.к. речь идет о масках одной и той же строки TLB */
%
%\hspace{0.5cm}\hspace{0.5cm}добавить в $C$ ограничение $vp_{vend .. vstart + m} = vq_{rend .. rstart + m }$;
%
%\hspace{0.5cm}\hspace{0.5cm}var $gi$ := $g$[$ip$];
%\hspace{0.5cm}\hspace{0.5cm}/*что равно $g$[$iq$], т.к. речь идет о битах глобальности одной и той же строки TLB */
%
%\hspace{0.5cm}\hspace{0.5cm}var $asidi$ := $asid$[$ip$];
%
%\hspace{0.5cm}\hspace{0.5cm}добавить в $C$ ограничение $gi = 1 \vee gi = 0 \wedge asidi = EntryHi$;
%
%\hspace{0.5cm}\hspace{0.5cm}var $tp := tags[ip]$;
%
%\hspace{0.5cm}\hspace{0.5cm}var $tq := tags[iq]$;
%
%\hspace{0.5cm}\hspace{0.5cm}var $sp := sets[ip]$;
%
%\hspace{0.5cm}\hspace{0.5cm}var $sq := sets[iq]$;
%
%\hspace{0.5cm}\hspace{0.5cm}var $idxp := idxs[ip]$;
%
%\hspace{0.5cm}\hspace{0.5cm}var $idxq := idxs[iq]$;
%
%\hspace{0.5cm}\hspace{0.5cm}если <<тэг полностью входит в pfn>> и $tp \neq tq$, то добавить в $C$ ограничение $vp_m \neq vq_m$;
%
%\hspace{0.5cm}\hspace{0.5cm}если <<сет полностью входит в pfn>> и $sp \neq sq$, то добавить в $C$ ограничение $vp_m \neq vq_m$;
%
%\hspace{0.5cm}\hspace{0.5cm}если <<тэг частично входит в pfn>> и $tp = tq$, то добавить в $C$ ограничение $vp_m = vq_m$;
%
%\hspace{0.5cm}\hspace{0.5cm}если <<тэг полностью входит в pfn, а сет частично входит в pfn>> и $tp = tq$ и $sp = sq$, то добавить в $C$ ограничение $vp_m = vq_m$;
%
%\hspace{0.5cm}\hspace{0.5cm}если <<pfn состоит только из тэга и сета>> и $tp = tq$ и $sp \neq sq$, то добавить в $C$ ограничение $vp_m \neq vq_m$;
%
%\hspace{0.5cm}\hspace{0.5cm}var $D$ : выражение := разделить\_на\_части( \\
%$(tp||sp||idxp)_{pfnend .. pfnstart} = (tq||sq||idxq)_{pfnend .. pfnstart}$ );
%
%\hspace{0.5cm}\hspace{0.5cm}добавить в $C$ ограничение $( vp_m = vq_m ) \Leftrightarrow D$;
%
%\hspace{0.5cm}end
%
%\hspace{0.5cm}var $iva$ : Nat $\mapsto$ инструкция := выбрать\_виртуальный\_адрес\_для\_индекса( $indexes, va$ );
%
%\hspace{0.5cm}для каждого( виртуального адреса $v$ из $va[ iva[\_]\ \cup$ инструкции из $tt$ с тестовой ситуацией TLB\_Refill или TLB\_Invalid ])
%
%\hspace{0.5cm}begin
%
%\hspace{0.5cm}\hspace{0.5cm}для каждого( виртуального адреса $w$ из $vas$ : индекс инструкции у $w \neq $ индекс инструкции у $v$ )
%
%\hspace{0.5cm}\hspace{0.5cm}begin
%
%\hspace{0.5cm}\hspace{0.5cm}\hspace{0.5cm}var $mw$ := маска строки TLB, с которой работает инструкция адреса $w$;
%
%\hspace{0.5cm}\hspace{0.5cm}\hspace{0.5cm}var $gw$ := поле g строки TLB, с которой работает инструкция адреса $w$;
%
%\hspace{0.5cm}\hspace{0.5cm}\hspace{0.5cm}var $asidw$ := поле asid строки TLB, с которой работает инструкция адреса $w$;
%
%\hspace{0.5cm}\hspace{0.5cm}\hspace{0.5cm}добавить в $C$ ограничение $v_{rend..rstart} \neq w_{rend..rstart}
%\vee v_{vpnend .. vpnstart + mw} \neq w_{vpnend .. vpnstart + mw}
%\vee gw = 0 \wedge asidw \neq EntryHi$ ;
%
%\hspace{0.5cm}\hspace{0.5cm}end
%
%\hspace{0.5cm}end
%
%end
%
%}
%
%Запись <<тег полностью входит в pfn>> означает, что биты физического
%адреса для поля pfn полностью включают (нестрого) в себя биты тега
%физического адреса. Запись <<тег частично входит в pfn>> означает,
%что либо есть такой бит тега физического адреса, который не входит в
%биты для поля pfn, либо биты тега и поля pfn совпадают. Аналогично с
%битами сета и соответствующими записями.
%
%Запись <<разделить на части($t_1||s_1 = t_2||s_2$)>> означает
%преобразование этого выражения к выражению $t_1 = t_2 \vee s_1 =
%s_2$ в случае, когда $t_1$ и $t_2$ имеют одинаковую битовую длину и
%$s_1$ и $s_2$ также имеют одинаковую битовую длину.
%
%Структура $iva$ получается выбором инструкции для каждого
%задействованного в тестовом шаблоне индекса строки TLB.

%Рассмотрим пример небольшого тестового шаблона, на котором
%проиллюстрируем алгоритм В.
%
%{ \normalsize
%
%\begin{verbatim}
%REGISTER x, y, z : 64;
%CONST of : 16;
%LW x, y, of
%    @ noexc{ LoadMemory:l1Hit; AddressTranslation:tlbHit }
%ADD z, x, y @ noexception
%SW x, z, of
%    @ noexc{ StoreMemory:l1Miss; AddressTranslation:tlbHit }
%\end{verbatim}
%}
%
%В тестовом шаблоне три инструкции: LW, ADD и SW. Задействованы 3
%регистра ($x, y, z$) и одна константа ($of$). Тестовые ситуации
%noexc обозначают нормальный ход выполнения инструкции: виртуальный
%адрес вычисляется в виде суммы второго и третьего параметров
%(регистра и константы), затем делается трансляция адресов
%(комментарий к ее выполнению приводится после слова
%AddressTranslation) и, наконец, делается запись или чтение из памяти
%(комментарий к выполнению этой операции приводится после слова
%LoadMemory или StoreMemory). Таким образом, при исполнении первой
%инструкции должны произойти кэш-попадание в кэше первого уровня, а
%при трансляции адресов кэш-попадание в кэше TLB. При исполнении
%третьей инструкции должны произойти кэш-промах в кэше первого уровня
%и кэш-попадание в кэше TLB.
%
%Составим для этого тестового шаблона ограничения согласно
%предложенным в статье алгоритмам. Назовем тег, соответствующий
%первой инструкции, $t_1$, а сет $s_1$. Соответственно для второй
%инструкции -- $t_2$ и $s_2$. Первый шаг -- распределить инструкции
%по сетам. Пусть $s_1 = s_2 = 0$. Следующий шаг -- выявление
%ограничений на теги внутри каждого сета. В данном случае получается
%$t_1 \neq t_2$. Следующий шаг -- выявление значений индексов строк
%TLB. Назовем индекс строки, с которой работает первая инструкция,
%$i_1$, а индекс для второй инструкции -- $i_2$. Т.к. обе инструкции
%исполняются с кэш-попаданием в кэше TLB, то $\{i_1, i_2\} \subseteq
%$ \{ индексы строк начального состояния кэша TLB \}. Пусть $i_1 =
%i_2 = 1$, а 1-я строка в TLB будет заполняться в последнюю очередь.
%Теперь выявляем ограничения на $x, y, z, of$, исходя из равенства
%сетов, неравенства тегов и равенства индексов строк TLB. Виртуальный
%адрес первой инструкции задается выражением $y + of$, виртуальный
%адрес второй инструкции -- выражением $z + of$. Пусть микропроцессор
%таков, что поле r строки TLB занимает биты с 63го по 62й на
%виртуальном адресе, поле vpn занимает биты с 40го по 13й на
%виртуальном адресе, поле pfn занимает 30 бит, тег физического адреса
%занимает 20 бит, сет -- 20 бит. Тогда получаются такие новые
%ограничения $(y+of)_{63..62} = (z+of)_{63..62}$. Пусть переменная
%$m_1$ будет обозначать маску первой строки TLB. Тогда получается
%такое новое ограничение $(y+of)_{40 .. 13+m_1} = (z + of)_{40 ..
%13+m_1}$. Пусть переменные $g_1$ и $asid_1$ будут обозначать флаг
%глобальности и поле asid первой строки TLB соответственно. Тогда
%добавляется ограничение $g_1 = 1 \vee g_1 = 0 \wedge asid_1 =
%EntryHi$. Поскольку тег занимает биты с 63 до 44, а pfn -- с 63 по
%39, то тег полностью входит в pfn и так как $t_1 \neq t_2$, то
%добавляется такое ограничение $(y+of)_{m_1} \neq (z+of)_{m_1}$.
%Далее составляем и упрощаем выражение $(t_1||s_1||idx_1)_{63..39} =
%(t_2||s_2||idx_2)_{63..39}$, что эквивалентно $t_1||s_{1 \{19..14\}}
%= t_2||s_{2 \{19..14\}}$, что эквивалентно $t_1 = t_2 \wedge s_{1
%\{19..14\}} = s_{2 \{19..14\}}$. Первый конъюнкт равен $\bot$, т.к.
%$t_1 \neq t_2$, а второй равен $\top$, т.к. $s_1 = s_2$. Таким
%образом, следует добавить ограничение $(y+of)_{m_1} = (z+of)_{m_1}
%\Leftrightarrow \bot$, которое только что было добавлено. Поскольку
%другие индексы не задействованы, то больше ограничений согласно
%приведенному алгоритму выделять не нужно. Остается добавить
%ограничение, описывающее инструкцию ADD, а именно $z = x + y$ и
%полученный набор ограничений на переменные -- целые числа разрешать
%любым известным алгоритмом разрешения ограничений. Кстати, для этого
%тестового шаблона все полученные ограничения можно представить в
%виде задачи линейного программирования, что дает возможность
%применить для их решения соответствующие инструменты решения задачи
%линейного программирования.
