\begin{enumerate}
\item предложен новый метод для построения тестовых данных процессора
\item разработан язык для описания тестовых ситуаций
\item построен прототип генератора тестовых данных\label{generator}
\end{enumerate}

\subsection{Метод построения тестовых данных}\label{usecase}

С помощью предлагаемого метода по формальному или полуформальному
описанию поведения операции можно построить код, использующий
тестовые данные. При этом будет задействована логическое
программирование с ограничениями (constraint logical programming).

\begin{enumerate}
    \item найти формальное или полуформальное описание поведения операции
    \item выделить аргументы операции
    \item определить тестовые ситуации, возникающие при выполнении данной операции
    \item для каждой тестовой ситуации определить способы ее достижения
    \item для каждой тестовой ситуации составить описание на предлагаемом автором данного исследования языке (см. п.~\ref{testlang})
    \item запустить генератор тестовых ситуаций (см. п.~\ref{generator}); он создаст файл с промежуточным представлением
    \item написать программный код на одном из поддерживаемых языков
    программирования (\textsf{С}, \textsf{C++}, \textsf{Java}), который обрабатывает файл с промежуточным
    представлением; в результате получится программа (на \textsf{С}, \textsf{C++} или
    \textsf{Java}), в которой сначала отыскиваются тестовые данные,
    а затем используются в других вычислениях
\end{enumerate}

Заметьте, что файл с описанием ситуации достаточно создать один раз
(и переписывать его только при смене спецификации тестовой
ситуации), запускать генератор тестовых ситуаций для одной тестовой
ситуации тоже один раз. Однако для каждого получения новых тестовых
данных необходимо запускать логический интерпретатор.


\subsection{Язык описания тестовых ситуаций}\label{testlang}
Язык описания тестовых ситуаций включает все операции псевдокода, на
котором описаны операции центрального процессора в
стандарте~\cite{MIPS64}:
\begin{itemize}
\item получение бита числа с заданным номером (например, \texttt{x[7]} -- 7й бит числа \texttt{x})
\item получение диапазона бит числа с заданными номерами границ этого диапазона (например, \texttt{x[8..5]} -- диапазон бит с 8го по 5й, включая оба граничных бита)
\item конкатенация чисел (например, \texttt{x.y} -- число, двоичная запись которого сначала состоит из двоичной записи числа \texttt{x}, а за ним - из двоичной записи числа \texttt{y})
\item битовая степень числа -- конкатенация числа с самим собой нужное количество раз (например, \texttt{x\^{}5} -- битовая степень числа \texttt{x})
\item привычные арифметические операции (сложение, вычитание, умножение)
\item логические операции \texttt{AND} и \texttt{OR}
\item оператор присваивания (например, \texttt{x := 5;})
\item оператор утверждения (например, \texttt{ASSERT x = 5;} - утверждение, что при исполнении данного оператора значение переменной \texttt{x} должно равняться
5)
\end{itemize}

Язык не включает условный оператор и операторы цикла, потому что для
\texttt{MIPS} все тестовые ситуации удалось описать без них.
Описание ситуации на таком языке представляет собой
последовательность операторов, при выполнении которых должна
произойти тестовая ситуация.

Язык не включает логическую операцию \texttt{NOT}. Это связано с
ограничением применяемого логического интерпретатора, работа
которого основана на методе резолюций. Тем более, что для
\texttt{MIPS} все тестовые ситуации удалось описать без применения
\texttt{NOT}. Для этого нужно использовать версии вспомогательных
функций, используемых в псевдокоде, операторов сравнения, логических
операторов, в которые уже внесён оператор \texttt{NOT} (например,
вместо \texttt{NOT(NotWordValue(x))} использовать
\texttt{WordValue(x)}).

\subsection{Генератор тестовых данных}

Генератор на входе получает файл с описанием тестовой ситуации,
транслирует его в промежуточное представление, исполняет
промежуточное представление и, наконец, анализируя результат этого
исполнения, формирует значения аргументов операции центрального
процессора. В качестве промежуточного представления используется
логическая программа, а ее исполнение проводится с помощью
логического интерпретатора с открытым кодом
\textsc{ECLiPSe}~\cite{ECLiPSe}. Выбор именно этого логического
интерпретатора обусловлен тем, что он поддерживает технологию
\textsc{CLP}~\cite{CLP} -- логического программирования с
ограничениями. Инструменты, поддерживающие эту технологию, позволяют
составлять и находить значения переменных для набора логических
выражений (\emph{ограничений}), на которых каждое логическое
выражение было бы истинно. Каждый оператор описания тестовой
ситуации может быть сведен к набору ограничений. Поиск значений
переменных для этого набора ограничений дает как раз нужные значения
аргументов операции центрального процессора. Отсутствие в языке
описания тестовых ситуаций операторов цикла гарантирует завершение
работы инструмента на любом описании тестовой ситуации.

\subsection{Пример}
\input{usecase}
