
%Рассмотрим метод на примере операции \textsf{ADD}. В
%стандарте~\cite{MIPS64} описание этой операции расположено на
%странице 36. Сначала выделяем аргументы этой операции. Для этого
%читаем: <<Description: $rd \leftarrow rs + rt$>>. Значит, аргументы
%этой операции -- $rt$ и $rs$. Определяемся с тестовыми ситуациями.
%Читаем псевдокод операции из описания операции в стандарте:

Consider the method at the operation \textsf{ADD}. There is
description of this operation in standard~\cite{IEEEhowto:MIPS64} on
page 36. For the beginning let's looking for its arguments. Read:
"Description : $rd \leftarrow rs + rd$". So, $rt$ and $rs$ are
arguments of this operation. Then let's looking for test situations.
Read an operation pseudocode from standard:

{ \tt

if NotWordValue(GPR[rs]) or NotWordValue(GPR[rt]) then

\qquad UNPREDICTABLE

endif

temp $\leftarrow$ (GPR[rs]$_{31}$||GPR[rs]$_{31..0}$) +
(GPR[rt]$_{31}$||GPR[rt]$_{31..0}$)

if temp$_{32}$ $\neq$ temp$_{31}$ then

\qquad SignalException(IntegerOverflow)

else

\qquad GPR[rd] $\leftarrow$ sign\_extend(temp$_{31..0}$)

endif}

В стандарте~\cite{MIPS64} возникающее исключение помечается вызовом
функции \texttt{SignalException}. Одной из тестовых ситуаций будет
создание исключения \texttt{IntegerOverflow}, т.е. переполнение при
сложении. Как должен выполняться этот псевдокод, чтобы произошло
переполнение? (т.е. вызвалась функция
\texttt{SignalException(IntegerOverflow)}) Cначала вычисление
выражения <<NotWordValue(GPR[rs]) or NotWordValue(GPR[rt])>> не
должно давать истинный (\texttt{true}) результат (иначе поведение не
определено, т.к. в псевдокоде написано \texttt{UNPREDICTABLE} --
значения, при которых поведение не определено, надо исключать).
Затем должно выполниться присваивание в $temp$ и, наконец, значения
32го и 31го битов этой переменной не должны совпасть. Только при
таком исполнении псевдокода вызовется
\texttt{SignalException(IntegerOverflow)}. Записываем это исполнение
на языке, описанном в п.~\ref{testlang}:
\begin{verbatim}
VAR INT rs;
VAR INT rt;

ASSERT WordValue(rs) AND WordValue(rt);

LONG temp :=
   rs[31].rs[31..0] + rt[31].rt[31..0];

SITUATION IntegerOverflow WHEN
   temp[32] # temp[31].
\end{verbatim}

Как видите, \texttt{NOT( NotWordValue(GPR[rs]) or
NotWordValue(GPR[rt]) )} был заменен на \texttt{ WordValue(GPR[rs])
or WordValue(GPR[rt])} и далее для сокращения убраны обращения к
\texttt{GPR}. В итоге получилось \texttt{WordValue(rs) AND
WordValue(rt)}.

Запускаем генератор (см. п.~\ref{generator}).

Наконец, последний шаг -- написание программного кода

 Осталось
встроить поиск значений переменных $rs$ и $rt$ в другой программный
код. Например, на \textsf{Java} это можно сделать так:
\begin{verbatim}
import java.io.IOException;
import java.util.List;
import ru.LesdenSolver;
import ru.LogicalVariable;
import ru.NoSolution;
import ru.EclipseException;

public class Main {
  /** compile situation file to intermediate */
  public List<LogicalVariable> compile(
     String situation, String interm ) {
      return LesdenSolver.compile(
         situation, logicprog );
  }

  /** run generator to get test data and use it */
  public void run( String interm,
      List<LogicalVariable> params ) {
      try {
       List<LogicalVariable> parameters =
            LesdenSolver.solve( path, params );
       for( LogicalVariable var: parameters ) {
          ...
          // name = var.getCanonicalName()
          // value = var.getValue()
       }
      }
      catch( NoSolution t ) {
        ... //no solutions
      }
      catch( IOException e ) {
        System.out.println("I/O error: "+e);
        e.printStackTrace();
      }
      catch( EclipseException e ) {
        System.out.println("ECLiPSe error: "+e);
        e.printStackTrace();
      }
  }
}
\end{verbatim}
