цель статьи: предложить аудитории алгоритм генерации тестовых программ по шаблонам с учетом кэширования

тестовый шаблон (трансляции адресов сейчас нет, косвенных обращений нет):
LW x, y, z @ noexc(l1Hit) --> noexc.tsl: LoadMemory(a,c);
ADD u, y, x

- это лишь упрощенная модель работы с памятью (не хватает трансляции адресов)
- какие предложены решения, чем они плохи в данном случае

- устройство кэша (адрес делится на тег, сет и индекс)
- кэширующий механизм работы с памятью
- может быть для начала дать очень простой и очень понятный пример, чтобы сразу не отпугивать слушателей?
- тестовые шаблоны и инструкции в них (LOAD, STORE - l1Hit, для остальных тесла-описание)
(показать картинкой, как важно знать, что инструкции работают с одним сетом)
- в предположении, что везде один сет: перевод каждой тестовой ситуации в систему уравнений
- как распределять по сетам
- ограничения на считанные и записываемые значения при одинаковых адресах

идти надо от простого, половина слов должна быть очевидна и знакома слушателю!

ассемблерные программы нужны: (вычисление статистик по текстам?)
1) как часть входных параметров:
- ими тестировать микропроцессор (программы с заданным заранее поведением)
- ими тестировать ассемблеры, оптимизаторы, кросс-ассемблеры
- ими профилировать микропроцессоры (замерять производительность направленно)
-
2) как часть выходных параметров: (дизассемблеры?)
- как этап трансляции программ
-? учебные цели
-? хитрая разработка с написанием не программы, а ее "прототипа", требований к ней
-
3) как внутреннее средство работы системы:
-

последовательности обращений к кэширующим системам:
- к физической памяти (кэш-память на процессоре L1, L2) [посл-ть физических адресов]
- к виртуальной памяти (кэш страниц) - процессор или ОС [посл-ть виртуальных адресов]
- к прокси-серверу (кэш статических данных) [посл-ть URLов]
- к веб-серверу (кэш динамических данных) [посл-ть URLов]
- к СУБД (кэш запросов)

для этих целей можно сначала формулировать требования к ассемблерным программам,
а потом реализовывать эти требования.
что это за требования?
- совпадение, несовпадение регистров разных инструкций
- совпадение, несовпадение адресов (виртуальных или физических) разных инструкций
- кэш-промахи, кэш-попадания в конкретных инструкциях
- особый результат работы конкретных инструкций (генерация конкретных исключений)



распределение регистров
определение тестовых ситуаций
генерация и разрешение ограничений


##############################
конференция слишком разношёрстна. Поэтому тематик слишком много и мало людей, заинтересованных в тематике каждого конкретного доклада.
Например, микропроцессорами в SE не занимаются - это же не Soft, a Hard !