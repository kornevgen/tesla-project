цель статьи: предложить аудитории алгоритм генерации тестовых программ по шаблонам с учетом кэширования

тестовый шаблон (трансляции адресов сейчас нет, косвенных обращений нет):
LW x, y, z @ noexc(l1Hit) --> noexc.tsl: LoadMemory(a,c);
ADD u, y, x

- это лишь упрощенная модель работы с памятью (не хватает трансляции адресов)
- какие предложены решения, чем они плохи в данном случае

- устройство кэша (адрес делится на тег, сет и индекс)
- кэширующий механизм работы с памятью
- может быть для начала дать очень простой и очень понятный пример, чтобы сразу не отпугивать слушателей?
- тестовые шаблоны и инструкции в них (LOAD, STORE - l1Hit, для остальных тесла-описание)
(показать картинкой, как важно знать, что инструкции работают с одним сетом)
- в предположении, что везде один сет: перевод каждой тестовой ситуации в систему уравнений
- как распределять по сетам
- ограничения на считанные и записываемые значения при одинаковых адресах

идти надо от простого, половина слов должна быть очевидна и знакома слушателю!

ассемблерные программы нужны: (вычисление статистик по текстам?)
1) как часть входных параметров:
- ими тестировать микропроцессор (программы с заданным заранее поведением)
- ими тестировать ассемблеры, оптимизаторы, кросс-ассемблеры
- ими профилировать микропроцессоры (замерять производительность направленно)
-
2) как часть выходных параметров: (дизассемблеры?)
- как этап трансляции программ
-? учебные цели
-? хитрая разработка с написанием не программы, а ее "прототипа", требований к ней
-
3) как внутреннее средство работы системы:
-

последовательности обращений к кэширующим системам:
- к физической памяти (кэш-память на процессоре L1, L2) [посл-ть физических адресов]
- к виртуальной памяти (кэш страниц) - процессор или ОС [посл-ть виртуальных адресов]
- к прокси-серверу (кэш статических данных) [посл-ть URLов]
- к веб-серверу (кэш динамических данных) [посл-ть URLов]
- к СУБД (кэш запросов)

для этих целей можно сначала формулировать требования к ассемблерным программам,
а потом реализовывать эти требования.
что это за требования?
- совпадение, несовпадение регистров разных инструкций
- совпадение, несовпадение адресов (виртуальных или физических) разных инструкций
- кэш-промахи, кэш-попадания в конкретных инструкциях
- особый результат работы конкретных инструкций (генерация конкретных исключений)



распределение регистров
определение тестовых ситуаций
генерация и разрешение ограничений


##############################
конференция слишком разношёрстна. Поэтому тематик слишком много и мало людей, заинтересованных в тематике каждого конкретного доклада.
Например, микропроцессорами в SE не занимаются - это же не Soft, a Hard !
################################

1. Что тестируем ?
- подсистемы кэширования. Они встречаются в:
	* микропроцессоры (кэш физических адресов)
	* операционные системы (кэш страниц виртуальной памяти)
	* СУБД (кэш запросов)
	* веб-сервера (кэш динамических страниц)
	* прокси-сервера (кэш статических данных)

2. Каким образом будет эти системы тестировать ?
- создавать ситуации в которых должны возникнуть кэш-промахи и кэш-попадания и смотреть, возникли ли они

3. Чем будем тестировать ? Что из себя представляет тест ?
для микропроцессора - ассемблерная программа, в ней есть инструкции загрузки в и из памяти...
для веб-сервера - последовательность urlов

4. Как задавать такие тесты? какие к ним предъявляются требования ?
- последовательность инструкций
- зависимости параметров
- кэш-промахи, кэш-попадания

Задаем требования -> Генерируем по ним ассемблерные программы.
Но для этого требования надо формализовать!

5. Как формализовать требования на ассемблерные программы ?
представить их в виде тестового шаблона

6. Как генерировать по ним ассемблерные программы?
пока непонятно, вспомним, что такое кэширование,
отсюда будет понятно, как выразить кэш-промахи и кэш-попадания

7. Кэширование.

8. Как это делает Genesys-Pro и почему он здесь не подходит.

9. Как конструировать систему уравнений-неравенств.
сначала показать более простые случаи:
- кэш прямого доступа
- полностью ассоциативный кэш (нет задачи распределения сетов)
- общий случай
- несколько уровневый кэш