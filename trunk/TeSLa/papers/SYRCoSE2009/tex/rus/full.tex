\section{Генерация тестовых данных для полностью ассоциативной
кэш-памяти}

\begin{figure}[h]
\centering
\includegraphics[width=2.5in]{full}
\caption{Полностью N-ассоциативный кэш} \label{full_assoc}
\end{figure}

\emph{Полностью ассоциативный кэш} состоит из заданного количества
ячеек (их количество называется \emph{ассоциативностью кэша}). В
каждой ячейке кэша могут храниться данные любых ячеек памяти. Все
ячейки кэша соответствуют разным ячейкам памяти. Все ячейки
кэш-памяти равноправны. При обращении к памяти первым делом данные
ищутся в кэше во всех ячейках кэш-памяти \emph{параллельно}.
Ситуация \emph{кэш-попадания} означает, что одна из ячеек кэш-памяти
соответствует требуемому адресу. Ситуация \emph{кэш-промаха}
означает, что ни одна из ячеек кэш-памяти не соответствует
требуемому адресу. В случае кэш-промаха одна из ячеек кэш-памяти
\emph{вытесняется} и заменяется на данные по требуемому адресу.
Согласно стратегии вытеснения LRU (Least Recently Used) будут
вытеснены данные, к которым дольше всего не было обращений. Везде
далее под фразой <<вытесняемый адрес $x$>> будут пониматься
вытесняемые данные по адресу $x$.

Предлагаемый алгоритм построения ограничений для тестового шаблона в
случае полностью ассоциативной кэш-памяти основывается на следующих
свойствах вытесняемых адресов:
\begin{enumerate}
\item вытесняемый адрес был добавлен ранее одной из инструкций
тестового шаблона (или находился среди адресов начального состояния
кэш-памяти);
\item между вытеснением адреса и последним кэш-попаданием к нему
(кэш-промах с замещением на этот адрес тоже считается
кэш-попаданием) происходят кэш-попадания ко всем остальным адресам
кэша.
\end{enumerate}

Алгоритм строит ограничения на следующие переменные:
\begin{enumerate}
\item $\alpha_1, \alpha_2, \alpha_3,...$ --  адреса начального
состояния кэш-памяти (их количество равно ассоциативности
кэш-памяти);
\item адреса, при обращении к которым происходят кэш-попадания (их
количество равно количеству инструкций, при обращении к которым
происходят кэш-попадания);
\item адреса, при обращении к которым происходят кэш-промахи (их
количество равно количеству инструкций, при обращении к которым
происходят кэш-промахи);
\item вытесняемые адреса (их количество равно количеству инструкций,
при обращении к которым происходят кэш-промахи);
\item $L_0, L_1, ...$ -- переменные-состояния кэш-памяти
(их количество -- на единицу больше количества инструкций, при
обращении к которым происходят кэш-промахи).
\end{enumerate}

Итак, каждая инструкций, при обращении к которой происходит
кэш-попадание, порождает 1 новую переменную; каждая инструкций, при
обращении к которой происходит кэш-промах порождает 1
переменную-состояние кэш-памяти, 1 переменную-вытесняющий адрес и 1
переменную-вытесняемый адрес. Алгоритм формирует ограничения для
каждой очередной инструкции следующим образом ($N$ --
ассоциативность кэш-памяти):
\begin{enumerate}
\item <<начальные ограничения>> генерируются для любого шаблона один раз:
$L_0 = \{ \alpha_1, \alpha_2,..., \alpha_N\}$, $|L_0| = N$ (или,
по-другому, все числа $\alpha_1, \alpha_2,..., \alpha_N$ разные);
\item <<ограничения кэш-попадания>> генерируются для каждой инструкции,
при обращении к которой происходит кэш-попадание: $x \in L$, где $x$
-- адрес в инструкции, $L$ -- текущая переменная-состояние
кэш-памяти;
\item <<ограничения кэш-промаха>> генерируются для каждой
инструкции, при обращении к которой происходит кэш-промах ($x$ --
вытесняющий адрес, $y$ -- вытесняемый адрес, $L$ -- текущая
переменная-состояние кэш-памяти): $y \in L, x \notin L, L' = L \cup
\{x\} \setminus \{y\}, lru(y)$, $L'$ становится текущей
переменной-состояния кэш-памяти для следующей инструкции.
\end{enumerate}

Ограничение $lru(y)$ описывает свойство, что $y$ является
вытесненным адресом.

\begin{figure}[h]
\centering
\includegraphics[width=2.5in]{lru}
\caption{LRU} \label{lru_picture}
\end{figure}

Ограничение $lru(y)$ представляется дизъюнкцией ограничений,
соответствующих всевозможным местам последнего обращения к $y$.
Каждый дизъюнкт к кэш-попаданию адреса $x$ фиксирует конъюнкцию двух
свойств:
\begin{enumerate}
\item $x = y$
\item $ L \setminus \{y\} = \{ x_1, x_2, ..., x_n \}$, где $x_1, x_2, ...,
x_n$ -- все адреса, к которым происходят обращения между обращением
к $x$ и вытеснением $y$.
\end{enumerate}

В качестве <<кэш-попаданий адреса $x$>> рассматриваются также
<<кэш-промахи адреса $x$>>, т.к. в результате кэш-промаха данные по
этому адресу подгружаются в кэш, и адреса данных, лежащих перед
исполнением тестового шаблона в кэше (в порядке <<последнего к ним
обращения>>).

Рассмотрим пример тестового шаблона и построение для него тестовых
данных. Будем рассматривать его для 3-х ассоциативного кэша.

LOAD x, y @ Hit

STORE u, z @ Miss

LOAD z, y @ Hit

Первым делом определимся с именами переменных так, чтобы они не
меняли свое значение (введем <<версии>> переменных). Учтем, что LOAD
дает новую версию переменной, идущей первым аргументом (т.к. в него
загружается значение из памяти). Для описания вытесняемого адреса
введем фиктивную переменную $z'_0$ (в ответ ее значение не попадет):

LOAD $x_1, y_0$ @ Hit

STORE $u_0, z_0$ @ Miss $\rightarrow z'_0$

LOAD $z_1, y_0$ @ Hit

Введем переменные начального состояния кэш-памяти: $\{ \alpha,
\beta, \gamma \}$ (их количество равно ассоциативности кэш-памяти).

Наша задача состоит в поиске значений $x_0, y_0, z_0, u_0, \alpha,
\beta, \gamma$, на которых инструкции тестового шаблона будут
исполнены в заданных тестовых ситуациях. Логично предположить, что
решение не будет единственным. Нам в данном случае достаточно найти
какое-либо одно решение.

Первые ограничения связаны с описанием попаданий и промахов, как
принадлежности текущей переменной-состоянию кэш-памяти:

$y_0 \in \{ \alpha, \beta, \gamma \}$,

$z_0 \notin \{ \alpha, \beta, \gamma \}$,

$z'_0 \in \{ \alpha, \beta, \gamma \}$,

$y_0 \in \{ \alpha, \beta, \gamma \} \setminus \{z'_0 \} \cup \{ z_0
\}$,

$\alpha, \beta, \gamma$ -- все разные

Осталось записать свойство $lru(z'_0)$. Кандидаты на последнее
обращение к этому адресу -- $y_0, \gamma, \beta, \alpha$. Первые два
кандидата не подходят, поскольку для них ограничение $L\setminus \{
z'_0\} = X$ не выполняется из-за несовпадения мощностей сравниваемых
множеств. Оставшиеся кандидаты дают следующую дизъюнкцию:

$z'_0 = \beta \wedge \{ \alpha, \beta, \gamma \} \setminus \{z'_0 \}
= \{ \gamma, y_0 \}$

$\vee$

$z'_0 = \alpha \wedge \{ \alpha, \beta, \gamma \} \setminus \{z'_0
\} = \{ \beta, \gamma, y_0 \}$

Упростим ее:

$z'_0 = \beta \wedge \{ \alpha, \gamma \} = \{ \gamma, y_0 \}$

$\vee$

$z'_0 = \alpha \wedge \{ \beta, \gamma \} = \{ \beta, \gamma, y_0
\}$

Что упрощается далее:

$z'_0 = \beta \wedge y_0 = \alpha$

$\vee$

$z'_0 = \alpha \wedge y_0 \in \{ \beta, \gamma \}$

Рассмотрим первую альтернативу дизъюнкции вместе с остальными
ограничениями (фиктивная переменную $z'_0$ в ответ не попадает):

$y_0 = \alpha$

$z_0 \notin \{ \alpha, \beta, \gamma \}$,

$\alpha, \beta, \gamma$ -- все разные

Заметьте, что $x_0$ и $u_0$ нигде не принимают участие -- их
значение может быть произвольным.

Пусть адреса занимают 8 бит. Тогда все переменные принимают значения
из области от 0 до 255. Разрешая полученные ограничения, можно
получить такие значения для переменных (замечу снова, что набор
значений не является единственным):

$\alpha = y_0 = x_0 = u_0 = 0$

$\beta = 1$

$\gamma = 2$

$z_0 = 3$

Проверим исполнение тестового шаблона с такими значениями
переменных:

начальное значения кэша: [2, 1, 0]

LOAD x, 0 - Hit, т.к. 0 $\in \{2,1,0\}$; согласно lru новое
состояние кэш-памяти равно [0, 2, 1]

STORE 0, 3 - Miss, т.к. 3 $\notin \{0,2,1\}$; согласно lru 3
попадает в кэш-память, 1 из кэша вытесняется, новое ее состояние
равно [3, 0, 2]

LOAD z, 0 - Hit, т.к. 0 $\in \{3, 0, 2\}$

Все инструкции тестового шаблона были исполнены согласно указанным
тестовым ситуациям.
