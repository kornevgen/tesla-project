\section{Генерация тестовых данных для кэш-памяти прямого отображения}

\begin{figure}[h]
\centering
\includegraphics[width=2.5in]{prm}
\caption{Кэш прямого отображения} \label{prm_pic}
\end{figure}

Вся память поделена на непересекающиеся части (будем называть их
\emph{регионами}). Каждому региону соответствуют 1 ячейка кэша.
Других ячеек в кэше нет. В каждой ячейке кэша могут храниться данные
только своего региона. При обращении к памяти по адресу первым делом
данные ищутся в (единственной) ячейке кэша своего региона. Ситуация
\emph{кэш-попадания} означает, что в этой ячейке кэш-памяти
находятся данные именно по требуемому адресу. Ситуация
\emph{кэш-промаха} означает, что в ячейке кэш-памяти требуемого
региона содержатся данные по адресу отличному от требуемого. В
случае кэш-промаха данные из ячейки кэш-памяти \emph{вытесняются} и
заменяются на данные по требуемому адресу. Поскольку вытесняемые
данные определены однозначно, о стратегиях вытеснения для кэш-памяти
прямого отображения не говорят.

Предлагаемый алгоритм построения ограничений для тестового шаблона в
случае кэш-памяти прямого отображения основывается на следующих
свойствах вытесняемых адресов:
\begin{enumerate}
\item любой (в том числе и вытесняемый) адрес был добавлен ранее одной из инструкций
тестового шаблона (или находился среди адресов начального состояния
кэш-памяти);
\item между вытеснением адреса и последним кэш-попаданием к нему
(кэш-промах с замещением на этот адрес тоже считается
кэш-попаданием) не происходит обращения к региону вытесняемого
адреса.
\end{enumerate}

Алгоритм строит ограничения на следующие переменные:
\begin{enumerate}
\item $\alpha_1, \alpha_2, \alpha_3,...$ --  адреса начального
состояния кэш-памяти (их количество равно количеству регионов);
\item адреса, при обращении к которым происходят кэш-попадания (их
количество равно количеству инструкций, при обращении к которым
происходят кэш-попадания);
\item адреса, при обращении к которым происходят кэш-промахи (их
количество равно количеству инструкций, при обращении к которым
происходят кэш-промахи);
\item вытесняемые адреса (их количество равно количеству инструкций,
при обращении к которым происходят кэш-промахи);
\item $L_0, L_1, ...$ -- переменные-состояния кэш-памяти
(их количество -- на единицу больше количества инструкций, при
обращении к которым происходят кэш-промахи).
\end{enumerate}

Введем функциональный символ $R(y)$, который для адреса $y$
возвращает множество всех ячеек того же региона, что и $y$. Для
этого функционального символа справедливы следующие свойства:

$\forall x~( x \in R(x) )$

$\forall x~\forall y~( x = y \rightarrow R(x) = R(y) )$

$\forall x~\forall y~( R(x) = R(y) \leftrightarrow x \in R(y) )$

$\forall x~\forall y~( R(x) = R(y) \leftrightarrow y \in R(x) )$

$\forall x~\forall y~( x \notin R(y) \rightarrow x \neq y )$

Алгоритм формирует ограничения для каждой очередной инструкции
следующим образом ($N$ -- количество регионов):
\begin{enumerate}
\item <<начальные ограничения>> генерируются для любого шаблона один раз:
$|\{ \alpha_1, \alpha_2,..., \alpha_N\}| = N$ (или, по-другому, все
числа $\alpha_1, \alpha_2,..., \alpha_N$ разные), $|\{ R(\alpha_1),
R(\alpha_2),..., R(\alpha_N)\}| = N$ (или, по-другому, все множества
$R(\alpha_1), R(\alpha_2),..., R(\alpha_N)$ разные);
\item <<ограничения кэш-попадания>> генерируются для каждой инструкции,
при обращении к которой происходит кэш-попадание: $x \in L$, где $x$
-- адрес в инструкции, $L$ -- текущая переменная-состояние
кэш-памяти;
\item <<ограничения кэш-промаха>> генерируются для каждой
инструкции, при обращении к которой происходит кэш-промах ($x$ --
вытесняющий адрес, $y$ -- вытесняемый адрес, $L$ -- текущая
переменная-состояние кэш-памяти): $y \in L, x \notin L, L' = L \cup
\{x\} \setminus \{y\}, R(y) = R(x)$, $L'$ становится текущей
переменной-состояния кэш-памяти для следующей инструкции.
\end{enumerate}

Ограничения для кэша прямого отображения отличаются от ограничений
для полностью ассоциативного кэша лишь описанием вытесняемого
адреса.

Рассмотрим тот же пример тестового шаблона и построение для него
тестовых данных. Пусть память поделена на 3 региона в зависимости от
остатка от деления на 3 адреса (т.е. $R(x) = R(y) \Leftrightarrow 3
| (x-y)$ ).

LOAD x, y @ Hit

STORE u, z @ Miss

LOAD z, y @ Hit

Первым делом определимся с именами переменных так, чтобы они не
меняли свое значение (введем <<версии>> переменных). Учтем, что LOAD
дает новую версию переменной, идущей первым аргументом (т.к. в него
загружается значение из памяти). Для описания вытесняемого адреса
введем фиктивную переменную $z'_0$ (в ответ ее значение не попадет):

LOAD $x_1, y_0$ @ Hit

STORE $u_0, z_0$ @ Miss $\rightarrow z'_0$

LOAD $z_1, y_0$ @ Hit

Введем переменные начального состояния кэш-памяти: $\{ \alpha,
\beta, \gamma \}$ (по одной для каждого региона).

Наша задача состоит в поиске значений $x_0, y_0, z_0, u_0, \alpha,
\beta, \gamma$, на которых инструкции тестового шаблона будут
исполнены в заданных тестовых ситуациях. Логично предположить, что
решение не будет единственным. Нам в данном случае достаточно найти
какое-либо одно решение.

Согласно алгоритму для кэш-попаданий и кэш-промахов будут выделены
следующие ограничения:

$y_0 \in \{ \alpha, \beta, \gamma \}$,

$z_0 \notin \{ \alpha, \beta, \gamma \}$,

$z'_0 \in \{ \alpha, \beta, \gamma \}$,

$y_0 \in \{ \alpha, \beta, \gamma \} \setminus \{z'_0 \} \cup \{ z_0
\}$,

$R(z_0) = R(z'_0)$,

$\alpha, \beta, \gamma$ -- все разные

$R(\alpha), R(\beta), R(\gamma)$ -- все разные

Упростим полученную систему ограничений:

$z'_0 \in \{ \alpha, \beta, \gamma \}$,

$y_0 \in \{ \alpha, \beta, \gamma \} \setminus \{z'_0\}$,

$z_0 \notin \{ \alpha, \beta, \gamma \}$,

$ 3 | ( z_0 - z'_0 )$,

$\alpha, \beta, \gamma$ -- все разные

$R(\alpha), R(\beta), R(\gamma)$ -- все разные

Заметьте, что $x_0$ и $u_0$ нигде не принимают участие -- их
значение может быть произвольным.

Пусть адреса занимают 8 бит. Тогда все переменные принимают значения
из области от 0 до 255. Разрешая полученные ограничения, можно
получить такие значения для переменных (замечу снова, что набор
значений не является единственным):

$\alpha = x_0 = u_0 = 0$

$\beta = y_0 = 1$

$\gamma = 2$

$z_0 = 3$

Проверим исполнение тестового шаблона с такими значениями
переменных:

начальное значения кэша: $L = [(R=0) \mapsto 0, (R=1) \mapsto 1,
(R=2) \mapsto 2]$

LOAD x, 1 - Hit, т.к. $R(1) = L[R=(1~mod~3)]$

STORE 0, 3 - Miss, т.к. $R(3) \neq L[R=( 3~mod~3 )]$, 1 из кэша
вытесняется, новое ее состояние равно $L = [(R=0) \mapsto 0, (R=1)
\mapsto 3, (R=2) \mapsto 2]$

LOAD z, 0 - Hit, т.к. $R(0) = L[R=(0~mod~3)]$

Все инструкции тестового шаблона были исполнены согласно указанным
тестовым ситуациям.
