%\documentclass[conference, compsoc]{IEEEtran}
\documentclass[twocolumn, 10pt]{article}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{pscyr}
\usepackage{graphicx}

\begin{document}
\title{Генерация тестовых данных для системного функционального тестирования кэш-памяти микропроцессоров}

\author{Е.В. Корныхин}

\date{}

%\author{\IEEEauthorblockN{Authors Name/s per 1st Affiliation (Author)}
%\IEEEauthorblockA{line 1 (of Affiliation): dept. name of organization\\
%line 2: name of organization, acronyms acceptable\\
%line 3: City, Country\\
%line 4: Email: name@xyz.com} \and \IEEEauthorblockN{Authors Name/s
%per 2nd Affiliation (Author)}
%\IEEEauthorblockA{line 1 (of Affiliation): dept. name of organization\\
%line 2: name of organization, acronyms acceptable\\
%line 3: City, Country\\
%line 4: Email: name@xyz.com} }


\maketitle


\begin{abstract}
%\boldmath
The abstract goes here.

\end{abstract}

\section{Introduction}
Системное функциональное тестирование микропроцессоров является
хорошо зарекомендовавшей себя техникой тестирования
микропроцессоров. Оно выполняется с использованием большого числа
программ на языке ассемблера (тестовых программ). Такие программы
загружаются в память машины, запускаются, процесс их исполнения
протоколируется и затем анализируется. В результате выносится
вердикт, в каких случаях микропроцессор себя ведет некорректно
(некорректным считается поведение, отличное от того, что заявлено в
спецификации). Системное тестирование привлекательно своей низкой
стоимостью и более ранним моментом обнаружения ошибок, т.к. его
можно проводить еще до выпуска микропроцессора на модели. Однако для
проведения системного тестирования требуется предоставить множество
тестовых программ. Причем для сложных современных процессоров таких
программ должно быть много, что делает актуальной задачу
автоматической генерации тестовых программ. Предложена
технологическая цепочка построения тестовых программ на основе
модели микропроцессора [1]. В рамках этой цепочки сначала тестовые
программы систематически строятся в абстрактном виде (в виде
тестового шаблона) – без конкретных параметров инструкций. Тестовые
шаблоны описывают последовательность инструкций, параметры
инструкций с указанием происходящих событий (например, переполнение,
промахи или попадания в кэш-памяти). В качестве параметров
инструкции могут быть указаны регистры и константы.
Последовательность инструкций чаще всего задана явно. Необходимость
в тестовом шаблоне обычно возникает тогда, когда тестирование
проводится нацеленным образом и эта цель выражена
последовательностью инструкций, каждая из которых должна быть
исполнена заданным образом. Чтобы получить тестовую программу по
заданному тестовому шаблону, достаточно найти начальные значения
регистров и той части кэш-памяти и других подсистем, с которыми
работают инструкции шаблона. Добавляемые к шаблону данные называются
тестовыми данными, а задача их построения – задачей генерации
тестовых данных. По тестовым данным строится набор инструкций
инициализации микропроцессора (загрузка значений в регистры, кэш и
т.д.), который добавляется в начало тестового шаблона. Полученную
таким образом тестовую программу можно исполнить и проверить,
совпадает ли поведение каждой инструкции с тем, что было заявлено в
тестовом шаблоне. Среди известных работ по генерации тестовых данных
для микропроцессоров можно выделить следующие методы ее решения:
1.комбинаторные техники; 2.решение задачи ATPG; 3.разрешение
ограничений. Однако комбинаторные техники применимы только в случае
простых шаблонов, где для тестовых данных явно указаны диапазоны
значений, и внутри это диапазона все значения равноправны. Генерация
тестовых данных через решение задачи ATPG (Automatic Test Pattern
Generation) скорее подходит не для функционального, а для
структурного тестирования микропроцессоров. Использование разрешения
ограничений представляется наиболее перспективной техникой генерации
тестовых данных. Почти 20-летние разработки компании IBM в этой
области привели к созданию инструмента Genesys-Pro для генерации
тестовых программ по тестовых шаблонам с использованием разрешения
ограничений. Однако для шаблонов, генерируемых методом в [1],
Genesys-Pro будет работать неэффективно. А авторы других
инструментов зачастую останавливаются на тестировании лишь
регистровой части микропроцессоров. Все эти факторы делают
актуальной задачу генерации тестовых данных иным методом, но с
использованием разрешения ограничений. Для ее решения разработана
система ТЕСЛА, включающая в себя язык описаний тестовых ситуаций
(для описания поведения инструкций микропроцессора) и генератор
тестовых данных.

2. Описание тестовых шаблонов на ТЕСЛА Тестовый шаблон задает
свойства будущей тестовой программы. Как и тестовая программа, в
тестовом шаблоне указывается последовательность инструкций тестовой
программы. Каждый элемент такой последовательности содержит указание
имени инструкции, параметров и тестовой ситуации – связи значений
операндов и состояния микропроцессора (ячейки кэш-памяти, регистры,
другие подсистемы) перед началом выполнения инструкции. В качестве
параметров инструкции в тестовом шаблоне могут выступать переменные
величины – регистры, непосредственные значения, адреса. Отдельно
могут быть зафиксированы в тестовой программе зависимости
(предикаты) между переменными величинами. Для возможности
автоматического построения тестовых данных каждую тестовую ситуацию
предлагается описать на простом императивном языке с единственным
типом – целым числом заданной битовой длины. Каждое описание
тестовой ситуации представляет собой последовательность операторов
присваивания и операторов утверждения (assert), выражая соотношения
между аргументами команды данной тестовой ситуации и состоянием
микропроцессора. Пример описания тестового шаблона : REGISTER ax :
32; REGISTER bx : 32; CONST offset : 16; ADD ax, bx, bx @ overflow
LW ax, bx, offset @ noexception( l1Miss, l2Hit ) XOR bx, ax, bx @
noexc В этом тестовом шаблоне три команды - ADD, LW и XOR. Шаблон
начинается с объявления переменных с указанием их битовых длин.
Модификатор (REGISTER или CONST) указывает семантику использования
переменной. Тестовая ситуация указывается после знака «@»: тестовая
ситуация первой команды – «overflow», второй команды – «noexception(
l1Miss, l2Hit )» и третьей – «noexc». Тестовая ситуация для второй
команды содержит аргументы - они более детально описывают тестовую
ситуацию. Каждой из трех задействованных тестовых ситуаций должно
быть предоставлено описание. Описание первой тестовой ситуации -
overflow - может быть таким (в описании используется операция
битовой конкатенации «||» и отношение неравенства «#»): VAR READONLY
x : 32; VAR READONLY y : 32; VAR READONLY z : 32; temp <- y[31]||y +
z[31]||z; ASSERT temp[32] # temp[31]; Сначала идут объявления
переменных с указанием семантики их использования. В частности, для
представленного выше тестового шаблона переменная тестовой ситуации
x соответствует переменной шаблона ax, а переменные тестовой
ситуации y и z соответствуют переменной шаблона bx. Затем идет
оператор присваивания – в присваиваемом выражении использованы
битовые операции конкатенации и взятия бита по номеру и
арифметическая операция сложения. И завершает описание оператор
утверждения, который сравнивает на неравенство 32й и 31й биты
значения переменной temp. Описание второй тестовой ситуации -
noexception - может быть таким: VAR RESULT x : 32; VAR READONLY y :
32; VAR READONLY c : 16; virtualAddr <- y + (32)c;
AddressTranslation( physicalAddr, virtualAddr ); LoadMemory( x,
physicalAddr, DATA ); В отличие от предыдущего описания добавились
вызовы процедур AddressTranslation и LoadMemory. Первая процедура
выполняет трансляцию адресов: по виртуальному адресу virtualAddr
получает физический адрес physicalAddr – а вторая процедура
загружает значение x по физическому адресу physicalAddr с
использованием кэша данных (DATA). Каждая процедура может иметь свою
тестовую ситуацию. Она указывается вместе с указанием тестовой
ситуации всей инструкции в виде списка идентификаторов с
фиксированной семантикой (например, l1Miss - указание на то, что при
загрузке из памяти должен произойти промах в кэш-памяти первого
уровня).


Задача решена в общем случае. Но здесь будет представлены 2 более
простых случая организации кэш-памяти: полностью ассоциативный кэш и
кэш прямого доступа. Произвольный кэш включает в себя характеристики
как полностью ассоциативного, так и кэша прямого доступа. Поэтому в
рамках общего случая рассматриваемые далее организации кэш-памяти
могут считаться базисными.

Операции LOAD и STORE. Тестовые ситуации Hit и Miss.

\input{full}

\input{prm}

\input{common}


\begin{thebibliography}{1}

\bibitem{IEEEhowto:kopka}
H.~Kopka and P.~W. Daly, \emph{A Guide to \LaTeX}, 3rd~ed.\hskip 1em
plus
  0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

\end{thebibliography}




% that's all folks
\end{document}
