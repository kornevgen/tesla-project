\section{Преобразования тестовых ситуаций в кэше
    в равенство~-~неравенство адресов}\label{eqs}

Согласно описанному алгоритму генерации тестовых данных сначала
происходит распределение тестовых ситуаций инструкций работы с
памятью по сетам, т.е. каждой такой тестовой ситуации сопоставить
число -- номер сета. Сопоставление можно проводить любым способом.
Главное -- чтобы выбор привел к системе ограничений, имеющей
решение. Например, можно сопоставить все тестовые ситуации одному
сету или в разные.

После распределения тестовых ситуаций по сетам отдельно для каждого
сета проводится следующий алгоритм, дающий ограничения
<<равенства-неравенства>> тегов. Исходными данным для этого
алгоритма является последовательность тестовых ситуаций в
кэш-памяти, относящихся к одному сету. Для каждой тестовой ситуации
указаны 1-2 тега (имеющийся тег либо пара из вытесняющего и вытесняемого
тегов). Алгоритм состоит из двух шагов. На первом шаге составляются
ограничения на конечные множества тегов, а на втором шаге эти
ограничения разрешаются символьно (упрощаются) до искомого
вида. Разрешение ограничений можно проводить любым из известных
алгоритмов разрешения ограничений~\cite{ConstrProp}. Ниже приведен
псевдокод алгоритма. В нем учитывается, что при кэш-промахе
происходит вытеснение согласно политике замещения LRU (Least
Recently Used), хотя подобная техника применима и к другим политикам
замещения. Текущее состояние сета моделируется множеством $L$.
Кэш-попадание описывается принадлежностью тэга этому множеству, а
кэш-промах -- непринадлежностью вытесняющего тега этому множеству.
Политика замещения LRU переформулирована в следующем виде: после
последнего обращения к тегу до его вытеснения должны произойти
обращения ко всем остальным тегам сета. $xs$ -- теги-переменные
начального состояния сета. Итоговые ограничения вида
равенство-неравенство адресов будут сформулированы на содержимое
$xs$ и на вытесняющие теги.

{ \tt \normalsize

procedure A( $tt$ : test\_template\_for\_set, $xs$ : тэгvar-list )

returns $C$ : constraint-set

begin

\hspace{0.5cm}$C := \{\}$

\hspace{0.5cm}var $L$ : тэг-set := \{\}

\hspace{0.5cm}для каждого (тега $t$ из $xs$)

\hspace{0.5cm}begin

\hspace{0.5cm}\hspace{0.5cm}добавить в $C$ ограничение $t \notin L$;

\hspace{0.5cm}\hspace{0.5cm}$L := L \cup \{ t \}$;

\hspace{0.5cm}end;

\hspace{0.5cm}для каждой (тестовой ситуации $\tau$ из $tt$)

\hspace{0.5cm}begin

\hspace{0.5cm}\hspace{0.5cm}если $\tau$ есть кэш-попадание тега $p$, то

\hspace{0.5cm}\hspace{0.5cm}\hspace{0.5cm}добавить в $C$ ограничение $p \in L$

\hspace{0.5cm}\hspace{0.5cm}иначе если $\tau$ есть кэш-промах тега $p$ с вытеснением тега $q$, то

\hspace{0.5cm}\hspace{0.5cm}begin

\hspace{0.5cm}\hspace{0.5cm}\hspace{0.5cm}добавить в $C$ ограничение $q \in L$;

\hspace{0.5cm}\hspace{0.5cm}\hspace{0.5cm}добавить в $C$ ограничение $p \notin L$;

\hspace{0.5cm}\hspace{0.5cm}\hspace{0.5cm}добавить в $C$ ограничение lru( $q, L, \tau, tt$ );

\hspace{0.5cm}\hspace{0.5cm}\hspace{0.5cm}$L := L \cup \{p\} \setminus \{q\}$;

\hspace{0.5cm}\hspace{0.5cm}end;

\hspace{0.5cm}end;

\hspace{0.5cm}упростить $C$;

end,

procedure lru( $q$ : тэг, $L$ : тэг-set, $\tau$ : тестовая\_ситуация,\\$tt$ : test\_template\_for\_set ) returns $C$ : constraint

begin

\hspace{0.5cm}$C := \bot$;

\hspace{0.5cm}для каждого ($\tau'(p1)$ : кэш-попадания из $tt$ с
начала~\footnote{с добавления тегов-переменных начального состояния
в сет} до $\tau$)

\hspace{0.5cm}begin

\hspace{0.5cm}\hspace{0.5cm}var $T$ : тэг-set := множество вытесняющих тегов и тегов попадания в $tt$ между $\tau'$ и $\tau$ невключительно;

\hspace{0.5cm}\hspace{0.5cm}$C := C \vee ( q = p1 ) \wedge (L \setminus \{ q \} = T);$

\hspace{0.5cm}end;

end
}

Приведенный алгоритм следует оптимизировать с целью уменьшения
размера $C$ с учетом следующих замечаний:
\begin{enumerate}
\item между последним обращением к тегу $q$ и его вытеснением должно
быть не менее $N - 1$ обращений к любым тегам, где $N$ --
ассоциативность кэш-памяти (размер сета), т.е. в цикле процедуры lru
можно пропустить кэш-попадания, отстоящие от $\tau$ ближе, чем $N -
1$
\item порядок последних обращений к тегам повторяет порядок их
вытеснения, т.е. в цикле процедуры lru можно пропустить
кэш-попадания от начала $tt$ до кэш-попадания тега, вытесняемого
предыдущим кэш-промахом из цикла процедуры А
\item последовательность кэш-попаданий в цикле процедуры lru не должна проходить
через более чем  $N$ вытеснений (в противном случае в этой
последовательности обязательно должен был бы появиться вытесняемый
тег), т.е. в этом цикле можно пропустить кэш-попадания от начала
$tt$ до кэш-промаха, отстоящего от $\tau$ ровно на $N$ кэш-промахов
\item в процедуре lru можно генерировать $C$ \emph{ленивым} образом,
т.е. для получения $C$ проходить небольшое количество итераций
цикла, затем возвращаться в алгоритм $A$; если такой $C$ не дал
решения, вернуться и пройти еще некоторое количество итераций (такой
механизм, например, реализован в системах логического
программирования с ограничениями~\cite{CLPusingECLiPSe})
\item если $tt$ начинается с последовательности кэш-промахов,
то несложно просчитать без разрешения ограничений, чему равны
вытесняемые теги (например, первый вытесняемый тег равен первому
добавлявшемуся тегу в сет, второй -- второму и т.д.)
\end{enumerate}

Рассмотрим пример последовательности тестовых ситуаций в кэше и
поведение алгоритма A на этой последовательности (с учетом
оптимизации):
\begin{verbatim}
 hit x1 //начальное состояние сета
 hit x2 //начальное состояние сета
 hit x3      L = { x1, x2, x3, x4 }
 hit x4 //начальное состояние сета
[ miss x5 -> x6 ]
 hit x5   // добавленный hit
 hit x7      L1 = ( { x1, x2, x3, x4 } \ { x6 } ) \/ { x5 }
[ miss x8 -> x9 ]
\end{verbatim}
и система для 4-х ассоциативной кэш-памяти (ассоциативность равна
размеру сета):
$$
\left\{
    \begin{aligned}
        x1 \notin \{x2, x3, x4\}, x2 \notin \{x3, x4\}, x3 \neq x4\\
        L = \{ x1, x2, x3, x4 \}\\
        x6 \in L\\
        x5 \notin L\\
        L1 = ( L \setminus \{ x6 \} ) \cup \{ x5 \}\\
        \{x7, x9\} \subseteq L1\\
        x8 \notin L1\\
        \\
        \left[
            \begin{aligned}
                \left\{
                    \begin{aligned}
                        x9 = x3\\
                        \{x4, x5, x7\} = L1 \setminus \{ x9 \}\\
                        x6 = x1\\
                        \{x2, x3, x4\} = L \setminus \{ x6 \}\\
                    \end{aligned}
                \right. \\
                \left\{
                    \begin{aligned}
                        x9 = x2\\
                        \{x3, x4, x5, x7\} = L1 \setminus \{ x9 \}\\
                        x6 = x1\\
                        \{x2, x3, x4\} = L \setminus \{ x6 \}\\
                    \end{aligned}
                \right. \\
            \end{aligned}
        \right.
    \end{aligned}
\right.
$$
Решением такой системы могут быть следующие зависимости между
тегами:
$$
\left\{
    \begin{aligned}
    \{ x1, x2, x3, x4, x5 \} - \text{ все разные }\\
    x6 = x1\\
    x7 = x2\\
    x9 = x3\\
    x8 \neq x2, x8 \neq x3, x8 \neq x4, x8 \neq x5\\
    \end{aligned}
\right.
$$
или
$$
\left\{
    \begin{aligned}
    \{ x1, x2, x3, x4, x5 \} - \text{ все разные }\\
    x6 = x1\\
    x7 = x3 \vee x7 = x4 \vee x7 = x5\\
    x9 = x2\\
    x8 \neq x2, x8 \neq x3, x8 \neq x4, x8 \neq x5\\
    \end{aligned}
\right.
$$
