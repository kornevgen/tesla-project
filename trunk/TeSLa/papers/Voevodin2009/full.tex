\section{Генерация тестовых данных для полностью ассоциативной
кэш-памяти}

\begin{figure}[h]
\centering
\includegraphics[width=2.5in]{full}
\caption{Полностью N-ассоциативный кэш} \label{full_assoc}
\end{figure}

\emph{Полностью ассоциативный кэш} состоит из заданного количества
ячеек (их количество называется \emph{ассоциативностью кэша}). В
каждой ячейке кэша могут храниться данные любых ячеек памяти. Все
ячейки кэша соответствуют разным ячейкам памяти. Все ячейки
кэш-памяти равноправны. При обращении к памяти первым делом данные
ищутся в кэше во всех ячейках кэш-памяти \emph{параллельно}.
Ситуация \emph{кэш-попадания} означает, что одна из ячеек кэш-памяти
соответствует требуемому адресу. Ситуация \emph{кэш-промаха}
означает, что ни одна из ячеек кэш-памяти не соответствует
требуемому адресу. В случае кэш-промаха одна из ячеек кэш-памяти
\emph{вытесняется} и заменяется на данные по требуемому адресу.
Согласно стратегии вытеснения FIFO (First-In First-Out) будут
вытеснены данные, которые находятся в кэше дольше всего. Везде далее
под фразой <<вытесняемый адрес $x$>> будут пониматься вытесняемые
данные по адресу $x$.

Предлагаемый алгоритм построения ограничений для тестового шаблона в
случае полностью ассоциативной кэш-памяти основывается на следующих
свойствах вытесняемых адресов:
\begin{enumerate}
\item вытесняемый адрес был добавлен ранее одной из инструкций
тестового шаблона (или находился среди адресов начального состояния
кэш-памяти);
\item между вытеснением адреса и кэш-промахом этого адреса происходят кэш-промахи всех остальных
адресов, содержащихся в кэше на момент вытеснения.
\end{enumerate}

Алгоритм строит ограничения на следующие переменные:
\begin{enumerate}
\item $\alpha_1, \alpha_2, \alpha_3,...$ --  адреса начального
состояния кэш-памяти (их количество равно ассоциативности
кэш-памяти);
\item адреса, при обращении к которым происходят кэш-попадания (их
количество равно количеству инструкций, при обращении к которым
происходят кэш-попадания);
\item адреса, при обращении к которым происходят кэш-промахи (их
количество равно количеству инструкций, при обращении к которым
происходят кэш-промахи);
\item $L_0, L_1, ...$ -- переменные-состояния кэш-памяти
(их количество -- на единицу больше количества инструкций, при
обращении к которым происходят кэш-промахи).
\end{enumerate}

Итак, каждая инструкция, при обращении к которой происходит
кэш-попадание, порождает 1 новую переменную; каждая инструкция, при
обращении к которой происходит кэш-промах порождает 1
переменную-состояние кэш-памяти и 1 переменную-вытесняющий адрес.
Алгоритм формирует ограничения для каждой очередной инструкции
следующим образом ($N$ -- ассоциативность кэш-памяти):
\begin{enumerate}
\item <<начальные ограничения>> генерируются для любого шаблона один раз:
$L_0 = \{ \alpha_1, \alpha_2,..., \alpha_N\}$, $|L_0| = N$ (или,
по-другому, все числа $\alpha_1, \alpha_2,..., \alpha_N$ разные);
\item <<ограничения кэш-попадания>> генерируются для каждой инструкции,
при обращении к которой происходит кэш-попадание: $x \in L$, где $x$
-- адрес в инструкции, $L$ -- текущая переменная-состояние
кэш-памяти;
\item <<ограничения кэш-промаха>> генерируются для каждой
инструкции, при обращении к которой происходит кэш-промах ($x$ --
вытесняющий адрес, $L$ -- текущая переменная-состояние кэш-памяти):
$x \notin L, L' = L \cup \{x\} \setminus \{y\}$, где $y$ --
вытесняемый адрес - это адрес, к которому происходит кэш-промах в
инструкции, находящейся перед данной инструкцией на $N$ инструкций
(в этом выражается стратегия вытеснения). Если перед данной
инструкцией меньше $N$ инструкций, то в порядке помещения адресов в
начальное состояние выбирается соответствующий адрес начального
состояния. $L'$ становится текущей переменной-состояния кэш-памяти
для следующей инструкции.
\end{enumerate}

В качестве <<кэш-попаданий адреса $x$>> рассматриваются также
<<кэш-промахи адреса $x$>>, т.к. в результате кэш-промаха данные по
этому адресу подгружаются в кэш, и адреса данных, лежащих перед
исполнением тестового шаблона в кэше (в порядке <<последнего к ним
обращения>>).

Рассмотрим пример тестового шаблона и построение для него тестовых
данных. Будем рассматривать его для 3-х ассоциативного кэша.

LOAD x, y @ Hit

STORE u, z @ Miss

LOAD z, y @ Hit

Первым делом определимся с именами переменных так, чтобы они не
меняли свое значение (введем <<версии>> переменных). Учтем, что LOAD
дает новую версию переменной, идущей первым аргументом (т.к. в него
загружается значение из памяти):

LOAD $x_1, y_0$ @ Hit

STORE $u_0, z_0$ @ Miss

LOAD $z_1, y_0$ @ Hit

Введем переменные начального состояния кэш-памяти: $\{ \alpha,
\beta, \gamma \}$ (их количество равно ассоциативности кэш-памяти).

Наша задача состоит в поиске значений $x_0, y_0, z_0, u_0, \alpha,
\beta, \gamma$, на которых инструкции тестового шаблона будут
исполнены в заданных тестовых ситуациях. Логично предположить, что
решение не будет единственным. Нам в данном случае достаточно найти
какое-либо одно решение.

Первые ограничения связаны с описанием попаданий и промахов, как
принадлежности текущей переменной-состоянию кэш-памяти:

$y_0 \in \{ \alpha, \beta, \gamma \}$,

$z_0 \notin \{ \alpha, \beta, \gamma \}$,

$y_0 \in \{ \alpha, \beta, \gamma \} \setminus \{ \alpha \} \cup \{
z_0 \}$,

$\alpha, \beta, \gamma$ -- все разные

Упрощаем полученную систему ограничений:

$y_0 \in (\{\alpha, \beta, \gamma\} \cap \{ \gamma, \beta, z_0 \})$

$z_0 \notin \{ \alpha, \beta, \gamma \}$,

$\alpha, \beta, \gamma$ -- все разные

Что упрощается до такой системы ограничений:

$y_0 \in \{\gamma, \beta\}$

$z_0 \notin \{ \alpha, \beta, \gamma \}$,

$\alpha, \beta, \gamma$ -- все разные


Заметьте, что $x_0$ и $u_0$ нигде не принимают участие -- их
значение может быть произвольным.

Пусть адреса занимают 8 бит. Тогда все переменные принимают значения
из области от 0 до 255. Разрешая полученные ограничения, можно
получить такие значения для переменных (замечу снова, что набор
значений не является единственным):

$\gamma = y_0 = x_0 = u_0 = 0$

$\beta = 1$

$\alpha = 2$

$z_0 = 3$

Проверим исполнение тестового шаблона с такими значениями
переменных:

начальное значения кэша: [0, 1, 2]

LOAD x, 0 - Hit, т.к. 0 $\in \{0,1,2\}$;

STORE 0, 3 - Miss, т.к. 3 $\notin \{0,1,2\}$; согласно FIFO 3
попадает в кэш-память, 2 из кэша вытесняется, новое состояние
кэш-памяти равно [3, 0, 1]

LOAD z, 0 - Hit, т.к. 0 $\in \{3, 0, 1\}$

Все инструкции тестового шаблона были исполнены согласно указанным
тестовым ситуациям.
