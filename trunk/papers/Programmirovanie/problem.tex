\section{Генерация тестовых данных для операций с памятью}

Под \emph{генерацией тестовых данных} понимается генерация
начального состояния микропроцессора (регистров, ячеек кэш-памяти,
строк TLB и т.п.) для заданного тестового шаблона. При исполнении
тестового шаблона из сгенерированного начального состояния
микропроцессора все инструкции шаблона должны быть исполнены в
соответствии с требованиями шаблона. В качестве требований к
исполнению инструкции используется указание \emph{тестовой ситуации}
у инструкции (ограничения на значения параметров и состояние
микропроцессора).

При исполнении инструкций загрузки и сохранения значений в памяти
могут быть задействованы такие подсистемы микропроцессора, как
кэш-память и TLB (Translation Lookaside
Buffer)~\cite{PattersonHennesy}. Параметры инструкции формируют
\emph{виртуальный адрес}, с которым работает инструкция. Затем по
виртуальному адресу (возможно, с помощью TLB) микропроцессор
вычисляет \emph{физический адрес}. И, наконец, с использованием
физического адреса (возможно, с помощью кэш-памяти) осуществляется
необходимая операция с оперативной памятью. Если данные по нужному
физическому адресу присутствуют в кэш-памяти (такая ситуация
называется \emph{кэш-попаданием}), они используются инструкцией и
обращение в оперативную память не производится. Если данные по
нужному физическому адресу отсутствуют в кэш-памяти (такая ситуация
называется \emph{кэш-промахом}), то происходит обращение в
оперативную память за требуемыми данными, которые после этого
помещаются в кэш-память. Поскольку размер кэш-памяти ограничен,
некоторые данные при этом должны быть \emph{вытеснены} из
кэш-памяти.

TLB состоит из набора строк, задающих соответствие значений бит
виртуального адреса, отвечающих номеру виртуальной страницы,
значениям бит физического адреса, отвечающих номеру физической
страницы. Кроме этого, TLB содержит небольшую собственную кэш-память
-- \emph{буфер TLB} -- для ускорения поиска нужной строки TLB.
Поэтому, в отношение TLB возможны такие ситуации, как
\emph{кэш-попадание в буфере TLB} и \emph{кэш-промах в буфере TLB}.

Тестовыми ситуациями для операций с памятью могут быть кэш-промах,
кэш-попадание, ограничение на адрес, с которым работает инструкция,
ограничение на строку TLB. Например, в следующем тестовом шаблоне:

{ \normalsize
\begin{verbatim}
REGISTER ax:32; REGISTER bx:32; CONST c:16;
LW ax, bx, c @ l1Hit, tlbMiss
SW ax, bx, c @ l2Miss, tlbHit
\end{verbatim}
}

\noindent в качестве тестовой ситуации первой инструкции указано
\texttt{l1Hit, tlbMiss}. Идентификатор \texttt{l1Hit} означает
попадание в кэш-памяти первого уровня (L1). Идентификатор
\texttt{tlbMiss} означает промах в буфере TLB. Тестовая ситуация
второй инструкции составлена из промаха в кэш-памяти второго уровня
(L2) -- \texttt{l2Miss} -- и попадания в буфере TLB
(\texttt{tlbHit}).

В данной работе предлагается метод генерации тестовых данных для
тестовых шаблонов с инструкциями, работающими с памятью. Тестовые
ситуации для таких инструкций можно разделить на \emph{тестовые
ситуации в кэш-памяти} и \emph{тестовые ситуации при трансляции
адресов}. Поскольку тестовые ситуации в кэш-памяти разных инструкций
связаны друг с другом~\footnote{Например, кэш-промах в одной
инструкции означает особый выбор физических адресов для предыдущих
инструкций с кэш-попаданием, поскольку при кэш-промахе вытесняемый
адрес есть один из тех адресов, к которым до этого были
кэш-попадания.}, то сначала в предлагаемом методе надо сгенерировать
ограничения для тестовых ситуаций в кэш-памяти (см. часть~\ref{eqs}
данной статьи). Так как тестовые ситуации при трансляции адресов
связаны друг с другом (там тоже используется кэширование), то
следующим шагом метода будет генерация ограничений для тестовых
ситуаций при трансляции адресов (см. часть~\ref{tlb} данной статьи).
В результате получится система ограничений на начальные значения
регистров, физические адреса и строки TLB, после разрешения которой
остается дополнить тестовый шаблон инструкциями инициализации
начального состояния микропроцессора на основе вычисленного
начального состояния его подсистем.
%
%
%Обратимся ближе к самой задаче генерации тестовых данных. Она
%возникает в рамках процесса построения тестовых программ. Один из
%таких систематических процессов был предложен в~\cite{kamkin}. Цель
%генерации тестовых программ задана с помощью критерия тестового
%покрытия, выделяющего набор тестовых ситуаций для каждой инструкции
%микропроцессора. Генератору тестовых программ на вход подаются
%описания тестируемых инструкций и тестовых ситуаций для них,
%возможные зависимости между инструкциями, а также параметры,
%управляющие генерацией (например, длина генерируемых
%последовательностей инструкций). В общих словах, технологическая
%цепочка состоит из следующих этапов:
%\begin{enumerate}
%\item генерируются всевозможные последовательности инструкций
%указанной длины;
%\item для каждой последовательности инструкций
%строятся всевозможные множества зависимостей между ними с точностью
%до изоморфизма;
%\item для каждого множества зависимостей
%комбинируются всевозможные тестовые ситуации. Получается тестовый
%шаблон, поскольку начальное состояние микропроцессора и значения
%параметров инструкций в тестовой программе еще не построены;
%\item завершающим этапом генерации тестовой программы является генерация
%начального состояния микропроцессора (регистров, кэш-памяти, TLB и
%др. -- это и есть \emph{тестовые данные}), на котором реализуются
%заданные в тестовом шаблоне зависимости и тестовые ситуации.
%\end{enumerate}
%
%В работе~\cite{kamkin} последний этап был описан достаточно
%схематично. Организации именно этого этапа (генерации тестовых
%данных) посвящена данная работа. Практика показывает, что при
%использовании штатных средств и алгоритмов удается строить тестовые
%данные для шаблонов небольшого размера (до трех команд), однако для
%тестирования современных процессоров следовало бы использовать
%тестовые шаблоны большего размера. Например, при тестировании
%конвейера приходится использовать тестовые программы, размер которых
%сопоставим с размером конвейера, а это несколько десятков команд.
%
%Входом генератора тестовых данных является тестовый шаблон и модель
%тестовых ситуаций. По ним генератор тестовых данных строит начальное
%состояние микропроцессора (т.е. начальные значения регистров, ячеек
%кэш-памяти, буфера трансляции адресов и пр.). Генератор тестовых
%данных использует разрешение ограничений над целыми числами, для
%которого разработаны эффективные алгоритмы~\cite{ConstrProp}. Причем
%обычно разрешение таких ограничений удается провести в разумные
%временные рамки. С использованием такого генератора тестовых данных
%удается полностью провести технологическую цепочку построения
%тестовых программ для микропроцессоров. Однако в известных
%работах~\cite{GenesysPro2004, MAATG} описывается генерация
%ограничений для шаблонов, использующих лишь регистры, а для
%инструкций работы с памятью приводятся алгоритмы, не учитывающие
%такие технологии, как кэширование и трансляция адресов (получение
%физических адресов по виртуальным). По сути в таких работах в виде
%ограничений кодируется изменений состояний каждого регистра и
%зависимости между ними. Наивное применение подобных идей для
%инструкций работы с памятью приводит к очень сложным
%ограничениям~\footnote{даже без учета трансляции адресов для
%кодирования состояния микропроцессора можно использовать формулу
%длиной порядка размера памяти ($mem_0 = var0 \wedge mem_1 = var1
%\wedge ...$); каждое изменение производится по неизвестному индексу,
%поэтому при записи нового состояния микропроцессора приходится
%перебирать все возможные варианты ($mem[i] := x$ приводит к формуле
%$(i = 0 \wedge mem_0 = x \wedge mem_1 = var1 \wedge ...) \vee (i = 1
%\wedge mem_0 = var0 \wedge mem_1 = x \wedge ...) \vee ...$), а если
%таких изменений несколько, то приходится рассматривать все возможные
%варианты значений индексов. Получающаяся формула имеет размер
%порядка $|L| \cdot 2^n$, где $|L|$ -- размер памяти, а $n$ --
%количество изменений памяти. В данной работе предложен метод
%кодирования изменений, приводящий к формуле размера порядка $|L| +
%n$.}, которые не удается разрешить за приемлимое время. В данной
%работе предложен алгоритм, который путем преобразует такие тестовые
%ситуации в очень простую форму -- в ограничения вида
%равенство-неравенство адресов (с использованием также принципа
%<<разделяй и влавствуй>>).
%
%Как следует из~\cite{kamkin}, тестовые шаблоны представляются
%последовательностью из кода инструкции, параметров и тестовой
%ситуации (для инструкций работы с памятью -- указания
%попаданий-промахов в кэше, ограничения на вытесняемые и вытесняющие
%теги, ограничения на физические и виртуальные адреса). Генерация
%ограничений для тестового шаблона производится так же
%последовательно для каждой тестовой ситуации в нем. Для трансляции
%тестовой ситуации инструкций работы с памятью приходится
%использовать и предыдущие тестовые инструкции данного шаблона -- в
%некоторых тестовых ситуациях они должны обращаться в одну <<область
%памяти>>. Эта область памяти задается значением заданного диапазона
%бит в адресе (назовем такую область памяти \emph{сетом}; внутри сета
%адреса определяются уникальным \emph{тегом}). Например, политика
%замещения LRU (Least Recently Used) формулируется в рамках сета:
%вытесняемые и вытесняющий теги лежат в одном сете и вытесняемый тег
%тот, к которому дольше всего не было обращений. Предлагается
%следующая последовательность шагов при генерации тестовых данных для
%шаблона:
%\begin{enumerate}
%\item распределить инструкции тестового шаблона по сетам;
%\item внутри этого сета формулировать ограничения на
%физические адреса (теги);
%\item сформулировать ограничения из трансляции адресов;
%\item сформулировать и решить задачу разрешения ограничений
%для всего шаблона;
%\item построить начальные состояния подсистем микропроцессора.
%\end{enumerate}
%
%Оставшаяся часть статьи организована следующим образом. Вначале
%будет дан обзор работ по системному функциональному тестированию
%микропроцессоров, затем в части~\ref{eqs} будет дан алгоритм для
%первых двух шагов алгоритма (в рамках которого будет осуществлено
%преобразование тестовых ситуаций в кэше в равенство-неравенство
%адресов), в части~\ref{tlb} будет дан алгоритм для остальных шагов.
