\section{Обзор работ по системному функциональному тестированию
микропроцессоров}

В настоящее время в практике системного функционального тестирования
микропроцессоров можно выделить следующие подходы к построению
тестовых программ:
\begin{itemize}
\item \emph{ручная разработка тестовых программ} хоть и практически неприменима
для полного тестирования микропроцессора, всё же может применяться
для тестирования особых, крайних случаев;
\item \emph{тестирование с использованием кросс-компиляции} применяется часто
из-за невысокой сложности его проведения: после согласования
спецификации микропроцессора можно начинать делать кросс-компилятор,
а код, предназначенный для кросс-компиляции, уже готов. Однако
гарантировать полноту такое тестирование не может;
\item \emph{случайная генерация тестовых программ} применяется так же часто в
силу простоты автоматизации. Сгенерированные таким образом тестовые
программы позволяют быстро обнаружить простые ошибки, однако не
гарантируют полноты тестирования. Разрабатываются и более сложные
варианты случайной генерации~\cite{muGP};
\item \emph{случайная генерация тестовых программ на основе тестовых
шаблонов} предполагает разделение процесса генерации тестовой
программы на два этапа (см. рис.~\ref{pic_commonprocess}): на первом
подготавливаются тестовые шаблоны -- абстрактные представления
тестовых программ (в тестовых шаблонах для параметров инструкций
вместо значений указываются ограничения на значения) -- а на втором
этапе по тестовым шаблонам генерируются тестовые программы. Второй
этап включает в себя \emph{генерацию тестовых данных}, т.е.
генерацию параметров инструкций (параметров-констант) и начальных
значений регистров, ячеек кэш-памяти, строк TLB и т.д. Иногда выбор
регистров для инструкций задается в тестовом шаблоне, а иногда выбор
регистров может сделать генератор тестовых данных.
\end{itemize}

\begin{figure}
\center
\includegraphics[width=0.8\textwidth]{test.eps}
\caption{Генерация тестовых программ на основе тестовых
шаблонов}\label{pic_commonprocess}
\end{figure}

Тестовые шаблоны описывают последовательность инструкций, параметры
инструкций с указанием происходящих событий (например, переполнение,
промахи или попадания в кэш-памяти). В качестве параметров
инструкции могут быть как явно указаны регистры и константы, так и
предоставлена возможность инструменту самому подобрать регистры.
Последовательность инструкций чаще всего задана явно. Необходимость
в тестовом шаблоне обычно возникает тогда, когда тестирование
проводится нацеленным образом и эта цель выражена
последовательностью инструкций, каждая из которых должна быть
исполнена заданным образом. Пример тестового шаблона:

{ \normalsize
\begin{verbatim}
REGISTER ax:32; REGISTER bx:32; REGISTER cx:32;
ADD ax, ax, bx @ overflow
LW cx, ax, 0 @ l1Hit
MUL ax, cx, bx @ normal
\end{verbatim}
}

\noindent В этом тестовом шаблоне 3 инструкции -- ADD, LW и MUL. У
каждой инструкции указаны параметры -- или 3 регистра, или 2
регистра и константа -- и после знака '@' информация о том, как
должна быть исполнена инструкция (ограничение на значения параметров
инструкции и состояние микропроцессора): overflow -- с переполнением
при целочисленном сложении (сумма параметров либо слишком мала, либо
слишком велика, чтобы точно записать ее в регистр-результат), l1Hit
-- c кэш-попаданием (при загрузке из памяти данные по требуемому
физическому адресу в момент исполнения инструкции должны
присутствовать в кэш-памяти) и normal -- без исключений (инструкция
выполняется полностью, регистр-результат содержит точное значение).
Чтобы получить тестовую программу по этому шаблону, достаточно
задать начальные значения регистров ax, bx и cx и той части
кэш-памяти, с которой работает вторая инструкция (LW) (это и будут
тестовые данные для данного шаблона). Это можно сделать, добавив в
начало тестового шаблона инструкции инициализации состояния
микропроцессора. Полученную тестовую программу можно исполнить и
проверить, совпадает ли поведение каждой инструкции с тем, что было
заявлено в тестовом шаблоне.

Обратимся к задаче генерации тестовых данных. Среди известных работ
можно выделить следующие методы ее решения:
\begin{itemize}
\item комбинаторные техники;
\item решение задачи ATPG;
\item разрешение ограничений.
\end{itemize}

\emph{Комбинаторные техники} применимы в случае простых тестовых
шаблонов. Такие тестовые шаблоны включают лишь простые ограничения,
а именно указание области значений переменной. Причем все значения
этой области в тестовой программе равноправны. Техника хоть и
простая, но довольно ограниченная в применении, поскольку не всегда
получается привести ограничения на переменные к такому простому
виду. В работе исследователей из Fujitsu Lab.~\cite{TSE}
предлагается описать тестовые программы в виде выражений (Test
Specification Expressions, TSE), а инструкции микропроцессора -- на
языке ISDL. Специальный генератор строит тестовые программы,
удовлетворяющие TSE. Kohno и Matsumoto~\cite{mVpGen} рассматривают
задачу верификации конвейерных микропроцессоров, используя для этого
генерацию тестовых программ с помощью тестовых шаблонов. Области
значений переменных в таких шаблонах складываются из регистров и
числовых констант.

Исследователи из Politecnico di Milano~\cite{toATPG} предложили
генеровать тестовые данные с использованием \emph{техник решения
задачи ATPG} (Automatic Test Pattern Generation). ATPG -- задача
поиска значений входных сигналов (<<векторов>>) схемы с целью поиска
ее некорректного поведения. ATPG чаще применяется для модульного
тестирования, если известна RTL-модель микропроцессора. Задача ATPG
известна давно и для ее решения существуют (в том числе
коммерческие) инструменты. Для применения ATPG при генерации
тестовых программ необходимо, чтобы RTL-модель микропроцессора была
готова к моменту генерации тестовых данных. Кроме того,
использование такой методики именно для функционального тестирования
ограничено, поскольку нарушено требование неизбыточности задания
семантики инструкций -- наличие RTL-модели является лишним,
дополнительным требованием к семантике и требует дополнительных
трудозатрат на свою подготовку.

Наиболее впечатляющих результатов достигают инструменты, использующие для
генерации тестовых данных \emph{разрешение ограничений}. Ограничение с
логической точки зрения то же, что и предикат, а задача разрешения ограничений
-- то же, что и задача выполнимости системы предикатов, но для решения этой
задачи применяются специальные алгоритмы~\cite{ConstrProp}. В
работе~\cite{MAATG} исследователей из Китайского Национального Университета
технологий безопасности описывается инструмент MAATG. Тестовый шаблон для него
может содержать лишь ограничения равенства или неравенства значений и указание
области значений переменной. Для задания архитектуры микропроцессора
используется описание на языке EXPRESSION. Другой инструмент --
Genesys-Pro~\cite{GenesysPro2004} -- позиционируется компанией IBM как
разработка, впитавшая лучшее из разработок последних 20 лет. Тестовые шаблоны
позволяют задавать тестовые программы переменной длины. Для любой инструкции в
тестовом шаблоне может быть указана эвристика для выбора значений
параметров~\cite{GenesysPro2004Innovations}. Среди возможных эвристик есть и
эвристики на события в кэш-памяти и при трансляции адресов. Однако в известных
работах не раскрывается содержание таких эвристик, что не дает возможности
понять эффективность генерации программ, нацеленных на тестирование памяти.
Система команд микропроцессора должна быть описана в виде ограничений
(constraint net) на операнды, код операции, что не является естественным
описанием поведения инструкции, особенно если в рамках нее выполняется
несколько последовательных вычислений на основе параметров инструкции. Для
генерации параметров очередной инструкции Genesys-Pro использует уже
построенную тестовую программу и состояние микропроцессора, которое известно
полностью. Этот подход обеспечил масштабируемость на большие тестовые шаблоны,
но и привел к необходимости использования механизма возврата (backtracking),
если выбрать параметры для очередной инструкции невозможно.

%Кроме того инструмент не использует """функциональные связи"""
%разных команд, а генерирует значения параметров очередной команды,
%исходя из уже построенной части тестовой программы до этой команды.
%Иными словами, тестовая программа строится по-командно, что может
%отрицательно сказаться на эффективности работы Genesys-Pro на
%больших тестовых шаблонах.

% по большому счету Genesys-Pro лишь строит параметры очередной команды,
% а я ставлю более сложную задачу - кроме параметров сгенерировать и
% начальное состояние! В IBM поступают хитрее: самое сложное - начальное
% состояние уже известно (в т.ч. все сеты), а генератор просто "выбирает".
% сравните: cache = [ set1:0,5,10; set2:2,4,7 ], select(set,tag: cache miss)
% -> задача: set isin {1,2}, tag ~isin cache(set). Решаем сначала первый предикат,
% затем второй. Получаем set = 1, tag = 1. Всё просто.
% И сравните это с тем, что у меня: (set,tag): cache miss,.... И все!
% тут надо описать, что такое miss.

В данной работе при решении задачи генерации тестовых данных также
используется разрешение ограничений. Выполняется эта работа в рамках
технологической цепочки построения тестовых программ на основе
модели микропроцессора~\cite{kamkin}. Однако для тестовых шаблонов,
получаемых в рамках этой технологической цепочки, инструмент MAATG
неприменим, поскольку шаблоны могут содержать не только ограничения
равенства или неравенства регистров, но и более сложные ограничения,
например, кэш-промах. В данной статье по сравнению с Genesys-Pro
тестовый шаблон транслируется в ограничения целиком (известно, что
задача разрешения ограничений (т.е. задача выполнимости) NP-полна;
это означает, что для больших тестовых шаблонов предлагаемый в
данной статье метод может быть не столь эффективным, однако практика
показывает, что ошибки в управляющей логике обнаруживаются на
тестовых программах небольшой длины). При предлагаемой организации
построения ограничений отпадает необходимость в механизме возврата.
Из-за этого качественно меняется разрешаемая система ограничений
(Genesys-Pro сводит общую задачу к множеству задач, на порядок
меньшей сложности). Кроме того, в данной статье предлагается более
технологичный метод построения тестовых данных: описание архитектуры
микропроцессора может быть получено из стандарта архитектуры
микропроцессора и представляет собой понятное для человека
императивное задание.

Особенностью тестовых шаблонов, получаемых в рамках~\cite{kamkin}, является
фиксация для каждой инструкции регистров-параметров. Для таких шаблонов
Genesys-Pro будет работать крайне неэффективно, поскольку теряется возможность
с помощью выбора параметров <<подогнать>> исполнение очередной инструкции под
заданные в тестовом шаблоне для нее события. На тестовых шаблонах
из~\cite{kamkin} Genesys-Pro будет работать следующим образом: выберет
некоторое начальное состояние микропроцессора, начнет исполнять тестовый шаблон
(поскольку начальное состояние ему известно), но как только дойдет до
инструкции, которая будет исполнена не так, как требуется в шаблоне,
Genesys-Pro сделает возврат в самое начало, а именно ему придется выбрать
другое начальное состояние микропроцессора и весь процесс запустить заново.
Такой процесс генерации тестовых данных слишком неэффективен. Для задания схемы
трансляции адресов в Genesys-Pro предлагается использовать подход
DeepTrans~\cite{DeepTrans}. Однако по имеющимся работам невозможно сделать
вывод о том, как такая схема трансляции адресов отображается в ограничения.
Авторы статьи используют при описании способа трансляции адреса элементы
массива Memory с неизвестными индексами. Известно, что попытки построения
ограничений, описывающих работу с элементами массива при неизвестных индексах,
приводит к очень сложным ограничениям, разрешимость которых за приемлимое время
можно поставить под сомнение.

Попытка наивного переноса идей из представленных в обзоре инструментов
(кодирование изменений состояния каждого регистра и зависимостей между ними в
виде ограничений) для инструкций работы с памятью приводит к очень сложным
ограничениям, которые не удается разрешить за приемлемое время. Даже без учета
трансляции адресов для кодирования состояния микропроцессора можно использовать
формулу длиной порядка размера памяти ($mem_0 = var0 \wedge mem_1 = var1 \wedge
...$); каждое изменение производится по неизвестному индексу, поэтому при
записи нового состояния микропроцессора приходится перебирать все возможные
варианты ($mem[i] := x$ приводит к формуле $(i = 0 \wedge mem_0 = x \wedge
mem_1 = var1 \wedge ...) \vee (i = 1 \wedge mem_0 = var0 \wedge mem_1 = x
\wedge ...) \vee ...$), а если таких изменений несколько, то приходится
рассматривать все возможные варианты значений индексов. Получающаяся формула
имеет размер порядка $|L| \cdot 2^n$, где $|L|$ -- размер памяти, а $n$ --
количество изменений памяти. В данной работе предложен метод кодирования
изменений, приводящий к формуле размера порядка $|L| + n$.

% отличия от Genesys-Pro:
% 1) другой алгоритм обработки тестового шаблона:
%    тестовый шаблон рассматривается целиком, а не по одной команде
% 2) задача построения тестовых данных (особенно, начального состояния)
%    выражена более логично. Genesys-Pro не ищет их, а выбирает просто числа
%    наобум. Если нельзя выбрать, откат. А у меня именно поиск.
% 3) используются более логичное описание тестовых ситуаций.
%    Не ограничения, а императив.
% 4) ниже сложность написания модели тестовых ситуаций, поскольку они уже
%    описаны в документации на стандарт архитектуры :)
% 5) Genesys-Pro на тестовых шаблонах, где нет возможности что-то подобрать
%   (как, например, в Сашиных шаблонах), будет работать крайне неэффективно,
%   ибо эффективность работы Genesys-Pro достигается и за счет того, что он сам
%   может выбирать аргументы, например, регистры, если в шаблоне нет указания,
%   какой это должен быть регистр. На Сашиных шаблонах Genesys-Pro предположит
%   некоторое начальное состояние микропроцессора, а затем начнет просто исполнять
%   шаблон (поскольку в Сашиных шаблонах все регистры уже выбраны). Можно выбирать
%   значения констант - на этом может сыграть Genesys-Pro. И вот если при исполнении
%   тестового шаблона не происходит указанных тестовых ситуаций, Genesys-Pro
%   откатится к самому началу и выберет другое начальное состояние. Опять исполнит
%   тестовый шаблон. Если не получилось, снова возврат и снова подбор начального значения.
%   Такая схема неэффективна в нашей постановке задачи!
