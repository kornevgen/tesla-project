\section{Введение}
Вычислительные системы играют все большую роль в процессах, от
которых зависит здоровье и жизнь людей. Поэтому необходимо, чтобы
вычислительные системы работали корректно. Базовым компонентом
многих вычислительных систем являются микропроцессоры, выполняющие
управляющие функции. Тестирование микропроцессоров является важной
задачей, которой и посвящена данная работа.

В данной работе микропроцессор рассматривается как единая система,
входными данными для которой являются машинные программы,
загруженные в память (далее такие программы будут называться
\emph{тестовыми программами}). Эти программы исполняются, процесс
исполнения протоколируется и затем анализируется. Для
функционального тестирования (которому посвящена данная статья)
важно лишь, правильно ли исполнена загруженная программа. Кроме
того, такое тестирование можно проводить еще до выпуска
микропроцессора с использованием симуляции его модели на языке
Verilog или VHDL.

В статье~\cite{kamkin} была предложена технологическая цепочка построения
тестовых программ на основе модели микропроцессора. Цель генерации
тестовых программ задается с помощью критерия тестового покрытия,
выделяющего набор тестовых ситуаций для каждой инструкции
микропроцессора. Генератору тестовых программ на вход подаются
описания тестируемых инструкций и тестовых ситуаций для них,
возможные зависимости между инструкциями, а также параметры,
управляющие генерацией (например, длина генерируемых
последовательностей инструкций). В общих словах, технологическая
цепочка состоит из следующих этапов:
\begin{enumerate}
\item генерируются всевозможные последовательности инструкций
указанной длины;
\item для каждой последовательности инструкций
строятся всевозможные множества зависимостей между ними с точностью
до изоморфизма;
\item для каждого множества зависимостей
комбинируются всевозможные тестовые ситуации. Получается еще не
тестовая программа, но некий шаблон программы, ее абстрактное
представление (\emph{тестовый шаблон}), поскольку начальное
состояние микропроцессора и значения параметров инструкций в
тестовой программе еще не построены;
\item завершающим этапом генерации тестовой программы является генерация
начального состояния микропроцессора (регистров, кэш-памяти, TLB и
др. -- это и есть \emph{тестовые данные}), на котором реализуются
заданные в тестовом шаблоне зависимости и тестовые ситуации.
\end{enumerate}

В работе~\cite{kamkin} последний этап был описан достаточно
схематично. Организации именно этого этапа (генерации тестовых
данных) посвящена данная работа. Практика показывает, что при
использовании штатных средств и алгоритмов удается строить тестовые
данные для шаблонов небольшого размера (до трех команд), однако для
тестирования современных процессоров следовало бы использовать
тестовые шаблоны большего размера. Например, при тестировании
конвейера приходится использовать тестовые программы, размер которых
сопоставим с размером конвейера, а это несколько десятков команд.

\begin{figure}[h] \centering
\begin{tabular}{r|l}
\parbox{9cm}{\texttt{\\
REGISTER ax : 32;\\
REGISTER bx : 32;\\
CONST offset : 16;\\
ADD ax, bx, bx @ overflow\\
LW ax, bx, offset @ noexc(l1Miss,l2Hit)\\
XOR bx, ax, bx @ noexc\\
}}
&\parbox{4cm}{\texttt{\\
LUI ax, 0x50\\
ORI ax, ax, 0x67\\
SW bx, ax, 0x204\\
ADD ax, bx, bx\\
LW ax, bx, 0x204\\
XOR bx, ax, bx\\
}}
\\
\end{tabular}
\caption{Пример тестового шаблона и соответствующей ему
тестовой программы}\label{test_template_example}
\end{figure}

Входом генератора тестовых данных является тестовый шаблон
(см.рис~\ref{test_template_example}) и модель тестовых ситуаций. По
ним генератор тестовых данных строит начальное состояние
микропроцессора (т.е. начальные значения регистров, ячеек
кэш-памяти, буфера трансляции адресов и пр.) и ячеек ОЗУ. Генератор
тестовых данных использует разрешение ограничений над целыми
числами, для которого разработаны эффективные
алгоритмы~\cite{ConstrProp}. Причем обычно разрешение таких
ограничений удается провести в разумные временные рамки. С
использованием такого генератора тестовых данных удается полностью
провести технологическую цепочку построения тестовых программ для
микропроцессоров. Однако в известных работах~\cite{GenesysPro2004,
MAATG} описывается генерация ограничений для шаблонов, использующих
лишь регистры, а для инструкций работы с памятью приводятся
алгоритмы, не учитывающие такие технологии, как кэширование и
трансляция адресов (получение физических адресов по виртуальным).
Для шаблонов из арифметических и логических инструкций
микропроцессора задача генерации тестовых данных заключается лишь в
генерации начальных значений регистров (состояние остальных
подсистем микропроцессора не меняется). Поэтому для таких шаблонов
достаточно записать изменение значений в регистрах каждой
инструкцией шаблона в виде ограничений и разрешить эти ограничения
(на целые числа). Однако наивное применение подобных идей для
инструкций работы с памятью приводит к очень сложным
ограничениям~\footnote{Даже без учета трансляции адресов для
кодирования состояния микропроцессора можно использовать формулу
длиной порядка размера памяти ($mem_0 = var0 \wedge mem_1 = var1
\wedge ...$); каждое изменение производится по неизвестному индексу,
поэтому при записи нового состояния микропроцессора приходится
перебирать все возможные варианты ($mem[i] := x$ приводит к формуле
$(i = 0 \wedge mem_0 = x \wedge mem_1 = var1 \wedge ...) \vee (i = 1
\wedge mem_0 = var0 \wedge mem_1 = x \wedge ...) \vee ...$), а если
таких изменений несколько, то приходится рассматривать все возможные
варианты значений индексов. Получающаяся формула имеет размер
порядка $|L| \cdot 2^n$, где $|L|$ -- размер памяти, а $n$ --
количество изменений памяти. В данной работе предложен метод
кодирования изменений, приводящий к формуле размера порядка $|L| +
n$.}, которые не удается разрешить за приемлимое время.


%В данной работе предложен алгоритм, который путем преобразует такие
%тестовые ситуации в очень простую форму -- в ограничения вида
%равенство-неравенство адресов (с использованием также принципа
%<<разделяй и влавствуй>>).
%
%Как следует из~\cite{kamkin}, тестовые шаблоны представляются
%последовательностью из кода инструкции, параметров и тестовой
%ситуации (для инструкций работы с памятью -- указания
%попаданий-промахов в кэше, ограничения на вытесняемые и вытесняющие
%теги, ограничения на физические и виртуальные адреса). Пример описания тестового шаблона :
%{ \normalsize
%\begin{verbatim}
%REGISTER ax : 32;REGISTER bx : 32;CONST offset : 16;
%ADD ax, bx, bx @ overflow
%LW ax, bx, offset @ noexception( l1Miss, l2Hit )
%XOR bx, ax, bx @ noexc
%\end{verbatim}
%}
%В этом тестовом шаблоне три команды - ADD, LW и XOR. Шаблон
%начинается с объявления переменных с указанием их битовых длин.
%Модификатор (REGISTER или CONST) указывает семантику использования
%переменной. Тестовая ситуация указывается после знака <<@>>:
%тестовая ситуация первой команды - <<overflow>>, второй команды -
%<<noexception( l1Miss, l2Hit )>> и третьей - <<noexc>>. Тестовая
%ситуация для второй команды содержит аргументы - они более детально
%описывают тестовую ситуацию.
%
%Генерация ограничений для тестового шаблона производится
%последовательно для каждой тестовой ситуации в нем. Для трансляции
%тестовой ситуации инструкций работы с памятью приходится
%использовать и предыдущие тестовые инструкции данного шаблона -- в
%некоторых тестовых ситуациях они должны обращаться в одну <<область
%памяти>>. Эта область памяти задается значением заданного диапазона
%бит в адресе (назовем такую область памяти \emph{сетом}; внутри сета
%адреса определяются уникальным \emph{тегом}~\cite{PattersonHennesy}). Например, политика
%замещения LRU (Least Recently Used) формулируется в рамках сета:
%вытесняемые и вытесняющий теги лежат в одном сете и вытесняемый тег
%тот, к которому дольше всего не было обращений. Предлагается
%следующая последовательность шагов при генерации тестовых данных для
%шаблона:
%\begin{enumerate}
%\item распределить инструкции тестового шаблона по сетам;
%\item внутри этого сета формулировать ограничения на
%физические адреса (теги);
%\item сформулировать ограничения из трансляции адресов;
%\item сформулировать и решить задачу разрешения ограничений
%для всего шаблона;
%\item построить начальные состояния подсистем микропроцессора.
%\end{enumerate}
%
%Оставшаяся часть статьи организована следующим образом. Вначале
%будет дан обзор работ по системному функциональному тестированию
%микропроцессоров, затем в части~\ref{eqs} будет дан алгоритм для
%первых двух шагов алгоритма (в рамках которого будет осуществлено
%преобразование тестовых ситуаций в кэше в равенство-неравенство
%адресов), в части~\ref{tlb} будет дан алгоритм для остальных шагов.
