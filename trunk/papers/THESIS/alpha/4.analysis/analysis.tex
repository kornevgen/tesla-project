\documentclass[12pt]{article}  %10pt :(((
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{pscyr}
\usepackage{indentfirst}
\usepackage{graphicx}

\title{Апробация, оценка предлагаемых методов, сравнение}
\author{}
\date{}

\textwidth=16cm \oddsidemargin=0cm

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{utv}{Утверждение}

% все главы диссертации:
% Введение (как автореферат)
% 1. Обзор и постановка задачи (сравнение -> уточнение постановки задачи)
% 2. Теоретическая глава
% 3. Программная реализация (архитектура программного решения, гибкость)
% 4. Апробация (оценка качества на проведенных экспериментах, возможно сравнение с random?)
% 5. Заключение

\begin{document}
\maketitle

%проведенные эксперименты: постановка задания, что сделано, каков
%результат (количество найденных ошибок, потраченное время)
%
%сколько было потрачено времени, написано строк кода, трудоемкость
%подготовки входных данных; сколько того же у ручной
%генерации.....понятно, что надо делать, чтобы подготовиться к
%генерации тестов - есть представление (или методика) оценки
%трудоемкости -- спроектировать шаблон, построить набор ограничений,
%запустить решатель, с точностью до времени отладки получается
%столько-то. Надо сравнить эти две методики в трех измерениях:
%трудоемкость (+ коэф. на отладку) , полнота тестирования (вроде бы у
%меня должна быть полная) ( например, "в 6 из 8 классов решение
%точное, а в остальных - приближенное"), (Саша Камкин подобрал
%параметры генерации для большей полноты, но могут быть избыточные,
%которые с точки зрения классов эквивалентности, которые я выделяю,
%можно было бы и не проверять!) избыточность (при ручной схеме может
%быть полный перебор, но очень много избыточных -- другой случай
%частичный перебор) ---  соотношение трудоемкости (время подготовки
%данных), полноты и избыточности (кол-во сгенерированных тестов).
%Например, при повышении качества трудоемкость растет чуть-чуть,
%кол-во тестов такое-то, а при ручной растет как-то, а кол-во тестов
%растет на порядок. В одном из измерений должно быть улучшение! Это и
%будет достоверным результатом, оценкой проделанной работы.
%
%трудоемкость  полнота  избыточность

\begin{abstract}
  В разделе показывается, как с использованием предлагаемых методов
  сгенерировать ограничения, описывающие работу MMU микропроцессоров
  в тестовых шаблонах для таких архитектур как PowerPC, Alpha и MIPS.
\end{abstract}

\section{Генерация ограничений для архитектуры MIPS}

\begin{utv}
Для архитектуры MIPS возможно применение методов совместной
генерации ограничений
\end{utv}

Рассмотрим исполнение инструкции обращения к памяти в
микропроцессоре архитектуры MIPS~\cite{mips64_III}. MMU в
микропроцессорах MIPS включает в себя кэш-память первого и второго
уровней (теги и сами кэшированные данные), TLB и небольшие
кэширующие буферы TLB. Кэш-память данных первого уровня в
микропроцессорах MIPS является virtually indexed physically tagged
(см. рис.~\ref{mips_mapped_cached}). Количественные параметры
рассмотрим на примере микропроцессора MIPS R10000. Кэш-память данных
первого уровня имеет размер 32 килобайта, размер строки кэш-памяти
32 байта, наборно-ассоциативная кэш-память, ассоциативность равна 2,
размер виртуального адреса 64 бита. Кэш-память второго уровня от 512
килобайт до 16 мегабайт~\cite{shnitman}. Размер JoinTLB -- 48 строк,
размер DTLB -- 4 строки.

\begin{figure}[p] \center
  \includegraphics[width=\textwidth]{mips_unmapped_cached}\\
  \caption{Неотображаемое кэшируемое обращение к данным в MIPS}\label{mips_unmapped_cached}
\end{figure}

\begin{figure}[p] \center
  \includegraphics[width=\textwidth]{mips_mapped_cached}\\
  \caption{Отображаемое кэшируемое обращение к данным в MIPS}\label{mips_mapped_cached}
\end{figure}

\begin{figure}[tp] \center
  \includegraphics[width=0.5\textwidth]{mips_unmapped_uncached}\\
  \caption{Неотображаемое некэшируемое обращение к данным в MIPS}\label{mips_unmapped_uncached}
\end{figure}

\begin{figure}[bp] \center
  \includegraphics[width=\textwidth]{mips_mapped_uncached}\\
  \caption{Отображаемое некэшируемое обращение к данным в MIPS}\label{mips_mapped_uncached}
\end{figure}

Инструкция содержит тестовые ситуации в:
\begin{itemize}
  \item кэш-памяти данных первого уровня (кэш-попадание или
  кэш-промах);
  \item объединенном TLB (JointTLB) (наличие или отсутствие
    подходящей под виртуальный адрес строки);
  \item кэш-буфере данных TLB (DTLB) (кэш-попадание или кэш-промах).
\end{itemize}

По аргументам инструкции вычисляется виртуальный адрес. Затем
производится определение, попадает ли виртуальный адрес в
отображаемую область виртуальной памяти (это также зависит и от
значения некоторых регистров и режима работы ОС). Если виртуальный
адрес не попадает в отображаемую область, вычисляется физический
адрес на основе лишь значения виртуального адреса. В противном
случае происходит \emph{трансляция} виртуального адреса в физический
с помощью TLB. Это происходит следующим образом. Из виртуального
адреса извлекаются битовые поля $r$, $vpn/2$. Сначала в DTLB, а при
отсутствие подходящей строки -- в JointTLB, ищется \emph{подходящая}
строка для данного виртуального адреса в данном состоянии
микропроцессора. Строка является подходящей в данном состоянии, если
следующие условия выполнены одновременно: значение битового поля $r$
этой строки равно значению битового поля $r$ виртуального адреса,
значение битового поля $mask$ этой строки равно значению регистра
микропроцессора $PageMask$ (его значение меняет ядро операционной
системы при настройке виртуальной памяти), биты поля $vpn/2$ этой
строки, ограниченные полем $mask$, равны битам поля $vpn/2$
виртуального адреса, ограниченные полем $mask$, если битовое поле
$g$ строки равно 0, то битовое поле $asid$ этой строки равно
значению регистра $ASID$ (его значение меняет ядро операционной
системы при переключении на очередной процесс). Если подходящая
строка не найдена даже в JointTLB, то происходит событие PageFault.
Его обрабатывает операционная система (она может изменить содержимое
TLB, изменив рабочее множество, и запустить исполнение инструкции с
начала). Если подходящая строка найдена, на основе маскируемого бита
номера виртуальной страницы (\emph{vpn}: все его биты, за
исключением самого младшего, образуют $vpn/2$ и не маскируются полем
$mask$, а младший бит маскируется этим полем) выбирается четная или
нечетная часть строки, содержая номер физического кадра (pfn),
алгоритм когерентности кэш-памяти (CCA: нам главное сейчас различать
Uncached и Cached значения, от которых будет зависеть использование
кэш-памяти при поиске данных, соответствующих физическому адресу) и
некоторые флаги, среди которых важен бит валидности. Если этот бит
равен 0, происходит событие TLBInvalid (его обработка также
осуществляется операционной системой). Если виртуальный адрес не
принадлежал отображаемой области, определение алгоритма
когерентности кэш-памяти также осуществляется на основе виртуального
адреса (это его битовое поле).

Если вычисленный алгоритм когерентности кэш-памяти запрещает
кэширующее обращение (иными словами, поле $CCA$ равно $Uncached$),
то осуществляется обращение с основной памятью непосредственно по
вычисленному физическому адресу (при <<неотображаемом>> виртуальном
адресе физический адрес вычисляется непосредственно по виртуальному,
при <<отображаемом>> виртуальном адресе физический адрес
составляется из поля pfn строки TLB и битового поля виртуального
адреса из всех бит младше битов поля $vpn$).

Если вычисленный алгоритм когерентности кэш-памяти не запрещает
кэширующее обращение, то из виртуального адреса выделяется поле
$index$ (биты .............

все известные константы - размер маски -> фильтруем данный TLB по
маскам,

Поскольку pfn, извлеченный из TLB, становится частью тегсета
физического адреса, то совместная генерация применима....
Особенностью TLB в микропроцессорах MIPS является то, что строка
хранит два pfn, ....биты vpn ... поэтому.... В качестве стратегий
вытеснения используется LRU, для которого имеются способы
составления ограничений (ссылка на диапазоны вытеснения и
полезности)

\section{Генерация ограничений для архитектуры PowerPC}

\section{Генерация ограничений для архитектуры Alpha}

\pagebreak
\bibliographystyle{plain}
\bibliography{../thesis}

\end{document}
