\documentclass{article}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{pscyr}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amssymb}

\title{Основная теоретическая часть диссертации}
\author{}
\date{}

\textwidth=16cm \oddsidemargin=0cm

\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}

\begin{document}
\maketitle

Введение: Исходная постановка задачи -- последовательность тестовых
ситуаций + что надо вычислить. Типы кэш-памяти: полностью
ассоциативный, прямого отображения и наборно-ассоциативный.

\section{Использование уравнений на множества для описания тестовых
ситуаций в кэш-памяти}

Общая идея решения поставленной задачи -- по тестовому шаблону
построить систему уравнений и решить ее. Поскольку решением задачи
является начальное состояние микропроцессора (значения регистров
перед началом исполнения тестового шаблона, значения ячеек
кэш-памяти и других подсистем микропроцессора перед началом
исполнения тестового шаблона), то в системе в качестве свободных
переменных будут представлены элементы начального состояния
микропроцессора.

Рассмотрим идеи, исходя из которых предлагается строить систему
уравнений. Каждая инструкция может поменять значение регистров или
содержимое кэш-памяти и других подсистем. Значения регистров будут
представляться <<скалярными>> переменными. Содержимое кэш-памяти
будет представляться \emph{множеством ячеек} кэш-памяти. Содержимое
кэш-памяти можно разделить на две структуры -- структура для
хранения кэшированных данных и структура для хранения тегов адресов
кэшированных данных. Для моделирования тестовых ситуаций в
кэш-памяти будет использоваться только структура для хранения тегов.

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{mpset}\\
  \caption{Представление состояния микропроцессора}\label{mpset}
\end{figure}

Теперь можно подходить ближе к тому, как эту систему составлять. Но
перед этим напомню тестовые ситуации инструкций, работающих с
кэш-памятью (для описания будут использоваться следующие переменные:
$L$ -- текущее состояние кэш-памяти (множество тегов), $x$ --
(физический) адрес данных в инструкции):
\begin{itemize}
\item \emph{кэш-попадание} происходит в том случае, когда данные по
данному адресу присутствуют в кэш-памяти; по такой тестовой ситуации
предлагается строить уравнение $x \in L$;
\item \emph{кэш-промах} происходит в случае, когда данные по данному
адресу не присутствуют в кэш-памяти; для этой тестовой ситуации
составляется уравнение $x \notin L$.
\end{itemize}

Физический адрес данных в инструкции ($x$) может быть составлен из
аргументов инструкции (обычно регистров). При этом следует
использовать значения регистров в момент данной инструкции
(применить для регистров Static single assignment form,
SSA).

Рассмотрим, как составить выражение для $L$ в каждой инструкции
методом индукции. $L$ для первой инструкции есть начальное
содержимое кэш-памяти, это переменная величина в системе уравнений.
Пусть выражение для очередной инструкции $L$, а для следующей --
$L'$. Тогда если очередная инструкция -- кэш-попадание, то $L'
\equiv L$ (так как содержимое не меняется), а если очередная
инструкция -- кэш-промах с адресом $x$, то $L' \equiv (L \setminus
\{x'\} \cup \{x\})$ (так как в кэш-память при промахе добавляются
данные по нужному адресу, а некоторые данные вытесняются, $x'$ есть
адрес вытесняемых данных). Для новой переменной $x'$ добавим в
систему такие уравнения: $x' \in L \wedge displaced(x') \wedge R(x)
= R(x')$, новый предикат $displaced$ описывает \emph{стратегию
вытеснения}, т.е. правило, по которому в кэш-памяти выбираются
данные, которые следует удалить, а на их место поместить данные,
вызвавшие промах. Для кэш-памяти прямого отображения общезначимо
утверждение $(R(x) = R(x')) \rightarrow displaced(x')$, поэтому для
такого типа кэш-памяти уравнение $displaced(x')$ убирается из
системы. Функциональный символ $R$ используется для задания набора,
которому относится адрес, в кэш-памяти прямого отображения и
наборно-ассоциативной кэш-памяти. Возможна такая семантика этого
символа -- $R(x)$ это множество адресов, которые потенциально могут
находиться в том же наборе, что и набор адреса $x$ (верно
утверждение, что адрес не может соответствовать более чем одному
набору и не соответствовать никакому набору вообще, одному набору
могут соответствовать разные адреса). Или такая семантика -- $R(x)$
это номер набора адреса $x$. Для составления уравнений может быть
выбрана любая семантика. Для полностью-ассоциативной кэш-памяти
уравнение $R(x) = R(x')$ является тождественной истиной, поскольку в
нем все адреса соответствуют одному набору.

Следующая теорема описывает выражение для $L$ без использования
индукции и составление ограничений для тестовых ситуаций в
кэш-памяти:
\begin{lemma}
Пусть $L$ -- выражение для текущего состояния кэш-памяти, $L_0$ --
множество адресов данных, расположенных в кэш-памяти перед
исполнением инструкций тестового шаблона, $\{x_i\}$ -- множество
адресов данных в инструкциях с кэш-промахами, расположенными до
текущей инструкции в том же порядке, что и в тестовом шаблоне,
$\{x'_i\}$ -- множество адресов вытесняемых данных в инструкциях с
кэш-промахами, расположенными до текущей инструкции в том же
порядке, что и в тестовом шаблоне. Тогда
$$L = L_0 \setminus \bigcup_{i} \{x'_i\} \cup \bigcup_{i} ( \{x_i\} \setminus \cup_{j > i} \{x'_j\}).$$
\end{lemma}
\begin{proof}
//TODO

Например, если перед данной инструкцией располагается 3 инструкции с
кэш-промахом, то $L = L_0 \setminus \{x'_1, x'_2, x'_3\} \cup
(\{x_1\} \setminus \{x'_2, x'_3\}) \cup (\{x_2\} \setminus \{x'_3\})
\cup \{x_3\}$.
\end{proof}

\begin{theorem}
Пусть $L_0$ -- множество адресов данных, расположенных в кэш-памяти
перед исполнением инструкций тестового шаблона, $\{x_i\}$ --
множество адресов данных в инструкциях с кэш-промахами,
расположенными до текущей инструкции в том же порядке, что и в
тестовом шаблоне, $\{x'_i\}$ -- множество адресов вытесняемых данных
в инструкциях с кэш-промахами, расположенными до текущей инструкции
в том же порядке, что и в тестовом шаблоне. Тогда
\begin{itemize}
\item для инструкции с кэш-попаданием адреса $x$ следует добавить
следующую совокупность уравнений:
$$
\left[
   \begin{array}{l}
    x \in L_0 \wedge x \notin \{x'_1, x'_2, ..., x'_n\} \\
    x = x_1 \wedge x \notin \{x'_2, ..., x'_n\} \\
    x = x_2 \wedge x \notin \{x'_3, ..., x'_n\} \\
    ...\\
    x = x_{n-1} \wedge x \notin \{x'_n\} \\
    x = x_n \\
   \end{array}
  \right.
$$

\item для инструкции с кэш-промахом адреса $x$ (и адресом
вытесненных данных $x'$) следует добавить следующую систему
уравнений:
$$
\left\{
   \begin{array}{l}

  \left[
   \begin{array}{l}
    x \notin L_0 \wedge x \notin \{x_1, x_2, ..., x_n\} \\
    x = x'_1 \wedge x \notin \{x_2, ..., x_n\} \\
    x = x'_2 \wedge x \notin \{x_3, ..., x_n\} \\
    ...\\
    x = x'_{n-1} \wedge x \notin \{x_n\} \\
    x = x'_n \\
   \end{array}
  \right. \\

  { }\\

  \left[
   \begin{array}{l}
    x' \in L_0 \wedge x \notin \{x'_1, x'_2, ..., x'_n\} \\
    x' = x_1 \wedge x \notin \{x'_2, ..., x'_n\} \\
    x' = x_2 \wedge x \notin \{x'_3, ..., x'_n\} \\
    ...\\
    x' = x_{n-1} \wedge x \notin \{x'_n\} \\
    x' = x_n \\
   \end{array}
  \right. \\

  { }\\

  displaced(x')\\

  { }\\

  R(x) = R(x')\\

  \end{array}
\right.
$$

\end{itemize}
\end{theorem}
\begin{proof}
//TODO
\end{proof}

Заметьте, что получившиеся ограничения для кэш-попадания и
кэш-промаха получились очень похожими, хотя изначально у них было
два совершенно противоположных представления. Теперь надо выразить
стратегию вытеснения в виде уравнений на множества тегов.

\subsection{Методика выделения ограничений для описания тестовых
ситуаций с помощью уравнений на множества}

Итак, есть тестовый шаблон, в тестовом шаблоне для некоторой
инструкции добавлена переменная для вытесняемого тега, и для этой
переменной надо записать условие, при котором она будет вытеснена в
данной инструкции. Это условие предлагается записывать в виде
системы (возможно, с дизъюнкциями) уравнений на множества тегов,
которые можно получить, учитывая следующие правила:

\begin{enumerate}
\item переменные не кодируют порядок элементов, только содержимое
кэша;
\item порядок элементов определяется на основе порядка
инструкций, только порядком инструкций (т.е. порядком адресов, к
которым происходит обращение) можно пользоваться для кодирования
различных механизмов упорядочения; рекомендуется использовать то
определение стратегии вытеснение, в котором порядок используется
меньше всего;
\item введение термина \emph{диапазон вытеснения} -- той части
тестового шаблона, которая непосредственно влияет на вытеснение; у
диапазона есть начало на некоторой инструкции или элементе
начального состояния кэш-памяти; конец диапазона вытеснения есть
инструкция, вытесняющая нужный тег; система ограничений может
содержать дизъюнкцию условий, каждое соответствует некоторому
диапазону вытеснения;
\item возможно использование функциональных символов
(например, как это сделано с $R$);
\item ориентирование на символьное решение системы уравнений на
множества.
\end{enumerate}

\subsection{Уравнения для некоторых стратегий вытеснения}

Здесь будет представлено, как приведенная выше методика была
применена для выделения уравнений, описывающих следующие стратегии
вытеснения, наиболее часто использующиеся в микропроцессорах -- это
LRU (Least Recently Used), FIFO (First-In First-Out) и Pseudo-LRU.
Стратегия вытеснения Random не рассматривается, ввиду ее
недетерминированности и детерминированности системы уравнений.

\subsubsection{LRU -- Least Recently Used}

LRU (Least Recently Used) -- это стратегия вытеснения, определяющая
вытесняемые данные как наименее используемые. Она эффективна для
алгоритмов, обладающих свойством локальности данных, т.е. чаще
использующих те данные, к которым недавно происходило обращение.

Стратегия вытеснения LRU обычно определяется с использованием
счетчиков обращений. Более подробно, для каждого элемента кэш-памяти
вводится счетчик обращений к нему. Каждое обращение увеличивает
счетчик. Вытесняемым будет элемент с минимальным счетчиком. Однако
описание в виде уравнений на множества изменений значений счетчиков
будет слишком громоздким.

Другой способ описания LRU основан на введении порядка на элементах
набора (т.е. набор представляется списком элементов). После каждой
инструкции элементы переупорядочиваются согласно следующим правилам
(см.рис.~\ref{lru1}):
\begin{itemize}
\item при кэш-попадании элемент, соответствующий адресу инструкции,
перемещается в начало, остальные элементы от первого до данного
сдвигаются на одну позицию;
\item при кэш-промахе вытесняется последний элемент, в начало
вставляется элемент, вызвавший промах.
\end{itemize}

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{lru1}\\
  \caption{Стратегия вытеснения LRU (w - ассоциативность кэш-памяти)}\label{lru1}
\end{figure}

Однако и это описание не подходит, потому как оно существенно
использует порядок элементов.

Третий способ описания LRU основан на выборе последнего обращения к
вытесняемому элементу: чтобы элементу был вытеснен, необходимо и
достаточно, чтобы между последним обращением к нему и вытеснением
были обращения ко всем элементам текущего состояния кэш-памяти,
кроме него. Инструкции от последнего обращения к вытеснению образуют
диапазон вытеснения (см. рис.~\ref{lru-ranges}).

\begin{figure}[h] \center
  \includegraphics[width=0.4\textwidth]{lru}\\
  \caption{LRU и диапазоны вытеснения}\label{lru-ranges}
\end{figure}

Запишем в виде уравнений на множества эту логику. Предикат
$displaced(x')$ будет представлен дизъюнкцией уравнений -- каждый
элемент дизъюнкции соответствует некоторому диапазону вытеснения.
Тогда для диапазона вытеснения к инструкции, обращающейся к адресу
$y$ надо составить такую систему уравнений ($x_1, x_2, ..., x_n$ --
множество адресов, к которым происходят обращения внутри диапазона
вытеснения (как с кэш-попаданиями, так и с кэш-промахами), $L$ --
выражение для состояния кэш-памяти для инструкции, вытесняющей
$x'$):
$$
\left\{
   \begin{array}{l}
    x' = y \\
    \{x_1, x_2, ..., x_n\} \cap R(y) = (L \setminus \{y\}) \cap R(y)\\
   \end{array}
  \right.
$$

Функциональный символ $R$ используется в смысле множества адресов
того же региона. С использованием следующей леммы упростим эту
систему:
\begin{lemma}\label{LRU_simplification}
Для любых конечных множеств $X$, $Y$ и $Z$ таких, что $X \cap Y
\subseteq Z$, если существует $y$ такой, что $y \in (Y \cap
Z)\setminus X$, то $X \cap Y = (Z \setminus \{y\}) \cap Y
\Leftrightarrow Y \cap ( Z \setminus X ) = \{ y \}$.
\end{lemma}
\begin{proof}
Необходимость. По определению вычитания множеств и коммутативности
операции пересечения множеств $X \cap Y = (Z \setminus \{y\}) \cap Y
\Leftrightarrow X \cap Y = Z \cap Y \cap \overline{\{y\}}$.
Обозначим $A = Z \cap Y$, $B = X \cap Y$. Следовательно, $B = A
\setminus \{y\}$. По условию $y \notin B$ и $y \in A$. Значит, $A =
B \sqcup \{y\}$. Отсюда $A \setminus B = \{y\}$. Осталось показать,
что $A \setminus B = (Z \setminus X ) \cap Y$ : $A \setminus B = A
\cap \overline{B} = Z \cap Y \cap \overline{X \cap Y} = Z \cap Y
\cap (\overline{X} \cup \overline{Y}) = (Z \cap Y \cap \overline{X})
\cup (Z \cap Y \cap \overline{Y}) = Z \cap \overline{X} \cap Y = (Z
\setminus X ) \cap Y$.

Достаточность. Обозначим $A = Z \cap Y$, $B = X \cap Y$. С
использованием определений операций над множествами и их свойств
получаем $X \cap Y \subseteq Z \Leftrightarrow (X \cap Y) \setminus
Z = \varnothing \Leftrightarrow X \cap Y \cap \overline{Z} =
\varnothing \Leftrightarrow X \cap Y \cap (\overline{Z} \cup
\overline{Y}) = \varnothing \Leftrightarrow B \setminus A =
\varnothing$. Кроме того, по условию $A \setminus B = \{y\}$.
Следовательно, $A = (A \setminus B) \cup (A \cup B) = \{y\} \cup (B
\setminus (B \setminus A)) = \{y\} \cup (B \setminus \varnothing) =
\{y\} \cup B$. Таким образом, $A = B \cup \{y\}$. Кроме того, $y
\notin B$, значит, $A = B \sqcup \{y\}$, следовательно, $B = A
\setminus \{y\}$. Подставляя определения множеств $A$ и $B$,
получаем: $X \cap Y = (Z \cap Y) \setminus \{y\} = Z \cap Y \cap
\overline{\{y\}} = (Z \setminus \{y\}) \cap Y$.
\end{proof}

\begin{lemma}[Отсутствие вложенных диапазонов]\label{includedranges}
//TODO
\end{lemma}
\begin{proof}
//TODO
\end{proof}

\begin{lemma}[О выполнимости условий
леммы~\label{LRU_simplification} для диапазонов вытеснения] $L
\supseteq \{x_1, x_2, ..., x_n\} \cap R(y)$
\end{lemma}
\begin{proof}[\proofname~(от противного)]
Пусть среди $x_1, x_2, ..., x_n$ есть $x_i$ такой, что $x_i \notin L
\wedge x_i \in R(y)$. Пусть $L_{i+1}$ -- состояние кэш-памяти после
обращения к $x_i$. Верно, что $x_i \in L_{i+1}$, но $x_i \notin L$,
следовательно, $x_i$ был вытеснен между $x_{i+1}$ и $x_n$. Иными
словами, среди $x_1, x_2, ..., x_n$ есть элемент, чей диапазон
вытеснения вложен в диапазон вытеснения $y$. Но согласно
лемме~\ref{includedranges} это невозможно. Противоречие.
\end{proof}

Таким образом, можно применить лемму~\ref{LRU_simplification} для
упрощения уравнения для lru. В результате получаем, что для каждого
диапазона вытеснения можно записать следующую систему уравнений:
$$
\left\{
   \begin{array}{l}
    x' = y \\
    R(y) \cap (L \setminus \{x_1, x_2, ..., x_n\} ) = \{y\}\\
   \end{array}
  \right.
$$

\begin{theorem}
Определения LRU через диапазоны вытеснения и через списки
эквивалентны.
\end{theorem}
\begin{proof}
//TODO

Показать, что согласно лемме~\ref{includedranges} можно использовать
$L$ перед концом диапазона.
\end{proof}

\subsubsection{FIFO -- First-In First-Out}

FIFO (First-In First-Out) -- это стратегия вытеснения, определяющая
вытесняемые данные согласно принципу очереди FIFO.

Стратегия FIFO может быть описана на основе порядка на элементах
набора (т.е. набор представляется списком элементов). После каждой
инструкции элементы переупорядочиваются согласно следующим правилам
(см.рис.~\ref{fifo1}):
\begin{itemize}
\item при кэш-попадании порядок элементов не меняется;
\item при кэш-промахе вытесняется последний элемент, в начало
вставляется элемент, вызвавший промах.
\end{itemize}

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{fifo1}\\
  \caption{Стратегия вытеснения FIFO (w - ассоциативность кэш-памяти)}\label{fifo1}
\end{figure}

Отличие от LRU лишь в том, что при FIFO не происходит перестановки
элементов набора при возникновении кэш-попадания.

Это поведение может быть записано компактно с использованием
уравнений на множества. Определим диапазоны вытеснения для FIFO как
множество инструкций от внесения адреса в кэш-память до его
вытеснения. Причем исключим из него все инструкции с кэш-попаданиями
(они не играют никакой роли с точки зрения FIFO). Тогда \emph{FIFO
будет выполнено в том случае, когда в диапазоне встречаются все
адреса состояния кэш-памяти перед вытеснением без самого
вытесняемого адреса}.

Запишем в виде уравнений на множества эту логику. Предикат
$displaced(x')$ будет представлен дизъюнкцией уравнений -- каждый
элемент дизъюнкции соответствует некоторому диапазону вытеснения.
Тогда для диапазона вытеснения к инструкции, обращающейся к адресу
$y$ надо составить такую систему уравнений ($x_1, x_2, ..., x_n$ --
множество адресов, к которым происходят обращения внутри диапазона
вытеснения \textbf{с кэш-промахами}, $L$ -- выражение для состояния
кэш-памяти для инструкции, вытесняющей $x'$):
$$
\left\{
   \begin{array}{l}
    x' = y \\
    \{x_1, x_2, ..., x_n\} \cap R(y) = (L \setminus \{y\}) \cap R(y)\\
   \end{array}
  \right.
$$

Функциональный символ $R$ используется в смысле множества адресов
того же региона.

Для FIFO справедливы все леммы о диапазонах вытеснения,
сформулированные для LRU. В частности, с использованием их система
уравнений для диапазона вытеснения может быть переписана следующим
образом:
$$
\left\{
   \begin{array}{l}
    x' = y \\
    R(y) \cap (L \setminus \{x_1, x_2, ..., x_n\}) = \{y\}\\
   \end{array}
  \right.
$$

\begin{theorem}
Определения FIFO через диапазоны вытеснения и через списки
эквивалентны.
\end{theorem}
\begin{proof}
//TODO

Показать, что согласно лемме~\ref{includedranges} можно использовать
$L$ перед концом диапазона.
\end{proof}

\subsubsection{Pseudo-LRU}

\pagebreak
\section{Разрешение уравнений, описывающих тестовые ситуации в
кэш-памяти; вопросы эффективности}

\pagebreak
\section{Выделение задач на кэш-память в архитектуре
микропроцессора}


\end{document}
