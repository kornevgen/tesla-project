% !Mode:: "TeX:UTF-8"
\documentclass[14pt,autoref,href
%,fixint=false
,facsimile
]{disser}

\usepackage{fix-cm}
\usepackage[a4paper, nohead, includefoot, mag=1000,
            margin=2cm, top=1.5cm, bottom=1.5cm, footskip=1cm]{geometry}
%\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenx}
\usepackage[english,russian]{babel}
\usepackage{tabularx}
%\usepackage{epstopdf}
\usepackage{amsthm}
\usepackage{xspace}
\usepackage{ifthen}

% Поддержка нескольких списков литературы в одном документе
%\usepackage{multibib}
% Создание команд для цитирования собственных работ диссертанта
% в отдельном разделе. В данном случае ссылка будет иметь вид \citemy{...}.
%\newcites{my}{Список публикаций}

\newtheorem{utv}{Утверждение}
\newtheorem{theorem}{Теорема}
\newtheorem{assumption}{Предположение}
%\newtheorem{heuristics}{Эвристика}
\newtheorem{definition}{Определение}{\bfseries}{\itshape}
%% Путь к файлам с иллюстрациями
%\graphicspath{{fig/}}

% Теперь "русифицируем" окружение enumerate:
\makeatletter
\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
\def\labelenumii{\theenumii)}    % а не латинские буквы
\def\p@enumii{\theenumi}         % а это для \ref
\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
\let\theenumiii\relax            % и отдельных ссылок на него не будет
\def\p@enumiii{\theenumi\theenumii}
\makeatother


% Включение файла с общим текстом диссертации и автореферата
% (текст титульного листа и характеристика работы).
\input{common}

\include{../delta/theorems}
\include{../delta/intro11}

\newcommand{\LRU}{LRU\xspace}
\newcommand{\FIFO}{FIFO\xspace}
\newcommand{\PseudoLRU}{Pseudo-LRU\xspace}


% --------------------------------------------------------------------------
\begin{document}

% Внешняя сторона обложки
\title{АВТОРЕФЕРАТ\\
диссертации на соискание ученой степени\\
кандидата физико-математических наук}

\maketitle

% Внутренняя сторона обложки
\noindent
Работа выполнена на кафедре системного программирования факультета вычислительной математики и кибернетики Московского государственного университета имени М. В. Ломоносова.
\vskip1ex
\noindent\begin{tabularx}{\linewidth}{lp{0.3cm}X}
Научный руководитель:  & & \emph{доктор физико-математических наук}, \\
                       & & \emph{профессор} \\
                       & & \emph{\textbf{Петренко Александр Константинович}}.
\\
Официальные оппоненты: & & \emph{доктор физико-математических наук}, \\
                       & & \emph{профессор} \\
                       & & \emph{\textbf{Смелянский Руслан Леонидович}};\\
                       & & \emph{доктор физико-математических наук}, \\
                       & & \emph{профессор} \\
                       & & \emph{\textbf{Лацис Алексей Оттович}}.
\\
Ведущая организация:   & & \emph{Научно-исследовательский институт системных исследований РАН}\\
\end{tabularx}

\vskip2ex\noindent
Защита состоится <<\underline{\hspace{0.7cm}}>> \underline{\hspace{3cm}} 2010 года в \underline{11} часов
на заседании диссертационного совета \emph{Д 501.001.44} \emph{Московского
государственного университета имени М.В. Ломоносова} по адресу:
\emph{119991, ГСП-1, Москва, Ленинские горы, МГУ имени М.В.Ломоносова, 2-й учебный корпус, факультет ВМК, ауд. 685.}

\vskip1ex\noindent
С диссертацией можно ознакомиться в библиотеке
\emph{факультета ВМК МГУ}.
С текстом автореферата можно ознакомиться на официальном сайте ВМК МГУ \underline{http://cs.msu.ru} в разделе <<Наука>> --- <<Работа диссертационных советов>> --- <<Д 501.001.44>>

\vskip1ex\noindent
Автореферат разослан <<\underline{\hspace{0.7cm}}>> \underline{\hspace{3cm}} 2010 г.
%\vskip2ex\noindent
%Отзывы и замечания по автореферату в двух экземплярах, заверенные печатью, просьба высылать по вышеуказанному адресу на имя ученого секретаря диссертационного совета.

\vfill\noindent
Ученый секретарь\\
диссертационного совета\\
\emph{профессор}
\hfill
\makeatletter
% вставка файла, содержащего факсимиле ученого секретаря
%\ifDis@facsimile
%  \raisebox{-4pt}{\includegraphics[width=3cm]{sec-facsimile}}\hfill
%\fi%
\makeatother%
\emph{Н.П. Трифонов}

\clearpage

\section*{Общая характеристика работы}

\subsection*{Актуальность темы}
\newcommand{\nocites}{}
\Actuality

\subsection*{Цель диссертационной работы}
\Objective

\subsection*{Научная новизна}
\Novelty

\subsection*{Практическая значимость}
\PracticalValue

% Результаты и положения, выносимые на защиту
%\resultssection
%\resultstext

% Апробация работы
%\approbationsection
%\approbationtext

\subsection*{Апробация работы и публикации}
\Pub

% Личный вклад автора
%\contribsection
%\contribtext

\subsection*{Структура и объем диссертации}
\Structure


%
% -----------------------------------------------------------------------
%


\section*{Содержание работы}

\paragraph{Во Введении} обоснована актуальность диссертационной работы,
сформулирована цель и задачи исследований, сформулированы полученные результаты и показана их
практическая значимость.

%
% -----------------------------------------------------------------------
%


\paragraph{Первая глава} содержит обзор существующих методов построения тестовых программ, обзор подсистем управления памяти и уточнение задач исследования по результатам этих обзоров.

В разделе 1.1 дается схема системного тестирования микропроцессора, описываются его отдельные этапы, в том числе и этап построения тестовых программ. Рассматриваются псевдослучайные и целенаправленные методы автоматического построения тестовых программ. В разделе 1.2 кратко описываются функции и типичный состав подсистем управления памяти, способы повышения их эффективности и классы ошибок. В разделе 1.3 сделан обзор целенаправленных методов построения тестовых программ. Выделены методы с явным нацеливанием на тестовую ситуацию и без него (методы типа <<итерация-фильтрация>>). В разделе 1.4 сделан анализ целенаправленных методов построения тестовых программ по применимости к подсистемам управления памяти, масштабируемости, возможности нацеливания на функциональность. Наиболее перспективными оказались методы с явным нацеливанием на ситуации в виде \emph{тестовых шаблонов} --- цепочек инструкций с указанием требований на выполнение каждой инструкции --- и методы, включающие разрешение ограничений (constraint satisfaction). В разделе 1.5 уточнены задачи в соответствии с проведенным исследованием целенаправленных методов.

\paragraph{Во второй главе} предложен подход к построению нацеленных тестовых программ. В разделе 2.1 описаны его этапы: формализация микропроцессора, построение и решение систем ограничений (constraints), построение текста программы на основе найденного решения.

Раздел 2.2 посвящен первому этапу -- этапу формализации микропроцессора. В нем предложены модели блоков подсистемы управления памяти и модели инструкций. Построение таких моделей является целью этапа формализации микропроцессора. Предлагается представлять блоки подсистемы управления памяти (кэш-память, таблицу страниц и т.п.) как ассоциативные массивы: блок состоит из строк, каждая строка состоит из набора полей, поля делятся на поля ключа и поля данных. Модель блока подсистемы управления памяти фиксирует некоторые структурные и функциональные характеристики соответствующего блока. К таким характеристикам относятся: стратегия вытеснения (\texttt{policy}), ассоциативность блока (\texttt{lines}), двоичный логарифм количества <<наборов>> блока (\texttt{regbits}), имена и битовые длины полей ключа (\texttt{key}), имена и битовые длины полей данных (\texttt{data}), предикат соответствия строки блока некоторой битовой строке (\texttt{keyMatch}). Алгоритмы построения систем ограничений параметризованы теми характеристиками, которые и составляют модель блока подсистемы управления памяти. Вытеснение в блоке выполняется либо микропроцессором в результате промаха, либо программно (например, если вытеснение предполагает дополнительные действия, такое возникает при отсутствии страницы виртуальной памяти в рабочем множестве). В первом случае в качестве стратегии вытеснения следует указать \texttt{LRU}, \texttt{FIFO}, \texttt{Pseudo-LRU} или иную стратегию. Во втором случае --- указать \texttt{none}.

В том же разделе предложены модели инструкций. Они состоят из набора моделей вариантов инструкций. Варианты инструкций соответствуют отдельным путям выполнения инструкций. Модель варианта инструкции формализует требования, которые определяют путь выполнения инструкции: допустимые значения операндов инструкции, вычисление значений операндов-результатов инструкции, условия возникновения исключительных ситуаций (если вариант инструкции состоит в возникновении такой ситуации), вычисление адресов (физических, виртуальных, эффективных) в инструкции, возникающие промахи или попадания в результате обращений в блоки, какие данные загружаются или сохраняются в блоках подсистемы управления памяти. Формализация этих требований осуществляется в виде последовательности операторов 4-х видов: оператор утверждения истинности свойства над битовыми строками (\texttt{assume}), оператор введения новой переменной (\texttt{let}), оператор попадания (\texttt{hit}), оператор промаха (\texttt{miss}). Первые два оператора хорошо известны и применяются в ряде языков программирования и спецификации. Остальные два оператора специфичны инструкциям, оперирующим с памятью. Оператор попадания \texttt{hit<B>(k;R)\{load(d); store(d'); \}} означает, что в данном варианте инструкции обращение в блок \texttt{B} по ключу \texttt{k} в <<набор>> с номером \texttt{R} должно быть с попаданием, причем ключу соответствуют данные \texttt{d} (если полей данных несколько, то соответствующие переменные для них перечисляются в скобках у \texttt{load} через запятую). Если в инструкции при этом обращении должны быть изменены данные по ключу \texttt{k} (например, если это инструкция сохранения данных в памяти), то следует написать \texttt{store} с перечислением переменных с новыми значениями полей данных. Оператор промаха \texttt{miss<B>(k;R)\{replace(d);\}} означает, что в данном варианте инструкции обращение в блок \texttt{B} по ключу \texttt{k} в <<набор>> с номером \texttt{R} должно быть с промахом. Если стратеги вытеснения отлична от \texttt{none}, нужно указать секцию \texttt{replace}. Эта секция задает поля данных той строки, которая будет помещена на место вытесненной. Операторов попаданий и промахов с одним и тем же блоком может быть несколько в рамках одного варианта инструкции. Это означает, что в рамках данного варианта инструкции осуществляется несколько обращений в указанном порядке.

В разделе 2.3 предлагается алгоритм построения ограничений для тестовых шаблонов. Он состоит из следующих шагов:
\begin{enumerate}
    \item объединить операторы из моделей вариантов инструкций в порядке их упоминания в тестовом шаблоне в одну последовательность операторов;
    \item разделить полученную последовательность операторов на
подпоследовательности:
            \begin{itemize}
                \item одна подпоследовательность включает все операторы \texttt{assume} и \texttt{let};
                \item каждая другая подпоследовательность включает все операторы
\texttt{hit} и \texttt{miss} в какую-нибудь одну таблицу;
            \end{itemize}
    \item транслировать операторы \texttt{assume} и \texttt{let} без изменений в
ограничения на битовые строки;
    \item объявить переменные для аргументов инструкций и полей строк в
операторах \texttt{hit} и \texttt{miss};
    \item для каждой построенной последовательности операторов \texttt{hit} и \texttt{miss} выполнить
            \begin{enumerate}
                \item алгоритм генерации ограничений на ключи обращений: если стратегия вытеснения таблицы, чья последовательность операторов транслируется,  есть \texttt{none}, использовать <<алгоритм 2.1>>, иначе использовать <<алгоритм 2.2>>;
                \item алгоритм генерации ограничений на загружаемые/сохраняемые
данные (<<алгоритм 3>>).
            \end{enumerate}
\end{enumerate}

Алгоритм последовательно строит ограничения для операторов, составляющих модели вариантов инструкций тестового шаблона. Операторы \texttt{assume} и \texttt{let} транслируются непосредственно. Для трансляции операторов \texttt{hit} и \texttt{miss} в разделе предложены алгоритмы 2.1, 2.2 и 3. Алгоритмы 2.1 и 2.2 отвечают за трансляцию свойств наличия (hit) и отсутствия (miss) ключей в таблице. Истинность таких свойств зависит от истории обращений в таблицу по ключам (т.е. от предыдущих инструкций).

Алгоритм 2.1 состоит из следующих шагов ($k_1, ..., k_n$ --- ключи операторов \texttt{hit}, $R_1, ..., R_n$ --- номера <<наборов>> (\emph{регионы}) этих обращений; $w$ --- значение параметра таблицы \texttt{lines}):

\begin{enumerate}
    \item для каждого \texttt{miss($k; R$)}, $k$ --- ключ обращения, $R$ --- регион
обращения, составить ограничение: $(k||R) \notin \{(k_1||R_1), ..., (k_n||R_n)
\}$

    \item если $n > w$, то составить
ограничение (<<в регионе не может быть больше различных строк, чем \texttt{lines}>>):
$\bigwedge_{l=1}^n \sum_{i=1}^l c_{R_l} (k_i, R_i) \leqslant w$, где
$$c_r (k_i, R_i) \equiv \mbox{~if~} (R_i = r ) \wedge \bigwedge_{j=1}^{i-1} (R_j
\neq r \vee k_j \neq k_i) \mbox{~then~} 1 \mbox{~else~} 0 \mbox{~endif}$$
\end{enumerate}

Алгоритм 2.2 состоит из следующих шагов:
\begin{enumerate}
    \item выбрать длину инициализирующей последовательности $m$;
    \item объявить переменные ключей инициализирующей последовательности $t_1,
t_2, ..., t_m$ и их регионов $r_1, r_2, ..., r_m$;
    \item составить ограничение <<все разные $(t_1||r_1), (t_2||r_2), ...,
(t_m||r_m)$>> (<<||>> -- операция битовой конкатенации);
    \item составить ограничение для каждого \texttt{hit($k_n;R_n$)}, $k_n$ --- ключ
обращения, $R_n$ --- регион обращения:
$$\left\{\begin{array}{l}
    (k_n||R_n) \in \{(t_1||r_1), (t_2||r_2), ..., (t_m||r_m), (k_1||R_1), ...,
(k_{n-1}||R_{n-1}) \}\\
    (k_n, R_n)~\mbox{\textbf{не} вытеснен к моменту этого обращения}\\
\end{array}\right.$$

где $k_1, ..., k_{n-1}$ --- ключи предыдущих обращений в эту же таблицу,\\ $R_1,
..., R_{n-1}$ --- регионы предыдущих обращений в эту же таблицу;

    \item составить ограничение для каждого \texttt{miss($k_n;R_n$)}, $k_n$ --- ключ
обращения, $R_n$ --- регион обращения:
$$\left\{\begin{array}{l}
    (k_n||R_n) \in \{(t_1||r_1), (t_2||r_2), ..., (t_m||r_m), (k_1||R_1), ...,
(k_{n-1}||R_{n-1}) \}\\
    (k_n, R_n)~\mbox{вытеснен к моменту этого обращения}\\
\end{array}\right.$$

где $k_1, ..., k_{n-1}$ --- ключи предыдущих обращений в эту же таблицу,\\ $R_1,
..., R_{n-1}$ --- регионы предыдущих обращений в эту же таблицу;

    \item если $n > w$, то составить
ограничение (<<в регионе не может быть больше различных строк, чем \texttt{lines}>>):
$\bigwedge_{l=1}^n \sum_{i=1}^l c_{R_l} (k_i, R_i) \leqslant w$, где
$$c_{R_l} (k_i, R_i) \equiv \mbox{~if~} (R_i = R_l ) \wedge ((k_i, R_i)
\mbox{~\footnotesize еще не вытеснен к моменту $l$'го обращения}$$
$$) \wedge \bigwedge_{j=i+1}^{l} (R_j \neq R_l \vee k_j \neq k_i) \mbox{~then~}
1 \mbox{~else~} 0 \mbox{~endif}$$
где $n$ --- количество обращений к таблице, $w$ --- значение параметра таблицы \texttt{lines}, $k_1, ..., k_n$ --- ключи обращений в эту таблицу, $R_1, ..., R_n$ --- регионы обращений в эту таблицу.
\end{enumerate}

Алгоритм 2.2 включает в себя шаг по генерации ограничений <<$(k_n, R_n)$~\textbf{не} вытеснен к моменту этого обращения>> и <<$(k_n, R_n)$~вытеснен к моменту этого обращения>>. Эти ограничения имеют непосредственное отношение к стратегии вытеснения таблицы. Задача построения таких ограничений до сих пор в литературе не рассматривалась. Решению этой задачи посвящен раздел 2.5.

В этом же разделе диссертации сформулированы и доказаны теоремы корректности и полноты алгоритмов 2.1 и 2.2 (из которых очевидным образом следует корректность и полнота основного алгоритма):

\begin{theorem}[Корректность алгоритма генерации ограничений на ключи обращений для таблицы, стратегия вытеснения которой не \texttt{none}]\label{mirror_correctness}
\CorrectnessMirror
\end{theorem}

Стратегию вытеснения будем называть \emph{существенно вытесняющей}, если $w$ промахов в один регион полностью вытесняют его предыдущее содержимое ($w$ --- значение параметра \texttt{lines} таблицы).

\begin{theorem}[Полнота алгоритма генерации ограничений на ключи обращений для таблицы, стратегия вытеснения которой не \texttt{none} и является \textbf{существенно вытесняющей}]\label{mirror_fullness}
\FullnessMirror
\end{theorem}

Алгоритм 3 состоит в следующем: для каждого обращения с load($d_n$) с ключом $k_n$ и регионом $R_n$ составить ограничения ($d_1$, ..., $d_{n-1}$ --- последовательность переменных-параметров у предыдущих load, store, replace в том же порядке,что и соответствующие операторы \texttt{hit} и \texttt{miss}, load идет перед store в случае, если они оба указаны в \texttt{hit}) $P_{n-1} = \mbox{~true}$, где
$$P_{l-1} \equiv (\mbox{if~} (k_l||R_l = k_{l-1}||R_{l-1}) \mbox{~then~} d_l =
d_{l-1} \mbox{~else~} P_{l-2} \mbox{~endif}), \mbox{для всех}~l = 2, 3, ... n$$
$$P_0 \equiv \mbox{~true}$$

В разделе 2.3.2 рассматриваются \emph{таблицы вытеснения} --- формальной модели стратегии вытеснения, предложенной в 2008 году в Университете Саарланда. С использованием таблиц вытеснения в разделе 2.3.3 сформулированы и доказаны теоремы о том, что стратегии вытеснения LRU, FIFO и Pseudo-LRU являются существенно вытесняющими:
\begin{theorem}\label{thm:LRU_essential}
Стратегия вытеснения LRU является существенно вытесняющей.
\end{theorem}

\begin{theorem}
  Стратегия вытеснения FIFO является существенно вытесняющей.
\end{theorem}

\begin{theorem}\label{thm:PseudoLRU_essential} \PseudoLRUEssential \end{theorem}

В этом же разделе исследуется вопрос длины инициализирующей последовательности (шаг 1 алгоритм 2.2). Сформулирована и доказана верхняя оценка количества инициализирующих обращений в блок:
\begin{utv}[Верхняя оценка количества инициализирующих обращений]
$$m \leqslant n \cdot (n + 2w)$$ где $w$ --- значение параметра \texttt{lines} таблицы, $n$ --- количество обращений в таблицу в шаблоне.
\end{utv}

Для стратегии вытеснения LRU в этом же разделе сформулирована и доказана более сильная оценка количества инициализирующих обращений в блок:
\begin{theorem}[Верхняя оценка количества инициализирующих обращений для
стратегии вытеснения \LRU]\label{thm_mirror_lenth_lru} \UpperBoundLRUMirror
\end{theorem}

Раздел 2.4 посвящен исследованию стратегии вытеснения Pseudo-LRU. В нем формализовано определение этой стратегии вытеснения для произвольной ассоциативности (а не только ассоциативности 4 или 8, для которых приводятся определения в литературе) и предложено новое определение. С использованием нового определения в следующем разделе будет показано применение предложенного там метода построения ограничений. В том же разделе сформулирована и доказана теорема, по сути показывающая эквивалентность этих двух определений:
\begin{theorem}[Инвариантность преобразования \PseudoLRU-ветвей относительными
позициями]\label{thm_pseudoLRU_invariant} \PseudoLRUInvariant
\end{theorem}

В разделе 2.5 предложен метод построения ограничений для свойства <<быть вытесненным к моменту заданного обращения в таблицу>> --- \emph{метод функций полезности}. С помощью него это свойство выражается в виде ограничений в теориях битовых строк и целочисленной линейной арифметики. В разделе предложена формализация понятия \emph{полезной для вытеснения} (или просто, \emph{полезной}) инструкции. Функция полезности --- это характеристическая функция свойства инструкции быть полезной. Поэтому свойство <<быть вытесненным>> рассматривается как ограничение снизу суммы функций полезности (количества полезных инструкций).

В разделе 2.5.1 предложено и формально обосновано представление свойства <<быть вытесненным>> для стратегии вытеснения LRU в виде ограничений, составленное по методу функций полезности:
\begin{theorem}[Выражение свойства <<быть вытесненным>> для \LRU]\label{correct_mirror_LRU} \LRUusefuls
\end{theorem}

В разделе 2.5.2 предложено и формально обосновано представление свойства <<быть вытесненным>> для стратегии вытеснения FIFO  в виде ограничений, составленное по методу функций полезности (генерируются те же ограничения, что и для LRU).

В разделе 2.5.3 предложено и формально обосновано представление свойства <<быть вытесненным>> для стратегии вытеснения Pseudo-LRU в виде ограничений, составленное по методу функций полезности:
\begin{theorem}[Выражение свойства <<быть вытесненным>> для \PseudoLRU]\label{correct_mirror_PLRU} \PLRUusefuls

$\pi_i$ --- позиции --- дополнительные переменные, для которых надо построить ограничения:
конъюнкцию для каждой пары $(s_i,\pi_i)$ и $(s_j, \pi_j)$ при $j > i$ ограничений:
\begin{itemize}
    \item если $j$'я инструкция --- попадание, то $(\pi_i||R(s_i) =
\pi_j||R(s_j)~\wedge$ $$\pi_i||R(s_i) \notin \{\pi_{m_1}||R(s_{m_1}),
\pi_{m_2}||R(s_{m_2}), \dots, \pi_{m_n}||R(s_{m_n})\}) \rightarrow s_i = s_j$$
    \item если $j$'я инструкция --- промах, то $(\pi_i||R(s_i) =
\pi_j||R(s_j)~\wedge$ $$\pi_i||R(s_i) \notin \{\pi_{m_1}||R(s_{m_1}),
\pi_{m_2}||R(s_{m_2}), \dots, \pi_{m_n}||R(s_{m_n})\}) \rightarrow s_i \neq
s_j$$
\end{itemize}
где $(\pi_{m_1},R(s_{m_1})), (\pi_{m_2},R(s_{m_2})), \dots,
(\pi_{m_n},R(s_{m_n}))$ --- позиции и регионы\\инструкций-промахов,
расположенных между $i$'й и $j$'й инструкциями.
\end{theorem}

В разделе 2.5.4 освещаются некоторые вопросы сложности разрешения ограничений, которые строятся согласно методу функций полезности.


В разделе 2.6 рассматривается последний этап построения тестовой программы --- этап конструирования текста программы. Текст состоит инициализирующей части и инструкций тестового шаблона. В инициализирующей части надо сконструировать инструкции для помещения вычисленных начальных значений в соответствующие регистры и последовательности инструкций, обращающихся в отдельные блоки по вычисленным адресам с вычисленными данными. Во многих случаях конструирование обращений в отдельные блоки не представляет сложности. Но в некоторых случаях микропроцессором не предусмотрены инструкции для обращений в блоки по отдельности. Один из таких примеров --- инициализация многоуровневой кэш-памяти в случае, когда инициализацию отдельных уровней кэш-памяти нельзя осуществить отдельно от остальных уровней. В разделе предложен метод конструирования последовательности инициализирующих инструкций, учитывающий особенности многоуровневой кэш-памяти. Метод заключается в построении дополнительных адресов, по которым надо обратиться в кэш-память первого уровня для обеспечения отсутствия в нем данных, при обращении к которым (из-за этого) будет задействована кэш-память второго уровня.

\paragraph{В третьей главе} анализируется применимость предлагаемых в диссертации методов формализации к существующим микропроцессорам некоторых распространенных архитектур (MIPS, PowerPC, IA-32), описывается реализация и проводится сравнение с существующими инструментами (MicroTESK, Genesys-Pro). В разделах 3.1, 3.2 и 3.3 показывается, что подсистемы управления памяти микропроцессоров архитектур MIPS, PowerPC и IA-32 можно представить в виде набора таблиц и формализовать варианты инструкций, оперирующих с памятью. Причем имеется документация по каждой архитектуре, где эти варианты уже описаны с использованием псевдокода. В разделе 3.4 описаны <<деятельности>>, составляющие систему генерации тестовых программ, приведены количественные характеристики компонентов реализации для модельного микропроцессора архитектуры MIPS64. Затронут вопрос переиспользования компонентов при смене микропроцессора. В разделе 3.5 описаны эксперименты по оценке времени построения тестовых программ и вероятности успешного построения за 60 секунд. Эксперименты показали увеличение допустимого размера тестовых шаблонов до 9-12 инструкций (по сравнению с 2-3 инструкциями в имеющихся технологиях). В разделе 3.6 проведено сравнение с инструментом Genesys-Pro: выделены сходства и отличия, преимущества и недостатки предложенных методов по сравнению с Genesys-Pro.

\paragraph{В Заключении} диссертационной работы перечисляются ее основные результаты.

% ----------------------------------------------------------------

\section*{Основные результаты работы}
\begin{enumerate}
  \item	Предложен подход к построению тестовых программ для проверки подсистем управления памяти микропроцессоров на основе построения и решения систем уравнений.

  \item Предложены модель блоков памяти, описывающая его структурные и функциональные характеристики, и модель инструкций, описывающая отдельные пути их выполнения в виде утверждений о свойствах параметров инструкций и свойств наличия или отсутствия данных в блоках.

  \item В рамках предложенного подхода разработаны и формально обоснованы методы построения уравнений, выражающих с использованием битовых операций свойства наличия или отсутствия данных в блоках памяти; свойства вытеснения.

  \item Создан прототип системы построения тестовых программ для проверки подсистем управления памяти и проведены эксперименты, показывающие эффективность разработанных методов.
\end{enumerate}


% ----------------------------------------------------------------
\renewcommand\bibsection{\section*{Публикации по теме диссертации}}
%\section*{Публикации по теме диссертации}
\bibliographystyle{gost780s}
\bibliography{../delta/thesis}
% ----------------------------------------------------------------

\end{document}


%%%
%% формулировка результатов
%%%