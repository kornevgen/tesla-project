% !Mode:: "TeX:UTF-8"
\documentclass[14pt,autoref,href
%,fixint=false
,facsimile
]{disser}

\usepackage{cmap}
\usepackage[a4paper, nohead, includefoot, mag=1000,
            margin=2cm, top=1.5cm, bottom=1.5cm, footskip=1cm]{geometry}
%\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenx}
\usepackage[english,russian]{babel}
\usepackage{tabularx}
%\usepackage{epstopdf}
\usepackage{amsthm}
\usepackage{xspace}
\usepackage{ifthen}

% Поддержка нескольких списков литературы в одном документе
%\usepackage{multibib}
% Создание команд для цитирования собственных работ диссертанта
% в отдельном разделе. В данном случае ссылка будет иметь вид \citemy{...}.
%\newcites{my}{Список публикаций}

\newtheorem{utv}{Утверждение}
\newtheorem{theorem}{Теорема}
\newtheorem{assumption}{Предположение}
%\newtheorem{heuristics}{Эвристика}
\newtheorem{definition}{Определение}{\bfseries}{\itshape}
%% Путь к файлам с иллюстрациями
%\graphicspath{{fig/}}

% Теперь "русифицируем" окружение enumerate:
\makeatletter
\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
\def\labelenumii{\theenumii)}    % а не латинские буквы
\def\p@enumii{\theenumi}         % а это для \ref
\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
\let\theenumiii\relax            % и отдельных ссылок на него не будет
\def\p@enumiii{\theenumi\theenumii}
\makeatother


% Включение файла с общим текстом диссертации и автореферата
% (текст титульного листа и характеристика работы).
\input{common}

\include{../delta/theorems}
\include{../delta/intro11}

\newcommand{\LRU}{LRU\xspace}
\newcommand{\FIFO}{FIFO\xspace}
\newcommand{\PseudoLRU}{Pseudo-LRU\xspace}


% --------------------------------------------------------------------------
\begin{document}

% Внешняя сторона обложки
\title{АВТОРЕФЕРАТ\\
диссертации на соискание ученой степени\\
кандидата физико-математических наук}

\maketitle

% Внутренняя сторона обложки
\noindent
Работа выполнена на кафедре системного программирования факультета вычислительной математики и кибернетики Московского государственного университета имени М. В. Ломоносова.
\vskip1ex
\noindent\begin{tabularx}{\linewidth}{lp{0.3cm}X}
Научный руководитель:  & & \emph{доктор физико-математических наук}, \\
                       & & \emph{профессор} \\
                       & & \emph{\textbf{Петренко Александр Константинович}}.
\\
Официальные оппоненты: & & \emph{доктор физико-математических наук}, \\
                       & & \emph{профессор} \\
                       & & \emph{\textbf{Смелянский Руслан Леонидович}};\\
                       & & \emph{доктор физико-математических наук}, \\
                       & & \emph{профессор} \\
                       & & \emph{\textbf{Лацис Алексей Оттович}}.
\\
Ведущая организация:   & & \emph{Научно-исследовательский институт системных исследований РАН}\\
\end{tabularx}

\vskip2ex\noindent
Защита состоится %<<\underline{15}>> \underline{октября} 2010 года в \underline{11} часов
15 октября 2010 года в 11 часов
на заседании диссертационного совета \emph{Д 501.001.44} \emph{Московского
государственного университета имени М.В. Ломоносова} по адресу:
\emph{119991, ГСП-1, Москва, Ленинские горы, МГУ имени М.В.Ломоносова, 2-й учебный корпус, факультет ВМК, ауд. 685.}

\vskip1ex\noindent
С диссертацией можно ознакомиться в библиотеке
\emph{факультета ВМК МГУ}.
С текстом автореферата можно ознакомиться на официальном сайте ВМК МГУ \underline{http://cs.msu.ru} в разделе <<Наука>> --- <<Работа диссертационных советов>> --- <<Д 501.001.44>>

\vskip1ex\noindent
Автореферат разослан <<\underline{15}>> \underline{сентября} 2010 г.
%\vskip2ex\noindent
%Отзывы и замечания по автореферату в двух экземплярах, заверенные печатью, просьба высылать по вышеуказанному адресу на имя ученого секретаря диссертационного совета.

\vfill\noindent
Ученый секретарь\\
диссертационного совета\\
\emph{профессор}
\hfill
\makeatletter
% вставка файла, содержащего факсимиле ученого секретаря
%\ifDis@facsimile
%  \raisebox{-4pt}{\includegraphics[width=3cm]{sec-facsimile}}\hfill
%\fi%
\makeatother%
\emph{Н.П. Трифонов}

\clearpage

\section*{Общая характеристика работы}

\subsection*{Актуальность темы}
\newcommand{\nocites}{}
\Actuality

\subsection*{Цель диссертационной работы}
\Objective

\subsection*{Научная новизна}
\Novelty

\subsection*{Практическая значимость}
\PracticalValue

% Результаты и положения, выносимые на защиту
%\resultssection
%\resultstext

% Апробация работы
%\approbationsection
%\approbationtext

\subsection*{Апробация работы и публикации}
\Pub

% Личный вклад автора
%\contribsection
%\contribtext

\subsection*{Структура и объем диссертации}
\Structure


%
% -----------------------------------------------------------------------
%


\section*{Содержание работы}

\paragraph{Во Введении} обоснована актуальность диссертационной работы,
сформулирована цель и задачи исследований, сформулированы полученные результаты и показана их
практическая значимость.

%
% -----------------------------------------------------------------------
%


\paragraph{Первая глава} содержит обзор существующих методов построения тестовых программ, обзор подсистем управления памяти и уточнение задач исследования по результатам этих обзоров.

В разделе 1.1 дается схема системного тестирования микропроцессора, описываются его отдельные этапы, в том числе и этап построения тестовых программ. Рассматриваются псевдослучайные и целенаправленные методы автоматического построения тестовых программ. В разделе 1.2 кратко описываются функции и типичный состав подсистем управления памяти, способы повышения их эффективности и классы ошибок. В разделе 1.3 сделан обзор целенаправленных методов построения тестовых программ. Выделены методы с явным нацеливанием на тестовую ситуацию и без него (методы типа <<итерация-фильтрация>>). В разделе 1.4 сделан анализ целенаправленных методов построения тестовых программ по применимости к подсистемам управления памяти, масштабируемости, возможности нацеливания на функциональность. Наиболее перспективными оказались методы с явным нацеливанием на ситуации в виде \emph{тестовых шаблонов} --- цепочек инструкций с указанием требований на выполнение каждой инструкции --- и методы, включающие разрешение ограничений (constraint satisfaction). В разделе 1.5 уточнены задачи в соответствии с проведенным исследованием целенаправленных методов.

\paragraph{Во второй главе} предложен подход целенаправленного построения нацеленных тестовых программ, сочетающий особенности перспективных методов построения тестовых программ. В разделе 2.1 описаны этапы построения тестовых программ согласно предлагаемому подходу: чтение документации по архитектуре, формализация архитектуры, выделение и формализация тестовых ситуаций (в виде шаблонов тестовых программ, далее \emph{тестовых шаблонов}), построение и решение системы ограничений для каждого тестового шаблона, конструирование текста тестовой программы на основе решения каждой совместной системы ограничений.

Тестовый шаблон содержит последовательность инструкций, для каждой из которых указан вариант исполнения (т.е. некоторый путь выполнения инструкции). Для алгоритмического построения ограничений и затем тестовых программ варианта инструкций должны быть формализованы в рамках этапа формализации микропроцессора. Раздел 2.2 более детально освещает этот этап . В этом разделе предложены модель функционирования устройств подсистемы управления памяти и модель вариантов инструкций. В рамках этого этапа следует выделить и формализовать те варианты инструкций, которые входят в тестовый шаблон, и задействованные в них устройства подсистемы управления памяти. Моделью состояния устройства подсистемы управления памяти (кэш-памяти, таблицы страниц и т.п.) предлагается последовательность ассоциативных массивов. Каждый массив состоит из \emph{строк}, каждая строка состоит из набора \emph{полей}, поля делятся на \emph{поля ключа} и \emph{поля данных}. Поля ключа задают ключи в ассоциативном массиве, поля данных --- значения. В модели устройства определены следующие операции: успешного обращения, успешного обращения с изменением, неуспешного обращения с замещением. На входе операции успешного обращения --- выражение, задающие ключ, и выражение, задающее номер ассоциативного массива из состояния устройства. Операция определена на тех входных данных и состоянии модели, при которых в соответствующем ассоциативном массиве есть строка, поля ключей которой \emph{соответствуют} аргументу-ключу этой операции. Операция возвращает поля данных соответствующей аргументу-ключу строки. Операция успешного обращения с изменением отличается от операции успешного обращения дополнительным аргументом --- полями данных, которые нужно заменить в строке, соответствующей аргументу-ключу. На входе операции  неуспешного обращения с замещением 3 аргумента: выражение, задающие ключ, выражение, задающее номер ассоциативного массива, и выражения для полей данных строки. Операция определена на тех входных данных и состоянии модели, при которых в соответствующем ассоциативном массиве нет строки, поля ключей которой \emph{соответствуют} аргументу-ключу этой операции. Эффект операции заключается в замене полей данных одной из строк в ассоциативном массиве, номер которого был передан в качестве одного из аргументов операции, на переданные операции поля данных. Выбор строки для замены определяется на основе стратегии вытеснения так же, как это делается в устройствах подсистемы управления памяти (например, в кэш-памяти). В рамках этапа формализации следует указать набор атрибутов, задающих модели устройств тестируемой подсистемы управления памяти: стратегия вытеснения, количество строк в массиве (<<ассоциативность>>), двоичный логарифм количества массивов, имена и битовые длины полей ключа и полей данных, предикат соответствия строки некоторой битовой строке (эта строка является аргументом-ключом в операциях над моделью). Алгоритмы построения систем ограничений параметризованы этими атрибутами. Таким образом моделируются кэш-память различных уровней, таблицы страниц, буферы трансляции адресов (TLB) и даже оперативная память.

В том же разделе предложены модели вариантов инструкций. Варианты инструкций соответствуют отдельным путям выполнения инструкций. Модель варианта инструкции формализует следующие виды требований: допустимые значения операндов инструкции, вычисление значений операндов-результатов инструкции, условия возникновения исключительных ситуаций (если вариант инструкции состоит в возникновении такой ситуации), вычисление адресов (физических, виртуальных, эффективных) в инструкции, обращения в устройства подсистемы управления памяти и успешность этих обращений, какие данные загружаются или сохраняются. При формализации для варианта инструкции объявляются операнды инструкции и последовательность операторов 4-х видов: оператор утверждения истинности свойства над битовыми строками (\texttt{assume}), оператор введения новой переменной (\texttt{let}), оператор попадания (\texttt{hit}), оператор промаха (\texttt{miss}). С помощью этой последовательности операторов задается набор условий на значения операндов инструкции и для моделей устройств, задействованных в этом варианте инструкции, условия на их состояние и изменение этого состояния в рамках данного варианта. Операторы \texttt{let} и \texttt{assume} имеют ту же семантику, которая используется при формализации императивных языков программирования. Операторы \texttt{hit} и \texttt{miss} специфичны инструкциям, оперирующим с памятью. Оператор попадания \texttt{hit<B>(k;R)\{loaded(d); [storing(d');] \}}, где \texttt{k, R, d, d'} --- выражения над определенными ранее переменными-битовыми строками, означает, что в данном варианте инструкции должно осуществляться успешное обращение в устройство \texttt{B} по ключу \texttt{k} в массив с номером \texttt{R}, причем ключу соответствуют данные \texttt{d} (если полей данных несколько, то соответствующие выражения для них перечисляются в скобках у \texttt{loaded}). Если указана секция \texttt{storing}, то в варианте инструкции должно осуществляться успешное обращение с изменением на поля данных \texttt{d'}. Оператор промаха \texttt{miss<B>(k;R)\{[replacing(d);]\}}, где \texttt{k, R, d, d'} --- выражения над определенными ранее переменными-битовыми строками, означает, что в данном варианте инструкции должно быть неуспешноеобращение в блок \texttt{B} по ключу \texttt{k} в массив с номером \texttt{R}. Секция \texttt{replacing} задает поля данных \texttt{d'} вытесняющей строки. Если секция \texttt{replacing} отсутствует, изменение состояния устройства \texttt{B} не должно происходить.

Формализовав устройства подсистемы управления памяти и инструкции и составив тестовый шаблон, нужно определить те значения регистров и состояние устройств, при которых исполнение инструкций, указанных в тестовом шаблоне, будет проходить согласно указанным там вариантам инструкций. Для этого составляется система ограничений, выражающая все необходимые условия таких значений. В результате разрешения этой системы определяются искомые значения. В разделе 2.3 описывается предлагаемый алгоритм построения ограничений для тестового шаблона. Несмотря на то, что в действительности исполнение последовательностей инструкций происходит с использованием механизмов распараллеливания,  --------------тут про последовательность----------- Алгоритм состоит из следующих шагов:
\begin{enumerate}
    \item объединить операторы из моделей вариантов инструкций в порядке их упоминания в тестовом шаблоне в одну последовательность операторов;
    \item разделить полученную последовательность операторов на
подпоследовательности:
            \begin{itemize}
                \item одна подпоследовательность включает все операторы \texttt{assume} и \texttt{let};
                \item каждая другая подпоследовательность включает все операторы
\texttt{hit} и \texttt{miss} в какую-нибудь одну таблицу;
            \end{itemize}
    \item транслировать операторы \texttt{assume} и \texttt{let} без изменений в
ограничения на битовые строки;
    \item объявить переменные для аргументов инструкций и полей строк в
операторах \texttt{hit} и \texttt{miss};
    \item для каждой построенной последовательности операторов \texttt{hit} и \texttt{miss} выполнить
            \begin{enumerate}
                \item алгоритм генерации ограничений на ключи обращений: если стратегия вытеснения таблицы, чья последовательность операторов транслируется,  есть \texttt{none}, использовать <<алгоритм 2.1>>, иначе использовать <<алгоритм 2.2>>;
                \item алгоритм генерации ограничений на загружаемые/сохраняемые
данные (<<алгоритм 3>>).
            \end{enumerate}
\end{enumerate}

Алгоритм последовательно строит ограничения для операторов, составляющих модели вариантов инструкций тестового шаблона. Операторы \texttt{assume} и \texttt{let} транслируются непосредственно. Для трансляции операторов \texttt{hit} и \texttt{miss} в разделе предложены алгоритмы 2.1, 2.2 и 3. Алгоритмы 2.1 и 2.2 отвечают за трансляцию свойств наличия (hit) и отсутствия (miss) ключей в таблице. Истинность таких свойств зависит от истории обращений в таблицу по ключам (т.е. от предыдущих инструкций).

Алгоритм 2.1 состоит из следующих шагов ($k_1, ..., k_n$ --- ключи операторов \texttt{hit}, $R_1, ..., R_n$ --- номера <<наборов>> (\emph{регионы}) этих обращений; $w$ --- значение параметра таблицы \texttt{lines}):

\begin{enumerate}
    \item для каждого \texttt{miss($k; R$)}, $k$ --- ключ обращения, $R$ --- регион
обращения, составить ограничение: $(k||R) \notin \{(k_1||R_1), ..., (k_n||R_n)
\}$

    \item если $n > w$, то составить
ограничение (<<в регионе не может быть больше различных строк, чем \texttt{lines}>>):
$\bigwedge_{l=1}^n \sum_{i=1}^l c_{R_l} (k_i, R_i) \leqslant w$, где
$$c_r (k_i, R_i) \equiv \mbox{~if~} (R_i = r ) \wedge \bigwedge_{j=1}^{i-1} (R_j
\neq r \vee k_j \neq k_i) \mbox{~then~} 1 \mbox{~else~} 0 \mbox{~endif}$$
\end{enumerate}

Алгоритм 2.2 состоит из следующих шагов:
\begin{enumerate}
    \item выбрать длину инициализирующей последовательности $m$;
    \item объявить переменные ключей инициализирующей последовательности $t_1,
t_2, ..., t_m$ и их регионов $r_1, r_2, ..., r_m$;
    \item составить ограничение <<все разные $(t_1||r_1), (t_2||r_2), ...,
(t_m||r_m)$>> (<<||>> -- операция битовой конкатенации);
    \item составить ограничение для каждого \texttt{hit($k_n;R_n$)}, $k_n$ --- ключ
обращения, $R_n$ --- регион обращения:
$$\left\{\begin{array}{l}
    (k_n||R_n) \in \{(t_1||r_1), (t_2||r_2), ..., (t_m||r_m), (k_1||R_1), ...,
(k_{n-1}||R_{n-1}) \}\\
    (k_n, R_n)~\mbox{\textbf{не} вытеснен к моменту этого обращения}\\
\end{array}\right.$$

где $k_1, ..., k_{n-1}$ --- ключи предыдущих обращений в эту же таблицу,\\ $R_1,
..., R_{n-1}$ --- регионы предыдущих обращений в эту же таблицу;

    \item составить ограничение для каждого \texttt{miss($k_n;R_n$)}, $k_n$ --- ключ
обращения, $R_n$ --- регион обращения:
$$\left\{\begin{array}{l}
    (k_n||R_n) \in \{(t_1||r_1), (t_2||r_2), ..., (t_m||r_m), (k_1||R_1), ...,
(k_{n-1}||R_{n-1}) \}\\
    (k_n, R_n)~\mbox{вытеснен к моменту этого обращения}\\
\end{array}\right.$$

где $k_1, ..., k_{n-1}$ --- ключи предыдущих обращений в эту же таблицу,\\ $R_1,
..., R_{n-1}$ --- регионы предыдущих обращений в эту же таблицу;

    \item если $n > w$, то составить
ограничение (<<в регионе не может быть больше различных строк, чем \texttt{lines}>>):
$\bigwedge_{l=1}^n \sum_{i=1}^l c_{R_l} (k_i, R_i) \leqslant w$, где
$$c_{R_l} (k_i, R_i) \equiv \mbox{~if~} (R_i = R_l ) \wedge ((k_i, R_i)
\mbox{~\footnotesize еще не вытеснен к моменту $l$'го обращения}$$
$$) \wedge \bigwedge_{j=i+1}^{l} (R_j \neq R_l \vee k_j \neq k_i) \mbox{~then~}
1 \mbox{~else~} 0 \mbox{~endif}$$
где $n$ --- количество обращений к таблице, $w$ --- значение параметра таблицы \texttt{lines}, $k_1, ..., k_n$ --- ключи обращений в эту таблицу, $R_1, ..., R_n$ --- регионы обращений в эту таблицу.
\end{enumerate}

Алгоритм 2.2 включает в себя шаг по генерации ограничений <<$(k_n, R_n)$~\textbf{не} вытеснен к моменту этого обращения>> и <<$(k_n, R_n)$~вытеснен к моменту этого обращения>>. Эти ограничения имеют непосредственное отношение к стратегии вытеснения таблицы. Задача построения таких ограничений до сих пор в литературе не рассматривалась. Решению этой задачи посвящен раздел 2.5.

В этом же разделе диссертации сформулированы и доказаны теоремы корректности и полноты алгоритмов 2.1 и 2.2 (из которых очевидным образом следует корректность и полнота основного алгоритма):

\begin{theorem}[Корректность алгоритма генерации ограничений на ключи обращений для таблицы, стратегия вытеснения которой не \texttt{none}]\label{mirror_correctness}
\CorrectnessMirror
\end{theorem}

\begin{theorem}[Полнота алгоритма генерации ограничений на ключи обращений для таблицы, стратегия вытеснения которой есть \texttt{none}]\label{mirror_fullness_none}
\FullnessMirrorNone
\end{theorem}

Стратегию вытеснения будем называть \emph{существенно вытесняющей}, если $w$ промахов в один регион полностью вытесняют его предыдущее содержимое ($w$ --- значение параметра \texttt{lines} таблицы).

\begin{theorem}[Полнота алгоритма генерации ограничений на ключи обращений для таблицы, стратегия вытеснения которой не \texttt{none} и является \textbf{существенно вытесняющей}]\label{mirror_fullness}
\FullnessMirror
\end{theorem}

Алгоритм 3 состоит в следующем: для каждого обращения с load($d_n$) с ключом $k_n$ и регионом $R_n$ составить ограничения ($d_1$, ..., $d_{n-1}$ --- последовательность переменных-параметров у предыдущих load, store, replace в том же порядке,что и соответствующие операторы \texttt{hit} и \texttt{miss}, load идет перед store в случае, если они оба указаны в \texttt{hit}) $P_{n-1} = \mbox{~true}$, где
$$P_{l-1} \equiv (\mbox{if~} (k_l||R_l = k_{l-1}||R_{l-1}) \mbox{~then~} d_l =
d_{l-1} \mbox{~else~} P_{l-2} \mbox{~endif}), \mbox{для всех}~l = 2, 3, ... n$$
$$P_0 \equiv \mbox{~true}$$

В разделе 2.3.2 рассматриваются \emph{таблицы вытеснения} --- формальной модели стратегии вытеснения, предложенной в 2008 году в Университете Саарланда. С использованием таблиц вытеснения в разделе 2.3.3 сформулированы и доказаны теоремы о том, что стратегии вытеснения LRU, FIFO и Pseudo-LRU являются существенно вытесняющими:
\begin{theorem}\label{thm:LRU_essential}
Стратегия вытеснения LRU является существенно вытесняющей.
\end{theorem}

\begin{theorem}
  Стратегия вытеснения FIFO является существенно вытесняющей.
\end{theorem}

\begin{theorem}\label{thm:PseudoLRU_essential} \PseudoLRUEssential \end{theorem}

В этом же разделе исследуется вопрос длины инициализирующей последовательности (шаг 1 алгоритм 2.2). Сформулирована и доказана верхняя оценка количества инициализирующих обращений в блок:
\begin{utv}[Верхняя оценка количества инициализирующих обращений]
$$m \leqslant n \cdot (n + 2w)$$ где $w$ --- значение параметра \texttt{lines} таблицы, $n$ --- количество обращений в таблицу в шаблоне.
\end{utv}

Для стратегии вытеснения LRU в этом же разделе сформулирована и доказана более сильная оценка количества инициализирующих обращений в блок:
\begin{theorem}[Верхняя оценка количества инициализирующих обращений для
стратегии вытеснения \LRU]\label{thm_mirror_lenth_lru} \UpperBoundLRUMirror
\end{theorem}

Раздел 2.4 посвящен исследованию стратегии вытеснения Pseudo-LRU. В нем формализовано определение этой стратегии вытеснения для произвольной ассоциативности (а не только ассоциативности 4 или 8, для которых приводятся определения в литературе) и предложено новое определение. С использованием нового определения в следующем разделе будет показано применение предложенного там метода построения ограничений. В том же разделе сформулирована и доказана теорема, по сути показывающая эквивалентность этих двух определений:
\begin{theorem}[Инвариантность преобразования \PseudoLRU-ветвей относительными
позициями]\label{thm_pseudoLRU_invariant} \PseudoLRUInvariant
\end{theorem}

В разделе 2.5 предложен метод построения ограничений для свойства <<быть вытесненным к моменту заданного обращения в таблицу>> --- \emph{метод функций полезности}. С помощью него это свойство выражается в виде ограничений в теориях битовых строк и целочисленной линейной арифметики. В разделе предложена формализация понятия \emph{полезной для вытеснения} (или просто, \emph{полезной}) инструкции. Функция полезности --- это характеристическая функция свойства инструкции быть полезной. Поэтому свойство <<быть вытесненным>> рассматривается как ограничение снизу суммы функций полезности (количества полезных инструкций).

В разделе 2.5.1 предложено и формально обосновано представление свойства <<быть вытесненным>> для стратегии вытеснения LRU в виде ограничений, составленное по методу функций полезности:
\begin{theorem}[Выражение свойства <<быть вытесненным>> для \LRU]\label{correct_mirror_LRU} \LRUusefuls
\end{theorem}

В разделе 2.5.2 предложено и формально обосновано представление свойства <<быть вытесненным>> для стратегии вытеснения FIFO  в виде ограничений, составленное по методу функций полезности (генерируются те же ограничения, что и для LRU).

В разделе 2.5.3 предложено и формально обосновано представление свойства <<быть вытесненным>> для стратегии вытеснения Pseudo-LRU в виде ограничений, составленное по методу функций полезности:
\begin{theorem}[Выражение свойства <<быть вытесненным>> для \PseudoLRU]\label{correct_mirror_PLRU} \PLRUusefuls

$\pi_i$ --- позиции --- дополнительные переменные, для которых надо построить ограничения:
конъюнкцию для каждой пары $(s_i,\pi_i)$ и $(s_j, \pi_j)$ при $j > i$ ограничений:
\begin{itemize}
    \item если $j$'я инструкция --- попадание, то $(\pi_i||R(s_i) =
\pi_j||R(s_j)~\wedge$ $$\pi_i||R(s_i) \notin \{\pi_{m_1}||R(s_{m_1}),
\pi_{m_2}||R(s_{m_2}), \dots, \pi_{m_n}||R(s_{m_n})\}) \rightarrow s_i = s_j$$
    \item если $j$'я инструкция --- промах, то $(\pi_i||R(s_i) =
\pi_j||R(s_j)~\wedge$ $$\pi_i||R(s_i) \notin \{\pi_{m_1}||R(s_{m_1}),
\pi_{m_2}||R(s_{m_2}), \dots, \pi_{m_n}||R(s_{m_n})\}) \rightarrow s_i \neq
s_j$$
\end{itemize}
где $(\pi_{m_1},R(s_{m_1})), (\pi_{m_2},R(s_{m_2})), \dots,
(\pi_{m_n},R(s_{m_n}))$ --- позиции и регионы\\инструкций-промахов,
расположенных между $i$'й и $j$'й инструкциями.
\end{theorem}

В разделе 2.5.4 освещаются некоторые вопросы сложности разрешения ограничений, которые строятся согласно методу функций полезности.


В разделе 2.6 рассматривается последний этап построения тестовой программы --- этап конструирования текста программы. Текст состоит инициализирующей части и инструкций тестового шаблона. В инициализирующей части надо сконструировать инструкции для помещения вычисленных начальных значений в соответствующие регистры и последовательности инструкций, обращающихся в отдельные блоки по вычисленным адресам с вычисленными данными. Во многих случаях конструирование обращений в отдельные блоки не представляет сложности. Но в некоторых случаях микропроцессором не предусмотрены инструкции для обращений в блоки по отдельности. Один из таких примеров --- инициализация многоуровневой кэш-памяти в случае, когда инициализацию отдельных уровней кэш-памяти нельзя осуществить отдельно от остальных уровней. В разделе предложен метод конструирования последовательности инициализирующих инструкций, учитывающий особенности многоуровневой кэш-памяти. Метод заключается в построении дополнительных адресов, по которым надо обратиться в кэш-память первого уровня для обеспечения отсутствия в нем данных, при обращении к которым (из-за этого) будет задействована кэш-память второго уровня.

\paragraph{В третьей главе} анализируется применимость предлагаемых в диссертации методов формализации к существующим микропроцессорам некоторых распространенных архитектур (MIPS, PowerPC, IA-32), описывается реализация и проводится сравнение с существующими инструментами (MicroTESK, Genesys-Pro). В разделах 3.1, 3.2 и 3.3 показывается, что подсистемы управления памяти микропроцессоров архитектур MIPS, PowerPC и IA-32 можно представить в виде набора таблиц и формализовать варианты инструкций, оперирующих с памятью. Причем имеется документация по каждой архитектуре, где эти варианты уже описаны с использованием псевдокода. В разделе 3.4 описаны <<деятельности>>, составляющие систему генерации тестовых программ, приведены количественные характеристики компонентов реализации для модельного микропроцессора архитектуры MIPS64. Затронут вопрос переиспользования компонентов при смене микропроцессора. В разделе 3.5 описаны эксперименты по оценке времени построения тестовых программ и вероятности успешного построения за 60 секунд. Эксперименты показали увеличение допустимого размера тестовых шаблонов до 9-12 инструкций (по сравнению с 2-3 инструкциями в имеющихся технологиях). В разделе 3.6 проведено сравнение с инструментом Genesys-Pro (IBM): выделены сходства и отличия, преимущества и недостатки предложенных методов по сравнению с Genesys-Pro. В разделе 3.7 проведено сравнение с работами, проводящимися в Intel.

\paragraph{В Заключении} диссертационной работы перечисляются ее основные результаты.

% ----------------------------------------------------------------

\section*{Основные результаты работы}
\begin{enumerate}
  \item	Предложен подход к построению тестовых программ для проверки подсистем управления памяти микропроцессоров на основе построения и решения систем уравнений.

  \item Предложены модель блоков памяти, описывающая его структурные и функциональные характеристики, и модель инструкций, описывающая отдельные пути их выполнения в виде утверждений о свойствах параметров инструкций и свойств наличия или отсутствия данных в блоках.

  \item В рамках предложенного подхода разработаны и формально обоснованы методы построения уравнений, выражающих с использованием битовых операций свойства наличия или отсутствия данных в блоках памяти; свойства вытеснения.

  \item Создан прототип системы построения тестовых программ для проверки подсистем управления памяти и проведены эксперименты, показывающие эффективность разработанных методов.
\end{enumerate}


% ----------------------------------------------------------------
\renewcommand\bibsection{\section*{Публикации по теме диссертации}}
%\section*{Публикации по теме диссертации}
\bibliographystyle{gost780s}
\bibliography{../delta/thesis}
% ----------------------------------------------------------------

\end{document}


%%%
%% формулировка результатов
%%%