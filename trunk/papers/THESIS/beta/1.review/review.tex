\chapter{Обзорная глава, постановка задачи}

\section{Обзор методов генерации тестовых программ}

Тестирование микропроцессоров является важной составляющей частью
процесса их разработки. Тестированию может подвергаться как готовый
чип, так и модель. Тестирование может проводиться как на модульном,
так и на системном уровне. В данной работе речь идет о системном
функциональном тестировании. Иными словами, целью тестирования
является проверка правильности функционирования микропроцессора
целиком. Эта проверка выполняется путем запуска на микропроцессоре
специальных машинных программ (далее такие программы будут
называться \emph{тестовыми}).

Системное функциональное тестирование включает в себя следующие
этапы~\cite{kamkin}:
\begin{enumerate}
\item определение целей тестирования, тестового покрытия и тестовых
ситуаций (структурные -- какие инструкции включать в тестирование --
и функциональные -- как инструкции должны быть исполнены);
\item генерация тестовых программ для тестовых ситуаций;
\item исполнение тестовых программ на микропроцессоре, получение
выходных данных (трасса исполнения, финальные значения регистров);
\item вынесение вердикта на основе анализа выходных данных.
\end{enumerate}

Данная работа посвящена этапу генерации тестовых программ. В
настоящее время в практике системного функционального тестирования
микропроцессоров можно выделить следующие подходы к построению
тестовых программ:
\begin{itemize}
\item \emph{ручная разработка тестовых программ} хоть и практически неприменима
для полного тестирования микропроцессора, всё же может применяться
для тестирования особых, крайних случаев;
\item \emph{тестирование с использованием кросс-компиляции} применяется часто
из-за невысокой сложности его проведения: после согласования
спецификации микропроцессора можно начинать делать кросс-компилятор,
а код, предназначенный для кросс-компиляции, уже готов. Однако
гарантировать полноту такое тестирование не может;
\item \emph{случайная генерация тестовых программ} применяется так же часто в
силу простоты автоматизации. Сгенерированные таким образом тестовые
программы позволяют быстро обнаружить простые ошибки, однако не
гарантируют полноты тестирования. Разрабатываются и более сложные
варианты случайной генерации~\cite{muGP};
\item \emph{генерация тестовых программ на основе тестовых
шаблонов} предполагает разделение процесса генерации тестовой
программы на два этапа: на первом на основе тестовых ситуаций
подготавливаются тестовые шаблоны -- абстрактные представления
тестовых программ -- а на втором этапе по тестовым шаблонам
генерируются тестовые программы.
\end{itemize}

Тестовые шаблоны могут описывать следующие свойства тестовых
программ:
\begin{itemize}
\item заданная последовательность инструкций (только коды операций или
коды операций с аргументами);
\item заданная последовательность типов инструкций;
\item выборка инструкций заданных типов;
\item аргументы инструкций (регистры, непосредственные
значения, переменные величины);
\item дополнительные ограничения на инструкции;
\item дополнительные ограничения на отдельные аргументы инструкций,
аргументы разных инструкций;
\item дополнительные функциональные ограничения на инструкции (при
исполнении должны произойти некоторые заданные события).
\end{itemize}

Выделяют следующие подзадачи при генерации тестовых программ по
тестовым шаблонам (подзадачи могут решаться по
отдельности~\cite{kamkin} или итеративно для каждой очередной
выделяемой инструкции~\cite{GenesysPro}):
\begin{enumerate}
  \item выбор последовательности инструкций / выбор очередной
  инструкции;
  \item выбор аргументов (не значений, а имен аргументов!) инструкций /
  выбор аргументов очередной инструкции;
  \item построение инициализации микропроцессора для выполнения
  тестовых ситуаций.
\end{enumerate}

Работа посвящена исследованию методов построения инициализации
микропроцессора. Исследователями предложены следующие классы методов
решения этой задачи:
\begin{enumerate}
\item ручная генерация тестовых программ;
\item комбинаторные методы;
\item использование методов генерации входных векторов (ATPG~\cite{ATPGbook});
\item использование методов разрешения ограничений.
\end{enumerate}

\subsection{Ручная генерация тестовых программ}

Александром Камкиным разработана технология системного
функционального тестирования микропроцессоров с использованием
тестовых шаблонов~\cite{kamkin}. Построение тестовых шаблонов
осуществляется полуавтоматически на основе тестового покрытия по
модели системы инструкций микропроцессора. Тестовые шаблоны
представляют из себя последовательность инструкций с зависимостями
между аргументами (например, <<запись-чтение>>) и тестовыми
ситуациями для инструкций.

Для получения тестовых программ по сгенерированным тестовым шаблонам
следует реализовать на языке Java \emph{конструкторы тестовых
данных}. Под <<тестовыми данными>> понимаются значения регистров,
аргументы инструкций обращения к памяти для инициализации состояния
кэш-памяти и ячеек оперативной памяти, если это требуется. Все
зависимости в тестовом шаблоне обладают направлением,
конструирование аргументов инструкций производится итеративно от
инструкций, которые не зависят от остальных инструкций, к
инструкциям, которые зависят от уже сгенерированных инструкций. Для
выбора независимых значений используется случайная генерация.

%//плюсы: возможность сгенерировать специальные крайние программы,
%минусы: сложно добиться хорошего покрытия при большом количестве
%зависимостей, потому как для этого надо писать нетривиальные
%конструкторы

\subsection{Комбинаторные методы генерации тестовых программ}

Тестовый шаблон состоит из заданной последовательности инструкций,
аргументами которых являются переменные величины. Кроме того для
каждой переменной величины указывается конечная область значений.
Все значения в области равноправны. Тестовая программа содержит ту
же последовательность инструкций, а для каждого аргумента выбрано
значение из области значений этого аргумента. В комбинаторных
методах инструкции воспринимаются лишь как синтаксические объекты
(термы) -- у них есть лишь имя и аргументы (возможно
типизированные).

Последовательность инструкций может быть задана неявно, но у каждой
инструкции всё же будут переменные величины в качестве аргументов и
для каждой переменной величины задана область значений.
Исследователи из Fujitsu Lab.~\cite{TSE} предлагается описать
последовательность инструкций в виде выражений (Test Specification
Expressions, TSE), а семантику инструкций -- на языке
ISDL~\cite{ISDL}. Отдаленно TSE могут напоминать регулярные
выражения, где бесконечнозначные операции заменены конечными
аналогами. ISDL-описание может включать в том числе и параметры
исполнения инструкции на конвейере, которые могут быть использованы
в TSE. Авторы исследования реализовали специальный генератор,
который строит тестовые программы, удовлетворяющие данному TSE.

Kohno и Matsumoto~\cite{mVpGen} рассматривают задачу верификации
конвейерных микропроцессоров, используя для этого генерацию тестовых
программ с помощью тестовых шаблонов. Тестовый шаблон явно содержит
последовательность типов инструкций, возможно, с использованием
конструкций итерирования блоков инструкций. Использование разными
инструкциями в шаблоне одной и той же переменной величины должно
приводить в тестовой программе к использованию одного и того же
значения для этой переменной величины. Областями значений являются
заданное в архитектуре множество регистров ($GPR$ -- множество
регистров общего назначения, $CPR$ -- множество регистров
сопроцессора).

%// плюсы:простота, минусы: низкое покрытие

\subsection{Генерация тестовых программ с использованием методов
решения задачи ATPG}

Задача ATPG (Automatic Test Pattern Generation)~\cite{ATPGbook}
относится к вопросам модульного тестирования микропроцессоров.
Модульное тестирование осуществляется подачей определенных сигналов
(возможно, многотактовых) на входы модуля (схемы) и снятие значения
выходных сигналов (возможно, также многотактовых). Принятие вердикта
осуществляется на основе сравнения ожидаемого выходного сигнала и
снимаемого с данной схемы. Тестовым воздействием является сигнал,
поданный на входные порты схемы. Моделью ошибки является смена
функции некоторых элементов схемы (например, в результате пробоя или
замыкания элемент может сменить функцию, которую он реализует, на
тождественную константу). ATPG -- это задача построения тестовых
воздействий для схем, нацеленных на данную модель ошибки. Аргументы
инструкций являются входными сигналами некоторых модулей
микропроцессора, поэтому решая задачу генерации входных сигналов,
можно решать и задачу генерации тестовых программ.

Эту идею использовали исследователи из Politecnico di
Milano~\cite{toATPG}. Тестовым шаблоном выступает
препроцессированная модель этапа декодирования инструкции. Модель
написана на языке VHDL~\cite{VHDL}. Специальный генератор
подставляет на место кода инструкции заданные значения кодов
операций и передает получившуюся модель стороннему (коммерческому)
ATPG-инструменту. Тот в свою очередь возвращает остальные значения,
которые надо передать в модуль декодирования инструкции, т.е.
значения аргументов инструкции. Метод был применен к тестированию
АЛУ VLIW-микропроцессора.

%//плюсы:позволяет нацеливаться на покрытие по RTL-модели, минусы:
%нужна RTL-модель, небольшая длина тестового шаблона

\subsection{Генерация тестовых программ с использованием методов
разрешения ограничений}

Под \emph{ограничением} будет пониматься предикат, в котором
переменные принимают значения из конечной области. Например, $x >
0$, если $x \in \{0, 10, 100\}$. Задачей разрешения ограничений
(constraint satisfaction problem) является задача поиска значений
для переменных из их областей значений, при которых все ограничения
выполнены~\cite{CSP}. Для областей значений небольшого размера
достаточно перебрать все комбинации значений переменных, пока не
встретится комбинация, на которой выполнены все ограничения. В общем
случае применяются более сложные алгоритмы (зачастую с привлечением
эвристик), сочетающие перебор с возвратом и распространение
ограничений (т.е. автоматический вывод ограничений-следствий по
данной системе ограничений).

Представление в виде CSP удобно для задач, сформулированных в виде
задачи выполнимости некоторого набора условий. Задача генерации
тестовых программ по тестовым шаблонам тоже может быть
сформулирована в таком виде, поскольку есть связанный набор
переменных (инструкций, аргументов инструкций, элементов состояния
микропроцессора), причем связи выражаются в виде утверждений,
зависимостей. Сама идея построения тестовой программы через
формулирование тестового шаблона близка решению задачи с
использованием CSP, поскольку этап построения тестового шаблона
(формализации требований к тестовому воздействию) по сути является
этапом формулирования задачи построения тестового шаблона в виде
утверждений, в виде задачи выполнимости. Остается только перевести
эту формулировку к виду, используемому в инструментах для решения
CSP. Выбор инструментов, метод их решения, а также вида самих
ограничений, зависит от того, какие применяются тестовые шаблоны и
как описывается семантика инструкций.

С целью упрощения подготовки нужного представления семантики
микропроцессора китайские исследователи в своем инструменте
MAATG~\cite{MAATG} предложили использовать хорошо известный язык
описания архитектуры EXPRESSION~\cite{EXPRESSION}. Тестовые шаблоны
позволяют явно задавать блоки инструкций, задавать ограничения на
аргументы разных инструкций (одинаковые регистры, разные регистры,
непосредственные значения из некоторого множества констант), а также
указывать события, которые могут произойти при исполнении инструкции
(например, целочисленное переполнение для инструкции ADD).
Специальный генератор строит тестовую программу итеративно. Сначала
он упорядочивает инструкции так, чтобы переменные для очередной
инструкции зависели только от переменных предыдущих инструкций. Это
позволяет разбить задачу генерации тестовой программы на
последовательность более простых задач генерации одной инструкции.
Однако по доступным публикациям невозможно сделать вывод о том,
какие ограничения генерирует MAATG и тем самым оценить эффективность
работы этого инструмента.

Еще одно семейство инструментов генерации тестовых программ на
основе тестовых шаблонов было разработано в IBM в течение последних
20 лет. Далее будет дано описание последнего на сегодняшний день
инструмента в этом семействе -- Genesys-Pro~\cite{GenesysPro2004}.
Тестовые шаблоны этого инструмента позволяют описывать как заданные
последовательности инструкций, так и всевозможные их композиции.
Разработчиками предложен несложный императивный язык, позволяющий
задать эту последовательность инструкций.

Для каждой инструкции могут быть указаны ограничения на аргументов
пожелания к значениям аргументов инструкции для улучшения тестового
покрытия (эта информация называется testing
knowledge)~\cite{GenesysTK}. Эти пожелания (по сути особенности
семантики инструкций и тестовые ситуации) предлагается описывать с
использованием ограничений~\cite{GenesysPro2004Innovations}. Можно
задавать ограничения на атрибуты аргументов инструкции (например,
значение одного аргумента больше значения другого) и состояние
микропроцессора (например, на значения в таблицах и буферах). Для
описания механизма трансляции адресов (получения физического адреса
по виртуальному) предлагается использовать подход
DeepTrans~\cite{DeepTrans}. В этом подходе предлагается пользователю
описать структуру строки таблицы, через которую осуществляется
трансляция, правило соответствия адреса строке, некоторые другие
преобразования, а специальный генератор автоматически построит
нужную систему ограничений для использования в Genesys-Pro.

Тестовый шаблон может содержать параметры работы генератора тестовых
программ: вероятности выбора тех или иных значений, параметры
распределения адресов в памяти и другие -- они позволяют управлять
выбором некоторого одного значения из множества допустимых.

Требуется описать структуру системы команд (architecture model),
задать исполнительную семантику команд (по сути симулятор
микропроцессора).

Рассмотрим теперь, как Genesys-Pro генерирует тестовые программы на
основе тестовых шаблонов. Для б\'{о}льшей эффективности этапы
построения последовательности инструкций и выбора аргументов
осуществляются вместе (отдельная инициализация состояния
микропроцессора не проводится). На основе параметров генерации,
текущего состояния модели микропроцессора и построенной тестовой
программы выбирается очередная инструкция (тестовые шаблоны
позволяют описывать сложные потоки управления на инструкциях). Далее
для этой инструкции генерируются аргументы инструкций. Для этого
строится и разрешается система ограничений на основе тестовых
ситуаций (testing knowledge) и текущего модельного состояния
микропроцессора), в результате чего получаются значения аргументов.
Готовая инструкция исполняется на модели микропроцессора
(architecture model, он готовится пользователем) с получением нового
модельного состояния микропроцессора. На этом генерация инструкции
завершается и генерируется следующая инструкция. Ключевым моментом
является эффективность работы решателя ограничений. Для этой цели
разработчики инструмента самостоятельно написали свой решатель
ограничений. Он базируется на хорошо известном семействе алгоритмов
разрешения ограничений MAC (Maintaining Arc-Consistency)~\cite{CSP},
но заточен под ограничения, генерируемые для тестовых
программ~\cite{GenesysSolver}. Написание такого решателя является
довольно нетривиальной задачей и предметом отдельного исследования.
Например, Genesys-Pro позволяет использовать для описания тестовых
ситуаций элементы массивов (Memory, таблицы страниц) с переменными
индексами.

Тем самым ни один из методов генерации тестовых программ,
использующих ограничения, не нацеливается на строго заданную
последовательность инструкций, однако потребности в использовании
тестовых шаблонов с заданной последовательностью инструкций
отмечаются исследователями~\cite{kamkin}.

%//плюсы: масштабируемость, технологичность; минусы: сложность
%внесения нового архитектурного механизма

\subsection{Сравнение методов генерации тестовых программ}

%%%Сравнение проводилось по следующим критериям:
%%%\begin{enumerate}
%%%\item выразительная мощность тестовых шаблонов;
%%%\item допустимые архитектурые механизмы;
%%%\item сложность подготовки исходных данных;
%%%\item переиспользуемость частей генератора тестовых программ;
%%%\item вычислительная эффективность генератора тестовых программ.
%%%\end{enumerate}
%%%
%%%\subsubsection{Выразительная мощность тестовых шаблонов}
%%%\noindent {\small
%%%\begin{tabular}{|l|c|c|c|c|}
%%%\hline &
%%%\begin{tabular}{c}ручная\\генерация\end{tabular} &
%%%\begin{tabular}{c}комбина-\\торные\\методы\end{tabular} &
%%%\begin{tabular}{c}использование\\ATPG\end{tabular} &
%%%\begin{tabular}{c}использование\\CSP\end{tabular} \\
%%%\hline
%%%\begin{tabular}{l}возможность\\задать\\последовательность\\инструкций \end{tabular} &
%%%+ & + & -- & + \\
%%%\hline
%%%\begin{tabular}{l}возможность\\задать\\тестовую\\ситуацию \end{tabular} &
%%%+ & -- & -- & + \\
%%%\hline
%%%\begin{tabular}{l}возможность\\задействовать\\состояние\\микропроцессора \end{tabular} &
%%%+ & -- & + & + \\
%%%\hline
%%%\end{tabular}}
%%%
%%%//нужен комментарий, почему заполнение такое?
%%%
%%%\subsubsection{Допустимые архитектурные механизмы}
%%%\noindent {\small \begin{tabular}{|l|c|c|c|c|} \hline &
%%%\begin{tabular}{c}ручная\\генерация\end{tabular} &
%%%\begin{tabular}{c}комбинаторные\\методы\end{tabular} &
%%%\begin{tabular}{c}использование\\ATPG\end{tabular} &
%%%\begin{tabular}{c}использование\\CSP\end{tabular} \\
%%%\hline
%%%\begin{tabular}{l}поддержка\\регистров\\общего\\назначения \end{tabular} &
%%%+ & + & -- & + \\
%%%\hline
%%%\begin{tabular}{l}поддержка\\кэш-памяти и \\трансляции\\адресов \end{tabular} &
%%%+ & -- & -- & + \\
%%%\hline
%%%\begin{tabular}{l}поддержка\\механизмов\\параллелизма \end{tabular} &
%%%+ & + & -- & + \\
%%%\hline
%%%\end{tabular}}
%%%
%%%//нужен комментарий, почему заполнение такое?
%%%
%%%\subsubsection{Сложность подготовки исходных данных}
%%%\noindent{\small
%%%\begin{tabular}{|l|c|c|c|c|}
%%%\hline &
%%%\begin{tabular}{c}ручная\\генерация\end{tabular} &
%%%\begin{tabular}{c}комбинаторные\\методы\end{tabular} &
%%%\begin{tabular}{c}использо-\\вание\\ATPG\end{tabular} &
%%%\begin{tabular}{c}использование\\CSP\end{tabular} \\
%%%\hline
%%%\begin{tabular}{l}при смене\\тестового\\шаблона \end{tabular} &
%%%сложно & \begin{tabular}{c}сложно\\(нужна\\RTL-модель)\end{tabular} & -- & несложно \\
%%%\hline
%%%\begin{tabular}{l}при смене\\микро-\\процессора \end{tabular} &
%%%\begin{tabular}{c}долго, но\\технологично\end{tabular} &
%%%\begin{tabular}{c}долго\\вплоть до\\невозможности\end{tabular} &
%%%просто & \begin{tabular}{c}небыстро\\(новые\\механизмы)\end{tabular} \\
%%%\hline
%%%\end{tabular}}
%%%
%%%//нужен комментарий, почему заполнение такое?
%%%
%%%\subsubsection{Переиспользуемость частей генератора тестовых
%%%программ} \noindent{\small
%%%\begin{tabular}{|l|c|c|c|c|}
%%%\hline &
%%%\begin{tabular}{c}ручная\\генерация\end{tabular} &
%%%\begin{tabular}{c}комбинаторные\\методы\end{tabular} &
%%%\begin{tabular}{c}использование\\ATPG\end{tabular} &
%%%\begin{tabular}{c}использование\\CSP\end{tabular} \\
%%%\hline
%%%\begin{tabular}{l}при смене\\тестового\\шаблона \end{tabular} &
%%%никакая & полная & полная & полная \\
%%%\hline
%%%\begin{tabular}{l}при смене\\микро-\\процессора \end{tabular} &
%%%никакая & полная &
%%%полная & \begin{tabular}{c}только\\общие\\механизмы\end{tabular} \\
%%%\hline
%%%\end{tabular}}
%%%
%%%//нужен комментарий, почему заполнение такое?
%%%
%%%\subsubsection{Вычислительная эффективность генератора тестовых
%%%программ}
%%%
%%%\noindent {\small
%%%\begin{tabular}{|l|c|c|c|c|}
%%%\hline &
%%%\begin{tabular}{c}ручная\\генерация\end{tabular} &
%%%\begin{tabular}{c}комбина-\\торные\\методы\end{tabular} &
%%%\begin{tabular}{c}использо-\\вание\\ATPG\end{tabular} &
%%%\begin{tabular}{c}использо-\\вание\\CSP\end{tabular} \\
%%%\hline
%%%\begin{tabular}{l}сложность\\достижения\\покрытия \end{tabular} &
%%%\begin{tabular}{c}сложно\\(можно достичь\\крайние случаи)\end{tabular} &
%%%\begin{tabular}{c}сложно\\(не задается\\семантика)\end{tabular} &
%%%\begin{tabular}{c}возможно\\покрытие\\структуры\\RTL-модели\end{tabular} &
%%%несложно \\
%%%\hline
%%%\begin{tabular}{l}среднее время\\генерации\\программ \end{tabular} &
%%%долго & быстро &
%%%\begin{tabular}{c}зависит от\\сложности\\RTL-модели\end{tabular} &
%%%недолго \\
%%%\hline
%%%\begin{tabular}{l}эффективность\\учёта начального\\состояния\\микропроцессора\end{tabular} &
%%%сложно & \begin{tabular}{c}не\\учитывается\end{tabular} &
%%%\begin{tabular}{c}не\\учитывается\end{tabular} &
%%%возможно \\
%%%\hline
%%%\end{tabular}}
%%%
%%%//нужен комментарий, почему заполнение такое?

Сравнение проводилось по следующим критериям:
\begin{enumerate}
\item сложность построения генератора тестовых программ;
\item допустимые архитектурые механизмы;
\item полнота метода.
\end{enumerate}

Из сделанного обзора следует, что возможность генерирования тестовых
программ для тестовых шаблонов, ориентированных на поведение MMU
(тестовые ситуации в кэширующих буферах и таблицах MMU), т.е.
поддержку механизмов кэширования в MMU, есть у следующих методов:
\begin{itemize}
  \item ручное написание генераторов тестовых
  программ~\cite{kamkin};
  \item вероятностные алгоритмы генерации тестовых программ (как разновидность
  -- примитивные переборные алгоритмы);
  \item покомандный перебор с возвратом на основе разрешения
  ограничений~\cite{GenesysPro}.
\end{itemize}

\begin{table}[h]\small
\begin{tabular}{|c||c|c|}\hline
 & полный & неполный\\
\hline \hline
простой & & \begin{tabular}{c}переборный алгоритм\\
примитивный вероятностный \end{tabular} \\
\hline
сложный & \begin{tabular}{c}вручную написанный генератор\\
хитрый вероятностный\\покомандный перебор с возвратом
 \end{tabular} & --- \\ \hline
\end{tabular}

\end{table}

Использование простых переборных или вероятностных алгоритмов
генерации тестовых программ позволяют подготовить генератор на
основе нехитрых идей, однако они не позволяют добиться хорошей
полноты. Это означает, что для произвольного тестового шаблона время
генерации тестовой программы может быть очень велико.

Напротив более хитрые варианты вероятностных (переборных)
алгоритмов, написанные вручную генераторы или генераторы, основанные
на более регулярных алгоритмах (например, покомандный перебор с
возвратом, реализованный в системе Genesys-Pro~\cite{GenesysPro})
нацелены на получение высокой полноты. Однако достигается это в
основном за счет разработки и применения уникальных идей, которые
сложно использовать вновь при тестировании другого микропроцессора.
Это усложняет написание таких генераторов и, как результат,
увеличивает время подготовки самого генератора.

Тем самым представляется перспективным исследование и разработка
регулярных легко переиспользуемых методов построения генераторов
тестовых программ по тестовым шаблонам, применимых для тестирования
механизмов кэширования, не уступающих в полноте существующим
методам.



\section{Постановка задачи}

В диссертации решается задача построения тестовых программ по
тестовым шаблонам, обладающим следующими свойствами. Тестовый шаблон
представляется последовательностью троек $(I_i, A_i, S_i)$, где
$I_i$ -- заданная инструкция, $A_i$ -- список аргументов инструкции,
$S_i$ -- тестовая ситуация инструкции. Аргументами являются явно
заданные регистры и переменные, не меняющие своего значения (в
тестовой программе они станут непосредственными значениями).
Тестовая ситуация инструкции -- это ограничение на аргументы
инструкции и текущее состояние микропроцессора. Примеры тестовых
ситуаций: <<при исполнении инструкции должно произойти целочисленное
переполнение (это ограничение только на аргументы инструкции)>>,
<<при исполнении инструкции должно произойти кэш-попадание в
кэш-памяти первого уровня>> (это ограничение не только на аргументы
инструкции, но и на состояние микропроцессора перед ее исполнением,
поскольку кэш-память является подсистемой микропроцессора). Кроме
тестового шаблона задано начальное состояние модели микропроцессора.
Состояние модели микропроцессора включает в себя состояние всех его
подсистем. Например, состоянием регистра является значение, которое
в нем хранится. Состоянием кэш-памяти является его содержимое.

Требуется построить тестовую программу по тестовому
шаблону~\cite{my_isp_2009, my_programmirovanie_2009}, которая
состоит из двух частей: инициализирующие инструкции и инструкции
тестового воздействия (см.рис.~\ref{problem}). Инициализирующие
инструкции переводят модель микропроцессора из заданного начального
состояния в состояние, необходимое для тестового воздействия.
Инструкции тестового воздействия в точности повторяют
последовательность инструкций тестового шаблона с заменой переменных
на непосредственные значения. На рисунке~\ref{test_template_exmp}
приведен пример тестового шаблона и возможных инструкций тестового
воздействия, построенных по этому шаблону.

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{1.review/problem}\\
  \caption{Составление тестовой программы}\label{problem}
\end{figure}

\begin{figure}[h]
\quad\parbox{0.5\textwidth}{\small \tt
AND r1, r2, r3 @ normal\\
LD r4, r2, c1 @ l1Hit\\
SUB r3, r1, r5 @ overflow } \parbox{0.3\textwidth}{\small \tt
AND r1, r2, r3\\
LD r4, r2, 0x0FA2\\
SUB r3, r1, r5
}
\caption{Тестовый шаблон и возможные соответствующие ему инструкции
тестового воздействия}\label{test_template_exmp}
\end{figure}


Уже сгенерированная программа может быть позднее дополнена
инструкциями проверки состояния микропроцессора после исполнения
инструкций тестового воздействия.

Инициализирующие инструкции призваны подготовить модель
микропроцессора к исполнению инструкций тестового воздействия. Без
инициализирующих инструкций запуск инструкций тестового воздействия
даже на корректной модели микропроцессора может приводить к ложным
сообщениям об ошибках в модели. В работе рассматривается модель
микропроцессора, включающая в себя регистры общего назначения,
кэш-память (возможно многоуровневую) и буфер трансляции адресов
(TLB, Translation Lookaside Buffer)~\cite{HennesyPatterson}. Таким
образом, инициализирующие инструкции могут включать инструкции
изменения значений регистров и ячеек кэш-памяти и TLB.

В данной работе среди методов генерации тестовых программ выбран
метод, использующий разрешение ограничений (CSP). Однако по
сравнению с существующими аналогами в данной работе поставлена
задача исследовать возможности снижения сложности подготовки
генератора тестовых программ (по сравнению, например, с мощным
Genesys-Pro), не проиграв сильно в масштабируемости генератора. При
этом, возможно, придется выделить среди всевозможных архитектурных
механизмов наиболее часто использующиеся и требующие тестирование в
современных микропроцессорах.


\section{Предварительные сведения и термины}

%Дополнительные сведения, необходимые для дальнейшего прочтения.

\subsection{Типы кэш-памяти}

По организации кэш-память делят на \emph{полностью ассоциативную},
\emph{прямого доступа} и \emph{наборно-ассоциативную}. Различие
производится на основе двух параметров: количества секций $W$ и
количества наборов $R$. Кэш-память хранит некоторый набор данных.
Каждому блоку данных соответствует некоторый адрес (физический или
виртуальный). Блоки с адресами организованы в \emph{секции} и
\emph{наборы} (см.рис.~\ref{cache_model}).

\begin{figure}[h] \center
  \includegraphics[width=0.7\textwidth]{1.review/cache}\\
  \caption{Модель кэш-памяти и адреса данных}\label{cache_model}
\end{figure}

Каждый адрес может быть разделен на два битовых поля: поле
\emph{тега адреса} и поле \emph{сет адреса}. Один набор составляют
адреса с одинаковым сетом. Кэш-память организована таким образом,
что для каждого сета хранится всегда одно и то же количество адресов
(равное количеству секций $W$). Адреса всех данных в кэш-памяти
различные. Отсюда следует, что теги адресов одного набора разные. В
кэш-памяти представлены все наборы, возможные в рамках битового поля
сета адреса.

Кэш-память является полностью ассоциативной, если $R = 1$.
Кэш-память является кэш-памятью прямого доступа, если $W = 1$. И
кэш-память является наборно-ассоциативной, если $R > 1$ и $W > 1$.

Инструкции обращения в память бывают двух видов: инструкции загрузки
данных из памяти по данному адресу и инструкции сохранения данных в
памяти по данному адресу. При выполнении этих инструкций может быть
задействована кэш-память. Если данные по требуемому адресу
присутствуют в кэш-памяти, операция проводится с нею. Такая ситуация
называется \emph{кэш-попаданием}. Если данные по требуемому адресу
не присутствуют в кэш-памяти, осуществляется подгрузка данных в
кэш-память и совершение операции. Такая ситуация называется
\emph{кэш-промахом}. В этом случае если кэш-память полностью
заполнена, некоторые данные должны быть \emph{вытеснены} из
кэш-памяти и на их место будут загружены данные по требуемому
адресу. \emph{Стратегия вытеснения} (или \emph{политика замещения})
-- это правило, по которому определяются вытесняемые данные.
Например, могут быть вытеснены данные, которые дольше всего не были
нужны (такая стратегия называется \LRU), или данные, которые были
внесены в кэш-память раньше остальных (такая стратегия называется
\FIFO).

\subsection{Таблицы вытеснения}

Для возможности формальных рассуждений о стратегиях вытеснения
потребуется более явное определение стратегии вытеснения нежели
просто <<правило определения вытесняемого тега>>. Для этого
воспользуемся \emph{таблицами вытеснения} (\emph{policy table}). Они
были предложены в 2008 году исследователями из немецкого
университета Саарланда~\cite{policy_tables}. Таблица вытеснения
однозначно описывает изменение порядка и вытеснение тегов в наборе.
Таблица представляет собой матрицу $(w{+}1) \times (w{+}1)$, где $w$
--- ассоциативность кэширующего буфера. Первый столбец ---
специальный, он содержит указание позиций от 0 до $w{-}1$ и
специальную <<псевдопозицию>> для промаха. Остальными элементами
матрицы являются числа от 0 до $w{-}1$ и специальный символ $m$ для
вытесняющего тега. Пример таблицы вытеснения (для стратегии
вытеснения \LRU) смотрите на рисунке~\ref{PolicyTableLRU8}.

\begin{figure}[h]
$$ \left[
     \begin{array}{c|cccccccc}
       \pi_0 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_1 & 1 & 0 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_2 & 2 & 0 & 1 & 3 & 4 & 5 & 6 & 7 \\
       \pi_3 & 3 & 0 & 1 & 2 & 4 & 5 & 6 & 7 \\
       \pi_4 & 4 & 0 & 1 & 2 & 3 & 5 & 6 & 7 \\
       \pi_5 & 5 & 0 & 1 & 2 & 3 & 4 & 6 & 7 \\
       \pi_6 & 6 & 0 & 1 & 2 & 3 & 4 & 5 & 7 \\
       \pi_7 & 7 & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
       \pi_m & m & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
     \end{array}
   \right]
$$
\caption{Таблица вытеснения для стратегии вытеснения \LRU,
8-ассоциативный кэширующий буфер}\label{PolicyTableLRU8}
\end{figure}

Первые строки таблицы вытеснения описывают изменение порядка
элементов набора при кэш-попаданиях. Каждой такой строке
соответствует свой случай кэш-попадания, при этом первый столбец
показывает, тег с какой позицией дает кэш-попадание, а части строк,
не включающие первый столбец, показывают, каким образом
осуществляется перестановка тегов набор из последовательности
индексов (0 1 ... $w{-}1$). Например, для стратегии вытеснения \LRU,
представленной на рисунке~\ref{PolicyTableLRU8}, при кэш-попадании
тега 5 к набору (4 6 5 7 1 0 2 3) будет применена перестановка
(смотрим строку с $\pi_2$, потому что тег 5 находится на втором
месте) (2 0 1 3 4 5 6 7), что даст следующий порядок элементов
набора: (5 4 6 7 1 0 2 3).

Последняя строка таблицы вытеснения соответствует ситуации
кэш-промаха. Вытесняющий элемент набора помечается буквой $m$.
Вытесняемый элемент -- элемент набора (0 1 ... $w{-}1$), который
отсутствует в последней строке таблицы вытеснения (в примере -- это
7, т.е. вытесняется последний элемент, а вытесняющий помещается на
нулевое место).

Приведем таблицы вытеснений для других двух стратегий вытеснения:
\FIFO и \MRU (таблица вытеснения для \PseudoLRU приведена ниже):
\begin{figure}[h] \centering
\parbox{0.4\textwidth}{
$$ \left[
     \begin{array}{c|cccccccc}
       \pi_0 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_1 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_2 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_3 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_4 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_5 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_6 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_7 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_m & m & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
     \end{array}
   \right]$$
\caption{Таблица вытеснения для стратегии вытеснения \FIFO,
8-ассоциативный кэширующий буфер} }
\qquad
\parbox{0.4\textwidth}{
$$ \left[
     \begin{array}{c|cccccccc}
       \pi_0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 0 \\
       \pi_1 & 0 & 2 & 3 & 4 & 5 & 6 & 7 & 1 \\
       \pi_2 & 0 & 1 & 3 & 4 & 5 & 6 & 7 & 2 \\
       \pi_3 & 0 & 1 & 2 & 4 & 5 & 6 & 7 & 3 \\
       \pi_4 & 0 & 1 & 2 & 3 & 5 & 6 & 7 & 4 \\
       \pi_5 & 0 & 1 & 2 & 3 & 4 & 6 & 7 & 5 \\
       \pi_6 & 0 & 1 & 2 & 3 & 4 & 5 & 7 & 6 \\
       \pi_7 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_m & 0 & 1 & 2 & 3 & 4 & 5 & 6 & m \\
     \end{array}
   \right]$$
\caption{Таблица вытеснения для стратегии вытеснения \MRU,
8-ассоциативный кэширующий буфер} }
\end{figure}





\subsection{Стратегия вытеснения \PseudoLRU}

Стратегия вытеснения \LRU хоть и хорошо приближает поведение
кэширующего буфера к идеальному случаю (когда данные находятся в
буфере в тот момент, когда они нужны), однако все известные на
сегодняшний момент реализации для микропроцессоров требуют большого
количества дополнительной логики. Поэтому производятся поиски
стратегии вытеснения, близкой по эффективности к \LRU, но имеющей
реализацию с меньшими накладными расходами. Эти поиски привели к
стратегии вытеснения \PseudoLRU. Она определяется только для
кэширующих буферов с ассоциативностью, являющейся степенью двойки.
Стратегия вытеснения \PseudoLRU используется во многих
микропроцессорах архитектур PowerPC и
Pentium~\cite{FundamentalOfComputerOrganizationAndDesign}.

\subsubsection{Каноническое определение \PseudoLRU на бинарном дереве}

Следующее описание часто появляется в
литературе~\cite{FundamentalOfComputerOrganizationAndDesign} для
определения стратегии вытеснения \PseudoLRU. Оно формулируется на
упорядоченном бинарном дереве высоты $\log_2 w$, в листьях которого
подряд расположены теги набора (их количество равно $w$).
Вытесняющий тег помещается в дереве на место вытесняемого. Дуга,
идущая влево, помечена цифрой 0, дуга, идущая вправо, помечена
цифрой 1.

При кэш-попадании по некоторому тегу меняются пометки в нелистовых
вершинах пути от корня до соответствующей тегу листовой вершины (см.
рис.~\ref{pseudo_lru_hit}). А именно вершина получает метку
исходящей из нее дуги в пути до соответствующей тегу листовой
вершины. Т.е. если дуга, соответствующая пути, выходит влево,
вершина помечается цифрой 0, если вправо -- 1. Пометки на остальных
вершинах дерева не меняются.

\begin{figure}[h] \center
  \includegraphics[width=0.7\textwidth]{2.theor/plruhit}\\
  \caption{Кэш-попадание для стратегия вытеснения \PseudoLRU
  (16-ассоциативная кэш-память)}\label{pseudo_lru_hit}
\end{figure}

Поиск вытесняемого элемента производится следующим образом: на
основе пометок нелистовых вершин дерева определяется единственный
путь следующим образом: в каждой вершине пути выбирается
направление, противоположное пометке вершины. Если вершина помечена
цифрой 0, значит дуга пути к вытесняемому тегу идет из этой вершины
вправо. Если вершина помечена цифрой 1 -- влево. На место
вытесняемого элемента помещается вытесняющий, битовая строка
меняется так, будто к вытесняющему элементу было обращение с
кэш-попаданием. Пример того, как определяется вытесняемый элемент,
показан на рис.~\ref{pseudo_lru_miss}. Цветом нелистовых вершин
показаны их пометки: черным вершинам соответствует пометка 1, белым
-- 0. В изображенном на рисунке дереве в качестве вытесняемого тега
будет выбран тег D, к которому ведет путь
$\alpha-\beta-\varepsilon$.

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{2.theor/plrumiss}\\
  \caption{Определение вытесняемого элемента для стратегия вытеснения
  Pseudo-LRU (16-ассоциативная кэш-память)}\label{pseudo_lru_miss}
\end{figure}


\subsubsection{Каноническое определение \PseudoLRU на битовой строке}

Для каждого набора хранится битовая строка длины $w-1$, где $w$ --
ассоциативность кэширующего буфера. Каждая инструкция, обращающаяся
к набору, меняет эту битовую строку. Определение вытесняемого
элемента производится на основании только лишь этой битовой строки.

Во многих книгах приводятся следующее определение стратегии
вытеснения \PseudoLRU для случая
$w=4$~\cite{FundamentalOfComputerOrganizationAndDesign} (в этом
случае для каждого набора выделяется 3 бита $B_1$, $B_2$ и $B_3$):
$$ \left[
  \begin{array}{c|ccc}
          & B_1 & B_2 & B_3 \\ \hline
    \pi_0 & 0 & 0 & \textsf{X} \\
    \pi_1 & 0 & 1 & \textsf{X} \\
    \pi_2 & 1 & \textsf{X} & 0 \\
    \pi_3 & 1 & \textsf{X} & 1 \\
  \end{array}
\right]
$$

При кэш-попадании тега, расположенного в секции с номером $i$,
действует $i$'я строка матрицы (она помечена символом $\pi_i$).
Биты, напротив которых в $i$'й строке находится \textsf{X}, не
меняются. Биты, напротив которых в $i$'й строке находится число,
принимают значение, равное этому числу.

При кэш-промахе надо определить номер секции, в которой будут
заменены данные. Для этого используется инвертированная форма той же
матрицы:
$$
\left[
  \begin{array}{ccc|c}
    B_1 & B_2 & B_3 & \\ \hline
    1 & 1 & \textsf{X} & \rightarrow \pi_0 \\
    1 & 0 & \textsf{X} & \rightarrow \pi_1 \\
    0 & \textsf{X} & 1 & \rightarrow \pi_2 \\
    0 & \textsf{X} & 0 & \rightarrow \pi_3 \\
  \end{array}
\right]
$$

Выбирается строка, соответствующая текущему состоянию бит $B_1$,
$B_2$ и $B_3$: если напротив бита в строке находится число, бит
должен быть равен этому числу -- если напротив бита в строке
находится \textsf{X}, то требования на соответствующий бит нет.
Подходящая строка всегда будет существовать и она будет
единственной.

Изменение битовой строки можно демонстрировать на бинарном дереве и
наоборот. Битовая строка составляется из пометок вершин дерева,
начиная с корня и далее по слоям от левых к правым вершинам (см.
рис.~\ref{plru_bittree}).

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{1.review/plru}\\
  \caption{Битовая строка в бинарном дереве}\label{plru_bittree}
\end{figure}

Формализованное описание для всех допустимых $w$ в литературе не
приводится. Однако в дальнейшем для формулирования и доказательства
утверждений про стратегию вытеснения \PseudoLRU такое описание будет
необходимо. Для $w=8$ стратегия будет задаваться следующей матрицей:
$$
\left[
  \begin{array}{c|ccccccc}
          & B_1 & B_2 & B_3 & B_4 & B_5 & B_6 & B_7 \\ \hline
    \pi_0 & 0 & 0 & \textsf{X} & 0 & \textsf{X} & \textsf{X} & \textsf{X} \\
    \pi_1 & 0 & 0 & \textsf{X} & 1 & \textsf{X} & \textsf{X} & \textsf{X} \\
    \pi_2 & 0 & 1 & \textsf{X} & \textsf{X} & 0 & \textsf{X} & \textsf{X} \\
    \pi_3 & 0 & 1 & \textsf{X} & \textsf{X} & 1 & \textsf{X} & \textsf{X} \\
    \pi_4 & 1 & \textsf{X} & 0 & \textsf{X} & \textsf{X} & 0 & \textsf{X} \\
    \pi_5 & 1 & \textsf{X} & 0 & \textsf{X} & \textsf{X} & 1 & \textsf{X} \\
    \pi_6 & 1 & \textsf{X} & 1 & \textsf{X} & \textsf{X} & \textsf{X} & 0 \\
    \pi_7 & 1 & \textsf{X} & 1 & \textsf{X} & \textsf{X} & \textsf{X} & 1 \\
  \end{array}
\right]
$$

Следующее утверждение~\ref{wMinus1PseudoLRU} дает алгоритм
преобразования списка бит\\ $B_1, B_2, ..., B_{w{-}1}$ в результате
кэш-попадания и кэш-промаха. В его формулировке применяется двоичное
разложение. Биты разложения обозначаются последовательностью от
старших бит к младшим (т.е. список ($x_1~x_2~\dots~x_n$) обозначает
число $x_n + 2x_{n-1} + 4x_{n-2} + \dots + 2^n x_1$, $x_i \in \{0,
1\}$ для $i = 1, 2, \dots, n$). Например, 1 = (0 0 1), 6 = (1 1 0).

Везде далее символ $W$ будет обозначать $\log_2 w$. По определению
стратегии вытеснения \PseudoLRU $W$ будет натуральным числом.

\begin{utv}[$(w{-}1)$-представление стратегии вытеснения
\PseudoLRU]\label{wMinus1PseudoLRU}При кэш-попадании тега с позицией
$i = (i_1~i_2~\dots~i_W)$ происходит следующее изменение бит $B_1,
B_2, ..., B_{w{-}1}$:

\parbox{0.3\textwidth}{
  $$ \begin{array}{l}
  B_{k_1} := i_1 \\
  B_{k_2} := i_2 \\
  B_{k_3} := i_3 \\
  ...\\
  B_{k_W} := i_W \\
  \end{array}$$
} \vline
\parbox{0.7\textwidth}{
  $$ \begin{array}{l}
  k_1 = (1) \\
  k_2 = (1~i_1) \\
  k_3 = (1~i_1~i_2) \\
  ...\\
  k_W = (1~i_1~i_2~\dots~i_{W{-}1}) \\
  \end{array} $$
}
\\[1cm]

При кэш-промахе тега позиция $i = (i_1~i_2~\dots~i_W)$ определяется
следующим образом:

\parbox{0.3\textwidth}{
  $$ \begin{array}{l}
  i_1 = \neg B_{k_1} \\
  i_2 = \neg B_{k_2} \\
  i_3 = \neg B_{k_3} \\
  ...\\
  i_W = \neg B_{k_W} \\
  \end{array}$$
} \vline
\parbox{0.7\textwidth}{
  $$ \begin{array}{l}
  k_1 = (1) \\
  k_2 = (1~\neg B_{k_1}) \\
  k_3 = (1~\neg B_{k_1}~\neg B_{k_2}) \\
  ...\\
  k_W = (1~\neg B_{k_1}~\neg B_{k_2}\dots\neg B_{k_{W{-}1}}) \\
  \end{array} $$
}
\\[0.5cm]

Кроме того при кэш-промахе после определения позиции $i$ делается
преобразование бит $B_1, B_2, ..., B_{w{-}1}$ так, как в случае
кэш-попадания на $\pi_i$.
\end{utv}

\subsubsection{Определение \PseudoLRU на ветвях бинарного
дерева}\label{PseudoLRUonBranches}

Здесь будет показано, как из канонического определения \PseudoLRU
получить формулировку \PseudoLRU с точки зрения одного элемента
набора (каноническое определение рассматривает весь набор целиком и
для него формулирует правила работы с последовательностью бит $B_1,
B_2, ..., B_{w{-}1}$). Это определение ранее не встречалось в
литературе.

Сначала этот переход покажем на примере $w=4$. Первый шаг --- это
смена <<состояния>>: вместо последовательности бит $B_1, B_2, ...,
B_{w-1}$ будем рассматривать последовательность векторов бит
$\beta_0, \beta_1, \dots, \beta_{w-1}$ размера $W$. Каждый $\beta_i$
соответствует $i$'й листовой вершине бинарного дерева. Кэш-попадание
меняет теперь не внутренние вершины дерева, а листовые вершины.
Каждый $\beta_i$ будет представляться списком длины $W$ -- путь от
корня дерева к $i$'й листовой вершине: $\beta_0$ соответствует
($B_1$ $B_2$), $\beta_1$ соответствует ($B_1$ $\neg B_2$), $\beta_2$
соответствует ($\neg B_1$ $B_3$) и $\beta_3$ соответствует ($\neg
B_1$ $ \neg
B_3$).\\[0.5cm]

\parbox{0.2\textwidth}{ \centering
  \includegraphics[width=0.2\textwidth]{1.review/btree}
}
\parbox{0.25\textwidth}{
$$ \left[
  \begin{array}{c|ccc}
          & B_1 & B_2 & B_3 \\ \hline
    \pi_0 & 0 & 0 & \textsf{X} \\
    \pi_1 & 0 & 1 & \textsf{X} \\
    \pi_2 & 1 & \textsf{X} & 0 \\
    \pi_3 & 1 & \textsf{X} & 1 \\
  \end{array}
\right]
$$
} $\stackrel{1}{\longrightarrow}$ %\vline
\parbox{0.4\textwidth}{
$$ \left[
  \begin{array}{c|cccc}
          & \beta_0 & \beta_1 & \beta_2 & \beta_3 \\ \hline
    \pi_0 & (0~0) & (0~1) & (1~\textsf{X}) & (1~\textsf{X}) \\
    \pi_1 & (0~1) & (0~0) & (1~\textsf{X}) & (1~\textsf{X}) \\
    \pi_2 & (1~\textsf{X}) & (1~\textsf{X}) & (0~0) & (0~1) \\
    \pi_3 & (1~\textsf{X}) & (1~\textsf{X}) & (0~1) & (0~0) \\
  \end{array}
\right]
$$
}

Заметим, что получилась симметричная матрица. На пересечении $\pi_i$
и $\beta_j$ располагается вектор, задающий изменение вектора в $j$'й
листовой вершине дерева при кэш-попадании $i$'й листовой вершины
дерева. Назовем позицию $i \oplus j$ \emph{относительной позицией}
$i$ относительно $j$. Рассмотрим отдельно каждый столбец
получившейся матрицы и переставим элементы столбца в порядке
увеличения относительных позиций.

\parbox{0.2\textwidth}{
$$ \left[
  \begin{array}{c|c}
          & \beta_0 \\ \hline
    \pi_0 & (0~0) \\
    \pi_1 & (0~1) \\
    \pi_2 & (1~\textsf{X}) \\
    \pi_3 & (1~\textsf{X}) \\
  \end{array}
\right]
$$
}\parbox{0.2\textwidth}{
$$ \left[
  \begin{array}{c|c}
          & \beta_1 \\ \hline
    \pi_0 & (0~1) \\
    \pi_1 & (0~0) \\
    \pi_2 & (1~\textsf{X}) \\
    \pi_3 & (1~\textsf{X}) \\
  \end{array}
\right]
$$
}\parbox{0.2\textwidth}{
$$ \left[
  \begin{array}{c|c}
          & \beta_2 \\ \hline
    \pi_0 & (1~\textsf{X}) \\
    \pi_1 & (1~\textsf{X}) \\
    \pi_2 & (0~0) \\
    \pi_3 & (0~1) \\
  \end{array}
\right]
$$
}\parbox{0.2\textwidth}{
$$ \left[
  \begin{array}{c|c}
          & \beta_3 \\ \hline
    \pi_0 & (1~\textsf{X}) \\
    \pi_1 & (1~\textsf{X}) \\
    \pi_2 & (0~1) \\
    \pi_3 & (0~0) \\
  \end{array}
\right]
$$
} $\stackrel{2}{\stackrel{\longrightarrow}{\pi^i_j \equiv \pi_{i
\oplus j}}}$

\parbox{0.24\textwidth}{
$$ \left[
  \begin{array}{c|c}
          & \beta_0 \\ \hline
    \pi^0_0 \equiv \pi_0 & (0~0) \\
    \pi^0_1 \equiv \pi_1 & (0~1) \\
    \pi^0_2 \equiv \pi_2 & (1~\textsf{X}) \\
    \pi^0_3 \equiv \pi_3 & (1~\textsf{X}) \\
  \end{array}
\right]
$$
}\parbox{0.24\textwidth}{
$$ \left[
  \begin{array}{c|c}
          & \beta_1 \\ \hline
    \pi^1_0 \equiv \pi_1 & (0~0) \\
    \pi^1_1 \equiv \pi_0 & (0~1) \\
    \pi^1_2 \equiv \pi_3 & (1~\textsf{X}) \\
    \pi^1_3 \equiv \pi_2 & (1~\textsf{X}) \\
  \end{array}
\right]
$$
}\parbox{0.24\textwidth}{
$$ \left[
  \begin{array}{c|c}
          & \beta_2 \\ \hline
    \pi^2_0 \equiv \pi_2 & (0~0) \\
    \pi^2_1 \equiv \pi_3 & (0~1) \\
    \pi^2_2 \equiv \pi_0 & (1~\textsf{X}) \\
    \pi^2_3 \equiv \pi_1 & (1~\textsf{X}) \\
  \end{array}
\right]
$$
}\parbox{0.24\textwidth}{
$$ \left[
  \begin{array}{c|c}
          & \beta_3 \\ \hline
    \pi^3_0 \equiv \pi_3 & (0~0) \\
    \pi^3_1 \equiv \pi_2 & (0~1) \\
    \pi^3_2 \equiv \pi_1 & (1~\textsf{X}) \\
    \pi^3_3 \equiv \pi_0 & (1~\textsf{X}) \\
  \end{array}
\right]
$$
}

После перехода к относительным позициям ($\pi^i_j$ -- это позиция
$\pi_j$ относительно $\pi_i$) все столбцы получились одинаковыми.
Иными словами, алгоритм изменения набора согласно стратегии
вытеснения \PseudoLRU на относительных позициях инвариантен
относительно абсолютной позиции вытесняемого тега. Тег вытесняется в
том случае, когда его вектор равен (1 1). Следующая теорема
формально доказывает этот факт.

Будем называть \emph{\PseudoLRU-ветвью позиции $i$} вектор
$(B_{k_1}^{\sigma_1}~B_{k_2}^{\sigma_2}~\dots~B_{k_W}^{\sigma_W})$,
в котором $\sigma_j = \neg i_j$, $k_j = (1~i_1~i_2~\dots~i_{j-1})$,
$j = 1, 2, \dots, W$, $i = (i_1~i_2~\dots~i_W)$ (двоичное
разложение). Степени определены стандартным образом: $B^1 \equiv B,
B^0 \equiv \neg B$.

\begin{theorem}[Инвариантность преобразования \PseudoLRU-ветвей относительными
позициями]\label{thm_pseudoLRU_invariant} Пусть
($\alpha_1~\alpha_2~\dots~\alpha_W$)
--- \PseudoLRU-ветвь некоторой позиции $i$. Тогда изменение этой
ветви согласно стратегии вытеснения \PseudoLRU определяется только
относительной позицией (относительно $i$) и происходит следующим
образом при обращении к тегу с (абсолютной) позицией $j$: если
$\pi^i_j \in [\frac{w}{2^k},~\frac{w}{2^{k-1}})$ для некоторого
$k=1,2,\dots,W$, то происходит изменение $\alpha_1 := 0,~\alpha_2 :=
0,~\dots,~ \alpha_{k-1} := 0,~\alpha_k := 1$; если $\pi^i_j = 0$, то
происходит изменение $\alpha_1 := 0,~\alpha_2 := 0,~\dots,~\alpha_W
:= 0$; вытеснение тега на позиции $i$ происходит в том случае, когда
$\alpha_1 = 1~\wedge~\alpha_2 = 1~\wedge~\dots~\wedge~\alpha_W = 1$.
\end{theorem}
\begin{proof}
  Пусть происходит обращение с позицией $j = (j_1~j_2~\dots~j_W)$.
  Тогда согласно каноническому определению \PseudoLRU будет
  произведены следующие изменения: $B_{(1)} := j_1; B_{(1~j_1)} :=
  j_2; \dots B_{(1~j_1~j_2~\dots~j_{W-1})} := j_W$. Однако только
  часть этих изменений повлияет на
  $(\alpha_1~\alpha_2~\dots~\alpha_W)$, $\alpha_1 = B_{(1)}^{\neg
  i_1}, \alpha_2 = B_{(1~i_1)}^{\neg i_2}, \dots, \alpha_W =
  B_{(1~i_1~i_2~\dots~i_{W-1})}^{\neg i_W}$. А именно влияние будет
  на те элементы вектора, у которых совпадают индексы с изменяемыми
  элементами согласно каноническому определению. Иными словами,
  изменение $B_{(1~j_1~j_2~\dots~j_k)}$ будет влиять на
  $B_{(1~i_1~i_2~\dots~i_m)}$ тогда и только тогда, когда
  $(1~j_1~j_2~\dots~j_k) = (1~i_1~i_2~\dots~i_m)$. Докажем, что при
  этом $k = m$. Действительно, если $k > m$, то
  $(1~j_1~j_2~\dots~j_k) \geqslant 2^k$, а $(1~i_1~i_2~\dots~i_m) <
  2^{m+1} \leqslant 2^k$, что исключает равенство этих чисел.
  Аналогично доказывается невозможность случая $k < m$.

  Условие $(1~j_1~j_2~\dots~j_k) = (1~i_1~i_2~\dots~i_k)$
  эквивалентно условию $(j_1~j_2~\dots~j_k) = (i_1~i_2~\dots~i_k)$.
  Эти вектора равны тогда и только тогда, когда их сумма по модулю 2
  равна 0, т.е. $(j_1~j_2~\dots~j_k) \oplus (i_1~i_2~\dots~i_k) =
  0$. Переходя к полным векторам, это условие записывается в виде $(j_1~j_2~\dots~j_W) \oplus
  (i_1~i_2~\dots~i_W) < 2^{W-k+1}$. Или, переходя от векторов к
  числам, $i \oplus j < 2^{W-k+1}$.

  При этом изменение элементов вектора
  ($\alpha_1~\alpha_2~\dots~\alpha_W$) будет происходить следующим
  образом (используется определение степени через сложение по модулю
  2: $x^y \equiv x \oplus y \oplus 1$): $\alpha_k :=
  (B_{(1~j_1~j_2~\dots~j_{k-1})})^{\neg i_k} =
  (B_{(1~j_1~j_2~\dots~j_{k-1})}) \oplus (\neg i_k) \oplus 1 =
  B_{(1~j_1~j_2~\dots~j_{k-1})} \oplus i_k = j_k \oplus i_k$. Так
  как $(j_1~j_2~\dots~j_{k-1}) = (i_1~i_2~\dots~i_{k-1})$, то
  $(j_1~j_2~\dots~j_{k-2}) = (i_1~i_2~\dots~i_{k-2})$ и $i_{k-1} =
  j_{k-1}$. В таком случае изменяется и $\alpha_{k-1}$, причем
  $\alpha_{k-1} := i_{k-1} \oplus j_{k-1} = 0$. Аналогично
  рассуждая, получим, что $\alpha_{k-2} := 0,~\dots~\alpha_1 := 0$.
  Иными словами, возможно даже вычислить изменения предыдущих
  элементов -- всем им присваивается значение 0. Найдется такой $p$,
  что $i_1 = j_1~\wedge~i_2 = j_2~\wedge~i_{p-1} =
  j_{p-1}~\wedge~i_p \neq j_p$. В этом случае изменяется
  $\alpha_p$ следующим образом: $\alpha_p := i_p \oplus j_p = 1$.
  Или записывая это условие с использованием чисел $i$ и $j$: $2^{W-p} \leqslant i
  \oplus j < 2^{W-p+1}$.

  Таким образом, получаем, что для $i \oplus j \in
  [\frac{w}{2^k},~\frac{w}{2^{k-1}})$ будет произведены следующие
  присваивания: $\alpha_k := 1,~\alpha_{k-1} := 0,~\alpha_{k-2} :=
  0,~\dots~\alpha_1 := 0$, остальные элементы не будут изменены. Для
  $i \oplus j = 0$, т.е. $i = j$ все элементы $\alpha_k := i_k \oplus
  j_k = 0$. Причем изменение определяется только суммой по модулю 2
  чисел $i$ и $j$, что и является относительной позицией $j$
  относительно $i$.

  Осталось разобраться с ветвью вытесняемого тега. Это будет такая
  позиция $i = (i_1~i_2~\dots~i_W)$, для которой справедливы
  уравнения $i_1 = \neg B_{k_1}~\wedge~\i_2 = \neg
  B_{k_2}~\wedge~\dots~\wedge~i_W = \neg B_{k_W}$, где $k_1 = (1)$,
  $k_2 = (1~\neg B_{k_1})$, ..., $k_W = (1~\neg B_{k_1}~\neg
  B_{k_2}~\dots~\neg B_{k_{W-1}})$. Используя уравнения для
  элементов $i$, можно переписать уравнения для элементов $k$
  следующим образом: $k_1 = (1)$,
  $k_2 = (1~i_1)$, ..., $k_W = (1~i_1~i_2~\dots~i_{W-1})$. Таким
  образом, элементов ветви вытесняемого тега будет вычисляться
  следующим образом: $\alpha_m \equiv B_{(1~i_1~i_2~\dots~i_{m-1})}
  \oplus i_m \equiv B_{k_m} \oplus i_m \equiv \neg i_m \oplus i_m
  \equiv 1$. Иными словами, ветвь вытесняемого тега состоит только
  из единиц.
\end{proof}

Доказанный факт позволяет сформулировать определение стратегии
вытеснения \PseudoLRU, сфокусированное не на изменении всего набора,
а на изменении свойства одного тега набора. На этом определении
будут базироваться применения предлагаемых методов генерации
ограничений для стратегии вытеснения \PseudoLRU.

\begin{utv}[формулировка \PseudoLRU на ветвях бинарного дерева]
Сопоставим тегу вектор длины $W$. Каждая инструкция с этим тегом
делает этот вектор равным (0 0 ... 0). Тег является вытесняемым в
том и только в том случае, если этот вектор равен (1 1 ... 1).
Влияние других инструкций определяется относительной позицией их
тега относительно позиции данного тега. Если относительная позиция
принадлежит множеству $[\frac{w}{2^k},~\frac{w}{2^{k-1}}), k =
1,2,...,W$, то первые $k{-}1$ элементов вектора становятся равными
0, $k$'й элемент вектора становится равным 1, остальные элементы
вектора не меняются.
\end{utv}

Вектор длины $W$ будет соответствовать пути из корня бинарного
дерева в листовую вершину дерева, соответствующую данному тегу.
Будем называть процесс изменения элемента вектора
\emph{перекрашиванием вершины ветви}. Элементы вектора, равные 0,
будем называть \emph{белыми}, элементы вектора, равные 1, будем
называть \emph{черными}.

Говоря в терминах бинарного дерева, нелистовая вершина в ветви к
данной листовой вершине будет <<белой>>, если дуга от нее идет
налево и она помечена цифрой 1 или дуга от нее идет направо и она
помечена цифрой 0 (т.е. в том случае, когда направление дуги из нее
соответствует пометке этой дуги). Нелистовая вершина будет
называться <<черной>>, если направление дуги из нее не соответствует
пометке этой дуги. Вытесняется тот тег набора, путь к которому
полностью состоит из несоответствующих дуг. На рисунке~\ref{recolor}
изображен процесс перекрашивания ветви, ведущей в А, под действием
кэш-попадания в C (для сокращения показана только ветвь в А без
остальной части дерева). Так как путь из корня в C совпадает из
верхних двух вершин, то они перекрашиваются в белый цвет. Дуга из
третьей вершины пути в С не совпадает с дугой пути в А, поэтому
третья вершина перекрашивается в черный цвет. Остальные вершины
ветви остаются без изменений.

\begin{figure}[h] \center
  \includegraphics[width=0.8\textwidth]{1.review/recolor}\\
  \caption{Перекрашивание ветви в А}\label{recolor}
\end{figure}


\subsubsection{Таблица вытеснения для \PseudoLRU}

Таблица вытеснения для 8-ассоциативного кэширующего буфера согласно
стратегии вытеснения \PseudoLRU выглядит следующим
образом~\cite{policy_tables}:
$$
\left[
  \begin{array}{c|cccccccc}
    \pi_0 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
    \pi_1 & 1 & 0 & 2 & 3 & 4 & 5 & 6 & 7 \\
    \pi_2 & 2 & 3 & 0 & 1 & 4 & 5 & 6 & 7 \\
    \pi_3 & 3 & 2 & 0 & 1 & 4 & 5 & 6 & 7 \\
    \pi_4 & 4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\
    \pi_5 & 5 & 4 & 6 & 7 & 0 & 1 & 2 & 3 \\
    \pi_6 & 6 & 7 & 4 & 5 & 0 & 1 & 2 & 3 \\
    \pi_7 & 7 & 6 & 4 & 5 & 0 & 1 & 2 & 3 \\
    \pi_m & m & 6 & 4 & 5 & 0 & 1 & 2 & 3 \\
  \end{array}
\right]
$$

В отличие от канонических определений, в которых теги получали свои
позиции и не меняли их до вытеснения, определение с помощью таблицы
вытеснения описывает перестановку тегов в наборе. Каждая инструкция
меняет позиции тегов. При кэш-попадании на тег он перемещается в
начало перестановки, на нулевую позицию. Вытесняется тег с
максимальной позицией.

Определение стратегии вытеснения \PseudoLRU на ветвях дерева
является связующим звеном между каноническим определением (например,
на битовой строке) и определением с помощью таблицы вытеснения,
поскольку ветвь -- это и есть позиция, которая меняется точно так
же, как и позиция в перестановке согласно таблице вытеснения.

Из таблицы вытеснения для \PseudoLRU можно заметить схожесть со
стратегией вытеснения \LRU: тег, к которому происходит обращение,
перемещается на нулевую позицию, а вытесняемым является тег с
позицией $w{-}1$.
