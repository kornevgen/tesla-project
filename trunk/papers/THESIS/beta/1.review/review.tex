\chapter{Обзорная глава, постановка задачи}

\section{Обзор методов генерации тестовых программ}

Тестирование микропроцессоров является важной составляющей частью
процесса их разработки. Тестированию может подвергаться как готовый
чип, так и модель. Тестирование может проводиться как на модульном,
так и на системном уровне. В данной работе речь идет о системном
функциональном тестировании. Иными словами, целью тестирования
является проверка правильности функционирования микропроцессора
целиком. Эта проверка выполняется путем запуска на микропроцессоре
специальных машинных программ (далее такие программы будут
называться \emph{тестовыми}).

Системное функциональное тестирование включает в себя следующие
этапы~\cite{kamkin}:
\begin{enumerate}
\item определение целей тестирования, тестового покрытия и тестовых
ситуаций (структурные -- какие инструкции включать в тестирование --
и функциональные -- как инструкции должны быть исполнены);
\item генерация тестовых программ для тестовых ситуаций;
\item исполнение тестовых программ на микропроцессоре, получение
выходных данных (трасса исполнения, финальные значения регистров);
\item вынесение вердикта на основе анализа выходных данных.
\end{enumerate}

Данная работа посвящена этапу генерации тестовых программ. В
настоящее время в практике системного функционального тестирования
микропроцессоров можно выделить следующие подходы к построению
тестовых программ:
\begin{itemize}
\item \emph{ручная разработка тестовых программ} хоть и практически неприменима
для полного тестирования микропроцессора, всё же может применяться
для тестирования особых, крайних случаев;
\item \emph{тестирование с использованием кросс-компиляции} применяется часто
из-за невысокой сложности его проведения: после согласования
спецификации микропроцессора можно начинать делать кросс-компилятор,
а код, предназначенный для кросс-компиляции, уже готов. Однако
гарантировать полноту такое тестирование не может;
\item \emph{случайная генерация тестовых программ} применяется так же часто в
силу простоты автоматизации. Сгенерированные таким образом тестовые
программы позволяют быстро обнаружить простые ошибки, однако не
гарантируют полноты тестирования. Разрабатываются и более сложные
варианты случайной генерации~\cite{muGP};
\item \emph{генерация тестовых программ на основе тестовых
шаблонов} предполагает разделение процесса генерации тестовой
программы на два этапа: на первом на основе тестовых ситуаций
подготавливаются тестовые шаблоны -- абстрактные представления
тестовых программ -- а на втором этапе по тестовым шаблонам
генерируются тестовые программы.
\end{itemize}

Тестовые шаблоны могут описывать следующие свойства тестовых
программ:
\begin{itemize}
\item заданная последовательность инструкций (только коды операций или
коды операций с аргументами);
\item заданная последовательность типов инструкций;
\item выборка инструкций заданных типов;
\item аргументы инструкций (регистры, непосредственные
значения, переменные величины);
\item дополнительные ограничения на инструкции;
\item дополнительные ограничения на отдельные аргументы инструкций,
аргументы разных инструкций;
\item дополнительные функциональные ограничения на инструкции (при
исполнении должны произойти некоторые заданные события).
\end{itemize}

Выделяют следующие подзадачи при генерации тестовых программ по
тестовым шаблонам (подзадачи могут решаться по
отдельности~\cite{kamkin} или итеративно для каждой очередной
выделяемой инструкции~\cite{GenesysPro}):
\begin{enumerate}
  \item выбор последовательности инструкций / выбор очередной
  инструкции;
  \item выбор аргументов (не значений, а имен аргументов!) инструкций /
  выбор аргументов очередной инструкции;
  \item построение инициализации микропроцессора для выполнения
  тестовых ситуаций.
\end{enumerate}

Работа посвящена исследованию методов построения инициализации
микропроцессора. Исследователями предложены следующие классы методов
решения этой задачи:
\begin{enumerate}
\item ручная генерация тестовых программ;
\item комбинаторные методы;
\item использование методов генерации входных векторов (ATPG~\cite{ATPGbook});
\item использование методов разрешения ограничений.
\end{enumerate}

\subsection{Ручная генерация тестовых программ}

Александром Камкиным разработана технология системного
функционального тестирования микропроцессоров с использованием
тестовых шаблонов~\cite{kamkin}. Построение тестовых шаблонов
осуществляется полуавтоматически на основе тестового покрытия по
модели системы инструкций микропроцессора. Тестовые шаблоны
представляют из себя последовательность инструкций с зависимостями
между аргументами (например, <<запись-чтение>>) и тестовыми
ситуациями для инструкций.

Для получения тестовых программ по сгенерированным тестовым шаблонам
следует реализовать на языке Java \emph{конструкторы тестовых
данных}. Под <<тестовыми данными>> понимаются значения регистров,
аргументы инструкций обращения к памяти для инициализации состояния
кэш-памяти и ячеек оперативной памяти, если это требуется. Все
зависимости в тестовом шаблоне обладают направлением,
конструирование аргументов инструкций производится итеративно от
инструкций, которые не зависят от остальных инструкций, к
инструкциям, которые зависят от уже сгенерированных инструкций. Для
выбора независимых значений используется случайная генерация.

%//плюсы: возможность сгенерировать специальные крайние программы,
%минусы: сложно добиться хорошего покрытия при большом количестве
%зависимостей, потому как для этого надо писать нетривиальные
%конструкторы

\subsection{Комбинаторные методы генерации тестовых программ}

Тестовый шаблон состоит из заданной последовательности инструкций,
аргументами которых являются переменные величины. Кроме того для
каждой переменной величины указывается конечная область значений.
Все значения в области равноправны. Тестовая программа содержит ту
же последовательность инструкций, а для каждого аргумента выбрано
значение из области значений этого аргумента. В комбинаторных
методах инструкции воспринимаются лишь как синтаксические объекты
(термы) -- у них есть лишь имя и аргументы (возможно
типизированные).

Последовательность инструкций может быть задана неявно, но у каждой
инструкции всё же будут переменные величины в качестве аргументов и
для каждой переменной величины задана область значений.
Исследователи из Fujitsu Lab.~\cite{TSE} предлагается описать
последовательность инструкций в виде выражений (Test Specification
Expressions, TSE), а семантику инструкций -- на языке
ISDL~\cite{ISDL}. Отдаленно TSE могут напоминать регулярные
выражения, где бесконечнозначные операции заменены конечными
аналогами. ISDL-описание может включать в том числе и параметры
исполнения инструкции на конвейере, которые могут быть использованы
в TSE. Авторы исследования реализовали специальный генератор,
который строит тестовые программы, удовлетворяющие данному TSE.

Kohno и Matsumoto~\cite{mVpGen} рассматривают задачу верификации
конвейерных микропроцессоров, используя для этого генерацию тестовых
программ с помощью тестовых шаблонов. Тестовый шаблон явно содержит
последовательность типов инструкций, возможно, с использованием
конструкций итерирования блоков инструкций. Использование разными
инструкциями в шаблоне одной и той же переменной величины должно
приводить в тестовой программе к использованию одного и того же
значения для этой переменной величины. Областями значений являются
заданное в архитектуре множество регистров ($GPR$ -- множество
регистров общего назначения, $CPR$ -- множество регистров
сопроцессора).

%// плюсы:простота, минусы: низкое покрытие

\subsection{Генерация тестовых программ с использованием методов
решения задачи ATPG}

Задача ATPG (Automatic Test Pattern Generation)~\cite{ATPGbook}
относится к вопросам модульного тестирования микропроцессоров.
Модульное тестирование осуществляется подачей определенных сигналов
(возможно, многотактовых) на входы модуля (схемы) и снятие значения
выходных сигналов (возможно, также многотактовых). Принятие вердикта
осуществляется на основе сравнения ожидаемого выходного сигнала и
снимаемого с данной схемы. Тестовым воздействием является сигнал,
поданный на входные порты схемы. Моделью ошибки является смена
функции некоторых элементов схемы (например, в результате пробоя или
замыкания элемент может сменить функцию, которую он реализует, на
тождественную константу). ATPG -- это задача построения тестовых
воздействий для схем, нацеленных на данную модель ошибки. Аргументы
инструкций являются входными сигналами некоторых модулей
микропроцессора, поэтому решая задачу генерации входных сигналов,
можно решать и задачу генерации тестовых программ.

Эту идею использовали исследователи из Politecnico di
Milano~\cite{toATPG}. Тестовым шаблоном выступает
препроцессированная модель этапа декодирования инструкции. Модель
написана на языке VHDL~\cite{VHDL}. Специальный генератор
подставляет на место кода инструкции заданные значения кодов
операций и передает получившуюся модель стороннему (коммерческому)
ATPG-инструменту. Тот в свою очередь возвращает остальные значения,
которые надо передать в модуль декодирования инструкции, т.е.
значения аргументов инструкции. Метод был применен к тестированию
АЛУ VLIW-микропроцессора.

%//плюсы:позволяет нацеливаться на покрытие по RTL-модели, минусы:
%нужна RTL-модель, небольшая длина тестового шаблона

\subsection{Генерация тестовых программ с использованием методов
разрешения ограничений}

Под \emph{ограничением} будет пониматься предикат, в котором
переменные принимают значения из конечной области. Например, $x >
0$, если $x \in \{0, 10, 100\}$. Задачей разрешения ограничений
(constraint satisfaction problem) является задача поиска значений
для переменных из их областей значений, при которых все ограничения
выполнены~\cite{CSP}. Для областей значений небольшого размера
достаточно перебрать все комбинации значений переменных, пока не
встретится комбинация, на которой выполнены все ограничения. В общем
случае применяются более сложные алгоритмы (зачастую с привлечением
эвристик), сочетающие перебор с возвратом и распространение
ограничений (т.е. автоматический вывод ограничений-следствий по
данной системе ограничений).

Представление в виде CSP удобно для задач, сформулированных в виде
задачи выполнимости некоторого набора условий. Задача генерации
тестовых программ по тестовым шаблонам тоже может быть
сформулирована в таком виде, поскольку есть связанный набор
переменных (инструкций, аргументов инструкций, элементов состояния
микропроцессора), причем связи выражаются в виде утверждений,
зависимостей. Сама идея построения тестовой программы через
формулирование тестового шаблона близка решению задачи с
использованием CSP, поскольку этап построения тестового шаблона
(формализации требований к тестовому воздействию) по сути является
этапом формулирования задачи построения тестового шаблона в виде
утверждений, в виде задачи выполнимости. Остается только перевести
эту формулировку к виду, используемому в инструментах для решения
CSP. Выбор инструментов, метод их решения, а также вида самих
ограничений, зависит от того, какие применяются тестовые шаблоны и
как описывается семантика инструкций.

С целью упрощения подготовки нужного представления семантики
микропроцессора китайские исследователи в своем инструменте
MAATG~\cite{MAATG} предложили использовать хорошо известный язык
описания архитектуры EXPRESSION~\cite{EXPRESSION}. Тестовые шаблоны
позволяют явно задавать блоки инструкций, задавать ограничения на
аргументы разных инструкций (одинаковые регистры, разные регистры,
непосредственные значения из некоторого множества констант), а также
указывать события, которые могут произойти при исполнении инструкции
(например, целочисленное переполнение для инструкции ADD).
Специальный генератор строит тестовую программу итеративно. Сначала
он упорядочивает инструкции так, чтобы переменные для очередной
инструкции зависели только от переменных предыдущих инструкций. Это
позволяет разбить задачу генерации тестовой программы на
последовательность более простых задач генерации одной инструкции.
Однако по доступным публикациям невозможно сделать вывод о том,
какие ограничения генерирует MAATG и тем самым оценить эффективность
работы этого инструмента.

Еще одно семейство инструментов генерации тестовых программ на
основе тестовых шаблонов было разработано в IBM в течение последних
20 лет. Далее будет дано описание последнего на сегодняшний день
инструмента в этом семействе -- Genesys-Pro~\cite{GenesysPro2004}.
Тестовые шаблоны этого инструмента позволяют описывать как заданные
последовательности инструкций, так и всевозможные их композиции.
Разработчиками предложен несложный императивный язык, позволяющий
задать эту последовательность инструкций.

Для каждой инструкции могут быть указаны ограничения на аргументов
пожелания к значениям аргументов инструкции для улучшения тестового
покрытия (эта информация называется testing
knowledge)~\cite{GenesysTK}. Эти пожелания (по сути особенности
семантики инструкций и тестовые ситуации) предлагается описывать с
использованием ограничений~\cite{GenesysPro2004Innovations}. Можно
задавать ограничения на атрибуты аргументов инструкции (например,
значение одного аргумента больше значения другого) и состояние
микропроцессора (например, на значения в таблицах и буферах). Для
описания механизма трансляции адресов (получения физического адреса
по виртуальному) предлагается использовать подход
DeepTrans~\cite{DeepTrans}. В этом подходе предлагается пользователю
описать структуру строки таблицы, через которую осуществляется
трансляция, правило соответствия адреса строке, некоторые другие
преобразования, а специальный генератор автоматически построит
нужную систему ограничений для использования в Genesys-Pro.

Тестовый шаблон может содержать параметры работы генератора тестовых
программ: вероятности выбора тех или иных значений, параметры
распределения адресов в памяти и другие -- они позволяют управлять
выбором некоторого одного значения из множества допустимых.

Требуется описать структуру системы команд (architecture model),
задать исполнительную семантику команд (по сути симулятор
микропроцессора).

Рассмотрим теперь, как Genesys-Pro генерирует тестовые программы на
основе тестовых шаблонов. Для б\'{о}льшей эффективности этапы
построения последовательности инструкций и выбора аргументов
осуществляются вместе (отдельная инициализация состояния
микропроцессора не проводится). На основе параметров генерации,
текущего состояния модели микропроцессора и построенной тестовой
программы выбирается очередная инструкция (тестовые шаблоны
позволяют описывать сложные потоки управления на инструкциях). Далее
для этой инструкции генерируются аргументы инструкций. Для этого
строится и разрешается система ограничений на основе тестовых
ситуаций (testing knowledge) и текущего модельного состояния
микропроцессора), в результате чего получаются значения аргументов.
Готовая инструкция исполняется на модели микропроцессора
(architecture model, он готовится пользователем) с получением нового
модельного состояния микропроцессора. На этом генерация инструкции
завершается и генерируется следующая инструкция. Ключевым моментом
является эффективность работы решателя ограничений. Для этой цели
разработчики инструмента самостоятельно написали свой решатель
ограничений. Он базируется на хорошо известном семействе алгоритмов
разрешения ограничений MAC (Maintaining Arc-Consistency)~\cite{CSP},
но заточен под ограничения, генерируемые для тестовых
программ~\cite{GenesysSolver}. Написание такого решателя является
довольно нетривиальной задачей и предметом отдельного исследования.
Например, Genesys-Pro позволяет использовать для описания тестовых
ситуаций элементы массивов (Memory, таблицы страниц) с переменными
индексами.

Тем самым ни один из методов генерации тестовых программ,
использующих ограничения, не нацеливается на строго заданную
последовательность инструкций, однако потребности в использовании
тестовых шаблонов с заданной последовательностью инструкций
отмечаются исследователями~\cite{kamkin}.

%//плюсы: масштабируемость, технологичность; минусы: сложность
%внесения нового архитектурного механизма

\subsection{Сравнение методов генерации тестовых программ}

%%%Сравнение проводилось по следующим критериям:
%%%\begin{enumerate}
%%%\item выразительная мощность тестовых шаблонов;
%%%\item допустимые архитектурые механизмы;
%%%\item сложность подготовки исходных данных;
%%%\item переиспользуемость частей генератора тестовых программ;
%%%\item вычислительная эффективность генератора тестовых программ.
%%%\end{enumerate}
%%%
%%%\subsubsection{Выразительная мощность тестовых шаблонов}
%%%\noindent {\small
%%%\begin{tabular}{|l|c|c|c|c|}
%%%\hline &
%%%\begin{tabular}{c}ручная\\генерация\end{tabular} &
%%%\begin{tabular}{c}комбина-\\торные\\методы\end{tabular} &
%%%\begin{tabular}{c}использование\\ATPG\end{tabular} &
%%%\begin{tabular}{c}использование\\CSP\end{tabular} \\
%%%\hline
%%%\begin{tabular}{l}возможность\\задать\\последовательность\\инструкций \end{tabular} &
%%%+ & + & -- & + \\
%%%\hline
%%%\begin{tabular}{l}возможность\\задать\\тестовую\\ситуацию \end{tabular} &
%%%+ & -- & -- & + \\
%%%\hline
%%%\begin{tabular}{l}возможность\\задействовать\\состояние\\микропроцессора \end{tabular} &
%%%+ & -- & + & + \\
%%%\hline
%%%\end{tabular}}
%%%
%%%//нужен комментарий, почему заполнение такое?
%%%
%%%\subsubsection{Допустимые архитектурные механизмы}
%%%\noindent {\small \begin{tabular}{|l|c|c|c|c|} \hline &
%%%\begin{tabular}{c}ручная\\генерация\end{tabular} &
%%%\begin{tabular}{c}комбинаторные\\методы\end{tabular} &
%%%\begin{tabular}{c}использование\\ATPG\end{tabular} &
%%%\begin{tabular}{c}использование\\CSP\end{tabular} \\
%%%\hline
%%%\begin{tabular}{l}поддержка\\регистров\\общего\\назначения \end{tabular} &
%%%+ & + & -- & + \\
%%%\hline
%%%\begin{tabular}{l}поддержка\\кэш-памяти и \\трансляции\\адресов \end{tabular} &
%%%+ & -- & -- & + \\
%%%\hline
%%%\begin{tabular}{l}поддержка\\механизмов\\параллелизма \end{tabular} &
%%%+ & + & -- & + \\
%%%\hline
%%%\end{tabular}}
%%%
%%%//нужен комментарий, почему заполнение такое?
%%%
%%%\subsubsection{Сложность подготовки исходных данных}
%%%\noindent{\small
%%%\begin{tabular}{|l|c|c|c|c|}
%%%\hline &
%%%\begin{tabular}{c}ручная\\генерация\end{tabular} &
%%%\begin{tabular}{c}комбинаторные\\методы\end{tabular} &
%%%\begin{tabular}{c}использо-\\вание\\ATPG\end{tabular} &
%%%\begin{tabular}{c}использование\\CSP\end{tabular} \\
%%%\hline
%%%\begin{tabular}{l}при смене\\тестового\\шаблона \end{tabular} &
%%%сложно & \begin{tabular}{c}сложно\\(нужна\\RTL-модель)\end{tabular} & -- & несложно \\
%%%\hline
%%%\begin{tabular}{l}при смене\\микро-\\процессора \end{tabular} &
%%%\begin{tabular}{c}долго, но\\технологично\end{tabular} &
%%%\begin{tabular}{c}долго\\вплоть до\\невозможности\end{tabular} &
%%%просто & \begin{tabular}{c}небыстро\\(новые\\механизмы)\end{tabular} \\
%%%\hline
%%%\end{tabular}}
%%%
%%%//нужен комментарий, почему заполнение такое?
%%%
%%%\subsubsection{Переиспользуемость частей генератора тестовых
%%%программ} \noindent{\small
%%%\begin{tabular}{|l|c|c|c|c|}
%%%\hline &
%%%\begin{tabular}{c}ручная\\генерация\end{tabular} &
%%%\begin{tabular}{c}комбинаторные\\методы\end{tabular} &
%%%\begin{tabular}{c}использование\\ATPG\end{tabular} &
%%%\begin{tabular}{c}использование\\CSP\end{tabular} \\
%%%\hline
%%%\begin{tabular}{l}при смене\\тестового\\шаблона \end{tabular} &
%%%никакая & полная & полная & полная \\
%%%\hline
%%%\begin{tabular}{l}при смене\\микро-\\процессора \end{tabular} &
%%%никакая & полная &
%%%полная & \begin{tabular}{c}только\\общие\\механизмы\end{tabular} \\
%%%\hline
%%%\end{tabular}}
%%%
%%%//нужен комментарий, почему заполнение такое?
%%%
%%%\subsubsection{Вычислительная эффективность генератора тестовых
%%%программ}
%%%
%%%\noindent {\small
%%%\begin{tabular}{|l|c|c|c|c|}
%%%\hline &
%%%\begin{tabular}{c}ручная\\генерация\end{tabular} &
%%%\begin{tabular}{c}комбина-\\торные\\методы\end{tabular} &
%%%\begin{tabular}{c}использо-\\вание\\ATPG\end{tabular} &
%%%\begin{tabular}{c}использо-\\вание\\CSP\end{tabular} \\
%%%\hline
%%%\begin{tabular}{l}сложность\\достижения\\покрытия \end{tabular} &
%%%\begin{tabular}{c}сложно\\(можно достичь\\крайние случаи)\end{tabular} &
%%%\begin{tabular}{c}сложно\\(не задается\\семантика)\end{tabular} &
%%%\begin{tabular}{c}возможно\\покрытие\\структуры\\RTL-модели\end{tabular} &
%%%несложно \\
%%%\hline
%%%\begin{tabular}{l}среднее время\\генерации\\программ \end{tabular} &
%%%долго & быстро &
%%%\begin{tabular}{c}зависит от\\сложности\\RTL-модели\end{tabular} &
%%%недолго \\
%%%\hline
%%%\begin{tabular}{l}эффективность\\учёта начального\\состояния\\микропроцессора\end{tabular} &
%%%сложно & \begin{tabular}{c}не\\учитывается\end{tabular} &
%%%\begin{tabular}{c}не\\учитывается\end{tabular} &
%%%возможно \\
%%%\hline
%%%\end{tabular}}
%%%
%%%//нужен комментарий, почему заполнение такое?

Сравнение проводилось по следующим критериям:
\begin{enumerate}
\item сложность построения генератора тестовых программ;
\item допустимые архитектурые механизмы;
\item полнота метода.
\end{enumerate}

Из сделанного обзора следует, что возможность генерирования тестовых
программ для тестовых шаблонов, ориентированных на поведение MMU
(тестовые ситуации в кэширующих буферах и таблицах MMU), т.е.
поддержку механизмов кэширования в MMU, есть у следующих методов:
\begin{itemize}
  \item ручное написание генераторов тестовых
  программ~\cite{kamkin};
  \item вероятностные алгоритмы генерации тестовых программ (как разновидность
  -- примитивные переборные алгоритмы);
  \item покомандный перебор с возвратом на основе разрешения
  ограничений~\cite{GenesysPro}.
\end{itemize}

\begin{table}[h]\small
\begin{tabular}{|c||c|c|}\hline
 & полный & неполный\\
\hline \hline
простой & & \begin{tabular}{c}переборный алгоритм\\
примитивный вероятностный \end{tabular} \\
\hline
сложный & \begin{tabular}{c}вручную написанный генератор\\
хитрый вероятностный\\покомандный перебор с возвратом
 \end{tabular} & --- \\ \hline
\end{tabular}

\end{table}

Использование простых переборных или вероятностных алгоритмов
генерации тестовых программ позволяют подготовить генератор на
основе нехитрых идей, однако они не позволяют добиться хорошей
полноты. Это означает, что для произвольного тестового шаблона время
генерации тестовой программы может быть очень велико.

Напротив более хитрые варианты вероятностных (переборных)
алгоритмов, написанные вручную генераторы или генераторы, основанные
на более регулярных алгоритмах (например, покомандный перебор с
возвратом, реализованный в системе Genesys-Pro~\cite{GenesysPro})
нацелены на получение высокой полноты. Однако достигается это в
основном за счет разработки и применения уникальных идей, которые
сложно использовать вновь при тестировании другого микропроцессора.
Это усложняет написание таких генераторов и, как результат,
увеличивает время подготовки самого генератора.

Тем самым представляется перспективным исследование и разработка
регулярных легко переиспользуемых методов построения генераторов
тестовых программ по тестовым шаблонам, применимых для тестирования
механизмов кэширования, не уступающих в полноте существующим
методам.



\section{Постановка задачи}

В диссертации решается задача построения тестовых программ по
тестовым шаблонам, обладающим следующими свойствами. Тестовый шаблон
представляется последовательностью троек $(I_i, A_i, S_i)$, где
$I_i$ -- заданная инструкция, $A_i$ -- список аргументов инструкции,
$S_i$ -- тестовая ситуация инструкции. Аргументами являются явно
заданные регистры и переменные, не меняющие своего значения (в
тестовой программе они станут непосредственными значениями).
Тестовая ситуация инструкции -- это ограничение на аргументы
инструкции и текущее состояние микропроцессора. Примеры тестовых
ситуаций: <<при исполнении инструкции должно произойти целочисленное
переполнение (это ограничение только на аргументы инструкции)>>,
<<при исполнении инструкции должно произойти кэш-попадание в
кэш-памяти первого уровня>> (это ограничение не только на аргументы
инструкции, но и на состояние микропроцессора перед ее исполнением,
поскольку кэш-память является подсистемой микропроцессора). Кроме
тестового шаблона задано начальное состояние модели микропроцессора.
Состояние модели микропроцессора включает в себя состояние всех его
подсистем. Например, состоянием регистра является значение, которое
в нем хранится. Состоянием кэш-памяти является его содержимое.

Требуется построить тестовую программу по тестовому
шаблону~\cite{my_isp_2009, my_programmirovanie_2009}, которая
состоит из двух частей: инициализирующие инструкции и инструкции
тестового воздействия (см.рис.~\ref{problem}). Инициализирующие
инструкции переводят модель микропроцессора из заданного начального
состояния в состояние, необходимое для тестового воздействия.
Инструкции тестового воздействия в точности повторяют
последовательность инструкций тестового шаблона с заменой переменных
на непосредственные значения. На рисунке~\ref{test_template_exmp}
приведен пример тестового шаблона и возможных инструкций тестового
воздействия, построенных по этому шаблону.

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{1.review/problem}\\
  \caption{Составление тестовой программы}\label{problem}
\end{figure}

\begin{figure}[h]
\quad\parbox{0.5\textwidth}{\small \tt
AND r1, r2, r3 @ normal\\
LD r4, r2, c1 @ l1Hit\\
SUB r3, r1, r5 @ overflow } \parbox{0.3\textwidth}{\small \tt
AND r1, r2, r3\\
LD r4, r2, 0x0FA2\\
SUB r3, r1, r5
}
\caption{Тестовый шаблон и возможные соответствующие ему инструкции
тестового воздействия}\label{test_template_exmp}
\end{figure}


Уже сгенерированная программа может быть позднее дополнена
инструкциями проверки состояния микропроцессора после исполнения
инструкций тестового воздействия.

Инициализирующие инструкции призваны подготовить модель
микропроцессора к исполнению инструкций тестового воздействия. Без
инициализирующих инструкций запуск инструкций тестового воздействия
даже на корректной модели микропроцессора может приводить к ложным
сообщениям об ошибках в модели. В работе рассматривается модель
микропроцессора, включающая в себя регистры общего назначения,
кэш-память (возможно многоуровневую) и буфер трансляции адресов
(TLB, Translation Lookaside Buffer)~\cite{HennesyPatterson}. Таким
образом, инициализирующие инструкции могут включать инструкции
изменения значений регистров и ячеек кэш-памяти и TLB.

В данной работе среди методов генерации тестовых программ выбран
метод, использующий разрешение ограничений (CSP). Однако по
сравнению с существующими аналогами в данной работе поставлена
задача исследовать возможности снижения сложности подготовки
генератора тестовых программ (по сравнению, например, с мощным
Genesys-Pro), не проиграв сильно в масштабируемости генератора. При
этом, возможно, придется выделить среди всевозможных архитектурных
механизмов наиболее часто использующиеся и требующие тестирование в
современных микропроцессорах.


\section{Предварительные сведения и термины}

%Дополнительные сведения, необходимые для дальнейшего прочтения.

\subsection{Типы кэш-памяти}

По организации кэш-память делят на \emph{полностью ассоциативную},
\emph{прямого доступа} и \emph{наборно-ассоциативную}. Различие
производится на основе двух параметров: количества секций $W$ и
количества наборов $R$. Кэш-память хранит некоторый набор данных.
Каждому блоку данных соответствует некоторый адрес (физический или
виртуальный). Блоки с адресами организованы в \emph{секции} и
\emph{наборы} (см.рис.~\ref{cache_model}).

\begin{figure}[h] \center
  \includegraphics[width=0.7\textwidth]{1.review/cache}\\
  \caption{Модель кэш-памяти и адреса данных}\label{cache_model}
\end{figure}

Каждый адрес может быть разделен на два битовых поля: поле
\emph{тега адреса} и поле \emph{сет адреса}. Один набор составляют
адреса с одинаковым сетом. Кэш-память организована таким образом,
что для каждого сета хранится всегда одно и то же количество адресов
(равное количеству секций $W$). Адреса всех данных в кэш-памяти
различные. Отсюда следует, что теги адресов одного набора разные. В
кэш-памяти представлены все наборы, возможные в рамках битового поля
сета адреса.

Кэш-память является полностью ассоциативной, если $R = 1$.
Кэш-память является кэш-памятью прямого доступа, если $W = 1$. И
кэш-память является наборно-ассоциативной, если $R > 1$ и $W > 1$.

Инструкции обращения в память бывают двух видов: инструкции загрузки
данных из памяти по данному адресу и инструкции сохранения данных в
памяти по данному адресу. При выполнении этих инструкций может быть
задействована кэш-память. Если данные по требуемому адресу
присутствуют в кэш-памяти, операция проводится с нею. Такая ситуация
называется \emph{кэш-попаданием}. Если данные по требуемому адресу
не присутствуют в кэш-памяти, осуществляется подгрузка данных в
кэш-память и совершение операции. Такая ситуация называется
\emph{кэш-промахом}. В этом случае если кэш-память полностью
заполнена, некоторые данные должны быть \emph{вытеснены} из
кэш-памяти и на их место будут загружены данные по требуемому
адресу. \emph{Стратегия вытеснения} (или \emph{политика замещения})
-- это правило, по которому определяются вытесняемые данные.
Например, могут быть вытеснены данные, которые дольше всего не были
нужны (такая стратегия называется \LRU), или данные, которые были
внесены в кэш-память раньше остальных (такая стратегия называется
\FIFO).

\subsection{Стратегия вытеснения \PseudoLRU}

Стратегия вытеснения \PseudoLRU стала одним из результатов попыток
предложить стратегию вытеснения, близкой по эффективности к \LRU, но
обладающую меньшими накладными расходами на организацию. ........

\subsubsection{Каноническое определение \PseudoLRU}

Во многих книгах приводятся следующее определение стратегии
вытеснения \PseudoLRU для случая
$w=4$~\cite{FundamentalOfComputerOrganizationAndDesign} (в этом
случае для каждого набора выделяется 3 бита $B_1$, $B_2$ и $B_3$,
обычно этот случай поясняется на \emph{бинарном дереве}):
$$ \left[
  \begin{array}{c|ccc}
          & B_1 & B_2 & B_3 \\ \hline
    \pi_0 & 0 & 0 & \textsf{X} \\
    \pi_1 & 0 & 1 & \textsf{X} \\
    \pi_2 & 1 & \textsf{X} & 0 \\
    \pi_3 & 1 & \textsf{X} & 1 \\
  \end{array}
\right]
$$

При кэш-попадании тега, расположенного в секции с номером $i$,
действует $i$'я строка матрицы (она помечена символом $\pi_i$).
Биты, напротив которых в $i$'й строке находится \textsf{X}, не
меняются. Биты, напротив которых в $i$'й строке находится число,
принимают значение, равное этому числу.

При кэш-промахе надо определить номер секции, в которой будут
заменены данные. Для этого используется инвертированная форма той же
матрицы:
$$
\left[
  \begin{array}{ccc|c}
    B_1 & B_2 & B_3 & \\ \hline
    1 & 1 & \textsf{X} & \rightarrow \pi_0 \\
    1 & 0 & \textsf{X} & \rightarrow \pi_1 \\
    0 & \textsf{X} & 1 & \rightarrow \pi_2 \\
    0 & \textsf{X} & 0 & \rightarrow \pi_3 \\
  \end{array}
\right]
$$

Выбирается строка, соответствующая текущему состоянию бит $B_1$,
$B_2$ и $B_3$: если напротив бита в строке находится число, бит
должен быть равен этому числу -- если напротив бита в строке
находится \textsf{X}, то требования на соответствующий бит нет.
Такая всегда всегда будет единственной.

Формализованное описание для всех допустимых $w$ не приводится.
Однако в дальнейшем для формулирования и доказательства утверждений
про стратегию вытеснения \PseudoLRU, такое описание будет
необходимо. Для $w=8$ стратегия будет задаваться следующей матрицей:
$$
\left[
  \begin{array}{c|ccccccc}
          & B_1 & B_2 & B_3 & B_4 & B_5 & B_6 & B_7 \\ \hline
    \pi_0 & 0 & 0 & \textsf{X} & 0 & \textsf{X} & \textsf{X} & \textsf{X} \\
    \pi_1 & 0 & 0 & \textsf{X} & 1 & \textsf{X} & \textsf{X} & \textsf{X} \\
    \pi_2 & 0 & 1 & \textsf{X} & \textsf{X} & 0 & \textsf{X} & \textsf{X} \\
    \pi_3 & 0 & 1 & \textsf{X} & \textsf{X} & 1 & \textsf{X} & \textsf{X} \\
    \pi_4 & 1 & \textsf{X} & 0 & \textsf{X} & \textsf{X} & 0 & \textsf{X} \\
    \pi_5 & 1 & \textsf{X} & 0 & \textsf{X} & \textsf{X} & 1 & \textsf{X} \\
    \pi_6 & 1 & \textsf{X} & 1 & \textsf{X} & \textsf{X} & \textsf{X} & 0 \\
    \pi_7 & 1 & \textsf{X} & 1 & \textsf{X} & \textsf{X} & \textsf{X} & 1 \\
  \end{array}
\right]
$$

Следующее утверждение~\ref{wMinus1PseudoLRU} дает алгоритм
преобразования списка бит\\ $B_1, B_2, ..., B_{w{-}1}$. В его
формулировке применяется двоичное разложение, биты разложения
обозначаются следующим образом, например, 1 = (0 0 1), 6 = (1 1 0).

\begin{utv}[$(w{-}1)$-представление стратегии вытеснения
\PseudoLRU]\label{wMinus1PseudoLRU}При кэш-попадании тега с позицией
$i = (i_1~i_2~\dots~i_W)$ происходит следующее изменение:

\parbox{0.3\textwidth}{
  $$ \begin{array}{l}
  B_{k_1} := i_1 \\
  B_{k_2} := i_2 \\
  B_{k_3} := i_3 \\
  ...\\
  B_{k_W} := i_W \\
  \end{array}$$
} \vline
\parbox{0.7\textwidth}{
  $$ \begin{array}{l}
  k_1 = (1) \\
  k_2 = (1~i_{W{-}1}) \\
  k_3 = (1~i_{W{-}2}~i_{W{-}1}) \\
  ...\\
  k_W = (1~i_1~i_2~\dots~i_{W{-}1}) \\
  \end{array} $$
}
\\[1cm]

При кэш-промахе тега позиция $i = (i_1~i_2~\dots~i_W)$ определяется
следующим образом:

\parbox{0.3\textwidth}{
  $$ \begin{array}{l}
  i_1 = \neg B_{k_1} \\
  i_2 = \neg B_{k_2} \\
  i_3 = \neg B_{k_3} \\
  ...\\
  i_W = \neg B_{k_W} \\
  \end{array}$$
} \vline
\parbox{0.7\textwidth}{
  $$ \begin{array}{l}
  k_1 = (1) \\
  k_2 = (1~\neg B_{k_1}) \\
  k_3 = (1~\neg B_{k_1}~\neg B_{k_2}) \\
  ...\\
  k_W = (1~\neg B_{k_1}~\neg B_{k_2}\dots\neg B_{k_{W{-}1}}) \\
  \end{array} $$
}
\\[0.5cm]

Кроме того при кэш-промахе после определения позиции $i$ делается
преобразование бит $B_1, B_2, ..., B_{W{-}1}$ так, как в случае
кэш-попадания на $\pi_i$.
\end{utv}

\subsubsection{Определение \PseudoLRU на путях бинарного дерева}

Здесь будет показано, как из канонического определения \PseudoLRU
получить формулировку \PseudoLRU, в которой рассматривается не вся
последовательность бит $B_1, B_2, ..., B_{W-1}$, а всего один ......

Сначала этот переход покажем на примере $w=4$. Первый шаг -- это
смена <<состояния>>: вместо последовательности $B_1, B_2, ...,
B_{w-1}$ будем рассматривать последовательность $\beta_0, \beta_1,
...., \beta_{w-1}$. Каждый $\beta_i$ соответствует $i$'й листовой
вершине бинарного дерева. Кэш-попадание меняет теперь не внутренние
вершины дерева, а листовые вершины. Каждый $\beta_i$ будет
представляться списком длины $W$ -- путь от корня дерева к $i$'й
листовой вершине: $\beta_0$ и $\beta_1$ соответствует ($B_1$ $B_2$),
$\beta_2$ и $\beta_3$ соответствует ($B_1$ $B_3$).\\[0.5cm]

\parbox{0.2\textwidth}{ \centering
  \includegraphics[width=0.2\textwidth]{1.review/btree}
}
\parbox{0.25\textwidth}{
$$ \left[
  \begin{array}{c|ccc}
          & B_1 & B_2 & B_3 \\ \hline
    \pi_0 & 0 & 0 & \textsf{X} \\
    \pi_1 & 0 & 1 & \textsf{X} \\
    \pi_2 & 1 & \textsf{X} & 0 \\
    \pi_3 & 1 & \textsf{X} & 1 \\
  \end{array}
\right]
$$
} $\stackrel{1}{\longrightarrow}$ %\vline
\parbox{0.4\textwidth}{
$$ \left[
  \begin{array}{c|cccc}
          & \beta_0 & \beta_1 & \beta_2 & \beta_3 \\ \hline
    \pi_0 & (0~0) & (0~1) & (1~\textsf{X}) & (1~\textsf{X}) \\
    \pi_1 & (0~1) & (0~0) & (1~\textsf{X}) & (1~\textsf{X}) \\
    \pi_2 & (1~\textsf{X}) & (1~\textsf{X}) & (0~0) & (0~1) \\
    \pi_3 & (1~\textsf{X}) & (1~\textsf{X}) & (0~1) & (0~0) \\
  \end{array}
\right]
$$
}

Кстати, получилась симметричная матрица.

Теперь рассмотрим каждый столбец отдельно.

\begin{utv}
.....формулировка через перекрашивание....
\end{utv}

"Черные вершины" -- не соответствующие своему направлению. "Белые
вершины" -- соответствующие своему направлению.


\subsubsection{Таблица вытеснения для \PseudoLRU}

$$
\left[
  \begin{array}{c|cccccccc}
    \pi_0 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
    \pi_1 & 1 & 0 & 2 & 3 & 4 & 5 & 6 & 7 \\
    \pi_2 & 2 & 3 & 0 & 1 & 4 & 5 & 6 & 7 \\
    \pi_3 & 3 & 2 & 0 & 1 & 4 & 5 & 6 & 7 \\
    \pi_4 & 4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\
    \pi_5 & 5 & 4 & 6 & 7 & 0 & 1 & 2 & 3 \\
    \pi_6 & 6 & 7 & 4 & 5 & 0 & 1 & 2 & 3 \\
    \pi_7 & 7 & 6 & 4 & 5 & 0 & 1 & 2 & 3 \\
    \pi_m & m & 6 & 4 & 5 & 0 & 1 & 2 & 3 \\
  \end{array}
\right]
$$

Это принципиально другой подход в отличие от канонического
определения, поскольку элементы переставляются, а в каноническом --
они остаются на месте............

Определение через ветви является связующим звеном между каноническим
определением и определением с помощью таблицы вытеснения, поскольку
$\beta_i$ -- это и есть позиция, которая меняется точно так же, как
и переставляется тег в наборе согласно таблице вытеснения.........
