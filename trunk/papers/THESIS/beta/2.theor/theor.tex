\chapter{Методы генерации ограничений для описания поведения тестовых программ}

\section{Совместная генерация ограничений}

В этом разделе формально ставится задача генерации тестовых данных
для последовательности тестовых ситуаций в кэширующем буфере,
выделяется подзадача описания механизма вытеснения и описывается
метод построения ограничений обозримого размера для генерации
тестовых программ по тестовым шаблонам с использованием ограничений.
Идея совместного метода заключается в использовании содержимого
нескольких кэширующих буферов и таблиц одновременно.

\subsection{Представление тестовых ситуаций в кэширующих буферах в виде
ограничений}

Тестовые шаблоны для последовательности инструкций описывают
ограничение на изменение состояния микропроцессора. Это изменение
достигается специальным выбором аргументов инструкций тестового
шаблона. Результат этого выбора фиксируется в виде тестовой
программы.

Методика генерации тестовых программ по тестовым шаблонам \emph{с
использованием ограничений} предполагает составление системы
ограничений, ее разрешение (результатом разрешения является модель
ограничений, т.е. значения переменных, на которых сформулированы
ограничения) и построение тестовой программы на основе модели
ограничений. Переменными могут являться значения регистров,
непосредственные значения в тестовой программе, значения в ячейках
оперативной памяти, значения в ячейках кэш-памяти и другие
подсистемы.

В данной работе особо важным классом инструкций будет являться класс
\emph{инструкций обращения к памяти}. Такие инструкций присутствуют
во всех микропроцессорах, входящих в состав вычислительных систем с
оперативной памятью. Инструкции обращения к памяти делятся на два
класса: \emph{инструкции загрузки данных из памяти} и
\emph{инструкции сохранения данных в памяти}. При исполнении такой
инструкции кроме оперативной памяти могут быть задействованы
некоторые специальные структуры данных-подсистемы микропроцессора- а
именно \emph{кэширующие буфера} и \emph{таблицы}.

Таблицы содержат последовательный набор данных, снабженный
индексами. Изменение содержимого таблиц осуществляется программно.
Пример таблицы -- таблица страниц виртуальной памяти. Изменение
содержимого этих таблиц осуществляется операционной системой.

Кэширующие буфера содержат множество пар (ячеек) <<(тег, значение)>>
заданного количества. Содержимое кэширующего буфера может меняться в
процессе работы микропроцессора: какие-то ячейки добавляются,
какие-то \emph{вытесняются}. Управление кэширующими буферами
осуществляется микропроцессором. Исполнение инструкции обращения к
памяти может включать в себя обращения к кэширующим буферам для
получения данных по некоторому тегу. Обращение к кэширующему буферу
может быть успешным (эта ситуация называется \emph{кэш-попаданием}),
если нужные данные есть в буфере, и неуспешным (эта ситуация
называется \emph{кэш-промахом}), если нужных данных нет в буфере.

Кэширующий буфер может быть \emph{подчинен} таблице, если при
неуспешном обращении к кэширующему буферу поиск данных продолжается
в таблице, при успешном -- обращение к таблице не производится. Если
поиск в таблице оказался успешным, то найденные данные добавляются в
кэширующий буфер (некоторые данные из кэширующего буфера при этом
вытесняются для поддержания постоянного размера буфера). Например, в
микропроцессоре MIPS RM7000~\cite{mips64_III} кэширующий буфер DTLB
подчинен таблице JoinTLB. Можно представить, что кэш-память
подчинена основной памяти, если рассматривать основную память как
таблицу, правда, основная память не является подсистемой
микропроцессора.

Тестовая ситуация инструкции обращения к памяти будет включать
указание на то, какие обращения к кэширующим буферам в данной
инструкции успешные, а какие -- нет.

Будем считать тестовую ситуацию на инструкцию обращения к памяти
\emph{полной}, если она содержит тестовые ситуации на все кэширующие
буфера, которые задействованы при исполнении этой инструкции.
Например, если микропроцессор содержит двухуровневую кэш-память и
при исполнении задействованы оба уровня кэш-памяти (например, в
кэш-памяти первого уровня происходит промах, а в кэш-памяти второго
уровня -- попадание), то тестовая ситуация на эту инструкцию
содержит тестовую ситуацию на кэш-память первого уровня и на
кэш-память второго уровня.

Данная работа не рассматривает тестовые шаблоны, в которых есть
инструкции обращения к памяти с неполными тестовыми ситуациями.

Обратимся более детально к построению ограничений по тестовым
шаблонам. Каждая инструкция при исполнении может поменять состояние
микропроцессора (значение регистров, содержимое кэширующих буферов и
таблиц). Значения регистров будут представляться <<скалярными>>
переменными. Содержимое кэширующих буферов будет представляться
\emph{множеством ячеек}. Содержимое кэширующих буферов можно
разделить на две структуры -- структура для хранения кэшированных
данных и структура для хранения тегов адресов кэшированных данных.
Для моделирования тестовых ситуаций в кэширующих буферах будет
использоваться только структура для хранения тегов, поскольку
тестовые ситуации на кэшируемые данные рассматриваться не будут.

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{2.theor/mpset}\\
  \caption{Представление состояния микропроцессора}\label{mpset}
\end{figure}

Ограничения для тестовых ситуаций в кэширующих буферах могут
включать адреса, с которыми работает инструкция.

\begin{utv}\label{hit_miss_simpleform}
Тестовые ситуации в кэширующих буферах имеют следующую простую
форму с использованием переменных $L$ -- текущее состояние
(содержимое) кэширующего буфера (множество тегов данных), $x$ -- тег
адреса данных в инструкции):
\begin{itemize}
\item \emph{кэш-попадание} выражается в виде ограничения $x \in L$;
\item \emph{кэш-промах} выражается в виде ограничения $x \notin L$.
\end{itemize}
\end{utv}

Для $x$ и $L$ надо составить дополнительные ограничения, описывающие
их значения. $x$ может быть составлен из аргументов инструкции
(обычно регистров) или быть результатом обращений к другим буферам и
таблицам.

Для переменной $L$ в каждой инструкции методом индукции может быть
составлено следующее выражение. База: $L$ для первой инструкции есть
начальное содержимое кэширующего буфера, это переменная величина в
системе уравнений. Теперь индуктивный шаг. Пусть выражение для
очередной инструкции $L$, а для следующей -- $L'$. Тогда если
тестовая ситуация очередной инструкции -- кэш-попадание, то $L'
\equiv L$ (так как содержимое не меняется), а если кэш-промах с
адресом $x$, то $L' \equiv (L \setminus \{x'\} \cup \{x\})$ (так как
в кэширующий буфер при промахе добавляются данные по нужному адресу,
а некоторые данные вытесняются, $x'$ есть адрес вытесняемых данных).
Для новой переменной $x'$ добавим в систему такие уравнения: $x' \in
L \wedge displaced(x') \wedge R(x) = R(x')$, предикат
$displaced(x')$ истинен, если $x'$ является адресов вытесняемых
данных в данной инструкции. Предикат $displaced$ описывает
\emph{стратегию вытеснения}, т.е. правило, по которому в кэширующем
буфере выбираются данные, которые следует удалить (вместе с тегом),
а на их место поместить данные, вызвавшие промах. Для кэширующего
буфера прямого отображения общезначимо утверждение $(R(x) = R(x'))
\rightarrow displaced(x')$, поэтому для такого типа кэширующих
буферов уравнение $displaced(x')$ можно исключить из ограничений.
Функциональный символ $R$ используется для задания набора, которому
относится адрес, в кэширующих буферах прямого отображения и
наборно-ассоциативных кэширующих буферах. Возможна такая семантика
этого символа -- $R(x)$ это множество адресов, которые потенциально
могут находиться в том же наборе, что и набор адреса $x$ (верно
утверждение, что адрес не может соответствовать более чем одному
набору и не соответствовать никакому набору вообще, одному набору
могут соответствовать разные адреса). Или такая семантика -- $R(x)$
это номер набора адреса $x$. Для составления уравнений может быть
выбрана любая семантика. Для полностью-ассоциативных кэширующих
буферов уравнение $R(x) = R(x')$ является тождественной истиной,
поскольку в нем все адреса соответствуют одному набору.

Следующая теорема описывает выражение для $L$ без использования
индукции и способ составления ограничений для тестовых ситуаций в
кэширующих буферах:
\begin{lemma}\label{L_current}
Пусть $L$ -- выражение для текущего состояния (содержимого)
кэширующего буфера, $L_0$ -- множество адресов данных, расположенных
в кэширующем буфере перед исполнением инструкций тестового шаблона,
$\{x_i\}$ -- множество адресов данных в инструкциях с кэш-промахами,
расположенными до текущей инструкции в том же порядке, что и в
тестовом шаблоне, $\{x'_i\}$ -- множество адресов вытесняемых данных
в инструкциях с кэш-промахами, расположенными до текущей инструкции
в том же порядке, что и в тестовом шаблоне. Тогда
$$L \equiv L_0 \setminus \bigcup_{i=1}^n \{x'_i\} \cup \bigcup_{i=1}^n (
\{x_i\} \setminus \cup_{j~=~i+1}^n \{x'_j\}).$$
\end{lemma}
\begin{proof}
По сути надо показать, что $( (L_0 \setminus \{x'_1\} \cup \{x_1\})
\setminus \{x'_2\} \cup \{x_2\}) ... \setminus \{x'_n\} \cup \{x_n\}
\equiv L_0 \setminus \bigcup_{i=1}^n \{x'_i\} \cup \bigcup_{i=1}^n (
\{x_i\} \setminus \cup_{j~=~i+1}^n \{x'_j\})$. Покажем это по
индукции. База: при $n = 0$ обе формулы имеют вид $L_0$, очевидно,
что они эквивалентны. Пусть эквивалентность установлена для
некоторого $n$, т.е. установлено, что $A \equiv ( (L_0 \setminus
\{x'_1\} \cup \{x_1\}) \setminus \{x'_2\} \cup \{x_2\}) ...
\setminus \{x'_n\} \cup \{x_n\} \equiv L_0 \setminus \bigcup_{i=1}^n
\{x'_i\} \cup \bigcup_{i=1}^n ( \{x_i\} \setminus \cup_{j~=~i+1}^n
\{x'_j\})$. Покажем, что $A \setminus \{x'_{n+1}\} \cup \{x_{n+1}\}
\equiv L_0 \setminus \bigcup_{i=1}^n \{x'_i\} \setminus \{x'_{n+1}\}
\cup \bigcup_{i=1}^n ( \{x_i\} \setminus (\cup_{j = i+1}^n \{x'_j\}
\cup \{x'_{n+1}\})) \bigcup \{x_{n+1}\}$. Для этого достаточно
применить правила дистрибутивности над множественными операциями: $A
\setminus \{x'_{n+1}\} \cup \{x_{n+1}\} \equiv (L_0 \setminus
\bigcup_{i=1}^n \{x'_i\} \cup \bigcup_{i=1}^n ( \{x_i\} \setminus
\cup_{j~=~i+1}^n \{x'_j\})) \setminus \{x'_{n+1}\} \cup \{x_{n+1}\}
\equiv L_0 \setminus \bigcup_{i=1}^n \{x'_i\}\setminus \{x'_{n+1}\}
\cup \bigcup_{i=1}^n ( \{x_i\} \setminus \cup_{j~=~i+1}^n \{x'_j\}
\setminus \{x'_{n+1}\} ) \cup \{x_{n+1}\}$.
\end{proof}

Например, если перед данной инструкцией располагается 3 инструкции с
кэш-промахом, то $L \equiv L_0 \setminus \{x'_1, x'_2, x'_3\} \cup
(\{x_1\} \setminus \{x'_2, x'_3\}) \cup (\{x_2\} \setminus \{x'_3\})
\cup \{x_3\}$.

\begin{theorem}[Дизъюнктивная форма уравнений для тестовых ситуаций
в кэширующих буферах]\label{hit_miss_equations} Пусть $L_0$ --
множество адресов данных, расположенных в кэширующем буфере перед
исполнением инструкций тестового шаблона, $\{x_i\}$ -- множество
адресов данных в инструкциях с кэш-промахами, расположенными до
текущей инструкции в том же порядке, что и в тестовом шаблоне,
$\{x'_i\}$ -- множество адресов вытесняемых данных в инструкциях с
кэш-промахами, расположенными до текущей инструкции в том же
порядке, что и в тестовом шаблоне. Тогда
\begin{itemize}
\item для инструкции с кэш-попаданием адреса $x$ следует добавить
следующую совокупность уравнений:
$$
\left[
   \begin{array}{l}
    x \in L_0 \wedge x \notin \{x'_1, x'_2, ..., x'_n\} \\
    x = x_1 \wedge x \notin \{x'_2, ..., x'_n\} \\
    x = x_2 \wedge x \notin \{x'_3, ..., x'_n\} \\
    ...\\
    x = x_{n-1} \wedge x \notin \{x'_n\} \\
    x = x_n \\
   \end{array}
  \right.
$$

\item для инструкции с кэш-промахом адреса $x$ (и адресом
вытесненных данных $x'$) следует добавить следующую систему
уравнений:
$$
\left\{
   \begin{array}{l}

  \left[
   \begin{array}{l}
    x \notin L_0 \wedge x \notin \{x_1, x_2, ..., x_n\} \\
    x = x'_1 \wedge x \notin \{x_2, ..., x_n\} \\
    x = x'_2 \wedge x \notin \{x_3, ..., x_n\} \\
    ...\\
    x = x'_{n-1} \wedge x \notin \{x_n\} \\
    x = x'_n \\
   \end{array}
  \right. \\

  { }\\

  \left[
   \begin{array}{l}
    x' \in L_0 \wedge x \notin \{x'_1, x'_2, ..., x'_n\} \\
    x' = x_1 \wedge x \notin \{x'_2, ..., x'_n\} \\
    x' = x_2 \wedge x \notin \{x'_3, ..., x'_n\} \\
    ...\\
    x' = x_{n-1} \wedge x \notin \{x'_n\} \\
    x' = x_n \\
   \end{array}
  \right. \\

  { }\\

  displaced(x')\\

  { }\\

  R(x) = R(x')\\

  \end{array}
\right.
$$

\end{itemize}
\end{theorem}
\begin{proof}
Применим утверждение~\ref{hit_miss_simpleform} для представления
тестовой ситуации и лемму~\ref{L_current} для записи текущего
состояния кэширующего буфера. Для вытесняемого тега записываем те же
ограничения, что и для кэш-попадания, поскольку вытесняемый тег
принадлежит текущему состоянию кэширующего буфера. Кроме того для
вытесняемого тега формулируются дополнительные ограничения --
$displaced(x')$ (стратегия вытеснения) и $R(x) = R(x')$ (из
определения вытеснения: вытесняемый тег обязательно относится к тому
же региону, что и вытесняющий).
\end{proof}

Заметьте, что получившиеся ограничения для кэш-попадания и
кэш-промаха получились очень похожими, хотя изначально у них было
два совершенно противоположных представления.

Теорему~\ref{hit_miss_equations} можно переформулировать без
использования вытеснямых тегов:

\begin{utv}\label{hit_miss_human} Пусть $L_0$ -- множество
адресов данных, расположенных в кэширующем буфере перед исполнением
первой инструкции тестового шаблона. Тогда
\begin{itemize}
\item для инструкции с кэш-попаданием адреса $x$ следует добавить
следующую совокупность уравнений:
$$
\left[
   \begin{array}{l}
    x \in L_0 \wedge x~\mbox{все еще не вытеснен} \\
    x~\mbox{внесен одним из кэш-промахов} \wedge \mbox{с тех пор не вытеснен} \\
   \end{array}
  \right.
$$

\item для инструкции с кэш-промахом адреса $x$ следует добавить следующую систему
уравнений ($\{x_i\}$ -- множество адресов данных в инструкциях с
кэш-промахами, расположенными до текущей инструкции):
$$
\left[
   \begin{array}{l}
    x \notin L_0 \wedge x \notin \{x_1, x_2, ..., x_n\} \\
    x~\mbox{был вытеснен} \wedge \mbox{не был больше внесен в буфер}\\
  \end{array}
\right.
$$

\end{itemize}
\end{utv}

Формально показано, что утверждение~\ref{hit_miss_human} описывает
все возможные сценарии появления и вытеснения данных в кэширующих
буферах. Однако применение этих ограничений в данном виде для
реальных микропроцессоров может быть ограничено из-за большого
размера $L_0$ (что влечет к большому размеру ограничений и к
невозможности разрешения таких больших ограничений доступными
инструментами). Далее будет показано, как \emph{совместное
рассмотрение} тестовых ситуаций разных буферов и таблиц позволят
существенно сократить размер этой формулы и обратиться к генерации
ограничений для описания вытеснения.

\subsection{Особенности исполнения инструкций обращения к памяти
на современных микропроцессорах}

В инструкции обращения к памяти в современных микропроцессорах
задействована не одна подсистема. Исполнение инструкции обращения к
памяти можно разбить на два этапа -- подготовка физического адреса и
собственно обращение с памятью (см.рис.~\ref{memoryAccess}).

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{2.theor/instr}\\
  \caption{Модель исполнения инструкции обращения к памяти}\label{memoryAccess}
\end{figure}

Подготовка физического адреса включает в себя формирование
\emph{виртуального адреса данных}, с которыми необходимо выполнить
операцию (некоторые архитектуры сначала вычисляется
\emph{эффективный адрес}, затем на его основе виртуальный, а на его
основе физический). Виртуальный адрес формируется на основе
аргументов инструкции. Формирование физического адреса на основе
виртуального адреса производится с использованием TLB. По сути в
виртуальном адресе выделяется номер страницы виртуальной памяти и
смещение внутри этой страницы, для страницы виртуальной памяти
выбирается соответствующий физический кадр, используя TLB, и,
наконец, физический адрес составляется из полученного номера
физического кадра и смещения внутри страницы (оно берется из
виртуального адреса). TLB содержит некоторое количество пар,
задающих соответствие номера страницы виртуальной памяти и номера
физического кадра. Размер самой страницы в виртуальной памяти и
физической памяти совпадает, поэтому смещение внутри страницы
используется в физическом адресе без изменений по сравнению с
виртуальным адресом.

Когда физический адрес готов, осуществляется обращение к памяти:
загрузка данных из памяти или сохранение данных в памяти. При этом
если данные по физическому адресу имеются в кэш-памяти, основная
память может остаться неизменной. Это сделано для повышения
эффективности работы с основной памятью.

%//////////////TODO зачем нужно было применять такие сложные вещи? может быть,
%20\% труда сделает 80\% работы (обычным рандомом), а в оставшемся
%небольшом остатке работы надо действовать более интеллектуально (а
%если вероятность (отношение количества тестовых данных к количеству
%значений в их области определения) не мала, то прагматический вопрос
%стоит очень остро); другой момент - \textbf{у Genesys-Pro очень
%много положительных моментов} и самый главный -- масштабируемость,
%напротив моё решение плохо масштабируемо, значит, надо искать
%критерий, по которому мое решение лучше... Если бы не цена
%Genesys-Pro, стоило ли делать эту работу?

\subsection{Уровни генерации тестовых данных}

Тестовая программа некоторым специальным образом меняет состояние
микропроцессора. Однако для того, чтобы это исполнение было
согласовано с тестовым шаблоном, необходимо перед исполнением
инструкций тестового шаблона перевести микропроцессор в некоторое
специальное состояние (изменить значения в регистрах, в ячейках
кэш-памяти и TLB, возможно в ячейках оперативной памяти). Практика
показала, что изменение значения в одном регистре делается одной
инструкцией, которая не затрагивает остальной части микропроцессора,
кроме данного регистра. Таким образом, изменение значений в
регистрах можно проводить последовательностью инструкций, каждая из
которых меняет один регистр. Значения, которые надо поместить в
регистры, входят в модель ограничений, генерируемых по тестовому
шаблону. По-иному ведут себя такие подсистемы, как кэш-память или
TLB, поскольку инструкции, которые изменяют их состояние независимо
от остальной части микропроцессора, могут отсутствовать. Иными
словами, одна инструкция может изменить состояние и кэш-памяти, и
TLB.

С точки зрения генерации ограничений эта особенность выражается в
возможности выделения частных случаев задачи, генерирования
некоторых специальных ограничений, которые кроме описания инструкций
будут соответствовать некоторому заданному способу подготовки
состояния микропроцессора. Переменными, на которые формулируются
такие ограничения, называются \emph{тестовыми данными}, а задача их
вычисления -- задачей \emph{генерации тестовых данных}. Эта задача
может быть представлена в следующих формах:
\begin{itemize}
\item \emph{простая форма:} найти начальное состояние
микропроцессора (тестовыми данными являются содержимое кэш-памяти,
TLB и других подсистем и значения регистров); генерирование
инструкций, приводящих кэш-память и TLB в это состояние, не входит в
ограничения и должно выполняться после разрешения ограничений (т.е.
получения тестовых данных); при выполнении тестовой программы
сгенерированные инструкции инициализации микропроцессора могут быть
исполнены некорректно и тогда на инструкциях тестового шаблона могут
не проявиться действительные ошибки или появиться ложные ошибки;
\item \emph{минимальная форма:} найти лишь значения регистров, используя
данное начальное состояние (содержимое) кэш-памяти, TLB и других
подсистем (тестовыми данными являются только значения регистров);
инструкции, подготавливающие состояние микропроцессора, не меняют
кэш-память и TLB, но в такой форме задача генерации тестовых данных
может быть неразрешима (при разрешимой другой форме);
\item \emph{смешанная форма:} требуется построить
значения регистров и последовательность инструкций инициализации
состояния микропроцессора (тестовыми данными являются значения
регистров и аргументы инструкций инициализации); эта форма является
компромиссом между простой и минимальной формой, правда в такой
форме увеличивается сложность задачи, потому что невозможно заранее
предугадать, сколько необходимо и достаточно дополнительных
инструкций.
\end{itemize}

Задачу поиска тестовых данных в минимальной форме будем называть
задачей генерации тестовых данных \emph{нулевого уровня}. Дальнейшие
уровни определяются возможностью изменять кэш-память и другие
подсистемы разными инструкциями. Например, для архитектуры
MIPS~\cite{mips64_II} были выделены следующие уровни генерации
тестовых данных помимо нулевого уровня:
\begin{itemize}
\item на \emph{первом уровне} разрешается менять те строки TLB,
которые не кэшированы в буфере TLB; изменение одной строки можно
делать независимо от остальных строк и буфера одной инструкцией
(TLBWI);
\item на \emph{втором уровне} разрешается менять любую строку TLB;
при этом кроме смены строк, не входящих в буфер TLB, нужно
переинициализировать содержимое буфера (на каждую строку отдельная
инструкция);
\item на \emph{третьем уровне} разрешается менять и TLB, и кэш-память.
\end{itemize}

Чем больше уровень, тем длиннее будет инициализирующая программа и
тем сложнее ее построить.

\subsection{Модульный алгоритм генерации тестовых
данных}\label{module_algorithm}

На основе представленной модели инструкции обращения к памяти можно
составить ограничения для каждого шага, получив тем самым
\emph{модульный алгоритм} генерации тестовых данных. Более
формально, пусть $\{(I_i, R_i, \{As\}_i, C_i, T_i)\}_{i=1, 2, ...,
n}$ -- тестовый шаблон, $\{I_i\}_{i=1, 2, ..., n}$ --
последовательность инструкций, $R_i$ -- регистр с данными,
$\{As\}_i$ -- параметры инструкции, задающие адрес в памяти,
$\{C_i\}_{i=1, 2, ..., n}$ -- последовательность тестовых ситуаций в
кэш-памяти, $\{T_i\}_{i=1, 2, ..., n}$ -- последовательность
тестовых ситуаций в TLB. Поскольку TLB может содержать
дополнительные буфера, ведущие себя как кэш-память, то в TLB также
возможны кэш-попадания и кэш-промахи. Тогда инструкция может быть
представлена в виде следующих уравнений для каждого $i$:
$$
\left\{
   \begin{array}{l}
    v_i = CalculateVirtualAddress(\{As\}_i) \\
    AddressTranslation(T_i,~p_i,~v_i,~TLB_0,~\{v_1,...,v_{i-1}\})\\
    CacheAccess(C_i,~p_i,~L_0,~\{p_1,...,p_{i-1}\})\\
    MemoryAccess(I_i,~R_i,~p_i,~\{p_1,...,p_{i-1}\},~\{R_1,...,R_{i-1}\})\\
   \end{array}
  \right.
$$
где $v_i$ и $p_i$ -- новые переменные, $TLB_0$ -- начальное
состояние (содержимое) TLB, $L_0$ -- начальное состояние
(содержимое) кэш-памяти, \\$CalculateVirtualAddress$ -- функция,
вычисляющая виртуальный адрес на основе аргументов инструкции.
$AddressTranslation$ -- предикат, описывающий трансляцию
виртуального адреса в физический (здесь может быть задействован
TLB). $CacheAccess, MemoryAccess$ -- предикаты, описывающие
обращение в память (в первом может быть задействована кэш-память, во
втором -- основная память).

Поскольку система уравнений для тестового шаблона составляется как
конъюнкция систем для каждой инструкции, то система из предикатов
может быть выделена в отдельные подзадачи (в этом проявляется
модульность). Таким образом выделяются следующие подзадачи:
\begin{itemize}
\item \emph{задача на TLB}
$$
\left\{
   \begin{array}{l}
    AddressTranslation(T_1,~p_1,~v_1,~TLB_0,~\varnothing)\\
    AddressTranslation(T_2,~p_2,~v_2,~TLB_0,~\{v_1\})\\
    ...\\
    AddressTranslation(T_n,~p_n,~v_n,~TLB_0,~\{v_1, ..., v_{n-1}\})\\
   \end{array}
  \right.
$$
\item \emph{задача на кэш-память}
$$
\left\{
   \begin{array}{l}
    CacheAccess(C_1, p_1, L_0, \varnothing)\\
    CacheAccess(C_2, p_2, L_0, \{p_1\})\\
    ...\\
    CacheAccess(C_n, p_n, L_0, \{p_1, ..., p_{n-1}\})\\
   \end{array}
  \right.
$$
\item \emph{задача на основную память}
$$
\left\{
   \begin{array}{l}
    MemoryAccess(I_1,~R_1,~p_1,~\varnothing, \varnothing)\\
    MemoryAccess(I_2,~R_2,~p_2,~\{p_1\}, \{R_1\})\\
    ...\\
    MemoryAccess(I_n,~R_n,~p_n,~\{p_1, ..., p_{n-1}\}, \{R_1, ..., R_{n-1}\})\\
   \end{array}
  \right.
$$
\end{itemize}

Задача на основную память задает соответствие между значениями
регистров, физическими адресами и значениями ячеек оперативной
памяти. Если представить основную память в виде одномерного массива
$memory$, индексация в котором идет по физическим адресам, то
\begin{itemize}
\item для инструкции, осуществляющей загрузку из памяти,
$MemoryAccess$ можно представлять как $R_i :=
memory[physicalAddress_i]$;
\item для инструкции, осуществляющей сохранение в памяти,
$MemoryAccess$ можно представлять как $memory[physicalAddress_i] :=
R_i$.
\end{itemize}
Таким образом, получается последовательность присваиваний, которая
может быть преобразована в систему уравнений с помощью
\emph{редукции Аккермана} (или
\emph{аккерманизации})~\cite{Ackermann}. А именно,
\begin{itemize}
\item для каждой упорядоченной пары инструкций (не обязательно
находящиеся подряд в тестовом шаблоне, но в том же порядке)\\
$STORE(R_1, p_1)$ и $LOAD(R_2, p_2)$ создается ограничение $$ (p_1 =
p_2 \wedge p_2 \notin \{ p_{(1)}, p_{(2)}, ..., p_{(k)}\})
\rightarrow R_1 = R_2$$ где $p_{(1)}, p_{(2)}, ..., p_{(k)}$ --
физические адреса инструкций $STORE$, расположенных между двумя
инструкциями этой пары;
\item для каждой упорядоченной пары инструкций (не обязательно
находящиеся подряд в тестовом шаблоне, но в том же порядке)\\
$LOAD(R_1, p_1)$ и $LOAD(R_2, p_2)$ создается ограничение $$ (p_1 =
p_2 \wedge p_2 \notin \{ p_{(1)}, p_{(2)}, ..., p_{(k)}\})
\rightarrow R_1 = R_2$$ где $p_{(1)}, p_{(2)}, ..., p_{(k)}$ --
физические адреса инструкций $STORE$, расположенных между двумя
инструкциями этой пары.
\end{itemize}

Задача на TLB должна задавать в виде ограничений соответствие между
начальным состоянием (содержимым) TLB, виртуальными адресами,
физическими адресами и вносимыми в TLB соответствиями в случае
промаха. Поскольку содержимое TLB также может быть рассмотрено в
виде массива записей, то для задачи на TLB тоже применима
аккерманизация. Кроме того, здесь также могут быть использованы
методы построения уравнений на множества тегов для описания тестовых
ситуаций на буферы, которые ведут себя как кэш-память, если таковые
присутствуют в TLB.

Для разрешения полученных ограничений применяется решатель CSP
(Constraint Satisfaction Problem)~\cite{CSP}. Сначала надо дать
определение, что такое CSP. Пусть $X = \{x_1, x_2, ..., x_n\}$ --
множество переменных (для каждой переменной известна область
определения -- обычно это конечное множество или ограниченный
интервал). CSP состоит из предикатов (\emph{ограничений}) $C(y_1,
y_2, ..., y_N)$, где $y_i \in X$ (см. рис.~\ref{csp}).

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{2.theor/csp}\\
  \caption{Constraint Satisfaction Problem}\label{csp}
\end{figure}

Решение задачи заключается в поиске значений переменных из областей
определения, на которых выполнены все предикаты. Основной методикой
решения CSP является \emph{constraint propagation}, а именно
итеративное построение новых ограничений на основе данного в задаче
множества ограничений (логических следствий). Если в процессе
constraint propagation будет построено тождественно ложное
ограничение, то CSP считается \emph{несовместной}. Иными словами,
для ее переменных не существует значений, при которых выполнены все
ограничения. Особо обращается внимание на одноместные ограничения,
поскольку с помощью них уменьшается область определения переменной.
Если constraint propagation не привел к тождественно ложному
ограничению, то если области определения уменьшены до единственного
значения, то это значение и будет ответом. Если же в области
определения всё ещё много значений, то для выбора из области
определения используются различные техники перебора
(последовательный перебор, перебор в случайном порядке, метод ветвей
и границ). Эвристические алгоритмы решения CSP обычно чередуют этапы
перебора значений и constraint propagation. Одними из таких
алгоритмов являются алгоритмы семейства MAC (Maintaining Arc
Consistency)~\cite{CSP}. Одним из важных направлений развития CSP
стала интеграция с парадигмой логического программирования --
результат этого слияния именуют CLP (Constraint Logic
Programming)~\cite{CLPusingECLiPSe}. Примеры систем CLP -- SICStus
Prolog~\cite{SICStus}, ILOG~\cite{ILOG},
ECLiPSe~\cite{CLPusingECLiPSe}.

Достоинством модульного алгоритма является простота построения
ограничений. Другим достоинством является его гибкость по отношению
к механизмам работы подсистем микропроцессора. Эти свойства успешно
использованы в инструменте Genesys-Pro~\cite{GenesysPro} от компании
IBM. Цель инструмента -- генерация тестовых программ по данным
тестовым шаблонам. Тестовые шаблоны позволяют задать инструкции
тестовой программы, ограничения на их аргументы и некоторые
параметры генерации аргументов. Тестовые программы строятся
итеративно по одной инструкции. А именно цель одного шага --
сгенерировать аргументы для очередной инструкции. Для этого на
основе аргументов инструкции и модели состояния микропроцессора
перед инструкцией составляется CSP, описывающая тестовую ситуацию.
Если эта CSP совместна, она разрешается с получением аргументов
инструкции, инструкция с построенными аргументами исполняется,
фиксируется состояние микропроцессора после этого и генерация
продолжается со следующей инструкции. Если эта CSP несовместна,
происходит возврат к предыдущей инструкции с целью сгенерировать для
нее другие аргументы. Тестовый шаблон может содержать указание
эвристики для выбора значения для переменной в ее области
определения. Кроме того тестовые шаблоны могут содержать указания
повторить некоторую последовательности инструкции некоторое
количество раз. Для тестирования механизмов трансляции этот
инструмент содержит специальный генератор ограничений
DeepTrans~\cite{DeepTrans}. Эффективность генерации тестовых
программ падает с усложнением тестовых шаблонов. В крайнем случае
вместо эффективного constraint propagation инструмент будет
перебирать всевозможные начальные состояния микропроцессора, пока не
подберется допустимый тестовым шаблоном.

Модульный алгоритм требует продвинутый решатель CSP, заточенный под
особенности генерации тестовых данных для тестовых шаблонов (как
минимум такие ограничения могут включать битовые операции). Подобный
решатель был разработан в IBM для инструмента
Genesys-Pro~\cite{GenesysSolver}. Создание такого решателя --
отдельное сложное исследование, которое не входило в цели данного
исследования. В данной работе было принято решение использовать
доступные существующие решатели (не обязательно CSP), а
сосредоточиться на упрощении генерируемых ограничений для некоторых
частных случаев архитектур. Кроме наличия битовых операций,
ограничения усложняются за счет огромных областей определения и
размерности переменных. Например, кэш-память может содержать порядка
$10^4-10^5$ тегов -- такие размерности могут вылиться в
невозможность даже просто хранить в памяти ограничения на такое
большое количество переменных.

\subsection{Метод совместной генерации ограничений}

Введем понятие <<тегсет>> и с помощью него выразим тестовые ситуации
в кэширующих буферах. Обращение к кэширующему буферу по данному
адресу осуществляется на основе тега и индекса, которые вычисляются
на основе адреса. По индексу из всех секций кэширующего буфера
выбираются пары <<(тег, значение)>>. Далее осуществляется поиск тега
адреса среди тегов выбранных пар. Зачастую тег адреса и индекс
адреса вычисляются как битовые поля адреса. Битовую конкатенацию
тега и индекса будем называть \emph{тегсетом} адреса. Если
кэширующий буфер является полностью ассоциативным, то тегсет
совпадает с тегом адреса.

\begin{figure}[h] \center
  \includegraphics[width=0.8\textwidth]{2.theor/cache_operation}\\
  \caption{Тег и индекс адреса}\label{cache_operation}
\end{figure}

В микропроцессорах зачастую тегсет является инвариантом при
обращениях в разные уровни кэш-памяти (обычно это делается для того,
чтобы не менялись оставшиеся биты физического адреса, они задают
смещение в строке кэш-памяти, и постоянство этих бит позволяет легко
перемещать строки кэш-памяти между разными уровнями).

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{2.theor/tagset}\\
  \caption{Тегсет физического адреса}\label{tagset}
\end{figure}

Тегсеты могут быть использованы для представления тестовых ситуаций
в кэширующих буферах с использованием ограничений таким же образом,
как это делалось для тегов: $x \in L$ для кэш-попадания и $x \notin
L$ для кэш-промаха, где $x$ -- тегсет адреса, а $L$ -- множество
тегсетов данных, хранящихся в кэширующем буфере перед исполнением
инструкции. Множество тегсетов составляется битовой конкатенацией
тега и индекса в каждом элементе начального содержимого кэширующего
буфера. Для тегсетов аналогичным образом формулируются и
доказываются лемма~\ref{L_current} и
теорема~\ref{hit_miss_equations} об ограничениях для тестовых
ситуаций в кэширующих буферах, сформулированных уже на тегсетах.

Рассмотрим следующее представление тестового шаблона, которое
назовем \emph{схемой последовательностей тестовых ситуаций}. По
одной оси будут располагаться инструкции тестового шаблона, по
другой оси -- кэширующие буферы микропроцессора
(см.рис.~\ref{template_scheme}). На пересечении инструкции и буфера
будет помещаться переменная -- тег или тегсет, если для этой
инструкции в тестовом шаблоне есть тестовая ситуация на обращение в
этот кэширующий буфер. Будем считать, что в исполнении инструкции
задействованы те кэширующие буферы, тестовые ситуации на которые
указаны в тестовом шаблоне для этой инструкции. Схема
последовательностей тестовых ситуаций позволяет увидеть имеющиеся в
тестовом шаблоне \emph{совместные} обращения в кэширующие буферы,
увидеть последовательности обращений к отдельным буферам, таким
образом оценить сложность будущих ограничений.

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{2.theor/template_scheme}\\
  \caption{Пример схемы последовательностей тестовых ситуаций}\label{template_scheme}
\end{figure}

Для каждой последовательности тестовых ситуаций вводятся
переменные-теги или тегсеты, а генерируемые для тестового шаблона
ограничения состоят из ограничений для каждой такой переменной и
ограничения, описывающие отношения введенных переменных. Этот
процесс можно выразить следующей последовательностью шагов:
\begin{enumerate}
  \item составить модель поведения MMU (выделить кэширующие буферы и
  таблицы);
  \item выделить последовательности тестовых ситуаций в тестовом
  шаблоне (составить \emph{схему последовательностей тестовых
  ситуаций});
  \item ввести переменные-теги тестовых ситуаций; если
  возможно, уменьшить количество переменных, заменив некоторые теги
  на тегсеты;
  \item выделить последовательности тестовых ситуаций, для записи
  которых потребуются большие массивы данных;
  \item построить ограничения для каждого тегсета -- при обращении к
  большим массивам данных строить \emph{совместные ограничения}.
\end{enumerate}

Последний шаг требует пояснения. Пусть имеются две тестовые ситуации
на кэширующие буферы. Упорядочим их в таком порядке, что данные,
полученные из первого буфера, связаны с тегом обращения ко второму
кэширующему буферу (см.рис.~\ref{conjunctive}). Причем первый
кэширующий буфер подчинен некоторой таблице.

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{2.theor/conjunctive}\\
  \caption{Совместные обращения в буферы}\label{conjunctive}
\end{figure}

В ограничениях появляется содержимое буферов целиком (иначе можно
просто выписать ограничения на первый и на второй буфер без
изменения). Согласно теореме~\ref{hit_miss_equations} для
кэш-попадания в первом буфере можно записать ограничения:
$$
\left[\begin{array}{l} t_1 \in T_1 \wedge \mbox{...}\\
t_1 = t_2 \wedge \mbox{...}
\end{array}\right.
$$

Значит, при этом тег принадлежит либо множеству тегов первого
буфера, либо множеству тегов из таблицы, которой подчинен первый
буфер. Из этого следует, что данные -- результат обращения в первый
буфер -- либо принадлежат данным из буфера ($TD_1$), либо
принадлежат данные из таблицы ($FD_1$). Для кэш-промаха ограничения:

$$
\left[\begin{array}{l} t_1 \notin T_1 \wedge \mbox{...}\\
t_1 = t_2' \wedge \mbox{...}
\end{array}\right.
$$

Соответственно, либо тег не принадлежит множеству тегов первого
буфера, но принадлежит множеству тегов в таблице, которой подчинен
первый буфер, либо тег принадлежит тегам той же таблицы (т.к. этим
тегам принадлежит $t_2'$). Значит, при кэш-промахе данные,
получаемые после обращения в первый кэширующий буфер, либо
принадлежат $FD_1 \setminus TD_1$, либо принадлежат $FD_1$.

Далее, учтем, что биты данных, полученных из первого буфера, связаны
с битами тега для обращения во второй буфер. Для обращения во второй
кэширующий буфер снова выпишем ограничения, согласно
теореме~\ref{hit_miss_equations}. Для кэш-попадания в одну из
конъюнкций входит большой массив тегов второго буфера:

$$
\left[\begin{array}{l} x_1 \in X_1 \wedge \mbox{...}\\
x_1 = x_2 \wedge \mbox{...}
\end{array}\right.
$$

Но поскольку тег связан с данными, полученными из первого буфера,
конъюнкция ограничений позволяет сократить множество тегов $L$,
оставив только те, которые подходят под множество констант,
участвующих в ограничении для обращения в первый буфер. Например,
вместо ограничения $x \in L$ если данные из первого буфера $d$
являются битовым полем $x$ (например, номер физического кадра
является битовым полем тегсета при обращении в кэш-память) и $d \in
DD$ можно записать ограничение $x \in L \cap [DD]$, т.е. $x \in
\{\lambda | \lambda \in L \wedge \lambda_{\mbox{биты данных}} \in
DD\}$. Соответствующее упрощение можно сделать и для $d$: $d \in
\widehat{L \cap [DD]}$, т.е. $d \in \{\delta | \delta \in DD \wedge
\exists x \in L : \delta = x_{\mbox{биты данных}}\}$. Множества
констант $L \cap [DD]$ и $\widehat{L \cap [DD]}$ могут быть
вычислены до генерации ограничений. Обычно множество $L \cap [DD]$
имеет значительно меньший размер, чем $L$, что позволяет существенно
сократить размер ограничений. В этом и заключается основной эффект
применения совместной генерации ограничений. Для кэш-промаха
получаются похожие ограничения, только вместо $x \notin L$ будет $x
\notin L \cap [DD]$.

Надо быть аккуратным, ведь не всегда таблицы и буферы имеют
действительно большой размер и иногда множество тегов, которое
входит в ограничения, может быть выписано целиком. Например, при
рассмотрении конъюнкции следующих подформул (первая получена от
кэш-попадания в кэш-памяти по тегу $x$, вторая получена от тестовой
ситуации в TLB, $\hat{x}$ -- номер физического кадра, входящий в
$x$):

$$
\left\{\begin{array}{l} x = x_i \wedge \mbox{...}\\
\hat{x} \in PFN \wedge \mbox{...}
\end{array}\right.
$$

искать множество $L$ и пересекать его с $PFN$ не нужно, потому как
$PFN$ небольшого размера выписывается целиком (а большого размера и
не участвует в ограничения -- см.теорему~\ref{hit_miss_equations}).



%Выражение -- множество констант -- в совместном ограничении на
%тегсет будем называть \emph{доменом} тегсета. С использованием этого
%определения сформулируем вариант теоремы~\ref{hit_miss_equations}
%для совместной генерации ограничений:
%
%\begin{utv}\label{hit_miss_human_domain} Пусть $D$ -- домен
%тегсета адреса $x$ текущей инструкции. Тогда
%\begin{itemize}
%\item если тестовая ситуация текущей инструкции -- кэш-попадание, то следует добавить
%следующую совокупность уравнений:
%$$
%\left[
%   \begin{array}{l}
%    x \in D \wedge x~\mbox{все еще не вытеснен} \\
%    x~\mbox{внесен одним из кэш-промахов} \wedge \mbox{с тех пор не вытеснен} \\
%   \end{array}
%  \right.
%$$
%
%\item если тестовая ситуация текущей инструкции -- кэш-промах, то следует добавить
%следующую совокупность уравнений ($\{x_i\}$ -- множество тегсетов
%предыдущих инструкций с кэш-промахами):
%$$
%\left[
%   \begin{array}{l}
%    x \notin D \wedge x \notin \{x_1, x_2, ..., x_n\} \\
%    x~\mbox{был внесен} \wedge x~\mbox{был затем вытеснен} \wedge \mbox{не был больше внесен в
%    кэш-память}\\
%    x \in D \wedge x~\mbox{был вытеснен} \wedge \mbox{не был больше внесен в
%    кэш-память}\\
%  \end{array}
%\right.
%$$
%
%\end{itemize}
%\end{utv}
%
%В заключение назову границы применимости совместной генерации
%ограничений. Начальное состояние кэш-памяти и TLB может быть
%использовано целиком для генерации тестовых данных нулевого уровня.
%Но для более высоких уровней надо применять более изощренные
%алгоритмы (например, вводить некую небольшую область в кэш-памяти и
%TLB, представлять ее переменными величинами, включать в ограничения,
%результатом разрешения этих ограничений будет инициализация этой
%неизвестной части). Другим важным требованием совместной генерации
%является \emph{существенность} совместного исполнения инструкции,
%иными словами, инструкция должна задействовать и кэш-память, и TLB
%(это может управляться сегментом виртуального адреса -- для
%трансляции виртуальных адресов из некоторых сегментов может не
%использоваться TLB, а обращение в память по физическим адресам,
%полученным из некоторых строк TLB, может происходить без участия
%кэш-памяти). В случае неотображаемого кэшируемого обращения (TLB не
%задействован, кэш-память задействована) нет возможности построить
%более компактную конъюнкцию.
%
%Однако несмотря на приведенные ограничения, метод совместной
%генерации ограничений можно рассматривать как быстрый
%\emph{достаточный} алгоритм решения задачи построения тестовых
%данных (не являющийся необходимым). И если он не дал решение, то
%воспользоваться уже другими более продвинутыми методами генерации
%тестовых данных.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\section{Зеркальная генерация тестовых данных}

Метод совместной генерации ограничений позволяет эффективно
построить тестовую программу, если для каждой инструкции имеется
более одного задействовано кэширующего буфера. Однако возможны
случаи, например, неотображаемого кэшируемого обращения в
микропроцессоре с TLB и кэш-памятью большого размера, когда в
ограничениях, генерируемых согласно
теореме~\ref{hit_miss_equations}, невозможно уменьшить размер $L_0$.

Другой случай -- это так называемая \emph{VIVT кэш-память}
(virtually indexed virtually tagged)~\cite{HennessyPatterson3rd}. В
этой кэш-памяти данные снабжены тегами виртуального адреса (в
virtually indexed physically tagged кэш-памяти данные снабжены
тегами физического адреса). Такая кэш-память в основном применяется
для кэширования инструкций. Эта кэш-память характеризуется тем, что
обращение к кэш-памяти первого уровня не требует предварительной
трансляции виртуального адреса в физический. Однако ограничения,
генерируемые согласно теореме~\ref{hit_miss_equations}, для
кэш-попадания нет возможности выделить совместное обращение (для
кэш-промаха совместное обращение возможно).

Противоположный случай -- когда составить систему ограничений
методом совместной генерации можно, но эта система оказывается
несовместной.

Однако если архитектура микропроцессора позволяет изменять
кэширующие буферы с помощью отдельных инструкций (возможно, при
особом значении некоторых регистров микропроцессора или области
виртуальной памяти), то можно воспользоваться этими инструкциями для
добавления в кэширующий буфер данных по тем тегам, которые будут
использованы в тестовой программе (а их уже можно выбирать
произвольно, что сильно упростит систему ограничений). При этом
можно не задумываться над тем, были ли эти теги в $L_0$ или нет.
Иными словами, если обращение к кэширующему буферу по некоторому
тегу должно быть успешным, то перед этим обращением должно быть
другое обращение по этому же тегу, после которого данные по этому
тегу не вытесняются до нужного обращения. Дополнительных
ограничений, кроме уже упомянутых, на тег не накладывается. Если
обращение к кэширующему буферу по некоторому тегу должно быть
неуспешным, то перед этим обращением всё равно должно быть другое
обращение по этому же тегу, после которого однако данные по этому
тегу должны быть вытеснены и не положены вновь до нужного обращения.
Таким образом, у каждого тега в тестового шаблона есть свой
<<зеркальный>> тег среди предыдущих тегов тестового шаблона или
дополнительных тегов инициализирующей программы.

Более формально, для данной последовательности тестовых ситуаций для
кэширующего буфера $(S_i, x_i)$, где $i = 1, 2, ..., n$, $S_i$ --
hit или miss, $x_i$ -- тег данных, требуется построить
последовательность тегов $t_j$ (\emph{инициализирующая
последовательность тегов}), $j = 1, 2, ..., m$, которые обеспечивают
данную последовательность тестовых ситуаций. Согласно зеркальному
методу для каждого данного тега $x_i$ при $S_i = $ hit надо
составить систему уравнений
$$
\left\{\begin{array}{l} x_i \in \{t_1, ..., t_m, x_1, ...,
x_{i-1}\}\\
x~\mbox{не вытеснен с момента последнего к нему}\\
\mbox{\quad обращения в}~t_1, ..., t_m, x_1, ..., x_{i-1}
\end{array} \right.
$$

а при $S_i = $ miss надо составить систему уравнений

$$
\left\{\begin{array}{l} x_i \in \{t_1, ..., t_m, x_1, ...,
x_{i-1}\}\\
x~\mbox{вытеснен и не добавлен с момента последнего}\\
\mbox{\quad к нему обращения в }~t_1, ..., t_m, x_1, ..., x_{i-1}
\end{array} \right.
$$

\begin{lemma}\label{monotonic_m}Если существует решение для некоторого $m$, то
существует решение и для $m+1$.
\end{lemma}
\begin{proof}
  Достаточно взять $t_{m+1} = t_m$.
\end{proof}

Ниже будет показано, что достаточно рассматривать $m$, ограниченные
линейной функцией от $n$ и $w$ (ассоциативности кэширующего буфера).
Поэтому может быть поставлена задача минимизации параметра $m$
(длины инициализирующей программы). Это увеличит качество
тестирования, поскольку уменьшит влияние дополнительных,
инициализирующих, инструкций на исполнение инструкций тестового
шаблона. Минимизация может быть эффективно выполнена с
использованием двоичного поиска оптимального значения $m$
(лемма~\ref{monotonic_m} показывает корректность применения
двоичного поиска) -- границу сверху для значения $m$ дает
теорема~\ref{mirror_fullness}.

\begin{utv}[Применимость зеркального метода]
Зеркальный метод генерации ограничений применим к данному тестовому
шаблону для данной архитектуры микропроцессоров, если система команд
микропроцессора содержит инструкции, позволяющие (при определенных
условиях) изменение задействованных в тестовом шаблоне кэширующих
буферов по отдельности от остальных кэширующих буферов.
\end{utv}

Например, в архитектуре MIPS~\cite{mips64_II} инструкции обращения к
памяти могут быть исполнены:
\begin{itemize}
  \item в некэширующем отображаемом режиме -- это позволяет изменять
  буфер данных TLB отдельно от кэш-памяти;
  \item в кэшируемом неотображаемом режиме -- это позволяет изменять
  кэш-память данных отдельно от буфера данных TLB.
\end{itemize}

При этом инструкции могут быть исполнены в кэшируемом или
отображаемом режиме по отношению к кэш-памяти инструкций или буферу
инструкций TLB. Для возможности применения зеркального метода в
случае, когда тестовый шаблон содержит тестовые ситуации на
кэш-память данных и на кэш-память инструкций, надо выбирать
расположение инициализирующих инструкций в памяти так, чтобы при
исполнении каждой такой инструкции был задействован всего один
кэширующий буфер.

Как будет показано далее, этих условий хватает для того, чтобы
зеркальный метод генерации ограничений был корректным, но не хватает
для его полноты. Однако для наиболее часто используемых в
микропроцессорах стратегий вытеснений зеркальный метод всё же
является полным.

\subsection{Корректность зеркального метода}

Далее формулируется и доказывается теорема о корректности
зеркального метода генерации ограничений. Она формально обоснует
применение зеркального метода для генерации тестовых программ по
тестовым шаблонам.

\begin{lemma}[Существование последнего
вытеснения]\label{lemma_latest_existance}
  Пусть $(S_i, x_i), i = 1, 2, \dots, n$ -- последовательность тегов с
  тестовыми ситуациями (если $S_i$ = miss, символом $x'_i$ будет обозначаться
  вытесняемый тег). Тогда если $S_n = $ miss и $x_n = x'_j$ для некоторого $j \in
  [1, n-1]$, то существует $k \in [j, n-1]$ такой, что $x_n = x'_k$
  и $x'_k \notin [x_{k+1}, \dots, x_{n-1}]_{\mbox{miss}}$
  ($[x_{k+1}, \dots, x_{n-1}]_{\mbox{miss}} \equiv \{x_p |
  p \in \{k+1, \dots, n-1\} \wedge S_p = \mbox{miss}\}$).
\end{lemma}
\begin{proof}
  Докажем от противного. Допустим, что такого $k$ не существует.
  Тогда получается, что для любого $l \in [j,n-1]$ справедлива дизъюнкция
  $x_n \neq x'_l$ или $x'_l \in [x_{l+1}, \dots,
  x_{n-1}]_{\mbox{miss}}$. В частности для $l = j$ получаем $x_n
  \neq x'_j \vee x'_j \in [x_{j+1}, \dots, x_{n-1}]_{\mbox{miss}}$.
  Так как по условию $x_n = x'_j$, то получаем, что существует такой
  $j_1 \in [j+1, \dots, n-1]$, что $x'_j = x_{j_1}$. Так как $x_n =
  x'_j$, то $x_n = x_{j_1}$. Тогда существует $j_2 \in [j_1+1, \dots,
  n-1]$ такой, что $x'_{j_2} = x_{j_1}$ (в противном случае $x_n
  \notin \{x'_{j_1+1}, \dots, x'_{n-1}\}$, что означает ситуацию,
  когда $x_n$ не будет вытеснен и останется в буфере, а это
  противоречит тому, что по условию $S_n$ = miss). Таким образом,
  существует $j_2$ такое, что $j_2 < n$ и $j_2 > j_1$ и $x_n =
  x'_{j_2}$. Получено то же условие, что и для $j$. Рассуждая
  аналогично, получим целую последовательность $j_3, j_4, \dots$.
  Поскольку $j_3 < j_4 < \dots < n$ (возрастающая
  последовательность, ограниченная сверху), то существует $j^*$
  такой, что $x_n = x_{j^*}$ и $x_{j^*} \notin \{x_{j^* + 1}, \dots,
  x_n\}$ (в противном случае будет нарушено $S_n$ = miss). Однако
  по предположению $x_n \neq x_{j^*}$ или $x_{j^*} \in \{x_{j^* + 1}, \dots,
  x_n\}$. Противоречие.
\end{proof}

\begin{theorem}[Корректность
зеркального метода]\label{mirror_correctness} Если зеркальный метод
генерации ограничений применим, то тестовая программа, построенная
по зеркальному методу удовлетворяет требованиям тестового шаблона
(тестовым ситуациям инструкций).
\end{theorem}
\begin{proof}
  Пусть $t_1, t_2, \dots, t_m$ -- последовательность
  инициализирующих тегов, $(S_1, x_1), (S_2, x_2), \dots, (S_n,
  x_n)$ -- тестовый шаблон, $x_1, x_2, \dots, x_n$ -- значения
  тегов, построенная в результате разрешения ограничений,
  сгенерированных согласно зеркальному методу.

  Без потери общности будем доказывать теорему для произвольного
  $x_i$ из $\{x_1, x_2, \dots, x_n\}$. Наша задача -- показать, что значение $x_i$,
  сгенерированное с помощью зеркального метода, соответствует
  тестовой ситуации $S_i$.

  Далее будут использованы следующие обозначения для произвольной
  последовательности тегов $\alpha_1, \alpha_2, ..., \alpha_N$:
  $[\alpha_1, \alpha_2, ..., \alpha_N]$ -- это подпоследовательность
  последовательности $\alpha_1, \alpha_2, ..., \alpha_N$, состоящая
  только из тех тегов, обращения к которым дают кэш-промах
  (\emph{подпоследовательность вытесняющих тегов}); $[\alpha_1,
  \alpha_2, ..., \alpha_N]'$ -- это последовательность всех тегов,
  вытесняемых тегами из $[\alpha_1, \alpha_2, ..., \alpha_N]$ с
  сохранением порядка ( \emph{подпоследовательность вытесняемых
  тегов} ).

  Зафиксируем некоторое начальное состояние кэширующего буфера перед
  последовательностью инициализирующих тегов $L_0$. Тогда каждому
  элементу этой последовательности $t_k$ можно приписать <<тестовую
  ситуацию>> $R_k$ ($R_k$ = hit или $R_k$ = miss) в зависимости от
  того, успешным или неуспешным было обращение к $t_k$ в буфере.

  \paragraph{Рассмотрим сначала случай $S_i$ = hit.}
  По условию $x_i$ сгенерирован с помощью зеркального метода, т.е.
  $x_i \in \{t_1, t_2, \dots, t_m, x_1, x_2, \dots, x_{i-1}\}$ и
  $x_i$ не равен ни одному вытесняемому тегу после последнего
  обращения к $x_i$. Запишем это условие с использованием операций
  над множествами (от последовательности используется множество
  элементов):
  $$\left[\begin{array}{l}\label{xxxxxx}
    x_i = t_1 \wedge x_i \notin [t_2, t_3, \dots, t_m]' \wedge x_i \notin \{y'_1, y'_2, \dots, y'_p\}\\
    x_i = t_2 \wedge x_i \notin [t_3, t_4, \dots, t_m]' \wedge x_i \notin \{y'_1, y'_2, \dots, y'_p\}\\
    ...\\
    x_i = t_m \wedge x_i \notin \{y'_1, y'_2, \dots, y'_p\}\\
    x_i = x_1 \wedge x_i \notin [x_2, x_3, \dots, x_{i-1}]'\\
    x_i = x_2 \wedge x_i \notin [x_3, x_4, \dots, x_{i-1}]'\\
    ...\\
    x_i = x_{i-1}\\
  \end{array}\right.$$
  где последовательность $y_1, y_2, ..., y_p \equiv [x_1, x_2, ...,
  x_{i-1}]$, последовательность $y'_1, y'_2, ..., y'_p \equiv [x_1,
  x_2, ..., x_{i-1}]'$


  Надо показать, что из этого условия следует следующее условие:
  $$
  \left[ \begin{array}{l}\label{yyyyyyyy}
    x_i \in L_1 \wedge x_i \notin \{y'_1, y'_2, ..., y'_p\}\\
    x_i = y_1 \wedge x_i \notin \{y'_2, y'_3, ..., y'_p\}\\
    x_i = y_2 \wedge x_i \notin \{y'_3, y'_4, ..., y'_p\}\\
    ...\\
    x_i = y_p\\
  \end{array}\right.
  $$
  где $L_1$ -- содержимое кэширующего буфера перед инструкциями
  тестового шаблона (после $t_m$).

  По теореме~\ref{hit_miss_equations} выражение $x_i \in L_1$ может
  быть переписано в следующем эквивалентном виде:
  $$
  \left[ \begin{array}{l}
  x_i \in L_0 \wedge x_i \notin \{s'_1, s'_2, ..., s'_q\}\\
  x_i = s_1 \wedge x_i \notin \{s'_2, s'_3, ..., s'_q\}\\
  x_i = s_2 \wedge x_i \notin \{s'_3, s'_4, ..., s'_q\}\\
  ...\\
  x_i = s_q\\
  \end{array} \right.
  $$
  где последовательность $s_1, s_2, ..., s_q \equiv [t_1, t_2, ...,
  t_m]$, а последовательность $s'_1, s'_2, ..., s'_q \equiv [t_1, t_2,
  ..., t_m]'$.

  Далее будет показано, что каждый элемент дизъюнкции~\ref{xxxxxx}
  будет присутствовать среди элементов дизъюнкции~\ref{yyyyyyyy},
  что и даст нужное обоснование.

  Рассмотрим $k$'й элемент дизъюнкции~\ref{xxxxxx} ($k = 1, 2, ..., m$).
  Если $R_k$ = miss, то элемент дизъюнкции $x_i = t_k \wedge x_i
  \notin \{s'_{r+1}, s'_{r+2}, \dots, s'_q\} \wedge x_i \notin \{y'_1,
  y'_2, \dots, y'_p\}$ входит целиком в дизъюнкцию~\ref{yyyyyyyy} для
  $r$ такого, что $t_k \equiv s_r$, так как $x_i = s_r \wedge x_i
  \notin \{s'_{r+1}, s'_{r+2}, \dots, s'_q\}$ является частью $x_i
  \in L_1$.

  Если $R_k$ = hit, то по теореме~\ref{hit_miss_equations} $x_i =
  t_k$ можно записать в следующем эквивалентном виде:
  $$\left[\begin{array}{l}
  x_i \in L_0 \wedge x_i \notin \{s'_1, s'_2, ..., s'_r\}\\
  x_i = s_1 \wedge x_i \notin \{s'_2, s'_3, ..., s'_r\}\\
  x_i = s_2 \wedge x_i \notin \{s'_3, s'_4, ..., s'_r\}\\
  ...\\
  x_i = s_r\\
  \end{array} \right.
  $$
  где $s_r$ -- ближайший предыдущих элемент к $t_k$ (или более
  формально $t_k \in \{s_1, s_2, ..., s_{r+1}\} \setminus \{s_1, s_2, ...,
  s_r\}$). Таким образом, элемент дизъюнкции $x_i = t_k \wedge x_i
  \notin \{s'_{r+1}, s'_{r+2}, \dots, s'_q\} \wedge x_i \notin \{y'_1,
  y'_2, \dots, y'_p\}$ эквивалентен дизъюнкции
  $$\left[\begin{array}{l}
  x_i \in L_0 \wedge x_i \notin \{s'_1, s'_2, ..., s'_q\} \wedge x_i \notin \{y'_1,
  y'_2, \dots, y'_p\}\\
  x_i = s_1 \wedge x_i \notin \{s'_2, s'_3, ..., s'_q\} \wedge x_i \notin \{y'_1,
  y'_2, \dots, y'_p\}\\
  x_i = s_2 \wedge x_i \notin \{s'_3, s'_4, ..., s'_q\} \wedge x_i \notin \{y'_1,
  y'_2, \dots, y'_p\}\\
  ...\\
  x_i = s_q \wedge x_i \notin \{y'_1, y'_2, \dots, y'_p\}\\
  \end{array}\right.
  $$
  Получен нужный вид части дизъюнкции~\ref{yyyyyyyy}.

  Рассмотрим $k+m$'й элемент дизъюнкции~\ref{xxxxxx} ($k = 1, 2, ...,
  i-1$).
  Если $S_k$ = miss, то $k+m$'й элемент дизъюнкции~\ref{xxxxxx} без
  изменений переходит в дизъюнкцию~\ref{yyyyyyyy}. Если $S_k$ = hit, то
  по теореме~\ref{hit_miss_equations} $x_i = x_k$ можно записать в
  следующем виде:
  $$\left[\begin{array}{l}
  x_i \in L_0 \wedge x_i \notin \{s'_1, s'_2, ..., s'_q\} \wedge \notin \{y'_1, y'_2, ..., y'_{p_i}\}\\
  x_i = s_1 \wedge x_i \notin \{s'_2, s'_3, ..., s'_q\}  \wedge \notin \{y'_1, y'_2, ..., y'_{p_i}\\
  x_i = s_2 \wedge x_i \notin \{s'_3, s'_4, ..., s'_q\}  \wedge \notin \{y'_1, y'_2, ..., y'_{p_i}\\
  ...\\
  x_i = s_q  \wedge \notin \{y'_1, y'_2, ..., y'_{p_i} \\
  x_i = y_1  \wedge \notin \{y'_2, y'_3, ..., y'_{p_i}\\
  x_i = y_2  \wedge \notin \{y'_3, y'_4, ..., y'_{p_i}\\
  ...\\
  x_i = y_{p_i}\\
  \end{array} \right.
  $$
  где $y_{p_i}$ -- ближайший предыдущих элемент к $x_k$ (или более
  формально $x_k \in \{y_1, y_2, ..., y_{p_i+1}\} \setminus \{y_1, y_2, ...,
  y_{p_i}\}$). Таким образом, элемент дизъюнкции $x_i = x_k \wedge x_i
  \notin \{y'_{p_i+1}, y'_{p_i+2}, \dots, y'_p\}$ эквивалентен дизъюнкции
  $$\left[\begin{array}{l}
  x_i \in L_0 \wedge x_i \notin \{s'_1, s'_2, ..., s'_q\} \wedge \notin \{y'_1, y'_2, ..., y'_p\}\\
  x_i = s_1 \wedge x_i \notin \{s'_2, s'_3, ..., s'_q\}  \wedge \notin \{y'_1, y'_2, ..., y'_p\}\\
  x_i = s_2 \wedge x_i \notin \{s'_3, s'_4, ..., s'_q\}  \wedge \notin \{y'_1, y'_2, ..., y'_p\}\\
  ...\\
  x_i = s_q  \wedge x_i \notin \{y'_1, y'_2, ..., y'_p\} \\
  x_i = y_1  \wedge x_i \notin \{y'_2, y'_3, ..., y'_p\}\\
  x_i = y_2  \wedge x_i \notin \{y'_3, y'_4, ..., y'_p\}\\
  ...\\
  x_i = y_{p_i} \wedge x_i \notin \{y'_{p_i+1}, y'_{p_i+2}, ..., y'_p\}\\
  \end{array} \right.
  $$
  которая является частью дизъюнкции~\ref{yyyyyyyy}.

  \paragraph{Теперь рассмотрим случай $S_i$ = miss.}
  По условию $x_i$ сгенерирован с помощью зеркального метода, т.е.
  $x_i \in \{t_1, t_2, \dots, t_m, x_1, x_2, \dots, x_{i-1}\}$ и
  $x_i$ равен некоторому вытесняемому тегу после последнего
  обращения к $x_i$. Запишем это условие с использованием операций
  над множествами (от последовательности используется множество
  элементов):
  $$\left[\begin{array}{l}\label{xxxxxx1}
    x_i = t_1 \wedge (x_i \in [t_2, t_3, \dots, t_m]' \vee x_i \in \{y'_1, y'_2, \dots, y'_p\})\\
    x_i = t_2 \wedge (x_i \in [t_3, t_4, \dots, t_m]' \vee x_i \in \{y'_1, y'_2, \dots, y'_p\})\\
    ...\\
    x_i = t_m \wedge (x_i \in \{y'_1, y'_2, \dots, y'_p\})\\
    x_i = x_1 \wedge (x_i \in [x_2, x_3, \dots, x_{i-1}]')\\
    x_i = x_2 \wedge (x_i \in [x_3, x_4, \dots, x_{i-1}]')\\
    ...\\
    x_i = x_{i-2} \wedge (x_i \in [x_{i-1}]')\\
  \end{array}\right.$$
  где последовательность $y_1, y_2, ..., y_p \equiv [x_1, x_2, ...,
  x_{i-1}]$, а последовательность $y'_1, y'_2, ..., y'_p \equiv [x_1,
  x_2, ..., x_{i-1}]'$.

  Надо показать, что из этого условия следует следующее условие:
  $$
  \left[ \begin{array}{l}\label{yyyyyyyy1}
    x_i \notin L_1 \wedge x_i \notin \{y_1, y_2, ..., y_p\}\\
    x_i = y'_1 \wedge x_i \notin \{y_2, y_3, ..., y_p\}\\
    x_i = y'_2 \wedge x_i \notin \{y_3, y_4, ..., y_p\}\\
    ...\\
    x_i = y'_p\\
  \end{array}\right.
  $$
  где $L_1$ -- содержимое кэширующего буфера перед инструкциями
  тестового шаблона (т.е. после $t_m$).

  По теореме~\ref{hit_miss_equations} выражение $x_i \notin L_1$ может
  быть переписано в следующем эквивалентном виде:
  $$
  \left[ \begin{array}{l}
  x_i \notin L_0 \wedge x_i \notin \{s_1, s_2, ..., s_q\}\\
  x_i = s'_1 \wedge x_i \notin \{s_2, s_3, ..., s_q\}\\
  x_i = s'_2 \wedge x_i \notin \{s_3, s_4, ..., s_q\}\\
  ...\\
  x_i = s'_q\\
  \end{array} \right.
  $$
  где последовательность $s_1, s_2, ..., s_q \equiv [t_1, t_2, ...,
  t_m]$, а последовательность $s'_1, s'_2, ..., s'_q \equiv [t_1, t_2,
  ..., t_m]'$. С учетом этого дизъюнкция~\ref{yyyyyyyy1}
  переписывается в виде:
  $$
  \left[ \begin{array}{l}\label{yyyyyyyy2}
    x_i \notin L_0 \wedge x_i \notin \{s_1, s_2, ..., s_q\}\wedge x_i \notin \{y_1, y_2, ..., y_p\}\\
    x_i = s'_1 \wedge x_i \notin \{s_2, s_3, ..., s_q\}\wedge x_i \notin \{y_1, y_2, ..., y_p\}\\
    x_i = s'_2 \wedge x_i \notin \{s_3, s_4, ..., s_q\}\wedge x_i \notin \{y_1, y_2, ..., y_p\}\\
    ...\\
    x_i = s'_q \wedge x_i \notin \{y_1, y_2, ..., y_p\}\\
    x_i = y'_1 \wedge x_i \notin \{y_2, y_3, ..., y_p\}\\
    x_i = y'_2 \wedge x_i \notin \{y_3, y_4, ..., y_p\}\\
    ...\\
    x_i = y'_p\\
  \end{array}\right.
  $$

  Далее будет показано, что каждый элемент дизъюнкции~\ref{xxxxxx1}
  будет присутствовать среди элементов дизъюнкции~\ref{yyyyyyyy2},
  что и даст нужное обоснование.

  Сначала избавимся от тех элементов дизъюнкции~\ref{xxxxxx1} среди первых $m$
  элементов $x_i = t_k \wedge ...$, в которых $R_k$ = hit. По
  теореме~\ref{hit_miss_equations}:
  $$\left[ \begin{array}{l}
  t_k \in L_0 \wedge x_i \notin \{s'_1, s'_2, ..., s'_r\}\\
  t_k = s_1 \wedge x_i \notin \{s'_2, s'_3, ..., s'_r\}\\
  t_k = s_2 \wedge x_i \notin \{s'_3, s'_4, ..., s'_r\}\\
  ...\\
  t_k = s_r\\
  \end{array} \right.
  $$
  где $s_r$ -- ближайший предыдущих элемент к $t_k$ (или более
  формально $t_k \in \{s_1, s_2, ..., s_{r+1}\} \setminus \{s_1, s_2, ...,
  s_r\}$). С учетом этого равенство $x_i = t_k$ преобразуется
  эквивалентным образом в дизъюнкцию:
  $$\left[ \begin{array}{l}
  x_i \in L_0 \wedge x_i \notin \{s'_1, s'_2, ..., s'_r\}\\
  x_i = s_1 \wedge x_i \notin \{s'_2, s'_3, ..., s'_r\}\\
  x_i = s_2 \wedge x_i \notin \{s'_3, s'_4, ..., s'_r\}\\
  ...\\
  x_i = s_r\\
  \end{array} \right.
  $$
  что дает возможность переписать эквивалентным образом
  дизъюнкцию~\ref{xxxxxx1} с использованием правила поглощения в следующем виде:
  $$\left[\begin{array}{l}\label{xxxxxx2}
    x_i \in L_0 \wedge (x_i \in \{y'_1, y'_2, ..., y'_p\})\\
    x_i = s_1 \wedge (x_i\in\{s'_2, s'_3, ..., s'_q\} \vee x_i
    \in \{y'_1, y'_2, ..., y'_p\})\\
    x_i = s_2 \wedge (x_i\in\{s'_3, s'_4, ..., s'_q\} \vee x_i
    \in \{y'_1, y'_2, ..., y'_p\})\\
    ...\\
    x_i = s_m \wedge x_i \in \{y'_1, y'_2, ..., y'_p\}\\
    x_i = x_1 \wedge (x_i \in [x_2, x_3, \dots, x_{i-1}]')\\
    x_i = x_2 \wedge (x_i \in [x_3, x_4, \dots, x_{i-1}]')\\
    ...\\
    x_i = x_{i-2} \wedge (x_i \in [x_{i-1}]')\\
  \end{array}\right.$$

  Сгруппируем элементы этой ДНФ следующим образом:
  $$\left[\begin{array}{l}
    x_i = s'_2 \wedge (x_i \in \{s_1\} \vee x_i \in L_0)\\
    x_i = s'_3 \wedge (x_i \in \{s_1, s_2\} \vee x_i \in L_0) \\
    ...\\
    x_i = s'_q \wedge (x_i \in \{s_1, s_2, ..., s_{q-1}\} \vee x_i \in L_0)\\
    x_i \in \{y'_1, y'_2, ..., y'_p\} \wedge (x_i \in \{s_1, s_2, ...,
    s_q\} \vee x_i \in L_0)\\
    x_i = x_1 \wedge (x_i \in [x_2, x_3, \dots, x_{i-1}]')\\
    x_i = x_2 \wedge (x_i \in [x_3, x_4, \dots, x_{i-1}]')\\
    ...\\
    x_i = x_{i-2} \wedge (x_i \in [x_{i-1}]')\\
  \end{array}\right.$$

  Рассмотрим каждый элемент этой дизъюнкции $x_i = s'_k \wedge
  (x_i \in \{s_1, s_2, ..., s_{k-1}\} \vee x_i \in L_0)$. По
  лемме~\ref{lemma_latest_existance} следует, что существует такой
  (<<последний>>) $s_{k'}$ ($k' \in [k+1, ..., i-1]$), что $s'_{k'} = s'_k$ и
  $s'_{k'} \notin \{s_{k'+1}, ..., s_q, y_1, ..., y_p\}$, или существует такой
  $y_{i'}$ ($i' \in [1, p]$), что $s'_k = y_{i'}$ и $s_k \notin
  \{y_{i'+1}, ...,y_p\}$. Это условие можно записать в виде
  дизъюнкции по всем $k'$ из $[k+1, ..., i-1]$ и $i'$ из $[1, p]$
  следующим образом:
  $$\left[\begin{array}{l}
    x_i = s'_2 \wedge x_i = s'_3 \wedge (x_i \notin\{s_4, s_5, ...,
    s_q, y_1, ..., y_p\}\\
    x_i = s'_2 \wedge x_i = s'_4 \wedge (x_i \notin\{s_5, s_6, ...,
    s_q, y_1, ..., y_p\}\\
    ...\\
    x_i = s'_3 \wedge x_i = s'_4 \wedge (x_i \notin\{s_5, s_6, ...,
    s_q, y_1, ..., y_p\}\\
    x_i = s'_3 \wedge x_i = s'_5 \wedge (x_i \notin\{s_6, s_7, ...,
    s_q, y_1, ..., y_p\}\\
    ...\\
    x_i \in \{y'_1, y'_2, ..., y'_p\} \wedge (x_i \in \{s_1, s_2, ...,
    s_q\} \vee x_i \in L_0)\\
    x_i = x_1 \wedge (x_i \in [x_2, x_3, \dots, x_{i-1}]')\\
    x_i = x_2 \wedge (x_i \in [x_3, x_4, \dots, x_{i-1}]')\\
    ...\\
    x_i = x_{i-2} \wedge (x_i \in [x_{i-1}]')\\
  \end{array}\right.$$
  Преобразуем дизъюнкцию, используя тождество $s_k \neq s'_k$ для всех
  $k$:
  $$\left[\begin{array}{l}
    x_i = s'_2 \wedge x_i \notin\{s_3, s_4, ..., s_q, y_1, ..., y_p\}\\
    x_i = s'_2 \wedge x_i \notin\{s_4, s_5, ..., s_q, y_1, ..., y_p\}\\
    ...\\
    x_i = s'_3 \wedge x_i \notin\{s_4, s_5, ..., s_q, y_1, ..., y_p\}\\
    x_i = s'_3 \wedge x_i \notin\{s_5, s_6, ..., s_q, y_1, ..., y_p\}\\
    ...\\
    x_i \in \{y'_1, y'_2, ..., y'_p\} \wedge (x_i \in \{s_1, s_2, ...,
    s_q\} \vee x_i \in L_0)\\
    x_i = x_1 \wedge (x_i \in [x_2, x_3, \dots, x_{i-1}]')\\
    x_i = x_2 \wedge (x_i \in [x_3, x_4, \dots, x_{i-1}]')\\
    ...\\
    x_i = x_{i-2} \wedge (x_i \in [x_{i-1}]')\\
  \end{array}\right.$$

  Из этой системы следует искомая дизъюнкция (над $[x_k, x_{k+1}, \dots, x_{i-1}]'$
  надо выполнить те же преобразования, что проводились для $[t_k, t_{k+1}, \dots, t_m]'$).
\end{proof}

\subsection{Полнота зеркального метода. Верхняя оценка длины
инициализирующей программы}

Далее сформулируем и докажем теорему о полноте зеркального метода
генерации ограничений. Из нее будет следовать в частности то, что
метод можно использовать для определения возможности построения хотя
бы одной тестовой программы для данного тестового шаблона.

Будем называть тестовый шаблон \emph{совместным}, если для него
существует удовлетворяющая ему тестовая программа.

\begin{theorem}[Полнота зеркального метода]\label{mirror_fullness}
Если данный тестовый шаблон является совместным, т.е. для
последовательности тестовых ситуаций $(S_1, x_1), (S_2, x_2), ...,
(S_n, x_n)$ и дополнительного ограничения $P(x_1, x_2, ..., x_n)$
при некотором начальном состоянии $L_1$ существует удовлетворяющая
им последовательность тегов $x_1, x_2, ..., x_n$, применим
зеркальный метод генерации ограничений и стратегия вытеснения
позволяет рано или поздно вытеснить любой тег в буфере, то с помощью
зеркального метода может быть построена система ограничений, имеющая
решение для той же последовательности тегов $x_1, x_2, ..., x_n$.
\end{theorem}
\begin{proof}
  Доказательство проведем указанием способа построения
  последовательности инициализирующих тегов $t_1, t_2, ..., t_m$ по
  известной последовательности $x_1, x_2, ..., x_n$. Выделим из
  последовательности $x_1, x_2,..., x_n$ подпоследовательности,
  соответствующие одинаковому значению региона. Части тестового
  шаблона, соответствующие разным регионам, ведут себя независимо,
  поэтому и последовательность инициализирующих тегов будет
  составляться из подпоследовательностей инициализирующих тегов для
  подпоследовательностей последовательности $x_1, x_2, ..., x_n$.
  Далее без ограничения общности можно считать, что все $x_1, x_2,
  ..., x_n$ относятся к одному региону.

  Сначала поместим в последовательность инициализирующих тегов
  \textbf{различные} теги в таком количестве, чтобы вытеснить все теги из
  кэширующего буфера, которые там были до первого инициализирующего
  тега (назовем эту последовательность <<вытесняющей последовательностью>>).
  В отличие от последовательности тегов тестового шаблона теги в
  вытесняющей последовательности не снабжаются указанием тестовой
  ситуации. Плюс к этому последовательность должна обеспечивать
  вытеснение при любом начальном состоянии кэширующего буфера $L_0$
  (только в тот момент, когда $L_0$ станет известен, можно будет
  точно сказать, успешным или неуспешным будет обращение по тегу
  вытесняющей последовательности). Однако по условию теоремы
  стратегия вытеснения обеспечивает вытеснение любого тега $L_0$ за
  конечное количество обращений. Соответственно конечное же
  количество обращений \textbf{различных} тегов обеспечит вытеснение
  всех тегов $L_0$. Начиная с некоторого элемента вытесняющей последовательности,
  каждое обращение будет приводить к кэш-промаху (это можно сказать
  точно, даже не зная содержимого $L_0$).

  Обязательно в эту последовательность вставим те теги из
  последовательности $x_1, x_2, ..., x_n$, которые должны давать
  кэш-промахи. Тем самым для этих тегов будет выполнено требование
  <<зеркальности>> (к тегу должно быть обращение и после этого тег
  должен быть вытеснен).

  С помощью выбора подходящей вытесняющей последовательности можно
  добиться любого наперед заданного состояния буфера. Осталось добиться
  того, чтобы для еще не упомянутых тегов из $x_1,
  x_2, ..., x_n$ был выполнен зеркальный принцип. Для этого добавим
  после вытесняющей последовательности нужные теги, возможно,
  перемешивая их с тегами, чьи значения не используются среди $x_1,
  x_2, ..., x_n$, для помещения первых на нужные позиции в буфере.
  Эти позиции задаются определением стратегии вытеснения в зеркальном
  методе для кэш-попадания (т.е. правило того, что тег не должен быть
  вытеснен). Ограничения для таких правил будут разрешимы, поскольку
  существуют $x_1, x_2, ..., x_n$.
\end{proof}

Как определять, позволяет ли стратегия вытеснения вытеснить любой
тег в наборе? (тем самым понять, полным ли будет зеркальный метод
генерации ограничений для данной стратегии вытеснения) Для ответа на
этот вопрос дадим более точное определение стратегии вытеснения,
нежели просто <<правило определения вытесняемого тега>>. Для этого
воспользуемся \emph{таблицами вытеснения} (\emph{policy table}). Они
были предложены в 2008 году исследователями из немецкого
университета Саарланда~\cite{policy_tables}. Таблица вытеснения
однозначно описывает изменение порядка и вытеснение тегов в наборе.
Пример таблицы вытеснения (для стратегии вытеснения \PseudoLRU)
смотрите на рисунке~\ref{PolicyTablePseudoLRU8}.

\begin{figure}[h]
$$ \left[
     \begin{array}{c|cccccccc}
       \pi_0 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_1 & 1 & 0 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_2 & 2 & 3 & 0 & 1 & 4 & 5 & 6 & 7 \\
       \pi_3 & 3 & 2 & 0 & 1 & 4 & 5 & 6 & 7 \\
       \pi_4 & 4 & 5 & 6 & 7 & 0 & 1 & 2 & 3 \\
       \pi_5 & 5 & 4 & 6 & 7 & 0 & 1 & 2 & 3 \\
       \pi_6 & 6 & 7 & 4 & 5 & 0 & 1 & 2 & 3 \\
       \pi_7 & 7 & 6 & 4 & 5 & 0 & 1 & 2 & 3 \\
       \pi_m & m & 6 & 4 & 5 & 0 & 1 & 2 & 3 \\
     \end{array}
   \right]
$$
\caption{Таблица вытеснения для стратегии вытеснения
\PseudoLRU}\label{PolicyTablePseudoLRU8}
\end{figure}

Первые строки таблицы вытеснения описывают изменение порядка
элементов набора при тестовых ситуациях кэш-попадания. Каждой такой
строке соответствует свой случай кэш-попадания, при этом первый
столбец показывает, на какой тег происходит кэш-попадание, а части
строк, не включающие первый столбец, показывают, каким образом
осуществляется перестановка тегов набор из последовательности
индексов (0 1 2 3 4 5 6 7) (в примере). Например, для стратегии
вытеснения \PseudoLRU, представленной на
рисунке~\ref{PolicyTablePseudoLRU8}, при кэш-попадании тега 5 набор
(4 6 5 7 1 0 2 3) изменится на (смотрим строку с $\pi_2$, потому что
тег 5 находится на втором месте) (5 7 4 6 1 0 2 3).

Последняя строка таблицы вытеснения соответствует ситуации
кэш-промаха. Вытесняющий элемент набора помечается буквой $m$.
Вытесняемый элемент -- элемент набора (0 1 2 3 4 5 6 7) (в примере),
который отсутствует в последней строке таблицы вытеснения (в примере
-- это 7, т.е. вытесняется последний элемент, а вытесняющий
помещается на нулевое место -- в этом стратегия вытеснения
\PseudoLRU проявляет схожесть со стратегией вытеснения \LRU).

Таблица вытеснения позволит ответить на вопрос о возможности
вытеснения любого тега в наборе. Для этого предлагается построить
орграф, вершинами которого будут всевозможные состояния буфера
(включая $m$), а дуги снабжены пометками -- числом от 0 до $w-1$ или
символом $m$. Две вершины соединены дугой с пометкой-числом, если из
одной вершины в другую осуществляется переход в результате
кэш-попадания с тегом -- этим числом. Две вершины соединены дугой с
пометкой $m$, если из одной вершины в другую осуществляется переход
в результате кэш-промаха.

\begin{utv}
Если в построенном графе есть цикл из дуг с пометками $m$, в который
ведет путь из вершины (0 1 ... $w-1$), на дугах которого не
встречаются одинаковые пометки-числа, то если цикл не включает
вершину $(m m ... m)$, то в стратегии вытеснения не всегда возможно
вытеснение любого тега набора.
\end{utv}

Назовем этот путь с циклом -- \emph{путем невытеснения}. Наличие
пути -- признак неполноты зеркального метода для этой стратегии
вытеснения.

Приведем пример стратегии вытеснения, для которой путь невытеснения
есть:
$$\left[
  \begin{array}{c|cccc}
    \pi_0 & 0 & 1 & 2 \\
    \pi_1 & 1 & 0 & 2 \\
    \pi_2 & 0 & 1 & 2 \\
    \pi_m & 0 & 1 & m \\
  \end{array}
\right]
$$

Соответствующий граф изображен на рисунке~\ref{badpolicy}. В нем
отсутствует какой-либо путь из вершины (0 1 2) в вершину $(m m m)$.
Пример пути вытеснения в этом графе: $1 m m ....$. Что и означает
невозможность вытеснить некоторые теги (например, тег 0) из набора
любой последовательностью различных тегов.
\begin{figure}[h]\center
  \includegraphics[width=0.7\textwidth]{2.theor/badpolicy}\\
  \caption{Граф для модельной стратегии вытеснения}\label{badpolicy}
\end{figure}

Для определения существования пути невытеснения может применяться
следующий алгоритм: ............

Граф для стратегии вытеснения \LRU: ..... В нем нет пути вытеснения.

Граф для стратегии вытеснения \PseudoLRU: ........

Граф для стратегии вытеснения \FIFO: ........

Таким образом, справедливо

\begin{utv} Зеркальный метод генерации
ограничений является полным для стратегий вытеснения \LRU, \FIFO и
\PseudoLRU.
\end{utv}
Это утверждение является важным, поскольку именно эти стратегии
вытеснения наиболее часто используются в микропроцессорах.

Доказательство теоремы~\ref{mirror_fullness} дает способ построения
последовательности инициализирующих тегов. Однако для некоторых
стратегий вытеснения такая последовательность будет избыточна и
существуют способы построения более коротких последовательностей
инициализирующих тегов. Следующая теорема дает линейное ограничение
для длины последовательности инициализирующих тегов от длины
тестового шаблона для стратегии вытеснения \LRU.

\begin{theorem}[Верхняя оценка для длины инициализирующей
последовательности тегов для стратегии вытеснения \LRU] Если данный
тестовый шаблон является совместным, т.е. для последовательности
тестовых ситуаций $(S_1, x_1), (S_2, x_2), ..., (S_n, x_n)$ и
дополнительного ограничения $P(x_1, x_2, ..., x_n)$ при некотором
начальном состоянии $L_1$ существует удовлетворяющая им
последовательность тегов $x_1, x_2, ..., x_n$, применим зеркальный
метод генерации ограничений и стратегией вытеснения является \LRU,
то с помощью зеркального метода может быть построена система
ограничений, имеющая решение для той же последовательности тегов
$x_1, x_2, ..., x_n$, причем длина последовательности
инициализирующих тегов $m$:
  $$0 \leqslant m \leqslant n \cdot w + M$$
  где $M$ -- количество инструкций тестового шаблона с кэш-промахами.
\end{theorem}
\begin{proof}
  Так же, как это было сделано при доказательстве
  теоремы~\ref{mirror_fullness}, разделим все $x_1, x_2, ..., x_n$
  по регионам. Для каждого задействованного региона составим свою
  последовательность инициализирующих тегов (обозначим ее длину $m_i$
  для $i$'го задействованного региона) и объединим эти
  последовательности для получения искомой последовательности
  инициализирующих тегов для всего тестового шаблона.
  Подпоследовательность последовательности $x_1, x_2, ..., x_n$,
  соответствующая одному региону, обозначим $y_1, y_2, ...,
  y_{n_i}$.

  Докажем, что $$m_i = M_i + w$$ где $M_i$ -- количество
  тегов последовательности $y_1, y_2, ..., y_{n_i}$, которые дают
  кэш-промахи при первым обращениям к ним. Тогда для всего тестового
  шаблона $m = \sum\limits_i m_i = \sum\limits_i M_i + \sum\limits_i w =
  M + w \cdot r$, где $r$ -- количество регионов, задействованных в
  $x_1, x_2, ..., x_n$. Очевидно, что $r \leqslant n$, тем самым это
  приводит к искомой оценке $m \leqslant M + n \cdot w$. Осталось
  доказать формулу для $m_i$.

  Укажем способ построения последовательности инициализирующих
  тегов. Выберем из $y_1, y_2, ..., y_{n_i}$ подпоследовательность,
  состоящую из тех тегов, которые дают кэш-промах и встречаются
  впервые. Обозначим их как $\mu_1, \mu_2, ..., \mu_{MM_i}$. Они будут первыми тегами в
  последовательности инициализирующих тегов. Далее выберем из $y_1, y_2, ..., y_{n_i}$
  все теги, при обращении к которым происходят кэш-попадания.
  Обозначим их как $\eta_1, \eta_2, ..., \eta_{HH_i}$. Если $MM_i > 0$ и $MM_i +
  HH_i < w + 1$, выберем произвольные различные теги $\nu_1, \nu_2,
  ..., \nu_{NN_i}$, которые не встречаются в $y_1, y_2, ...,
  y_{n_i}$.

  Покажем, что такая последовательность инициализирующих тегов
  удовлетворяет зеркальному методу построения ограчений. Все теги,
  при обращении к которым происходят кэш-попадания, встречаются в
  этой последовательности. Это следует из того, что первые такие
  теги мы поместили явно (в конец последовательности), а дальнейшие
  теги не могут встречаться впервые в тестовом шаблоне, в противном
  случае они были бы вытеснены до того, как должно быть
  кэш-попадание. Очевидно, что эти первые теги не вытеснены,
  поскольку они помещены в конец последовательности инициализирующих
  тегов. Все теги, при обращении к которыми происходят кэш-промахи,
  тоже встречаются в этой последовательности (мы их туда поместили
  явно). При этом поскольку от своего кэш-промаха они отделены не
  менее $w+1$ инструкцией, то к моменту кэш-промаха они будут
  вытеснены (для первой инструкции это очевидно по построению, а
  для остальных следует из леммы~\ref{includedranges} о невложенных диапазонах вытеснения).

  Длина такого тестового шаблона при $MM_i$ = 0 равна количеству
  встречающихся тегов $y_1, y_2, ..., y_{n_i}$, при обращении к
  которым происходят кэш-попадания. Таких тегов не более чем $w$,
  т.к. последовательность из кэш-попаданий может задать лишь часть
  или целиком весь набор. При $MM_i > 0$ длина последовательности
  есть сумма из $M_i$ (поскольку туда включаются все теги $y_1, y_2,
  ..., y_{n_i}$, при обращении к которым происходят кэш-промахи) и
  $w$ (поскольку в последовательность инициализирующих тегов
  добавляются фиктивные теги и теги, при обращении к которым
  происходят кэш-попадания). В обоих случах $m_i = M_i + w$.
\end{proof}
\begin{sld}
    Для длины последовательности инициализирующих тегов $m$ в случае
    стратегии вытеснения \LRU справедливо равенство:
      $$m = O(n)$$
\end{sld}

Следствие показывает, что зеркальный метод может быть эффективно
использован при стратегии вытеснения \LRU для поиска минимального
$m$ методом дихотомии.

\subsection{Совместно-зеркальная генерация}

Можно заметить, что при $m = 0$ формулировка ограничений для
зеркальной генерации становится частным случаем
теоремы~\ref{hit_miss_equations}. Это позволяет сформулировать
расширенный вариант этой теоремы, добавив туда <<зеркальную>>
инициализирующую последовательность тегов, и тем самым по сути этим
показывается соединение совместной и зеркальной генерации, ведь
даже, уменьшив множество констант $L_0$, система ограничений,
составленная на основе совместной генерации, может оказаться
несовместной -- в этом случае методом зеркальной генерации можно
будет добиться выполнения последовательности тестовых ситуаций,
указанных в тестовом шаблоне.

\begin{utv}\label{mirror_hit_miss_human} Пусть $L_0$ -- множество
адресов данных, расположенных в кэширующем буфере перед исполнением
первой инструкции тестового шаблона, $t_1, ..., t_m$ --
инициализирующая последовательность тегов. Тогда
\begin{itemize}
\item для инструкции с кэш-попаданием адреса $x$ следует добавить
следующую совокупность уравнений:
$$
\left[
   \begin{array}{l}
    x \in L_0 \wedge x~\mbox{все еще не вытеснен} \\
    x \in \{t_1, ..., t_m\} \wedge x~\mbox{не вытеснен} \\
    x~\mbox{внесен одним из кэш-промахов} \wedge \mbox{с тех пор не вытеснен} \\
   \end{array}
  \right.
$$

\item для инструкции с кэш-промахом адреса $x$ следует добавить следующую систему
уравнений ($\{x_i\}$ -- множество адресов данных в инструкциях с
кэш-промахами, расположенными до текущей инструкции):
$$
\left[
   \begin{array}{l}
    x \notin L_0 \wedge x \notin \{x_1, x_2, ..., x_n\} \\
    x \in \{t_1, ..., t_m\} \wedge x~\mbox{вытеснен и не внесен} \\
    x~\mbox{был вытеснен} \wedge \mbox{не был больше внесен в буфер}\\
  \end{array}
\right.
$$

\end{itemize}
\end{utv}

Некоторые решатели ограничений (\cite{Z3}) позволяют указывать веса
конъюнктов~-~ограничений в ДНФ. Эти веса могут использоваться для
построения решений, удовлетворяющих конъюнктам с минимальным или
максимальным суммарным весом. Таким образом, для дальнейшей
минимизации длины инициализирующей программы можно задавать
конъюнктам с $t_i$ больший вес, чем конъюнктам с $L_0$, и искать
решения с минимальным суммарным весом.

\subsection{Построение инициализирующей программы}

Если кэширующий буфер, для которого применяется зеркальный метод
генерации ограничений, подчинен некоторой таблице, то перед
инициализирующей последовательностью тегов ($t_1, t_2, ..., t_m$)
следует поместить инструкции, заполняющие нужные для этих тегов
строки таблицы. Например, перед последовательностью инициализирующих
обращений в TLB (допустим, что TLB является кэширующим буфером,
подчиненным таблице страниц виртуальной памяти) в таблицу страниц
надо поместить (если их там не было) страницы, соответствующие
инициализирующей последовательности тегов.

Если зеркальная генерация применяется к последовательностям тестовых
ситуаций для нескольких кэширующих буферов, то для каждого буфера
будет своя инициализирующая последовательность тегов. Может
ставиться задача построения более компактной инициализирующей
последовательности, объединяя некоторые обращения к буферам. Однако
эта задача не рассматривалась в работе.

\section{Единый взгляд на все предлагаемые методы}

\begin{figure}[p]
  \includegraphics[width=0.9\textwidth]{2.theor/methods}\\
  \caption{Построение ограничений для тестовых шаблонов}\label{methods}
\end{figure}

На рисунке~\ref{methods} дан общий взгляд на предлагаемые методы
генерации ограничений для тестовых шаблонов. Надо записать в виде
ограничений последовательности кэш-попаданий и кэш-промахов (это
центральный столбец рисунка) -- это можно сделать с использованием
совместной генерации, зеркальной генерации, совместно-зеркальной
генерации или просто воспользовавшись
теоремой~\ref{hit_miss_equations}, в зависимости от свойств
тестового шаблона и MMU. Эти методы записи тестовых ситуаций в
кэширующих буферах позволяют использовать различные методы записи
стратегий вытеснения в виде ограничений (правый столбец рисунка).
Самих по себе методов записи тестовых ситуаций еще недостаточно для
генерации ограничений, поскольку они содержат в себе параметрическую
часть -- запись стратегии вытеснения. Для записи стратегий
вытеснения можно воспользоваться диапазонами вытеснения или
функциями полезности, к рассмотрению которых мы и переходим. Выбор в
пользу того или иного метода записи стратегии вытеснения
производится на основе возможностей решателя ограничений и
требований к эффективности желаемого генератора тестовых программ.

\begin{figure}[ht]
  \includegraphics[width=0.8\textwidth]{2.theor/lenful}\\
  \caption{Сравнение полноты и средней длины инициализирующей программы,
  которую дают предлагаемые методы}\label{lenful}
\end{figure}

Рисунок~\ref{lenful} показывает сравнение средней длины
инициализирующих программ (без учета инструкций, не меняющих
кэширующие буферы и таблицы) и полноту предлагаемых методов.
Совместный метод генерации ограничений (СМ) не дает вообще никакой
инициализирующей программы, зато и применим он далеко не ко всем
тестовым шаблонам (в том числе и к тем, для которых возможно
построение тестовой программы) -- поэтому этот метод не является
полным. Совместно-зеркальный метод (СЗМ) и зеркальный метод (ЗМ)
дают неплохие показатели полноты, поскольку применимость этих
методов не так сильно зависит от тестового шаблона. Применение
теоремы~\ref{hit_miss_equations} (T1) без учета существующего
начального состояния микропроцессора (в противном случае эта теорема
уже не будет давать полного метода из-за большого размера
генерируемых ею ограничений -- $L_0$ должен быть выписан полностью)
дает полный метод всегда: если возможна хотя бы какая-нибудь
инициализация микропроцессора, она будет найдена. Однако ценою этого
является очень большая длина инициализирующей программы, поскольку
необходимо переинициализировать полностью весь микропроцессор, даже
если делать это не всегда обязательно.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Методы генерации ограничений для описания стратегий вытеснения}

\section{Метод перебора диапазонов вытеснения записи стратегии
вытеснения в виде ограничений}

В разделе рассматривается метод составления ограничений, описывающих
стратегию вытеснения, для которых можно определить \emph{метрику
вытеснения} и \emph{диапазон вытеснения}. Ограничение представляет
собой дизъюнкцию по всем возможным диапазонам вытеснения для данного
вытесняемого тега. В разделе приведены метрики вытеснения и
ограничения для трех наиболее часто использующихся в
микропроцессорах стратегий вытеснения -- \LRU, \FIFO и \PseudoLRU.

Неформально говоря, \emph{диапазон вытеснения} -- это непрерывная
часть тестового шаблона, заканчивающаяся в данной инструкции (это
т.н. \emph{конец диапазона вытеснения}), непосредственно влияющая на
вытеснение некоторого элемента кэш-памяти. Зачастую \emph{началом
диапазона вытеснения} является инструкция, в которой осуществляется
последнее обращение к вытесняемому элементу.

\emph{Метрикой вытеснения} будем называть функцию от текущего
состояния кэш-памяти и части тестового шаблона. Она максимальна в
конце диапазона вытеснения и минимальна в начале диапазона
вытеснения. Определение того, что является диапазоном вытеснения,
может производиться на основе такой метрики.

\subsection{Метод перебора диапазонов вытеснения для стратегии
вытеснения \LRU}\label{LRU_constraints}

LRU (Least Recently Used) -- это стратегия вытеснения, определяющая
вытесняемые данные как наименее используемые. Она эффективна для
алгоритмов, обладающих свойством локальности данных, т.е. чаще
использующих те данные, к которым недавно происходило обращение. Эта
стратегия используется, например, в микропроцессорах архитектуры
MIPS~\cite{mips64_II}.

Стратегия вытеснения LRU обычно определяется с использованием
счетчиков обращений. Более подробно, для каждого элемента кэш-памяти
вводится счетчик обращений к нему. Каждое обращение увеличивает
счетчик. Вытесняемым будет элемент с минимальным счетчиком.
Поскольку значение счетчика неизвестно, неизвестны его верхняя
граница, то формулирование метрики вытеснения на основе счетчика
провести сложно.

Другой способ описания LRU основан на введении порядка на элементах
набора (т.е. набор представляется списком элементов). После каждой
инструкции элементы переупорядочиваются согласно следующим правилам
(см.рис.~\ref{lru1}):
\begin{itemize}
\item при кэш-попадании элемент, соответствующий адресу инструкции,
перемещается в начало, остальные элементы от первого до данного
сдвигаются на одну позицию;
\item при кэш-промахе вытесняется последний элемент, в начало
вставляется элемент, вызвавший промах.
\end{itemize}

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{2.theor/lru1}\\
  \caption{Стратегия вытеснения LRU (w - ассоциативность кэш-памяти)
  -- реализация на списках}\label{lru1}
\end{figure}

Это описание подходит для определения метрики вытеснения: ею будет
\emph{индекс элемента в этом списке}. Эта метрика максимальна в
момент вытеснения (индекс равен длине списка). Минимальное значение
она принимает в момент кэш-попадания на этот элемент (т.к. он
переносится в самое начало, индекс становится равным 1). Значит,
применение перебора диапазонов вытеснения возможно (выделена метрика
вытеснения), началом диапазонов вытеснения будет последнее обращение
к вытесняемому элементу.

\begin{utv}[метрика вытеснения для стратегии вытеснения LRU]
Метрикой вытеснения элемента для стратегии вытеснения LRU является
индекс элемента в наборе согласно порядку последних обращений.
Диапазон вытеснения начинается в инструкции, последний раз
обращающейся к элементу (или в начальном состоянии, если инструкции
тестового шаблона к этому элементу не обращаются).
\end{utv}

Другое объяснение таким диапазонам вытеснения можно дать, исходя из
самого определения LRU. А именно, если элемент должен стать LRU,
т.е. наиболее неиспользуемым, все остальные элементы, наоборот,
должны быть хотя бы раз использованы (т.е. к ним должны быть
обращения до вытесняющей инструкции). Иными словами, чтобы элемент
был вытеснен, необходимо и достаточно, чтобы между последним
обращением к нему и вытеснением были обращения ко всем элементам
текущего состояния кэш-памяти, кроме него (см.
рис.~\ref{lru-ranges}).

\begin{figure}[h] \center
  \includegraphics[width=0.4\textwidth]{2.theor/lru}\\
  \caption{Диапазоны вытеснения для стратегии вытеснения LRU}\label{lru-ranges}
\end{figure}

Запишем в виде уравнений на множества эту логику~\cite{my_syrcose_2009}. Предикат\\
$displaced(x')$ будет представлен дизъюнкцией уравнений -- каждый
элемент дизъюнкции соответствует некоторому диапазону вытеснения.
Тогда для диапазона вытеснения к инструкции, обращающейся к адресу
$y$ надо составить такую систему уравнений ($x_1, x_2, ..., x_n$ --
множество адресов, к которым происходят обращения внутри диапазона
вытеснения (как с кэш-попаданиями, так и с кэш-промахами, а также
элементы начального состояния, если диапазон начинается там), $L$ --
выражение для состояния кэш-памяти для инструкции, вытесняющей
$x'$):
$$
\left\{
   \begin{array}{l}
    x' = y \\
    \{x_1, x_2, ..., x_n\} \cap R(y) = (L \setminus \{y\}) \cap R(y)\\
   \end{array}
  \right.
$$

Функциональный символ $R$ используется в смысле множества адресов
того же региона. С использованием следующей леммы упростим эту
систему:
\begin{lemma}
Для любых конечных множеств $X$, $Y$ и $Z$ таких, что $X \cap Y
\subseteq Z$, если существует $y$ такой, что $y \in (Y \cap
Z)\setminus X$, то $X \cap Y = (Z \setminus \{y\}) \cap Y
\Leftrightarrow Y \cap ( Z \setminus X ) = \{ y \}$.
\end{lemma}
\begin{proof}
Необходимость. По определению вычитания множеств и коммутативности
операции пересечения множеств $X \cap Y = (Z \setminus \{y\}) \cap Y
\Leftrightarrow X \cap Y = Z \cap Y \cap \overline{\{y\}}$.
Обозначим $A = Z \cap Y$, $B = X \cap Y$. Следовательно, $B = A
\setminus \{y\}$. По условию $y \notin B$ и $y \in A$. Значит, $A =
B \sqcup \{y\}$. Отсюда $A \setminus B = \{y\}$. Осталось показать,
что $A \setminus B = (Z \setminus X ) \cap Y$ : $A \setminus B = A
\cap \overline{B} = Z \cap Y \cap \overline{X \cap Y} = Z \cap Y
\cap (\overline{X} \cup \overline{Y}) = (Z \cap Y \cap \overline{X})
\cup (Z \cap Y \cap \overline{Y}) = Z \cap \overline{X} \cap Y = (Z
\setminus X ) \cap Y$.

Достаточность. Обозначим $A = Z \cap Y$, $B = X \cap Y$. С
использованием определений операций над множествами и их свойств
получаем $X \cap Y \subseteq Z \Leftrightarrow (X \cap Y) \setminus
Z = \varnothing \Leftrightarrow X \cap Y \cap \overline{Z} =
\varnothing \Leftrightarrow X \cap Y \cap (\overline{Z} \cup
\overline{Y}) = \varnothing \Leftrightarrow B \setminus A =
\varnothing$. Кроме того, по условию $A \setminus B = \{y\}$.
Следовательно, $A = (A \setminus B) \cup (A \cup B) = \{y\} \cup (B
\setminus (B \setminus A)) = \{y\} \cup (B \setminus \varnothing) =
\{y\} \cup B$. Таким образом, $A = B \cup \{y\}$. Кроме того, $y
\notin B$, значит, $A = B \sqcup \{y\}$, следовательно, $B = A
\setminus \{y\}$. Подставляя определения множеств $A$ и $B$,
получаем: $X \cap Y = (Z \cap Y) \setminus \{y\} = Z \cap Y \cap
\overline{\{y\}} = (Z \setminus \{y\}) \cap Y$.
\end{proof}

\begin{lemma}[Отсутствие вложенных диапазонов]\label{includedranges}
//TODO
\end{lemma}
\begin{proof}
//TODO
\end{proof}

\begin{lemma}[О выполнимости условий
леммы~\label{LRU_simplification} для диапазонов вытеснения]
$$L \supseteq \{x_1, x_2, ..., x_n\} \cap R(y)$$
\end{lemma}
\begin{proof}[\proofname~(от противного)]
Пусть среди $x_1, x_2, ..., x_n$ есть $x_i$ такой, что $x_i \notin L
\wedge x_i \in R(y)$. Пусть $L_{i+1}$ -- состояние кэш-памяти после
обращения к $x_i$. Верно, что $x_i \in L_{i+1}$, но $x_i \notin L$,
следовательно, $x_i$ был вытеснен между $x_{i+1}$ и $x_n$. Иными
словами, среди $x_1, x_2, ..., x_n$ есть элемент, чей диапазон
вытеснения вложен в диапазон вытеснения $y$. Но согласно
лемме~\ref{includedranges} это невозможно. Противоречие.
\end{proof}

Таким образом, можно применить лемму~\ref{LRU_simplification} для
упрощения уравнения для LRU:
\begin{theorem}[Уравнение для LRU]\label{LRU_equation}
Решение системы (тег $x'$)
$$
\left\{
   \begin{array}{l}
    x' = y \\
    R(y) \cap (L \setminus \{x_1, x_2, ..., x_n\} ) = \{y\}\\
   \end{array}
  \right.
$$
где последовательность тегов $y, x_1, x_2, ..., x_n$ -- диапазон
вытеснения, является вытесняемым тегом для стратегии вытеснения LRU
согласно определению на списках.
\end{theorem}
\begin{proof}
//TODO
Показать, что согласно лемме~\ref{includedranges} можно использовать
$L$ перед концом диапазона.
\end{proof}


\subsection{Метод перебора диапазонов вытеснения для стратегии
вытеснения FIFO}

FIFO (First-In First-Out) -- это стратегия вытеснения, определяющая
вытесняемые данные согласно принципу очереди FIFO. Например, в
микропроцессоре PowerPC 970FX вытеснение из небольшого буфера,
хранящего последние преобразованные эффективные адреса в физические,
D-ERAT происходит согласно FIFO~\cite{PowerPC970FXUserManual}.

Стратегия FIFO может быть описана на основе порядка на элементах
набора (т.е. набор представляется списком элементов). После каждой
инструкции элементы переупорядочиваются согласно следующим правилам
(см.рис.~\ref{fifo1}):
\begin{itemize}
\item при кэш-попадании порядок элементов не меняется;
\item при кэш-промахе вытесняется последний элемент, в начало
вставляется элемент, вызвавший промах.
\end{itemize}

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{2.theor/fifo1}\\
  \caption{Стратегия вытеснения FIFO (w - ассоциативность кэш-памяти)}\label{fifo1}
\end{figure}

Отличие от LRU лишь в том, что при FIFO не происходит перестановки
элементов набора при возникновении кэш-попадания.

Аналогично LRU в качестве метрики вытеснения можно взять индекс
элемента в списке, что дает возможность использовать перебор
диапазонов вытеснения для описания стратегии вытеснения FIFO.
Началом диапазона вытеснения будет внесение элемента в кэш-память,
концом диапазона вытеснения -- его вытеснение. При составлении
ограничений все инструкции с кэш-попаданиями внутри диапазона будем
игнорировать (они не влияют на вытеснение с точки зрения FIFO).
Тогда \emph{FIFO будет выполнено в том случае, когда в диапазоне
встречаются все адреса состояния кэш-памяти перед вытеснением без
самого вытесняемого адреса}.

\begin{utv}[метрика вытеснения для стратегии вытеснения FIFO]
Метрикой вытеснения элемента для стратегии вытеснения FIFO является
индекс элемента в наборе согласно порядку последних обращений.
Диапазон вытеснения начинается в инструкции c кэш-промахом,
последний раз обращающейся к элементу (или в начальном состоянии,
если инструкции тестового шаблона к этому элементу не обращаются).
\end{utv}

Запишем в виде уравнений на множества эту логику~\cite{my_nivc_2009}. Предикат\\
$displaced(x')$ будет представлен дизъюнкцией уравнений -- каждый
элемент дизъюнкции соответствует некоторому диапазону вытеснения.
Тогда для диапазона вытеснения к инструкции, обращающейся к адресу
$y$ надо составить такую систему уравнений ($x_1, x_2, ..., x_n$ --
множество адресов, к которым происходят обращения внутри диапазона
вытеснения \textbf{с кэш-промахами}, а также элементы начального
состояния, если диапазон начинается там, $L$ -- выражение для
состояния кэш-памяти для инструкции, вытесняющей $x'$):
$$
\left\{
   \begin{array}{l}
    x' = y \\
    \{x_1, x_2, ..., x_n\} \cap R(y) = (L \setminus \{y\}) \cap R(y)\\
   \end{array}
  \right.
$$

Функциональный символ $R$ используется в смысле множества адресов
того же региона.

Для FIFO справедливы все леммы о диапазонах вытеснения,
сформулированные для LRU. В частности, с их использованием теорема
об уравнении, описывающем вытесняемый тег, может быть переписана
следующим образом:
\begin{theorem}[Уравнение для FIFO]\label{FIFO_equation}
Решение системы (тег $x'$)
$$
\left\{
   \begin{array}{l}
    x' = y \\
    R(y) \cap (L \setminus \{x_1, x_2, ..., x_n\} ) = \{y\}\\
   \end{array}
  \right.
$$
где последовательность тегов $y, x_1, x_2, ..., x_n$ -- диапазон
вытеснения, является вытесняемым тегом для стратегии вытеснения FIFO
согласно определению на списках.
\end{theorem}
\begin{proof}
//TODO
Показать, что согласно лемме~\ref{includedranges} можно использовать
$L$ перед концом диапазона.
\end{proof}

\subsection{Метод перебора диапазонов вытеснения для стратегии
вытеснения Pseudo-LRU}

Стратегия вытеснения LRU хоть и хорошо приближает поведение
кэш-памяти к идеальному случаю (когда данные находятся в кэш-памяти
в тот момент, когда они нужны), но для нее не удалось найти
эффективную реализацию. Поэтому производятся поиски стратегии
вытеснения, близкой по качеству к LRU, но имеющей эффективную
реализацию. Эти поиски привели к стратегии вытеснения Pseudo-LRU.
Она определяется только для кэш-памяти с ассоциативностью,
являющейся степенью двойки. Стратегия вытеснения Pseudo-LRU
используется во многих микропроцессорах архитектур PowerPC и
Pentium~\cite{FundamentalOfComputerOrganizationAndDesign}.

Для каждого набора хранится битовая строка длины $w-1$, где $w$ --
ассоциативность кэш-памяти. Каждая инструкция, обращающаяся к
набору, меняет эту битовую строку. Определение вытесняемого элемента
производится тоже на основании этой битовой строки. Для наглядности
алгоритм изменения битовой строки описывают на упорядоченном
бинарном дереве высоты $\log_2 w$, в листьях которого подряд
расположены элементы набора. Вытесняющий элемент помещается в дереве
на место вытесняемого. Между элементами битовой строки и нелистовыми
элементами установлено взаимнооднозначное соответствие. Каждая дуга
в дереве помечена числом 0 или 1, из каждого нелистового узла
выходят дуги, помеченные разными числами.

При кэш-попадании по некоторому адресу меняются элементы битовой
строки, соответствующие вершинам дерева, которые входят в путь от
корня до этого адреса (см. рис.~\ref{pseudo_lru_hit}). А именно,
элемент битовой строки становится равным пометке дуги, исходящей из
соответствующего ему узла. Остальные элементы битовой строки не
меняются.

\begin{figure}[h] \center
  \includegraphics[width=0.7\textwidth]{2.theor/plruhit}\\
  \caption{Кэш-попадание для стратегия вытеснения Pseudo-LRU
  (16-ассоциативная кэш-память)}\label{pseudo_lru_hit}
\end{figure}

Поиск вытесняемого элемента производится следующим образом: на
основе значений элементов битовой строки (т.е. нелистовых узлов
дерева) определяется единственный путь. Лист, к которому ведет этот
путь, и является вытесняемым элементом. Путь определяется
итеративно: первая вершина -- всегда корень, из него выбирается
дуга, помеченная значением, противоположным значению элемента
битовой строки, соответствующей корню. Затем эта же операция
повторяется для узла -- конца этой дуги, а именно, выбирается
исходящая из него дуга, пометка которого имеет значение,
противоположное тому, какому этот узел соотнесен в битовой строке.
На место вытесняемого элемента помещается вытесняющий, битовая
строка меняется так, будто к вытесняющему элементу было обращение с
кэш-попаданием. Пример того, как определяется вытесняемый элемент,
показан на рис.~\ref{pseudo_lru_miss}. Цветом нелистовых узлов
показано значение соответствующего им элементов битовой строки:
черный узел соответствует значению 1, белый -- 0. В изображенном
дереве будет выбран путь $\alpha-\gamma-\zeta$, согласно которому
будет вытеснен элемент $e$.

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{2.theor/plrumiss}\\
  \caption{Определение вытесняемого элемента для стратегия вытеснения
  Pseudo-LRU (16-ассоциативная кэш-память)}\label{pseudo_lru_miss}
\end{figure}

Иными словами, определение вытесняемого элемента можно проводить,
последовательно рассматривая тестовые ситуации от данной инструкции
с кэш-промахом назад к первой инструкции. Каждая очередная
инструкция отсекает то поддерево, которому принадлежит адрес в этой
инструкции (если адрес принадлежит уже отсеченной части дерева,
инструкция игнорируется). В результате, на некотором шаге останется
дерево из одного элемента, вытесняемый элемент и будет тем самым
элементом.

Взглянем на эту схему со стороны одного элемента и попробуем вывести
логику, согласно которой именно он был бы вытеснен. Для простоты
рассмотрим сначала самый левый элемент. Он будет вытеснен в том и
только в том случае, когда вся ветвь дерева к нему состоит из черных
вершин. После обращения к этому элементу ветвь дерева к нему состоит
целиком из белых вершин. Таким образом, вытеснение можно понимать
как процесс перекрашивания вершин ветви от белых к черным. Каждое
обращение к какому-либо элементу дерева перекрашивает часть ветви к
данному элементу, и когда будет закрашена в черный цвет вся ветвь
целиком будет вытеснен сам данный (самый левый) элемент. Иными
словами, метрикой вытеснения может стать количество черных вершин в
ветви, если рассматривается самая левая ветвь. В момент вытеснения
это количество максимально (равно $\log_2 w - 1$). Минимальное
значение этой метрики равно 0, оно соответствует моменту обращения к
соответствующей листовой вершине. Таким образом, возможно применение
перебора диапазонов вытеснения для описания Pseudo-LRU: началом
диапазона будет последнее обращение к элементу (листовой вершине
дерева), концом диапазона будет вытесняющая этот элемент инструкция.

Аналогичные рассуждения проводятся для всех остальных листовых
вершин, только конкретные цвета, белый и черный, надо заменить на те
цвета, которые ведут в вершину и противоположные к ним.

\begin{utv}[метрика вытеснения для стратегии вытеснения Pseudo-LRU]
Метрикой вытеснения элемента для стратегии вытеснения Pseudo-LRU
является количество вершин в ветви к вытесняемой листовой вершине с
пометками, противоположными пометкам при прохождении по ветви при
кэш-попадании. Диапазон вытеснения начинается в инструкции,
последний раз обращающейся к листовой вершине (или в начальном
состоянии, если инструкции тестового шаблона к этой листовой вершине
не обращаются).
\end{utv}

%Отличием этой метрики вытеснения от метрики вытеснения для LRU или
%FIFO является \emph{немонотонность}. Обращение к листовым вершинам,
%лежащим близко к данной, может перекрасить в белый цвет некоторые до
%этого бывшие черными вершины, что уменьшит метрику, но не сделает ее
%значение минимальной. Как будет продемонстрировано ниже, монотонные
%метрики вытеснения позволяют строить более компактные ограничения,
%чем немонотонные. Метрика вытеснения не является единственной для
%стратегии вытеснения, поэтому поиск монотонной метрики вытеснения
%является еще одним способом упрощения ограничений.

Осталось записать уравнения, описывающие предложенные диапазоны
вытеснения. Каждый элемент кэш-памяти снабдим \emph{позицией} --
номером этого элемента среди листовых вершин дерева. Будем
обозначать позицию буквой $\pi$. Предикат $displaced(x')$ будет
представлен дизъюнкцией уравнений -- каждый элемент дизъюнкции
соответствует некоторому диапазону вытеснения. Тогда для диапазона
вытеснения к инструкции, обращающейся к адресу $x_1$ c позицией
$\pi_1$ надо составить такую систему уравнений ($x_2, x_3, ..., x_n$
-- множество адресов, к которым происходят обращения внутри
диапазона вытеснения, $\pi_2, \pi_3, ..., \pi_n$ -- соответствующие
им позиции, $\delta_i = \pi_i \oplus \pi', i \in 2..n$, где $\oplus$
-- операция сложения по модулю 2 двоичных разложений операндов ):

\begin{figure}[h] \center
  \includegraphics[width=0.5\textwidth]{2.theor/plru-ranges}\\
  \caption{Диапазоны вытеснения для стратегии вытеснения Pseudo-LRU}
\end{figure}

$$
\left\{
\begin{array}{l}
x' = x_1\\
\pi' = \pi_1\\
\pi = \pi'\\
((0~op_x~\delta_2)~op_x~\delta_3) ... ~op_x~\delta_n  = w-1\\
\end{array}
\right.
$$

Операция $op_x$ выполняет очередной шаг по <<перекрашиванию>> ветви,
ведущей в элемент $x$. Она может быть определена следующей формулой:

$$X~op_x~\delta \equiv \mbox{~if~} R(X) \neq R(x) \mbox{~then~} X \mbox{~else~} (X \&
\delta_{<1>}) | \delta_{<0>} \mbox{~end~}$$

где \& -- побитовая конъюнкция, | -- побитовая дизъюнкция,
$\delta_{<1>} = 2 * \delta_{<0>} - 1$, а $\delta_{<0>} = 2^{[\log_2
\delta]}$ может быть определено следующим переборным способом:
$\delta_{<0>} = \mbox{~if~} 1 \leqslant \delta < 2 \mbox{~then~} 1
\mbox{~elsif~} 2 \leqslant \delta < 4 \mbox{~then~} 2 \mbox{~elsif~}
... \mbox{~else~} w \mbox{~end~}$. Другой способ получения
$\delta_{<0>}$ и $\delta_{<1>}$ удобно применять при побитовом
рассмотрении $\delta$: $\delta_{<0>} = (\delta_{<1>} + 1) \gg 1$,
$\delta_{<1>}[i] = \delta[1] \vee \delta[2] \vee ... \vee
\delta[i]$, где символом $d[i]$ обозначен $i$'й бит числа $d$, биты
нумеруются со старших к младшим.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\section{Метод функций полезности записи стратегии вытеснения в виде
ограничений}

В разделе рассматривается метод составления ограничений, описывающих
стратегию вытеснения, для которых можно определить метрик
вытеснения. Стратегия вытеснения описывается ограничением сверху на
количество \emph{полезных} инструкций (т.е. помогающих вытеснению).
В разделе приведены метрики полезности и ограничения для трех
наиболее часто использующихся в микропроцессорах стратегий
вытеснения -- LRU, FIFO и Pseudo-LRU. Освещается понятие
\emph{монотонной метрики вытеснения}, которая является залогом более
компактной системы ограничений.

Пусть для стратегии вытеснения сформулирована метрика вытеснения (ее
значение максимально в вытесняющей инструкции). Будем называть
инструкцию \emph{полезной}, если она увеличивает метрику на этапе
монотонного увеличения метрики до максимального значения (см.
рис.~\ref{useful}).

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{2.theor/useful}\\
  \caption{К определению полезных инструкций}\label{useful}
\end{figure}

Тогда вытеснение будет происходить в том случае, когда количество
полезных инструкций превысит некоторое константное количество.
Вытеснение не будет происходить, если количество полезных инструкций
не превысит некоторой константной верхней границы. Количество
полезных инструкций можно записать в виде суммы
переменных-полезностей, каждая такая переменная соответствует своей
инструкции и равна 1 тогда и только тогда, когда инструкция является
полезной, и 0 тогда и только тогда, когда инструкция не является
полезной. Иными словами, ограничение будет иметь вид $\sum_{i=1}^n
u(x_i) < N$ или $\sum_{i=1}^n u(x_i) = N$, где $u(x_i)$ --
\emph{функция полезности} (равна 1, если $x_i$ -- полезная
инструкция, и равна 0, если $x_i$ не является полезной инструкцией).

\subsection{Метод функций полезности для стратегии
вытеснения LRU}

Функцией полезности является номер вытесняемого элемента согласно
порядку счетчика LRU (см. рис.~\ref{lru1}). Значит, полезной будет
инструкция, переставляющая вытесняемый элемент в этом порядке к
концу. Такими инструкциями являются все кэш-промахи (поскольку они
вытесняют последний элемент с передвижением всех остальных на одну
позицию к концу, в том числе будет передвинут и данный вытесняемый
элемент) и кэш-попадания к элементам, находившимся ближе к концу,
чем данный вытесняемый (потому как при кэш-попадании они
передвинутся в самое начало, а все элементы от начала и до них
сдвинутся на одну позицию к концу, в том числе и данный
вытесняемый).

Осталось выразить эту идею в виде ограничений~\cite{my_ewdts_2009}.
Для этого удобно использовать формулировку тестовых ситуаций в
кэш-памяти из утверждения~\ref{hit_miss_human_domain}. Символом
$\lambda_\delta$ будет обозначаться элемент домена -- начального
состояния кэш-памяти -- с индексом $\delta$ по порядку LRU, $1
\leqslant \delta \leqslant w$. Индекс 1 обозначает самый молодой
элемент, индекс $w$ обозначает самый старый элемент.

Применение полезностей эффективно в том случае, когда домен имеет
небольшой размер. В этом случае можно перебрать все элементы домена
(это и будут $\lambda_\delta$) и составить для них свои полезности,
причем для каждого элемента будет известен индекс по порядку LRU
($\delta$). Ограничение, описывающее стратегию вытеснения, будет при
этом иметь вид дизъюнкции по элементам домена.

Если вытесняемый элемент был в начальном состоянии (пусть это
$\lambda_\delta$) и к нему не было обращений, то для его вытеснения
необходимо $w-\delta + 1$ полезных инструкций, потому что столько
раз надо подвинуть элемент с индексом $\delta$ в LRU-списке в
сторону к концу (к элементам с индексом $w$), чтобы он вышел за
границу списка (иными словами, чтобы он был вытеснен).

Если вытесняемый элемент был в начальном состоянии и к нему было
обращение, то для его вытеснения необходимо $w$ инструкций, так как
во время обращения элемент был поставлен в самое начало LRU-списка.
То же справедливо для внесенных в кэш-память новых тегсетов -- чтобы
их вытеснить, надо так же $w$ полезных инструкций, чтобы переместить
их к концу LRU-списка.

В таблице~\ref{hit_miss_table} приведены все функции полезности для
кэш-попаданий и кэш-промахов. Далее идет ряд формулировок и теорем,
доказывающих корректность применения полезностей для записи
стратегии вытеснения LRU в виде ограничений.

\begin{landscape}
\begin{table}[p]\small
\begin{tabular}{|c|c|c|c|c|c|}
\hline  & \centering случай &
\begin{tabular}{c}переменная\\перебора\end{tabular} & система &
\begin{tabular}{c}функция полезности\\для кэш-попадания\end{tabular} &
\begin{tabular}{c}функция полезности\\для кэш-промаха\end{tabular} \\
\hline \hline \multirow{10}{*}{\rotatebox{90}{кэш-попадание}} &
\makecell[c{p{0.38\textwidth}}]{тегсет находится в начальном
состоянии кэш-памяти, к нему нет обращений до данной инструкции и он
всё ещё не вытеснен} & $\lambda_\delta \in D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \notin \{x_1, ..., x_n\}\\
\sum\limits^n_{i=1} u(x_i) \leqslant w - \delta
\end{array}\right.
$ &
\begin{tabular}{c}
$x_i \in \{ \lambda_{\delta+1}, ..., \lambda_w\}$\\
$\wedge~x_i \notin \{x_1, ..., x_{i-1}\}$
\end{tabular}
& $R(x_i) = R(x)$
\\ \hhline{~|-----}
& \makecell[c{p{0.38\textwidth}}]{тегсет находится в начальном
состоянии кэш-памяти, к нему есть обращение до данной инструкции и
он всё ещё не вытеснен} & $\lambda_\delta \in D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \in \{x_1, ..., x_n\}\\
\sum\limits^n_{i=1} u(x_i) < w
\end{array}\right.
$ &
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~x_i \in \{ \lambda_{\delta+1}, ..., \lambda_w\}$\\
$\wedge~\sum_{j=1}^{i-1} c_i (x_j) = 0,$\\
$c_i(x_j) \equiv (x\notin \{x_j, ..., x_i\}$\\
$\wedge~x_i = x_j)$\\
\end{tabular}
&
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)$\\
\end{tabular}
\\  \hhline{~|-----}
& \makecell[c{p{0.38\textwidth}}]{тегсет был внесен одним из
кэш-промахов и с того момента не вытеснен} & -- &
$\left\{\begin{array}{l} x \in [x_1, ..., x_n]_{miss}\\
\sum\limits^n_{i=1} u(x_i) < w
\end{array}\right.
$ &
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)~\wedge$\\
$\sum^{i-1}_{j=1} c_i(x_j) = 0,$\\
$c_i(x_j) \equiv (x\notin \{x_j, ..., x_i\}$\\
$\wedge~x_i = x_j)$\\
\end{tabular}
&
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)$\\
\end{tabular}
\\ \hline \hline \multirow{15}{*}{\rotatebox{90}{кэш-промах}}
& \makecell[l]{тегсет встречается впервые} & -- &
$\left\{\begin{array}{l} x \notin D\\
x \notin [x_1, ..., x_n]_{miss}\\
\end{array}\right.
$ & -- & -- \\ \hhline{~|-----} &
\makecell[l{p{0.38\textwidth}}]{тегсет ранее был внесен одной из
инструкций шаблона, затем вытеснен} & -- & $\left\{\begin{array}{l}
x \in [x_1, ..., x_n]_{miss}\\
\sum\limits^n_{i=1} u(x_i) \geqslant w\\
\end{array}\right.$ &
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)~\wedge$\\
$\sum_{j=1}^{i-1}c_i(x_j) = 0,$\\
$c_i(x_j) \equiv (x\notin\{x_j, ..., x_i\}$\\
$\wedge~x_i = x_j)$
\end{tabular}
&
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)$\\
\end{tabular}
\\  \hhline{~|-----} &
\makecell[c{p{0.38\textwidth}}]{тегсет находился в начальном
состоянии кэш-памяти и был вытеснен, к нему не было обращений в
шаблоне} & $\lambda_\delta \in D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \notin \{x_1, ..., x_n\}\\
\sum^n_{i=1} u(x_i) \geqslant w - \delta + 1\\
\end{array}\right.
$ &
\begin{tabular}{c}
$x_i \in\{\lambda_{\delta+1}, ..., \lambda_w\}$\\
$\wedge~x_i \notin \{x_1, ..., x_{i-1}\}$\\
\end{tabular}
&
\begin{tabular}{c}
$R(x_i) = R(x)$\\
\end{tabular}
\\ \hhline{~|-----} &
\makecell[c{p{0.38\textwidth}}]{тегсет находился в начальном
состоянии кэш-памяти и был вытеснен, к нему было обращение в шаблоне
после последнего внесения в кэш-память} & $\lambda_\delta \in D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \in \{x_1, ..., x_n\}\\
\sum\limits^n_{i=1} u(x_i) \geqslant w\\
\end{array}\right.
$ &
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~x_i \in \{\lambda_{\delta+1}, ..., \lambda_w\}$\\
$\wedge~\sum_{j=1}^{i-1}c_i(x_j) = 0,$\\
$c_i(x_j) \equiv (x\notin\{x_j, ..., x_i\}$\\
$\wedge~x_i = x_j)$
\end{tabular}
&
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)$\\
\end{tabular}
\\ \hline
\end{tabular}
\caption{Таблица систем уравнений для тестовых ситуаций в LRU
кэш-памяти c использованием функций
полезности}\label{hit_miss_table}
\end{table}
\end{landscape}

\paragraph{Кэш-попадание -- первый случай} Это случай обозначен в
формулировке утверждения~\ref{hit_miss_human_domain} фразой $x \in D
\wedge x~\mbox{все еще не вытеснен}$. Возможны два подслучая в
зависимости от того, было ли обращение к $x$ до вытесняющей его
инструкции. Подслучай отсутствия такого обращения будем называть
кэш-попаданием-I', а наличия -- кэш-попаданием-I''. Ограничения для
этих подслучаев объединяются в дизъюнкцию.

\begin{lemma}[представление кэш-попадания-I' с помощью функций
полезности для LRU] Пусть $x$ -- тегсет текущей инструкции при
стратегии вытеснения LRU. Тогда если $x = \lambda \in L_0$ и $x
\notin \{x_1, x_2, ..., x_n\}$, где $x_1, x_2, ..., x_n$ -- тегсеты
предыдущих инструкций, то $x$ не вытеснен к моменту текущей
инструкции согласно определению LRU на списках тогда и только тогда,
когда $\sum^n_{i=1} u(x_i) \leqslant w - \delta$, где $\delta \in
\{1, 2, ..., w\}$ -- индекс $\lambda$ в своем наборе $L_0$ согласно
метрике вытеснения LRU, а $u(x_i)$ (\emph{функция полезности})
определена следующим образом:

$$u(x_i) \equiv \left\{
\begin{array}{l}
    x_i \in \{ \lambda_{\delta+1}, ..., \lambda_w\} \wedge x_i \notin
\{x_1, ..., x_{i-1}\},\\ \qquad \mbox{если}~x_i~\mbox{дает кэш-попадание} \\
    R(x_i) = R( \lambda_\delta ), \mbox{если}~x_i~\mbox{дает кэш-промах}\\
\end{array}
\right.$$

\end{lemma}
\begin{proof}
//TODO
\end{proof}

\begin{lemma}[представление кэш-попадания-I'' с помощью функций
полезности для LRU] Пусть $x$ -- тегсет текущей инструкции при
стратегии вытеснения LRU. Тогда если $x = \lambda \in L_0$ и $x \in
\{x_1, x_2, ..., x_n\}$, где $x_1, x_2, ..., x_n$ -- тегсеты
предыдущих инструкций, то $x$ не вытеснен к моменту текущей
инструкции согласно определению LRU на списках тогда и только тогда,
когда $\sum^n_{i=1} u(x_i) < w$, где $u(x_i)$ (\emph{функция
полезности}) определена следующим образом:

$$u(x_i) \equiv \left\{
\begin{array}{l}
    x \notin \{x_i, ..., x_n\} \wedge x_i \in \{ \lambda_{\delta+1},
..., \lambda_w\} \wedge \sum_{j=1}^{i-1} c_i(x_j) = 0,\\ \qquad \mbox{если}~x_i~\mbox{дает кэш-попадание} \\
    x \notin \{x_i, ..., x_n\} \wedge R(x_i) = R(x), \mbox{если}~x_i~\mbox{дает кэш-промах}\\
\end{array}
\right.$$

$\delta \in \{1, 2, ..., w\}$ -- индекс $\lambda$ в своем наборе
$L_0$ согласно метрике вытеснения LRU ($\lambda = \lambda_\delta$),

$$
c_i(x_j) \equiv (x \notin \{x_j, x_{j+1}, ..., x_i\} \wedge x_i =
x_j)
$$

\end{lemma}
\begin{proof}
//TODO
\end{proof}

Неформально говоря, все инструкции до последнего обращения к
вытесняемому элементу считаются бесполезными, а после этого
обращения полезным считается лишь первое обращение к элементу,
находящемуся между $\lambda_\delta$ и концом списка (т.е. между
$\lambda_{\delta+1}$ и $\lambda_w$). Функциональный символ $c$ как
раз призван считать количество предшествующих обращений к таким
элементам с момента последнего обращения к вытесняемому элементу.
Если $c = 0$, значит, это первое обращение (предшествующих нет).

\paragraph{Кэш-попадание -- второй случай} Этот случай представлен
фразой <<$x~\mbox{был внесен}$ $\wedge$ $\mbox{с тех пор не
вытеснен}$>>. Функции полезности совпадают со случаем, когда $x$ был
в начальном состоянии, к нему до вытеснения было обращение и он все
еще не вытеснен, потому что с момента последнего обращения поведение
списка LRU не зависит от инструкций, предшествовавших последнему
обращению. Разница только в том, что в данном случае не известен
индекс элемента $\delta$, потому как нет равенства $x =
\lambda_\delta$. Но, как оказалось, ограничение можно записать в
этом случае и без знания $\delta$ -- ограничения $R(x_i) = R(x)$
достаточно при условии, что это первое обращение.

\begin{lemma}[представление кэш-попадания-II с помощью функций
полезности для LRU] Пусть $x$ -- тегсет текущей инструкции при
стратегии вытеснения LRU. Тогда если $x \in [x_1, x_2, ...,
x_n]_{\mbox{miss}}$, где $x_1, x_2, ..., x_n$ -- тегсеты предыдущих
инструкций, а $[x_1, x_2, ..., x_n]_{\mbox{miss}}$ -- тегсеты,
дающие кэш-промах, то $x$ не вытеснен к моменту текущей инструкции
согласно определению LRU на списках тогда и только тогда, когда
$\sum^n_{i=1} u(x_i) < w$, где $u(x_i)$ (\emph{функция полезности})
определена следующим образом:

$$u(x_i) = \left\{
\begin{array}{l}
    x \notin \{x_i, ..., x_n\} \wedge R(x_i) = R(x) \wedge \sum_{j=1}^{i-1} c_i(x_j) = 0,
        \\ \qquad \mbox{если}~x_i~\mbox{дает кэш-попадание} \\
    x \notin \{x_i, ..., x_n\} \wedge R(x_i) = R(x), \mbox{если}~x_i~\mbox{дает кэш-промах}\\
\end{array}
\right.$$

$$
c_i(x_j) \equiv (x \notin \{x_j, x_{j+1}, ..., x_i\} \wedge x_i =
x_j)
$$

\end{lemma}
\begin{proof}
//TODO
\end{proof}



\paragraph{Кэш-промах -- первый случай} Этот случай описывает
тегсет, который еще не встречался ни среди предыдущих инструкций
тестового шаблона, ни среди начального состояния кэш-памяти. Он
может быть описан вообще без привлечения функций полезности, что и
сделаем:

\begin{equation}
\left\{
\begin{array}{l}
x \notin D\\
x \notin [x_1, x_2, ..., x_n]_{miss}\\
\end{array}
\right.
\end{equation}

$x_1, x_2, ..., x_n$ -- тегсеты предыдущих инструкций, $[x_1, x_2,
..., x_n]_{\mbox{miss}}$ -- тегсеты, дающие кэш-промах.

\paragraph{Кэш-промах -- второй случай} описывает ситуацию, когда
тегсет был внесен в кэш-память одним из предыдущих кэш-промахов,
затем некоторым последующим кэш-промахом он был вытеснен и с того
момента не был внесен в кэш-память вновь. Обращение к такому тегсету
в данной инструкции вызовет кэш-промах. С помощью функций полезности
запишем тот факт, что, начиная с последнего обращения к элементу,
было не менее $w$ полезных инструкций. Именно столько раз надо
сдвинуть элемент в списке LRU от начала до самого конца, чтобы его
вытеснить.

\begin{lemma}[представление кэш-промаха-II с помощью функций
полезности для LRU] Пусть $x$ -- тегсет текущей инструкции при
стратегии вытеснения LRU. Тогда если $x \in [x_1, x_2, ...,
x_n]_{\mbox{miss}}$, где $x_1, x_2, ..., x_n$ -- тегсеты предыдущих
инструкций, а $[x_1, x_2, ..., x_n]_{\mbox{miss}}$ -- тегсеты,
дающие кэш-промах, то $x$ вытеснен к моменту текущей инструкции
согласно определению LRU на списках тогда и только тогда, когда
$\sum^n_{i=1} u(x_i) \geqslant w$, где $u(x_i)$ (\emph{функция
полезности}) определена следующим образом:

$$u(x_i) = \left\{
\begin{array}{l}
    x \notin \{x_i, ..., x_n\} \wedge R(x_i) = R(x) \wedge \sum_{j=1}^{i-1} c_i(x_j) = 0,
        \\ \qquad \mbox{если}~x_i~\mbox{дает кэш-попадание} \\
    x \notin \{x_i, ..., x_n\} \wedge R(x_i) = R(x), \mbox{если}~x_i~\mbox{дает кэш-промах}\\
\end{array}
\right.$$

$$
c_i(x_j) \equiv (x \notin \{x_j, x_{j+1}, ..., x_i\} \wedge x_i =
x_j)
$$

\end{lemma}
\begin{proof}
//TODO
\end{proof}



\paragraph{Кэш-промах -- третий случай} Это случай обозначен в
формулировке утверждения~\ref{hit_miss_human_domain} фразой <<$x \in
D \wedge x~\mbox{был вытеснен}~\wedge~\mbox{не внесен вновь}$>>.
Возможны два подслучая в зависимости от того, было ли обращение к
$x$ до вытесняющей его инструкции (кэш-промах-III' будет
соответствовать отсутствию обращений до вытесняющей инструкции,
кэш-промах-III'', наоборот, наличию такого обращения). Ограничения
для этих подслучаев объединены в дизъюнкцию. Для кэш-промаха-III'
нужно более $w-\delta$ полезных инструкций ($x = \lambda_\delta$),
для кэш-промаха-III'' нужно не менее $w$ полезных инструкций.

\begin{lemma}[представление кэш-промаха-III' с помощью функций
полезности для LRU] Пусть $x$ -- тегсет текущей инструкции при
стратегии вытеснения LRU. Тогда если $x = \lambda \in L_0$ и $x
\notin \{x_1, x_2, ..., x_n\}$, где $x_1, x_2, ..., x_n$ -- тегсеты
предыдущих инструкций, то $x$ вытеснен к моменту текущей инструкции
согласно определению LRU на списках тогда и только тогда, когда
$\sum^n_{i=1} u(x_i) > w - \delta$, где $\delta \in \{1, 2, ...,
w\}$ -- индекс $\lambda$ в своем наборе $L_0$ согласно метрике
вытеснения LRU, а $u(x_i)$ (\emph{функция полезности}) определена
следующим образом:

$$u(x_i) \equiv \left\{
\begin{array}{l}
    x_i \in \{ \lambda_{\delta+1}, ..., \lambda_w\} \wedge x_i \notin
\{x_1, ..., x_{i-1}\},\\ \qquad \mbox{если}~x_i~\mbox{дает кэш-попадание} \\
    R(x_i) = R( \lambda_\delta ), \mbox{если}~x_i~\mbox{дает кэш-промах}\\
\end{array}
\right.$$

\end{lemma}
\begin{proof}
//TODO
\end{proof}

\begin{lemma}[представление кэш-промаха-III'' с помощью функций
полезности для LRU] Пусть $x$ -- тегсет текущей инструкции при
стратегии вытеснения LRU. Тогда если $x = \lambda \in L_0$ и $x \in
\{x_1, x_2, ..., x_n\}$, где $x_1, x_2, ..., x_n$ -- тегсеты
предыдущих инструкций, то $x$ вытеснен к моменту текущей инструкции
согласно определению LRU на списках тогда и только тогда, когда
$\sum^n_{i=1} u(x_i) \geqslant w$, где $u(x_i)$ (\emph{функция
полезности}) определена следующим образом:

$$u(x_i) = \left\{
\begin{array}{l}
    x \notin \{x_i, ..., x_n\} \wedge x_i \in \{ \lambda_{\delta+1},
..., \lambda_w\} \wedge \sum_{j=1}^{i-1} c_i(x_j) = 0,\\
        \qquad \mbox{если}~x_i~\mbox{дает кэш-попадание} \\
    x \notin \{x_i, ..., x_n\} \wedge R(x_i) = R( \lambda_\delta ), \mbox{если}~x_i~\mbox{дает кэш-промах}\\
\end{array}
\right.$$

$\delta \in \{1, 2, ..., w\}$ -- индекс $\lambda$ в своем наборе
$L_0$ согласно метрике вытеснения LRU ($\lambda = \lambda_\delta$),

$$
c_i(x_j) \equiv (x \notin \{x_j, x_{j+1}, ..., x_i\} \wedge x_i =
x_j
$$

\end{lemma}
\begin{proof}
//TODO
\end{proof}

Неформально говоря, все инструкции до последнего обращения к
вытесняемому элементу считаются бесполезными, а после этого
обращения полезным считается лишь первое обращение к элементу,
находящемуся между $\lambda_\delta$ и концом списка (т.е. между
$\lambda_{\delta+1}$ и $\lambda_w$). Функциональный символ $c$ как
раз призван считать количество предшествующих обращений к таким
элементам с момента последнего обращения к вытесняемому элементу.
Если $c = 0$, значит, это первое обращение (предшествующих нет).

\begin{theorem}[корректность использования функций полезности для
записи LRU]Тестовая программа, построенная по ограничениям, которые
сгенерированы с использованием предъявленных выше функций
полезности, удовлетворяет своему тестовому шаблону.
\end{theorem}
\begin{proof}
  //TODO задействовать леммы для отдельных частей утверждения
  \ref{hit_miss_human}.
\end{proof}

Несколько слов об уменьшении ограничений для всех случаев.
Представленные ограничения достаточны для полного описания
кэш-попаданий и кэш-промахов. В некоторых случаях однако их
количество можно сократить, используя следующие эвристики:
\begin{itemize}
\item \emph{тождественные ограничения мощности}: ограничения вида\\
$\sum_{i=1}^n a_i \leqslant C$ можно не включать в конъюнкцию, если
$C > n$; если $C < 0$, то вся конъюнкция несовместна; если $C = 0$
или $C = n$, то ограничение мощности можно сразу расписать в
конъюнкцию вида $\bigwedge_i (a_i = \alpha)$, где $\alpha = 0$, если
$C = 0$, и $\alpha = 1$, если $C = n$; аналогично с ограничениями
вида $\sum_{i=1}^n a_i \geqslant C$;
\item \emph{ограничения на $\delta$}: если $\delta + 1 < w$, то
функция полезности, в которую входит множество
$\{\lambda_{\delta+1}, ..., \lambda_w\}$, равна 0;
\item \emph{пересечение тегсетов}: при совместном рассмотрении
тестовых ситуаций на кэш-память и буфер TLB возникают конъюнкции
ограничений вида $x \in \{x_1, ..., x_n\} \wedge \widehat{x} \notin
\{ \widehat{y_1}, ..., \widehat{y_m} \}$, где $\widehat{x}$ --
битовое поле номера физического кадра в тегсете, а среди $x_1, ...,
x_n$ и $y_1, ..., y_m$ есть общие тегсеты; поскольку если не равны
битовые поля чисел, то не равны и сами числа, то общие тегсеты можно
исключить из ограничения на $x$.
\end{itemize}


\subsection{Метод функций полезности для стратегии
вытеснения FIFO}

Как было показано ранее, стратегию вытеснения FIFO можно
воспринимать, как LRU, в котором кэш-попадание не меняет состояния
списка LRU. Таким образом, все инструкции кэш-попадания будут
бесполезными. Их вообще можно исключить из ограничений, что и
продемонстрировано в таблице~\ref{fifo_table}. Доказательства
корректности и полноты этих ограничений идентичны доказательствами
для LRU. Символом $[\sum\limits^n_{i=1}]_{miss} u(x_i)$ обозначена
сумма $u(x_i)$, где $i=1..n$ и тегсет $x_i$ дает в своей инструкции
кэш-промах.

\begin{landscape}
\begin{table}
\begin{tabular}{|c|c|c|c|c|c|}
\hline  & \centering случай &
\begin{tabular}{c}переменная\\перебора\end{tabular} & система &
\begin{tabular}{c}функция\\полезности\\для кэш-\\попадания\end{tabular} &
\begin{tabular}{c}функция\\полезности\\для кэш-\\промаха\end{tabular} \\
\hline \hline \rotatebox{90}{кэш-попадание} & -- & -- & -- & -- & --
\\ \hline \hline \multirow{15}{*}{\rotatebox{90}{кэш-промах}} &
\makecell[c{p{0.35\textwidth}}]{тегсет встречается впервые} & -- &
$\left\{\begin{array}{l} x \notin D\\
x \notin [x_1, ..., x_n]_{miss}\\
\end{array}\right.
$ & -- & -- \\ \hhline{~|-----} &
\makecell[c{p{0.35\textwidth}}]{тегсет ранее был внесен одной из
инструкций шаблона, затем вытеснен} & -- &
$\left\{\begin{array}{l}
x \in [x_1, ..., x_n]_{miss}\\
\left[ \sum\limits^n_{i=1} \right]_{miss} u(x_i) \geqslant w - \delta + 1\\
\end{array}\right.$& -- &
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)$\\
\end{tabular}
\\  \hhline{~|-----} &
\makecell[c{p{0.35\textwidth}}]{тегсет находился в начальном
состоянии кэш-памяти и был вытеснен, к нему не было обращений в
шаблоне} & $\lambda_\delta \in D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \notin \{x_1, ..., x_n\}\\
\left[ \sum\limits^n_{i=1} \right]_{miss} u(x_i) \geqslant w - \delta + 1\\
\end{array}\right.$ & -- &
\begin{tabular}{c}
$R(x_i) = R(x)$\\
\end{tabular}
\\ \hhline{~|-----} &
\makecell[c{p{0.35\textwidth}}]{тегсет находился в начальном
состоянии кэш-памяти и был вытеснен, к нему было обращение в шаблоне
после последнего внесения в кэш-память} & $\lambda_\delta \in D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \in \{x_1, ..., x_n\}\\
\left[ \sum\limits^n_{i=1} \right]_{miss} u(x_i) \geqslant w\\
\end{array}\right.$ & -- &
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)$\\
\end{tabular}
\\ \hline
\end{tabular}
\caption{Таблица систем уравнений для тестовых ситуаций в FIFO
кэш-памяти c использованием функций полезности}\label{fifo_table}
\end{table}
\end{landscape}

\subsection{Метод функций полезности для стратегии
вытеснения Pseudo-LRU}

При использовании полезностей не происходит выделение участка
тестового шаблона, непосредственно влияющего на вытеснение.
Считается, что влияние начинается с момента появления тегсета в
кэш-памяти. Другое дело, что одни инструкции влияют на его
вытеснение (все полезные инструкции влияют), а другие -- нет.

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{2.theor/plru-useful}\\
  \caption{Заполнение ветви черными вершинами в стратегии вытеснения
  Pseudo-LRU}\label{plru-useful}
\end{figure}

Рассмотрим в качестве метрики вытеснения длину черной части ветви,
начиная от листовых вершин к корню дерева. Причем вершина будет
учитываться в метрике как черная не в тот момент, когда ее
перекрашивают, а в тот момент, когда это ее последнее покрашивание в
черный цвет. Если таким образом будет закрашена вся ветвь целиком
перед кэш-промахом, то листовая вершина будет вытеснена.
Представленный на рисунке~\ref{plru-useful} шаблон успевает
покрасить 5 вершин ветви в черный цвет. %Полезные инструкции
%объединены в ломаную, которую далее будем называть \emph{лестницей},
%а ее элемент \emph{ступенью лестницы}.

\begin{utv}
Инструкция считается полезной для стратегии Pseudo-LRU, если все
последующие обращения не затрагивают элементов вершины не выше той,
до которой данное обращение совпадает в ветви вытесняемого элемента,
после последнего обращения к вытесняемому элементу.
\end{utv}

Количество полезных инструкций, необходимых для вытеснения, зависит
от цвета ветви, с которого начинается отсчет полезных инструкций:
если обращение было, то нужно не менее $\log_2 w$ инструкций (длина
ветви), если обращения не было и элемент был в кэш-памяти
изначально, то не менее $\log_2 w - n_0$, где $n_0$ -- это
количество черных вершин от листовой вершины, изначально покрашенных
в ветви, ниже которых нет обращений в тестовом шаблоне. Далее для
сокращения записи символ $W$ будет обозначать $\log_2 w$.

Отличие этой метрики вытеснения от метрики вытеснения для LRU
является \emph{немонотонность}. Это означает, что полезные
инструкции надо считать для каждого кэш-промаха заново ---
инструкции между двумя соседними кэш-промахами могут забелить
несколько вершин ветви, что уменьшит метрику вытеснения
(см.рис.~\ref{nonmonotonic}). Метрика для LRU является монотонной,
потому что инструкции между кэш-промахами не могут уменьшить метрику
вытеснения -- либо не меняют, либо увеличивают ее, сдвигая
вытесняемый тегсет к концу списка LRU (см. рис.~\ref{monotonic}).
Таким образом, ограничение, описывающее стратегию вытеснения
Pseudo-LRU, будет представлено дизъюнкцией ограничений по всем
предыдущим кэш-промахам.

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{2.theor/nonmonotonic}\\
  \caption{Немонотонная метрика вытеснения}\label{nonmonotonic}
\end{figure}

\begin{figure}[h] \center
  \includegraphics[width=0.6\textwidth]{2.theor/monotonic}\\
  \caption{Монотонная метрика вытеснения}\label{monotonic}
\end{figure}

Осталось записать понятие полезной инструкции для Pseudo-LRU в виде
ограничений. Напомню, что каждый тегсет кроме своего значения $x_i$
снабжен позицией $\pi_i$ ($\pi_i \in \{0..w-1\})$. Пусть считается
функция полезности тегсета $(x_i, \pi_i)$ относительно тегсета
$(x,\pi)$. Пусть выбрана некоторая инструкция с кэш-промахом между
$i$'й и вытесняющей. Пусть $(x_{i+1},\pi_{i+1}), ..., (x_m, \pi_m)$
-- тегсеты с позициями инструкций, расположенными между $(x_i,
\pi_i)$ и выбранным кэш-промахом, а $(x_{i+1},\pi_{i+1}), ..., (x_n,
\pi_n)$ -- тегсеты с позициями инструкций, расположенными между
$(x_i, \pi_i)$ и $(x, \pi)$. Тогда $(x_i, \pi_i)$ будет полезным,
если выполнены одновременно три условия:
\begin{itemize}
\item $x \notin \{x_i, x_{i+1}, ..., x_n\}$ -- инструкция
расположена после последнего обращения к вытесняемому тегсету;
\item $R(x) = R(x_i)$ -- инструкция принадлежит тому же региону;
\item $P(\pi_i \oplus \pi,~\pi_{i+1} \oplus \pi) \wedge ... \wedge
P(\pi_i \oplus \pi,~\pi_m \oplus \pi)$ -- все последующие обращения
должны пересекаться только в более верхних частях ветви (это
выражает предикат $P$ для пары векторов); предикат $P(\delta_i,
\delta_j)$ истинен тогда и только тогда, когда количество старших
нулевых бит у $\delta_i$ больше количества старших нулевых бит у
$\delta_j$, иными словами, только и только тогда, когда существует
$k$ такое, что $\delta_i < 2^k \leqslant \delta_j$; с использованием
битовых операций этот предикат можно записать в следующем виде:
$P(\delta_i, \delta_j) \equiv (\delta_j \geqslant 2 * \delta_i~\vee~
\delta_j > \delta_i \wedge \delta_j \oplus \delta_i > \delta_i)$,
сравнения беззнаковые.
\end{itemize}

Таблица~\ref{plru_table} содержит ограничения для разных случаев
кэш-попаданий и кэш-промахов (см. утв.~\ref{hit_miss_human_domain}).
В каждое из них включается ограничение на количество полезных
инструкций согласно предлагаемой методике использования функций
полезности. Полезности считаются относительно некоторого кэш-промаха
(для их перебора используется сокращение $x_m : \mbox{miss}$).

\begin{theorem}[корректность использования функций полезности для
записи Pseudo-LRU]
Тестовая программа, построенная по ограничениям,
которые сгенерированы с использованием предъявленных выше функций
полезности, удовлетворяет своему тестовому шаблону.
\end{theorem}
\begin{proof}
  //TODO
\end{proof}

\begin{table} \small
\begin{tabular}{|c|c|c|c|}
\hline  & \centering случай &
\begin{tabular}{c}переменная\\перебора\end{tabular} & система \\
\hline \hline \multirow{10}{*}{\rotatebox{90}{кэш-попадание}} &
\makecell[c{p{0.35\textwidth}}]{тегсет находится в начальном
состоянии кэш-памяти, к нему нет обращений до данной инструкции и он
всё ещё не вытеснен} & $\lambda_p \in D$ &
$\left\{\begin{array}{l} x = \lambda_p\\
x \notin \{x_1, ..., x_n\}\\
\bigwedge\limits_{x_m:\mbox{miss}}\sum\limits^{m-1}_{i=1} u_m(x_i)
\leqslant W - p
\end{array}\right.
$ \\ \hhline{~|---} & \makecell[c{p{0.35\textwidth}}]{тегсет
находится в начальном состоянии кэш-памяти, к нему есть обращение до
данной инструкции и он всё ещё не вытеснен} & $\lambda_p \in D$ &
$\left\{\begin{array}{l} x = \lambda_p\\
x \in \{x_1, ..., x_n\}\\
\bigwedge\limits_{x_m:\mbox{miss}}\sum\limits^{m-1}_{i=1} u_m(x_i) <
W
\end{array}\right.
$ \\  \hhline{~|---} & \makecell[c{p{0.35\textwidth}}]{тегсет был
внесен одним из кэш-промахов и с того момента не вытеснен} & -- &
$\left\{\begin{array}{l}
x \in [x_1, ..., x_n]_{miss}\\
\bigwedge\limits_{x_m:\mbox{miss}}\sum\limits^{m-1}_{i=1} u_m(x_i) <
W
\end{array}\right.
$ \\ \hline \hline \multirow{20}{*}{\rotatebox{90}{кэш-промах}} &
\makecell[c{p{0.35\textwidth}}]{тегсет встречается впервые} & -- &
$\left\{\begin{array}{l} x \notin D\\
x \notin [x_1, ..., x_n]_{miss}\\
\end{array}\right.
$ \\ \hhline{~|---} & \makecell[c{p{0.35\textwidth}}]{тегсет ранее
был внесен одной из инструкций шаблона, затем вытеснен} & -- &
$\left\{\begin{array}{l}
x \in [x_1, ..., x_n]_{miss}\\
\bigvee\limits_{x_m : \mbox{miss}}\sum\limits^{m-1}_{i=1} u_m(x_i) \geqslant W\\
\end{array}\right.$ \\  \hhline{~|---} &
\makecell[c{p{0.35\textwidth}}]{тегсет находился в начальном
состоянии кэш-памяти и был вытеснен, к нему не было обращений в
шаблоне} & $\lambda_p \in D$ &
$\left\{\begin{array}{l}
x = \lambda_p\\
x \notin \{x_1, ..., x_n\}\\
\bigvee\limits_{x_m : \mbox{miss}}\sum\limits^{m-1}_{i=1} u_m(x_i) \geqslant W - p + 1\\
\end{array}\right.
$ \\ \hhline{~|---} & \makecell[c{p{0.35\textwidth}}]{тегсет
находился в начальном состоянии кэш-памяти и был вытеснен, к нему
было обращение в шаблоне после последнего внесения в кэш-память} &
$\lambda_p \in D$ &
$\left\{\begin{array}{l} x = \lambda_p\\
x \in \{x_1, ..., x_n\}\\
\bigvee\limits_{x_m : \mbox{miss}}\sum\limits^{m-1}_{i=1} u_m(x_i) \geqslant W\\
\end{array}\right.
$ \\ \hline
\end{tabular}
\caption{Таблица систем уравнений для тестовых ситуаций в Pseudo-LRU
кэш-памяти c использованием функций полезности}\label{plru_table}
\end{table}



\subsection{Разрешение уравнений, описывающих стратегии вытеснения}

Ограничения, которые предлагается генерировать для описания тестовых
ситуаций в кэш-памяти, можно разделить на две группы: ограничения на
конечные множества тегсетов и \emph{ограничения мощности}.

Ограничения вида $C_1 \leqslant \sum_{i=1}^n a_i \leqslant C_2$, где
$C_1, C_2$ -- неотрицательные целые числа, а $a_i$ принимают
значения 0 или 1, называются \emph{ограничениями мощности}
(cardinality constraints). Речь идет об ограничении размера
некоторого множества элементов, возможно, заданного с помощью
характеристической функции. Такие ограничения можно рассматривать,
как компактную форму записи уравнения вида $\bigvee_{C_1 \leqslant C
\leqslant C_2} \sum_{i=1}^n a_i = C$, где равенство есть
\begin{itemize}
\item тождественная ложь, если $C < 0$ или $C > n$;
\item конъюнкция $\bigwedge_{1\leqslant i\leqslant n} (a_i = 0)$,
если $C = 0$;
\item дизъюнкция по всевозможным выборкам индексов $i_1, ..., i_C$, где
для каждого индекса $i_k$ справедливы свойства $1 \leqslant i_k
\leqslant n$ и $i_k < i_{k+1}$, конъюнкций $\bigwedge_{i_k} (a_{i_k}
= 1)$, если $1 \leqslant C \leqslant n$.
\end{itemize}

Задача организации особой процедуры разрешения ограничений не
входила в проводимое исследование, поэтому были использованы
имеющиеся инструменты решения систем уравнений и неравенств.

После устранения ограничений мощности в формуле остаются только
ограничения на конечные множества тегсетов: принадлежности и
непринадлежности тега конечному множеству тегсетов и равенства и
неравенства битовых полей тегсетов. Поскольку конечные множества
тегсетов известны (заданы перечислением тегсетов, которые в входят в
это множество), то ограничения принадлежности и непринадлежности
могут быть переписаны без использования этих отношений. Отношение
принадлежности $x \in \{x_1, x_2, ..., x_n\}$ может быть переписано
в виде дизъюнкции $(x = x_1) \vee (x = x_2) \vee ... \vee (x =
x_n)$, а отношение непринадлежности $x \notin \{x_1, x_2, ...,
x_n\}$ -- в виде конъюнкции $(x \neq x_1) \wedge (x \neq x_2) \wedge
... \wedge (x \neq x_n)$.

В результате получается предикат, в котором переменными величинами
являются неотрицательные целые числа с конечной областью значений
(тегсеты), над переменными возможны операции получения битового
поля, в предикате используется отношение равенства и неравенства над
битовыми полями. Кроме того, этот предикат задается с использованием
ограничений мощности.

Для разрешения такого рода предикатов можно было бы разрабатывать
собственные процедуры распространения ограничений, но это свело бы
на нет все усилия по выработке собственного представления стратегии
вытеснения. В последний десяток лет разрабатываются инструменты,
поддерживающие идею SMT (SAT Modulo Theories)~\cite{Z3, Yices}.
Задачей для SMT является разрешение предиката, т.е. выяснение
наличия модели у этого предиката. Однако язык предикатов для SMT
намного богаче языка предикатов для SAT (только пропозициональная
логика). Язык предикатов для SMT включает целые числа с линейными
операциями и отношениями сравнения целых чисел, термы
(неинтерпретируемые функции), битовые строки и др. Этого языка
вполне хватает, чтобы выразить в нем генерируемые предикаты для
тестовых ситуаций в кэш-памяти.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\pagebreak
\section{Ограничения, описывающие тестовые ситуации в некоторых
частных случаях, для стратегии вытеснения LRU}

\subsection{Тестовые шаблоны без кэш-промахов}

В случае тестовых шаблонов, в которых нет кэш-промахов, нет ни
вытесняющих, ни вытесняемых тегсетов. Поэтому в таких шаблонов
уравнения для кэш-попаданий имеют очень простой вид:

$$
\left\{
\begin{array}{l}
x \in D\\
... (\mbox{тестовая ситуация на буфер TLB})\\
\end{array}
\right.
$$

\subsection{Тестовые шаблоны без кэш-попаданий}

В случае тестовых шаблонов, в которых нет кэш-попаданий, надо
генерировать ограничения для вытесняющих и лишь иногда для
вытесняемых тегсетов. А именно, вытесняемый тегсет требуется лишь в
том случае, когда кэш-промах вносит в кэш-память ранее вытесненный
тегсет. В этом случае для вытесняемого тегсета известен домен, что
позволяет построить уравнения обозримого размера. Кроме того,
поскольку отсутствуют кэш-попадания, повторные обращения к
вытесняемым тегсетам (кроме кэш-промаха, который их может внести в
кэш-память) невозможны, что также упрощает генерируемые уравнения.

В результате получается, что вытесняющий тегсет описывается в
тестовом шаблоне без кэш-попаданий следующей системой уравнений:
$$
F'(x) \vee F''(x) \vee \bigvee_{\lambda_\delta \in D} F'''(x, \lambda_\delta)
$$

где

$$F'(x) \equiv (x \notin D \wedge x \notin \{x_1, ..., x_n\})$$

$$F''(x) \equiv (x \in \{x_1, ..., x_n\} \wedge \sum_{i=1}^n u''(x_i) \geqslant w)$$

$$u''(x_i) \equiv (x\notin \{x_i, ..., x_n\} \wedge R(x_i) = R(x))$$

$$F'''(x, \lambda_\delta) \equiv (x = \lambda_\delta \wedge x \notin
\{x_1, ..., x_n\} \wedge \sum_{i=1}^n (R(x_i) = R(x)) \geqslant w -
\delta + 1)$$

\subsection{Простые тестовые шаблоны}

Рассмотрим еще один класс тестовых шаблонов -- т.н. \emph{простые
тестовые шаблоны}. Структура этих тестовых шаблонов такова, что все
диапазоны вытеснения будут начинаться в начальном состоянии
кэш-памяти. Это позволит строить более простые уравнения по
сравнению с общим случаем.

Тестовый шаблон называется \emph{простым}, если в нем не более $w$ кэш-промахов.

\begin{theorem}
Случай, когда вытесняемый тегсет не находился в начальном состоянии
кэш-памяти, а был внесен одной из инструкций тестового шаблона,
невозможен для простых тестовых шаблонов.
\end{theorem}
\begin{proof}
//TODO
\end{proof}

\subsection{Короткие тестовые шаблоны}

Будем называть тестовый шаблон \emph{коротким}, если в нем не более
$w$ инструкций обращения к памяти. Очевидно, что любой короткий
тестовый шаблон является простым. Из 7 случаев для коротких тестовых
шаблонов остается всего 5 (первые два можно еще объединить в более
компактную систему уравнений).

\begin{theorem}[корректность использования функций полезности для
записи LRU в коротких тестовых шаблонах] Тестовая программа,
построенная по ограничениям, которые сгенерированы с использованием
предъявленных в таблице~\ref{short_templates_table} функций
полезности, удовлетворяет своему короткому тестовому шаблону.
\end{theorem}
\begin{proof}
  //TODO
\end{proof}


\begin{landscape}
\begin{table}
\begin{tabular}{|c|c|c|c|c|c|}
\hline  & \centering случай &
\begin{tabular}{c}переменная\\перебора\end{tabular} & система &
\begin{tabular}{c}функция\\полезности\\для кэш-\\попадания\end{tabular} &
\begin{tabular}{c}функция\\полезности\\для кэш-\\промаха\end{tabular} \\
\hline \hline \multirow{-2}{*}{\rotatebox{90}{кэш-попадание}} &
\makecell[c{p{0.3\textwidth}}]{тегсет находится в начальном
состоянии кэш-памяти и он всё ещё не вытеснен} & $\lambda_\delta \in
D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
\sum\limits^n_{i=1} u(x_i) \leqslant w - \delta
\end{array}\right.
$ &
\begin{tabular}{c}
$x_i \in \{ \lambda_{\delta+1}, ..., \lambda_w\}$\\
$\wedge~x_i \notin \{x_1, ..., x_{i-1}\}$
\end{tabular}
& $R(x_i) = R(x)$
\\ \hhline{~|-----}
& \makecell[c{p{0.3\textwidth}}]{тегсет уже встречался в шаблоне} &
-- & $x \in \{x_1, ..., x_n\}$ & -- & --
\\ \hline \hline \multirow{6}{*}{\rotatebox{90}{кэш-промах}}
& \makecell[c{p{0.3\textwidth}}]{тегсет встречается впервые} & -- &
$\left\{\begin{array}{l} x \notin D\\
x \notin \{x_1, ..., x_n\}\\
\end{array}\right.
$ & -- & -- \\ \hhline{~|-----} &
\makecell[c{p{0.3\textwidth}}]{тегсет находился в начальном
состоянии кэш-памяти и был вытеснен} &
$\begin{array}{c}\lambda_\delta \in D,\\\delta \geqslant
w-n+1\end{array}$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \notin \{x_1, ..., x_n\}\\
\sum\limits^n_{i=1} u(x_i) > w - \delta\\
\end{array}\right.
$ &
\begin{tabular}{c}
$x_i \in\{\lambda_{\delta+1}, ..., \lambda_w\}$\\
$\wedge~x \notin \{x_1, ..., x_{i-1}\}$\\
\end{tabular}
&
\begin{tabular}{c}
$R(x_i) = R(x)$\\
\end{tabular}
\\ \hline
\end{tabular}
\caption{Таблица систем уравнений для тестовых ситуаций в кэш-памяти
для коротких тестовых шаблонов в случае стратегии вытеснения
LRU}\label{short_templates_table}
\end{table}
\end{landscape}


\subsection{Генерация тестовых данных для кэш-памяти, содержащей
<<грязные>> ячейки}

Любая ячейка в кэш-памяти может быть помечена \emph{грязной}
(\emph{invalid}). Это означает, что данные, находящиеся в кэш-памяти
по этому адресу, не могут использоваться в качестве данных,
хранящихся в памяти по этому адресу.

Рассмотренные ранее в этой работе случаи не учитывали грязные ячейки
кэш-памяти, хотя они зачастую присутствуют в микропроцессоре после
его запуска -- с таким состоянием кэш-памяти работают первые после
запуска микропроцессора инструкции.

Кэш-попадание возникает в том случае, когда требуемые данные
присутствуют среди <<чистых>> ячеек кэш-памяти. Кэш-промах возникает
в том случае, когда требуемых данных нет среди <<чистых>> ячеек.
Причем при наличии <<грязных>> ячеек вытеснения может и не
произойти. А именно, если все ячейки набора, с которым работает
инструкция, являются <<чистыми>>, то происходит вытеснение согласно
стратегии вытеснения, остальные наборы не меняются. Если же среди
ячеек набор есть <<грязные>> ячейки, то вытеснение не происходит, а
на место одной из <<грязных>> ячеек помещаются данные из основной
памяти по заданному адресу и ячейка объявляется <<чистой>>.
Остальные ячейки не меняются. В стратегии вытеснения LRU эта бывшая
<<грязная>> ячейка становится самой новой.

Для генерации тестовых данных для кэш-памяти с грязными ячейками
предлагается применять ограничения с функциями полезности.
Примечательно, что наличие грязных ячеек не меняет качественно
систему уравнений.

В данном разделе рассматривается случай, когда начальное состояние
микропроцессора известно. Кроме того, рассматриваемый случай
учитывает отсутствие инструкций в тестовом шаблоне, которые
превращали бы <<чистые>> ячейки в <<грязные>> (т.е. все такие
изменения должны делаться явно вне тестовых шаблонов).

\subsubsection{случай полностью-ассоциативной кэш-памяти}

В случае полностью-ассоциативной кэш-памяти очевидно, что первые
кэш-промахи будут заполнять <<грязные>> ячейки. Пусть $N$ --
количество <<грязных>> ячеек в начальном состоянии кэш-памяти, а
$L_0$ -- начальное состояние (выражение) кэш-памяти (только
<<чистые>> ячейки). Тогда для тестовых ситуаций надо генерировать
такие ограничения ($L$ -- выражение для состояния кэш-памяти перед
исполнением инструкции, $L'$ -- выражение для состояния кэш-памяти
после исполнения инструкции):
\begin{itemize}
\item для \emph{кэш-попадания} hit($x$) генерируются ограничения
$$
\left\{
\begin{array}{l}
x \in L\\
L' \equiv L\\
\end{array}
\right.
$$

\item для \emph{кэш-промаха} miss($x$), если это один из первых $N$
кэш-промахов, генерируются ограничения:
$$
\left\{
\begin{array}{l}
x \notin L\\
L' \equiv L \cup \{x\}\\
\end{array}
\right.
$$

\item для \emph{кэш-промаха} miss($x$), являющегося по счету более
чем $N$'м кэш-промахом тестового шаблона, генерируются ограничения:
$$
\left\{
\begin{array}{l}
x \notin L\\
x' \in L\\
L' \equiv L\setminus\{x'\} \cup \{x\}\\
displaced(x', L)\\
\end{array}
\right.
$$
\end{itemize}

Предикат $displaced(x', L)$ истинен, если $x'$ является вытесняемым
тегом в текущем состоянии кэш-памяти $L$. Для стратегии вытеснения
LRU этот предикат может быть записан с использованием тех же
диапазонов вытеснения, что и для кэш-памяти без <<грязных>> ячеек
(см.п.~\ref{LRU_constraints}). А именно, диапазон вытеснения
начинается на инструкции, которая последний раз перед вытеснением
тега обращается к нему. Тогда между этой инструкцией и инструкцией,
вытесняющей $x$, должны быть обращения ко всем остальным тегам
текущего состояния кэш-памяти. Эта логика может быть записана в виде
тех же уравнений, что и в пункте~\ref{LRU_constraints}. Нетрудно
проверить, что для кэш-памяти с <<грязными>> ячейками остается
справедливой лемма о невложенных диапазонах вытеснения, что
доказывает корректность использования ограничений из
пункта~\ref{LRU_constraints} для кэш-памяти с <<грязными>> ячейками.

\subsubsection{случай наборно-ассоциативной кэш-памяти}

Рассмотрим совместную генерацию тестовых данных для кэш-памяти и
TLB. Как и прежде, заметим, что в зависимости от значения
виртуального адреса, обращения в память можно разделить по двум
критериями: Cached-unCached и Mapped-unMapped. Для полностью
ассоциативной кэш-памяти и TLB генерация ограничений рассмотрена в
предыдущем пункте. Генерация ограничений для наборно-ассоциативной
кэш-памяти будет рассмотрена здесь. Для примера рассмотрим случай
Cached-Mapped. В этом пункте будет показано, что ограничения для
кэш-памяти, начальное состояние которой содержит <<грязные>> ячейки,
качественно не отличаются от ограничений для кэш-памяти без
<<грязных>> ячеек.

Аналогично тому, как это делалось для кэш-памяти без <<грязных>>
ячеек, для тестовых ситуаций на кэш-память с <<грязными>> ячейками
тоже возможно следующее исчерпывающее выделение случаев:
\begin{itemize}
\item кэш-попадание тега:
    \begin{enumerate}
    \item данный тег находился в начальном состоянии кэш-памяти и не был
    вытеснен к моменту кэш-попадания;
    \item данный тег был внесен в кэш-память одной из инструкций
    кэш-промаха и с тех пор не был вытеснен.
    \end{enumerate}
\item кэш-промах тега:
    \begin{enumerate}
    \item данный тег не встречался ранее (не находился в начальном
    состоянии кэш-памяти и не был внесен какими-либо кэш-промахами);
    \item данный тег был ранее вытеснен из кэш-памяти и с тех пор
    не был внесен в кэш-память вновь.
    \end{enumerate}
\end{itemize}

Соответствующие ограничения приведены в
таблице~\ref{dirty_hit_miss_table}.

\begin{landscape}
\begin{table} \small
\begin{tabular}{|c|c|c|c|c|c|}
\hline  & \centering случай &
\begin{tabular}{c}переменная\\перебора\end{tabular} & система &
\begin{tabular}{c}функция полезности\\для кэш-попадания\end{tabular} &
\begin{tabular}{c}функция полезности\\для кэш-промаха\end{tabular} \\
\hline \hline \multirow{10}{*}{\rotatebox{90}{кэш-попадание}} &
\makecell[c{p{0.38\textwidth}}]{тегсет находится в начальном
состоянии кэш-памяти, к нему нет обращений до данной инструкции и он
всё ещё не вытеснен} & $\lambda_\delta \in D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \notin \{x_1, ..., x_n\}\\
\sum\limits^n_{i=1} u(x_i) \leqslant w - \delta
\end{array}\right.
$ &
\begin{tabular}{c}
$x_i \in \{ \lambda_{\delta+1}, ..., \lambda_\Delta\}$\\
$\wedge~x_i \notin \{x_1, ..., x_{i-1}\}$
\end{tabular}
& $R(x_i) = R(x)$
\\ \hhline{~|-----}
& \makecell[c{p{0.38\textwidth}}]{тегсет находится в начальном
состоянии кэш-памяти, к нему есть обращение до данной инструкции и
он всё ещё не вытеснен} & $\lambda_\delta \in D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \in \{x_1, ..., x_n\}\\
\sum\limits^n_{i=1} u(x_i) < w
\end{array}\right.
$ &
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~x_i \in \{ \lambda_{\delta+1}, ..., \lambda_\Delta\}$\\
$\wedge~\sum_{j=1}^{i-1} c_i (x_j) = 0,$\\
$c_i(x_j) \equiv (x\notin \{x_j, ..., x_i\}$\\
$\wedge~x_i = x_j)$\\
\end{tabular}
&
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)$\\
\end{tabular}
\\  \hhline{~|-----}
& \makecell[c{p{0.38\textwidth}}]{тегсет был внесен одним из
кэш-промахов и с того момента не вытеснен} & -- &
$\left\{\begin{array}{l} x \in [x_1, ..., x_n]_{miss}\\
\sum\limits^n_{i=1} u(x_i) < w
\end{array}\right.
$ &
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)~\wedge$\\
$\sum^{i-1}_{j=1} c_i(x_j) = 0,$\\
$c_i(x_j) \equiv (x\notin \{x_j, ..., x_i\}$\\
$\wedge~x_i = x_j)$\\
\end{tabular}
&
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)$\\
\end{tabular}
\\ \hline \hline \multirow{20}{*}{\rotatebox{90}{кэш-промах}}
& \makecell[c{p{0.38\textwidth}}]{тегсет встречается впервые} & -- &
$\left\{\begin{array}{l} x \notin D\\
x \notin [x_1, ..., x_n]_{miss}\\
\end{array}\right.
$ & -- & -- \\ \hhline{~|-----} &
\makecell[c{p{0.38\textwidth}}]{тегсет ранее был внесен одной из
инструкций шаблона, затем вытеснен} & -- &
$\left\{\begin{array}{l} x \in [x_1, ..., x_n]_{miss}\\
\sum\limits^n_{i=1} u(x_i) \geqslant w\\
\end{array}\right.
$ &
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)~\wedge$\\
$\sum_{j=1}^{i-1}c_i(x_j) = 0,$\\
$c_i(x_j) \equiv (x\notin\{x_j, ..., x_i\}$\\
$\wedge~x_i = x_j)$
\end{tabular}
&
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)$\\
\end{tabular}
\\  \hhline{~|-----} &
\makecell[c{p{0.38\textwidth}}]{тегсет находился в начальном
состоянии кэш-памяти и был вытеснен, к нему не было обращений в
шаблоне} & $\lambda_\delta \in D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \notin \{x_1, ..., x_n\}\\
\sum\limits^n_{i=1} u(x_i) \geqslant w - \delta + 1\\
\end{array}\right.
$ &
\begin{tabular}{c}
$x_i \in\{\lambda_{\delta+1}, ..., \lambda_\Delta\}$\\
$\wedge~x_i \notin \{x_1, ..., x_{i-1}\}$\\
\end{tabular}
&
\begin{tabular}{c}
$R(x_i) = R(x)$\\
\end{tabular}
\\ \hhline{~|-----} &
\makecell[c{p{0.38\textwidth}}]{тегсет находился в начальном
состоянии кэш-памяти и был вытеснен, к нему было обращение в шаблоне
после последнего внесения в кэш-память} & $\lambda_\delta \in D$ &
$\left\{\begin{array}{l} x = \lambda_\delta\\
x \in \{x_1, ..., x_n\}\\
\sum\limits^n_{i=1} u(x_i) \geqslant w\\
\end{array}\right.
$ &
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~x_i \in \{\lambda_{\delta+1}, ..., \lambda_\Delta\}$\\
$\wedge~\sum_{j=1}^{i-1}c_i(x_j) = 0,$\\
$c_i(x_j) \equiv (x\notin\{x_j, ..., x_i\}$\\
$\wedge~x_i = x_j)$
\end{tabular}
&
\begin{tabular}{c}
$x \notin \{x_i, ..., x_n\}$\\
$\wedge~R(x_i) = R(x)$\\
\end{tabular}
\\ \hline
\end{tabular}
\caption{Таблица систем уравнений для тестовых ситуаций в кэш-памяти
c <<грязными>> ячейками в начальном состоянии, использующих функции
полезности}\label{dirty_hit_miss_table}
\end{table}
\end{landscape}

В таблице~\ref{dirty_hit_miss_table} символ $\Delta$ означает
количество <<чистых>> ячеек в начальном состоянии того региона, про
который идет речь в уравнении. На самом деле $\Delta$ есть функция
региона ($\Delta = \Delta(\lambda_\delta)$, но для сокращения записи
оставлен только функциональный символ. Кроме того, в приведенных
уравнениях домен переменной включает только <<чистые>> ячейки.

Сходства уравнений (со случаем кэш-памяти без <<грязных>> ячеек)
удалось добиться за счет рассмотрения <<грязных>> ячеек, как ячеек с
наименьшим счетчиком LRU, которые не участвуют в определении
нахождения тега в кэш-памяти. Поэтому в функциях полезности
участвуют множества не $\{\lambda_{\delta+1}, ..., \lambda_w\}$, а
множества $\{\lambda_{\delta+1}, ..., \lambda_\Delta\}$. Все
<<чистые>> ячейки получили первые индексы, т.е. индексы всех от 1 до
$\Delta$.

\begin{theorem}[корректность использования функций полезности для
записи LRU в случае наличия <<грязных>> ячеек в начальном состоянии
кэширующего буфера] Тестовая программа, построенная по ограничениям,
которые сгенерированы с использованием предъявленных в
таблице~\ref{dirty_hit_miss_table} функций полезности, в случае
наличия <<грязных>> ячеек в начальном состоянии кэширующего буфера
удовлетворяет своему тестовому шаблону.
\end{theorem}
\begin{proof}
  //TODO
\end{proof}

Для приведенных ограничений также могут быть применены эвристики,
сокращающие их количество, которые были упомянуты для кэш-памяти без
<<грязных>> ячеек. Кроме того, в данном случае возможна
дополнительная эвристика \emph{ограничение на $\delta$}: если
$\delta + 1 < \Delta$, то функция полезности, в которую входит
множество $\{\lambda_{\delta+1}, ..., \lambda_\Delta\}$, равна 0.

\subsection{Функции полезности для зеркальной генерации тестовых
данных}

Рассмотрим ограничения, генерируемые для тестовых шаблонов
зеркальным методом с использованием функций полезности. По сравнению
с представленными ограничениями (см. табл.~\ref{hit_miss_table})
зеркальная генерация имеет свои особенности:
\begin{enumerate}
  \item множества констант (как, например, $L, D$) не используются,
  поэтому в ограничениях будут отсутствовать соответствующие им
  случаи;
  \item так как теги инструкций тестового шаблона должны появиться
  среди инициализирующей последовательности, то для вытеснения
  требуется $w-1$ инструкций, где $w$ -- ассоциативность кэширующего буфера;
  \item учет полезных инструкций начинается уже в инициализирующей
  последовательности, тем самым необходимо сформулировать функцию
  полезности для инициализирующих инструкций.
\end{enumerate}

Следующая теорема описывает функцию полезности для инициализирующих
инструкций и описывает ограничения, генерируемые для тестовых
шаблонов зеркальным методом с использованием функций полезности
(количество инициализирующих инструкций зафиксировано, оно будет
обозначено параметром $m$):

\begin{theorem}[Корректность ограничений, генерируемые зеркальным методом с
использованием функций полезности для LRU] Пусть $t_1, t_2, ...,
t_m$ -- теги инициализирующей последовательности, $x$ -- текущий тег
тестового шаблона, $x_1, x_2, ..., x_n$ -- теги предыдущих
инструкций тестового шаблона. Тогда $x$ удовлетворяет тестовой
ситуации согласно определению на списках тогда и только тогда,
когда:
\begin{itemize}
\item если текущая инструкция дает кэш-попадание, то
$$
\left\{\begin{array}{l} x \in \{t_1, ..., t_m, x_1, ..., x_n\}\\
\sum\limits_{i=1}^m u_x(t_i) + \sum\limits_{i=1}^n u_x(x_i) < w\\
\{t_1, ..., t_m\} - \mbox{все разные}\\
\end{array} \right.
$$
\item если текущая инструкция дает кэш-промах, то
$$
\left\{\begin{array}{l} x \in \{t_1, ..., t_m, x_1, ..., x_n\}\\
\sum\limits_{i=1}^m u_x(t_i) + \sum\limits_{i=1}^n u_x(x_i)
\geqslant w\\
\{t_1, ..., t_m\} - \mbox{все разные}\\
\end{array} \right.
$$

где функции полезности определены следующим образом:

$$u_x(t_i) \equiv (x \notin \{t_i, ..., t_m, x_1, ..., x_n\} \wedge
R(x) = R(t_i))$$

$$\begin{array}{c}u_x(x_i) \equiv (x \notin \{x_i, ..., x_n\} \wedge R(x) =
R(x_i)),\\ \mbox{если инструкция с $x_i$ содержит
кэш-промах}\end{array}$$

$$\begin{array}{c}u_x(x_i) \equiv (x \notin \{x_i, ..., x_n\} \wedge R(x) =
R(x_i) \\ \wedge \sum\limits_{j=1}^{n} \tilde{c}_{x_i}(t_j) = 0
\wedge \sum\limits_{j=1}^{i-1} c_i(x_j) = 0),\\ \mbox{если
инструкция с $x_i$ содержит кэш-попадание}\end{array}$$

$$c_i(x_j) \equiv (x \notin \{x_j, ..., x_i\} \wedge x_i = x_j)$$

$$\tilde{c}_{x_i}(t_j) \equiv (x \notin \{t_j, ..., t_m, x_1, ..., x_{i-1}\} \wedge x_i = t_j)$$

$$c_i(x_j) \equiv (x \notin \{x_j, ..., x_i\} \wedge x_i = x_j)$$

\end{itemize}
\end{theorem}
\begin{proof}//TODO\end{proof}

Стоит заметить, что функции полезности добавили новое дополнительное
условие на теги инициализирующих инструкций: они должны быть
различными. В этом выражается свойство <<простоты>> инициализирующей
последовательности, эта последовательность не должна содержать
сложной внутренней последовательности изменений состояния
кэширующего буфера.

Рассмотрим один часто встречающийся случай кэширующих буферов,
инициализация которого может вызывать трудности. Речь идет о
кэш-памяти второго уровня. Зачастую кэш-память второго уровня не
может быть инициализирована отдельно от остальных подсистем
микропроцессора, обычно оно связано с изменением кэш-памяти первого
уровня. Это создает дополнительные сложности при формулировании
ограничений методом зеркальной генерации, поскольку инициализирующая
последовательность должна подготавливать сразу два кэширующих буфера
одновременно -- кэш-память первого уровня и кэш-память второго
уровня. Кроме того, зачастую кэш-память второго уровня является
совместной для хранения в ней данных и инструкций. Поэтому на
инициализацию кэш-памяти второго уровня влияют и сами
инициализирующие инструкции, и даже адрес расположения тестовой
программы в памяти (от него зависит виртуальный адрес инструкций, а
значит теги и индексы при обращении к кэш-памяти инструкций).

Если принять дополнительное требование (и оно даст решение), что в
кэш-памяти второго уровня наборы, используемые для доступа к
инструкциям, не пересекаются с наборами, используемыми для доступа к
данным, то генерируемые ограничения упрощаются (кэширование
инструкций можно вообще не учитывать). С точки зрения зеркальной
генерации это означает, что надо сформулировать требования на
инициализирующую последовательность. Напомню, что одним из ключевых
требований является произвольность начального состояния
(содержимого) кэш-памяти.

Предположим, что обращение к кэш-памяти второго уровня
осуществляется при кэш-промахе в кэш-памяти первого уровня и
кэш-память не является virtually indexed virtually
tagged~\cite{HennessyPatterson}. Для составления ограничений с
использованием функций полезности необходимо знать, которые
инструкции среди инициализирующей последовательности действительно
обращаются в кэш-память второго уровня (иными словами, в каких
инструкциях среди инициализирующей последовательности происходит
кэш-промах при обращении к кэш-памяти первого уровня). Возможным
решением было бы перебирать всевозможные распределения тестовых
ситуаций в кэш-памяти первого уровня на элементах инициализирующей
последовательности (с предварительной подготовкой этих тестовых
ситуаций). Однако следующая лемма~\ref{special_initialization_L2}
показывает, что для любого такого произвольного распределения
тестовых ситуаций в кэш-памяти первого уровня существует решение со
специальным распределением тестовых ситуаций. Это позволяет
перебирать только такие специальные распределения тестовых ситуаций
в кэш-памяти первого уровня. При этом вычислительная сложность
процедуры поиска инициализирующей последовательности, дающей
решение, изменяется от экспоненциальной от длины тестового шаблона к
полиномиальной, что показывает лемма~\ref{max_k_l_r}

\begin{lemma}[О существовании специальной инициализации
кэш-памяти]\label{special_initialization_L2} Если для данного
тестового шаблона $(S_i, x_i)$, где $i = 1, 2, ..., n$, $S_i \in \{
\mbox{l1Hit}, \mbox{l1Miss l2Hit}, \mbox{l1Miss l2Miss} \}$, $x_i$
-- тегсет, существует некоторое решение, полученное зеркальным
методом, а именно, $t_1, ..., t_m$ -- инициализирующая
последовательность и $v_1, ..., v_n$ -- значения тегсетов тестового
шаблона, то для этого же тестового шаблона существует и решение
следующего вида: инициализирующая последовательность состоит из трех
подпоследовательностей $s_1, ..., s_k$, $p_1, ..., p_l$, $q_1, ...,
q_r$, где при обращении к тегсетам $p_1, ..., p_l$ происходят
кэш-промахи в кэш-памяти первого уровня, при обращении к тегсетам
$q_1, ..., q_r$ происходят кэш-попадания в кэш-памяти первого
уровня, последовательность тегсетов $s_1, ..., s_k$ обеспечивают
выполнение тестовых ситуаций в кэш-памяти первого уровня для
последующих элементов инициализирующей последовательности, значения
тегсетов тестового шаблона те же, $v_1, ..., v_n$.
\end{lemma}
\begin{proof}
  //TODO
\end{proof}

\begin{lemma}[Верхняя оценка длины специальной инициализирующей
последовательности]\label{max_k_l_r}
$$0 \leqslant k \leqslant 3 |\mbox{l2Hit}| * w_1 + |\mbox{l2Miss}| * (w_2+2) * w_1 + |\mbox{l1Hit}|$$
$$0 \leqslant l \leqslant |\mbox{l2Hit}| + |\mbox{l2Miss}| * w_2$$
$$0 \leqslant r \leqslant |\mbox{l1Hit}| + 2 |\mbox{l2Hit}| * w_1 + 2 |\mbox{l2Miss}| * w_1$$
где $w_1$ -- ассоциативность кэш-памяти первого уровня, $w_2$ --
ассоциативность кэш-памяти второго уровня, $|\mbox{l1Hit}|$ --
количество инструкций в тестовом шаблоне c кэш-попаданием в
кэш-памяти первого уровня, $|\mbox{l2Hit}|$ -- количество инструкций
в тестовом шаблоне c кэш-попаданием в кэш-памяти второго уровня,
$|\mbox{l2Miss}|$ -- количество инструкций в тестовом шаблоне c
кэш-промахом в кэш-памяти второго уровня.
\end{lemma}
\begin{proof}
  //TODO
\end{proof}
\begin{sld}
$$0 \leqslant m \leqslant n * (w_1 * w_2 + 5w_1 + w_2 + 3)$$ где $m$
-- длина специальной инициализирующей последовательности, $n$ --
длина тестового шаблона, $w_1$ -- ассоциативность кэш-памяти первого
уровня, $w_2$ -- ассоциативность кэш-памяти второго уровня.
\end{sld}

Для получения инициализирующей программы минимальной длины, можно
применять сначала двоичный поиск суммы $k+l+r$ с применением
дальнейшего поиска допустимых значений $k$, $l$ и $r$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
