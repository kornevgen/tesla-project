% !Mode:: "TeX:UTF-8"
\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}

%Мысль первая: Есть тестирование программами, но для него надо
%генерировать программы.
%
%Мысль вторая: Можно писать вручную, использовать готовые программы
%или погенерировать случайно. Но это всё плохо.
%
%Мысль третья: Поэтому надо генерировать по-умному, а именно отделять
%цель тестирования от генерации программы. При этом не забываем, что
%есть куча других методов построения программ, которые не выделяют
%цели тестирования (model checking для достижения особых случаев в
%поведении, coverage-based анализ, генетический сбор программ как
%хромосом и другие)
%
%Мысль четвертая: Показать, что процесс построения через цели
%тестирования является хорошим
%
%Ну и далее речь пойдет уже построении программ для шаблонов

Диссертация посвящена вопросам функционального тестирования
микропроцессоров. Среди всевозможных способов функционального
тестирования своей наглядностью и относительно невысокой
трудоемкостью выделяется тестирование машинными программами. Эти
программы помещаются в память машины, возможно туда же помещается и
некоторая дополнительная информация, затем машина запускается,
микропроцессор считывает инструкции программы одну за другой и
исполняет их. ...Микропроцессор работает в разных ситуациях... После
того, как машина закончила свою работу, на основе анализа ее
состояния и трассы исполнения принимается решение о корректности
работы микропроцессора.

Важным является вопрос качества тестирования --- насколько полно был
протестирован микропроцессор, насколько разнообразными были те
ситуации, в которых работал микропроцессор на использованных
машинных программах. В предельном случае тестирование будет полным,
если количество машинных программ соответствует пространству всех
состояний микропроцессора. Однако это пространство настолько
огромное, что даже построение соответствующих ему программ
невозможно.

До сих пор активно используется ручное написание программ. В
основном это такие <<узкие>> места микропроцессора, о которых
сообщают его разработчики. Другой случай --- это так называемые
<<крайние>> случаи исполнения инструкций.

Однако для более полного тестирования построение машинных программ
автоматизируется. Правда, зачастую эта автоматизация не уходит
дальше случайно сгенерированных программ или переиспользования
программ, которые были подготовлены для совместимых
микропроцессоров. Тем не менее, даже после такого тестирования всё
ещё остаются ошибки и довольно критичные [FDIV].

В ИнстиБыло предложено строить машинные программы (т.е. тесты)
нацеленным образом. Это означает формулирование сначала целей
тестирования, а затем автоматическая генерация тестов,
удовлетворяющих целям тестирования [MicroTESK]. Например, в качестве
цели тестирования может быть выбрана особая ситуация в работе
микропроцессора (скажем, возникновение переполнения), соответственно
эта ситуация должна произойти при исполнении теста.

>>>>> Написать, что эта технология неплохая...

Автоматическое построение тестов, удовлетворяющих целям
тестирования, является сложной задачей с алгоритмической точки
зрения. Но в то же время ее решение необходимо для генерации тестов.
До сих пор эта задача не решена для произвольных целей тестирования.
Всё это определило актуальность задачи и важность ее решения. В том
числе данная статья посвящена задаче автоматического построения
тестов.

Очевидно, что сложность построения тестов напрямую зависит от тех
целей, которые необходимо достичь в тестах. Часто используются
специальные цели, для которых построение тестов выполняется
относительно просто [TSE]. В качестве примера, можно привести цели,
которые состоят из заданной последовательности инструкций с
незаданными аргументами - регистрами или непосредственными
значениями - с указанием зависимостей между аргументами (например,
одна инструкция записывает значение в регистр - другая этот регистр
читает). Однако не все цели тестирования выражаются в такой простой
форме. Примером такой цели может быть возникновение кэш-попадания
при исполнении некоторой инструкции.

Для дальнейшего важными являются следующие моменты. Во-первых, в
микропроцессоре есть подсистемы, которые ведут себя как кэш-память
(собственно, кэш-память в узком понимании этого термина, различные
буферы, хранящие временные данные). Далее такие подсистемы будут
называться кэширующими буферами. Их можно представить как множество
пар "(адрес, данные)", в которых все адреса разные (термин "данные"
понимается в узком смысле, а именно как информация, которая хранится
в оперативной памяти и используется в процессах счета). Обращением к
кэширующему буферу будем называть процедуру получения данных,
хранящихся по заданному адресу. Обращение будет считаться успешным
(эта ситуация называется кэш-попаданием), если в кэширующем буфере
есть пара с заданным адресом. В противном случае обращение будем
считать неуспешным (и называть эту ситуацию кэш-промахом).

Во-вторых, во время исполнения инструкций обращения к памяти могут
происходить обращения к кэширующим буферам. Например, такие
обращения возможны при трансляции адреса, если в микропроцессоре
хранятся последние осуществленные трансляции адресов. Или такие
обращения возможны при работе с данными оперативной памяти,
поскольку микропроцессор хранит те данные, к которым недавно были
обращения.

В-третьих, в качестве целей тестирования будем рассматривать
заданные последовательности кэш-попаданий/кэш-промахов. Тесты,
удовлетворяющие таким целям тестирования, могут использоваться для
тестирования модулей управления памяти (MMU) микропроцессоров.
Кэш-попадания/кэш-промахи происходят (или не происходят) в
зависимости от адреса и состояния кэширующего буфера. Адрес
вычисляется на основе аргументов инструкции. Поэтому зависимые
аргументы инструкций порождают и зависимые адреса. Кроме того,
состояние кэширующего буфера изменяется заданным образом в
зависимости от тех же кэш-попаданий/кэш-промахов. А именно, при
кэш-промахе некоторые данные из кэширующего буфера вытесняются и на
их место помещаются данные по заданному в обращении адресу. Иными
словами, состояния кэширующего буфера в разных инструкциях также
являются зависимыми. Тем самым рассматриваемая цель тестирования
порождает множество зависимостей на значения аргументов инструкций и
состояние микропроцессора.

По сути построение тестов для рассматриваемых целей тестирования
требует решения задачи выполнимости. Задача выполнимости, т.е.
вычисления значений аргументов предиката, на которых он истинен,
является известной сложной задачей.

В-четвертых, вопрос представления решения. Состояние кэширующего
буфера состоит из пар чисел (адрес и данные). Однако не любой
микропроцессор позволяет задать состояние кэширующего буфера
напрямую (заполнением парами чисел). Даже если это и возможно, то
изменение состояний всех нужных кэширующих буферов перед каждым
тестом увеличит время проведения тестирования. Например, увеличение
времени на пару секунд для 100000 тестов увеличит время генерации
тестов более чем на 50 часов. Решением этой проблемы была бы
генерация инициализирующих инструкций. Такие инструкции помещаются
перед тестом и подготавливают микропроцессор к исполнению этого
теста. Другим возможным решением могло бы быть более оптимальное
использованием заданного начального состояния кэширующих буферов,
если о нем имеется информация. В данной статье рассматривается
генерация инициализирующих инструкций.
