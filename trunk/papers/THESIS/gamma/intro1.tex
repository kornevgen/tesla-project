% !Mode:: "TeX:UTF-8"
\addcontentsline{toc}{chapter}{Введение}
\chapter*{Введение}

\section*{Актуальность}

Современные микропроцессоры --- сложные многокомпонентные системы. Размеры современных микропроцессоров оцениваются как $10^7-10^8$ вентилей~\cite{HennesyPatterson}. При разработке таких сложных систем в проекты микропроцессоров естественно вносятся ошибки, порой довольно критичные~\cite{IntelValidation}. Поэтому для обнаружения этих ошибок в цикл разработки микропроцессора в обязательном порядке входят этапы функциональной верификации.

Чем позднее обнаруживаются ошибки в микропроцессорах, тем дороже обойдутся их исправления: сделать это в готовой микросхеме, тем более выпущенной на рынок, практически невозможно. Тем актуальнее становятся методы обнаружения ошибок на ранних этапах разработки микропроцессоров. Сам цикл разработки предполагает подготовку микропроцессоров в виде исполнимых моделей на языках Verilog или VHDL~\cite{VHDL}, что делает возможным проведение функциональной верификации на таких моделях и актуальным исследование методов такой верификации.

Обычно выделяют следующие виды функциональной верификации --- экспертиза, имитационное тестирование и формальная верификация~\cite{KamkinPopular}. Экспертиза --- принципиально неавтоматизируемый способ верификации, эффективно применяемый на ранних стадиях разработки для обнаружения большого числа ошибок. Однако ввиду наличия человеческого фактора в результате экспертизы ошибки в микропроцессоре всё же остаются. Методы формальной верификации позволяют дать исчерпывающий ответ на вопрос о корректности отдельных модулей или всего микропроцессора. Однако трудоемкость формальной верификации чрезвычайно велика. Например, при разработке Intel Pentium 4 были формально верифицированы модуль работы с плавающей точкой (FPU), модуль декодирования инструкции и логика внеочередного выполнения (out-of-order), было найдено порядка 20 ошибок, однако трудоемкость этого проекта составила порядка 60 человеко-лет~\cite{IntelValidation}.

Имитационное тестирование позволяет ценой меньших усилий обнаружить значительную часть ошибок, в том числе критичных. Имитационное тестирование (далее, просто <<тестирование>>) проводят для отдельных модулей (\emph{модульное тестирование}) и для всего микропроцессора в целом (\emph{системное тестирование})~\cite{EDAbook}. Модули тестируются подачей специальных сигналов на входы модуля и снятие выходных сигналом с последующим их анализом. Входом при системном тестировании является программы на машинном языке (\emph{тестовые программы}). Проведение модульного тестирования требует кроме подготовки самих входных данных подготовку тестирующей установки (testbench), выделение тестируемого модуля из всего проекта микропроцессора и т.п. Системное тестирование избавлено от этой необходимости. Поскольку размер и сложность отдельного модуля всегда меньше размера и сложности микропроцессора в целом, потенциально качество модульного тестирования может быть выше, чем системного. Однако для достижения высокого качества тестирования как число модульных тестов, так и совокупная трудоемкость их изготовления, являются очень большими. Это вынуждает часть проверок проводить на модульном уровне, а другую часть на системном. Невысокая стоимость проведения системного тестирования определила его наибольшую актуальность среди других методов функциональной верификации. Практически все разработчики микропроцессоров проводят системное тестирование
%нужна ссылка?
.

Ключевым вопросом, определяющим качество тестирования, является вопрос выбора тестов. Поскольку современные микропроцессоры обладают множеством инструкций (порядка сотен), длины конвейеров имеют порядок десятка стадий, количество различных состояний и ситуаций, в которых надо протестировать микропроцессор измеряется десятками тысяч. Поэтому для тщательного системного тестирования нужно не меньшее количество тестов. Это определяет актуальность задачи автоматического построения тестов для системного тестирования. Сложность микропроцессоров растет (увеличивается количество функциональных требований, количество ситуаций, в которых поведение микропроцессора должно обладать нужной спецификой), это требует тестов нового качества и делает актуальными дальнейшие исследования в области построения тестов.

%%%%! подредактировать про "новое качество" - это непонятно.

К числу наиболее сложных механизмов современных процессоров (поэтому наиболее подверженные ошибкам), использующих конвейеры и многоуровневые буферы типа кэш-памяти, относится механизм доступа к памяти. Поэтому актуальной является задача построения тестовых программ для проверки подсистем управления памяти микропроцессоров.

%%%% тем более, что зачастую нет способов прямого создания ситуаций?

%%% нацеленные методы (итерация-фильтрация, прямые конструкторы, random expansion, csp) - систематичные
%%% ненацеленные методы не тестируют тщательно или не находят ошибки, если микропроцессор не сырой

%%% в обзоре про MMU добавить классификацию ситуаций, которые надо тестировать

%%% цели:
%%% 1) понять, какие тесты "хорошие" (определение)
%%% 2) проанализировать методы их получения
%%% 3) предложить улучшения с целью получения более качественных тестов

%%% NB: ситуации не обязательно задавать шаблонами

%%% в приложение поместить примеры описаний MIPS'овских инструкций в xml ?


%А) микропроцессоры сложные -> в них есть ошибки
%Современные микропроцессоры --- это сложные системы, поэтому вероятность появления ошибки как при проектировании микропроцессора, так и при его производстве становится всё выше. При этом <<цена ошибки>> в готовом микропроцессоре велика (как минимум, это означает перевыпуск микропроцессора заново). Поэтому актуально развитие методов верификации микропроцессоров.

%%В) основная доля ошибок на этапе разработки моделей (design'а)
%Современные технологии проектирования микропроцессоров представляют собой средства разработки \emph{модели (design) на специальных языках} типа VHDL или Verilog~\cite{VerilogDesign}. Эти технологии позволяют в конечном итоге построить так называемые <<синтезируемые модели>>, из которых автоматически получаются фотошаблоны, необходимые для производства. Основная доля ошибок появляется именно на этапе разработки моделей (design), поэтому основные усилия по их выявлению или даже предотвращению их появления, также приходятся на фазу разработки моделей. Поэтому данная работа также нацелена на выявление ошибок в моделях микропроцессоров.

%%Г) модульное и системное тестирование ->
%% интересные ситуации нельзя создать инструкциями
%Тестирование на модели бывает \emph{модульным} (unit-level verification) и \emph{системным} (core-level verification, full-chip level verification)~\cite{UnitCoreLevel}. Модульное тестирование модели микропроцессора предполагает генерацию тестовых воздействий на входы отдельных модулей, блоков, микропроцессора, описанных на одном из языков типа VHDL, Verilog, и проверку выходов таких блоков. В рамках системного тестирования проверяется работа всего микропроцессора в целом --- тестом здесь является некоторая тестовая программа (программа на машинном языке), которая загружается в память и выполняется микропроцессором (речь все время идет о некоторой программной модели микропроцессора). Поскольку размер и сложность отдельного блока всегда меньше, размера и сложности микропроцессора в целом, потенциально качество модульного тестирования может быть выше, чем системного. Однако для достижения высокого качества тестирования как число модульных тестов, так и совокупная трудоемкость их изготовления, являются очень большими. Это вынуждает часть проверок проводить на модульном уровне, а другую часть на системном.

%Сложность микропроцессора определяет количество системных тестов. Если выделить различные аспекты функционирования микропроцессора (конвейер, буферы подсистемы управления памяти), то особое функционирование возникает при различных комбинациях этих аспектов. Это означает, что количество тестов должно быть не меньше произведения количества разных аспектов. Количество инструкций измеряется сотнями, а цепочек инструкций, соответственно, порядками сотен, плюс если учесть возможные аспекты в конвейере, в кэш-памяти, количество тестов получается очень большим. Для избежания проблемы такого <<взрывного>> характера количества тестов, их объединяют в классы эквивалентности --- \emph{тестовые ситуации}.

%При этом есть проблема покрытия всех потенциально интересных тестовых ситуаций. Нет никаких прямых способов создать многие из таких ситуаций нет. Например, интересно, как происходит доступ в память, когда соответствующий адрес имеется в кэш-памяти или не имеется. Или еще более тонкий анализ --- адрес имеется/или не имеется в кэш-памяти второго уровня. Среди инструкций процессора нет таких, которые были бы предназначены специально для создания таких ситуаций. Эти ситуации создаются \emph{динамически} в ходе выполнения программ.


%%Д) схема системного тестирования, показать здесь смежные вопросы
%% (вопросы построения оракула, покрытия и др.)
%Рассмотрим традиционную схему системного тестирования, известные подходы к автоматизации построения тестов и выявим проблемы, которые мешают строить более эффективные тесты.

%Микропроцессор рассматривается как черный (или серый) ящик. Входными тестовыми данными является некоторая программа, которая загружается в память. Результатом прогона теста является либо финальное состояние памяти (возможно, включая состояние регистров) или (в случае <<серого ящика>>) трасса изменения значений ячеек памяти или регистров.
%В этой общей схеме тестирования пока не упомянуты:
%\begin{itemize}
%	\item	генератор тестов (или набор уже готовых тестов);
%	\item	подсистема проверки корректности полученного результата --- тестового оракула, или арбитра;
%	\item	перечень <<интересных>> ситуаций, которые надо воспроизвести в ходе выполнения тестов;
%	\item	некая система мониторинга, которая фиксирует прохождение <<интересных>> ситуаций --- оценивает полноту покрытия.
%\end{itemize}
%
%Тестовый оракул, или арбитр, строится по схеме с использованием <<эталонной>> модели (simulation-based verification)~\cite{SimulationBased}. Каждая тестовая программа выполняется на двух моделях --- на тестируемой (design) и на <<эталонной>>. Потом состояния памяти или трассы изменения состояния памяти для тестируемой и эталонной моделей сравниваются. Если оракул признает, что трассы не эквивалентны, это свидетельствует о наличии ошибки в тестируемой системе (или эталонной, но это происходит реже). Как правило, эталонная модель пишется на одном из языков программирования (например, Си или Си++) и не загромождается деталями.  На этом основании считается, что такая модель существенно проще тестируемой, в ней с меньшей вероятностью встречаются ошибки, именно поэтому к ней можно относиться как к <<эталонной>>.
%
%% критика этого подхода: он не позволяет проверить модули, работающие за счет внешних воздействий - For example, fast interrupt request (FIQ), interrupt request (IRQ), data abort exception (Dabort) and prefetch abort exception (Pabort) of ARM7. Это пишут в статье "Automatic Verification of External Interrupt Behaviors for Microprocessor Design", авторы Fu-Ching Yang, Wen-Kai Huang, Ing-Jer Huang.
%
%
%Методы автоматической генерации тестов делят на псевдослучайные/комбинаторные (pseudo-random) и целенаправленные (что не отменяет возможности использования уже готовых тестов)~\cite{HoPhD}. В случае псевдослучайной генерации инструкции, их порядок и аргументы выбираются случайным образом или перебираются некоторым комбинаторным способом. Целенаправленная генерация начинается с задания некоторого шаблона тестовой программы, который определяет набор инструкций, их последовательность и аргументы. В рамках целенаправленной генерации порядок инструкций и их аргументы должны быть подобраны таким образом, чтобы каждый новый тест покрывал новые, еще не покрытые тестовые ситуации. Целенаправленную генерацию можно реализовать как выполнение массовой генерации комбинаторных тестов с последующей фильтрацией, с тем чтобы оставлять только те тесты, которые дают дополнительное покрытие. Однако уже для достаточно коротких шаблонов (длиной 3-4 инструкции) перебор становится слишком большим.
%
%Целенаправленная генерация тестов дает по тесту на каждую ситуацию. Набор тестов, которые покрывают все ситуации, называют нацеленными тестами (нацеленными на эти ситуации). Набор ситуаций конечен, следовательно и набор нацеленных тестов конечен. Вопрос
%%(это и есть основная тема исследования)
%, как систематическим образом строить тестовые программы, чтобы в совокупности они воспроизвели все заданные <<интересные>> ситуации.
%
%
%Перечень (конечный) <<интересных>> ситуаций и мониторинг. В совокупности две эти возможности задают метрику и механизм оценки полноты тестирования. Мониторинг организовать относительно легко, поскольку мы работаем не с реальным процессором, а с его моделями. Как построить перечень «интересных» ситуаций» --- вопрос открытый --- это одно из направлений моей работы.
%
%%Е) нацеленное/ненацеленное тестирование

\section*{Цель работы}
%Ж) формулирование цели работы - исследование методов построения нацеленных тестов-программ (на память)
%Целью исследования является разработка методов целенаправленной генерации системных тестов, которые, в свою очередь, должны предлагать и адекватные методы задания метрики и оценки полноты покрытия в соответствии с предложенными метриками.

Целью диссертационной работы является исследование и разработка методов и программных средств построения тестовых программ для проверки подсистем управления памяти микропроцессоров.

%%% надо тут, видимо, более точно изложить цель - что целью является улучшение некоторых ппараметров!

Для достижения этой цели были поставлены следующие задачи:
\begin{enumerate}
	\item исследовать описанные в научной литературе методы построения системных тестов на предмет их применимости для подсистем управления памяти микропроцессоров и качества получающихся тестов;
	\item разработать методы построения системных тестов для подсистем управления памяти.
\end{enumerate}

\section*{Научная новизна}

Научной новизной обладают следующие результаты работы:
\begin{enumerate}
    \item предложен подход к построению тестовых программ для проверки подсистем управления памяти микропроцессоров на основе построения и решения систем ограничений;

    \item предложена формальная модель блоков памяти, описывающая его структурные и функциональные характеристики;
        
    \item предложена формальная модель инструкций, описывающая отдельные пути их выполнения в виде утверждений о свойствах параметров инструкций и свойств наличия или отсутствия данных в блоках;

    \item в рамках предложенного подхода разработаны и формально обоснованы методы построения ограничений, выражающих с использованием битовых операций свойства наличия или отсутствия данных в блоках памяти; свойства вытеснения.
    % надо пояснить, что это за методы?
\end{enumerate}

\section*{Практическая значимость}
Разработанные модели и методы могут быть использованы в коллективах, занимающихся разработкой микропроцессоров, для автоматизации построения тестовых программ. Разработанный прототип системы построения тестовых программ использовался для генерации тестов подсистем управления памяти ряда микропроцессоров архитектуры MIPS64. Результаты работы могут быть использованы в исследованиях, которые ведутся в Институте системного программирования РАН, Московском государственном институте электроники и математики, НИИ системных исследований РАН, Институте точной механики и вычислительной техники им. С.А. Лебедева РАН, Институте проблем информатики РАН и других
научных и промышленных организациях.

\section*{Апробация работы и публикации}

По материалам диссертации опубликовано десять работ~\cite{my_syrcose_2008, my_isp_2008, my_lomonosov_2009, my_lomonosov_2010, my_miet_2009, my_nivc_2009, my_syrcose_2009, my_isp_2009, my_ewdts_2009, my_programmirovanie_2010}, в том числе одна~\cite{my_programmirovanie_2010} в издании, входящем в перечень ведущих рецензируемых научных журналов и изданий ВАК. Основные положения докладывались на следующих конференциях и семинарах:
\begin{enumerate}
  \item на втором и третьем весеннем коллоквиуме молодых исследователей в области программной инженерии (SYRCoSE) (2008 и 2009 гг.);
  \item на шестнадцатой и семнадцатой международной конференции студентов, аспирантов и молодых ученых <<Ломоносов>> (2009 и 2010 гг.);
  \item на шестнадцатой всероссийской межвузовской научно-технической конференции студентов и аспирантов <<Микроэлектроника и информатика - 2009>> (2009 г.);
  \item на седьмом международном симпозиуме по проектированию и тестированию под эгидой IEEE (EWDTS) (2009 г.);
  \item на российско-ирландской летней школе по научным вычислениям (2009 г.);
  \item на научной конференции <<Тихоновские чтения>> (2009 г.);
  \item на научной конференции <<Ломоносовские чтения>> (2010 г.);
  \item на объединенном научно-исследовательском семинаре имени М.Р. Шура-Бура (2010 г.);
  \item на семинаре отдела Технологий программирования Института системного программирования РАН (2009, 2010 гг.).
\end{enumerate}
