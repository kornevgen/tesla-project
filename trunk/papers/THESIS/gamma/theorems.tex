\newcommand{\LcurrentBody}{
Пусть $L$ -- выражение для текущего состояния (содержимого)
кэширующего буфера, $L_0$ -- множество адресов данных, расположенных
в кэширующем буфере перед исполнением инструкций тестового шаблона,
$\{x_i\}$ -- множество адресов данных в инструкциях с кэш-промахами,
расположенными до текущей инструкции в том же порядке, что и в
тестовом шаблоне, $\{x'_i\}$ -- множество адресов вытесняемых данных
в инструкциях с кэш-промахами, расположенными до текущей инструкции
в том же порядке, что и в тестовом шаблоне. Тогда
$$L \equiv L_0 \setminus \bigcup_{i=1}^n \{x'_i\} \cup \bigcup_{i=1}^n (
\{x_i\} \setminus \cup_{j~=~i+1}^n \{x'_j\}).$$
}

\newcommand{\HitMissEquations}{
Пусть $L_0$ --
множество адресов данных, расположенных в кэширующем буфере перед
исполнением инструкций тестового шаблона, $\{x_i\}$ -- множество
адресов данных в инструкциях с кэш-промахами, расположенными до
текущей инструкции в том же порядке, что и в тестовом шаблоне,
$\{x'_i\}$ -- множество адресов вытесняемых данных в инструкциях с
кэш-промахами, расположенными до текущей инструкции в том же
порядке, что и в тестовом шаблоне. Тогда
\begin{itemize}
\item для инструкции с кэш-попаданием адреса $x$ следует добавить
следующую совокупность уравнений:
$$
\left[
   \begin{array}{l}
    x \in L_0 \wedge x \notin \{x'_1, x'_2, ..., x'_n\} \\
    x = x_1 \wedge x \notin \{x'_2, ..., x'_n\} \\
    x = x_2 \wedge x \notin \{x'_3, ..., x'_n\} \\
    ...\\
    x = x_{n-1} \wedge x \notin \{x'_n\} \\
    x = x_n \\
   \end{array}
  \right.
$$

\item для инструкции с кэш-промахом адреса $x$ (и адресом
вытесненных данных $x'$) следует добавить следующую систему
уравнений:
$$
\left\{
   \begin{array}{l}

  \left[
   \begin{array}{l}
    x \notin L_0 \wedge x \notin \{x_1, x_2, ..., x_n\} \\
    x = x'_1 \wedge x \notin \{x_2, ..., x_n\} \\
    x = x'_2 \wedge x \notin \{x_3, ..., x_n\} \\
    ...\\
    x = x'_{n-1} \wedge x \notin \{x_n\} \\
    x = x'_n \\
   \end{array}
  \right. \\

  { }\\

  \left[
   \begin{array}{l}
    x' \in L_0 \wedge x \notin \{x'_1, x'_2, ..., x'_n\} \\
    x' = x_1 \wedge x \notin \{x'_2, ..., x'_n\} \\
    x' = x_2 \wedge x \notin \{x'_3, ..., x'_n\} \\
    ...\\
    x' = x_{n-1} \wedge x \notin \{x'_n\} \\
    x' = x_n \\
   \end{array}
  \right. \\

  { }\\

  displaced(x')\\

%  { }\\
%
%  R(x) = R(x')\\
%
  \end{array}
\right.
$$

\end{itemize}
}

\newcommand{\CorrectnessMirror}{
Если тестовый шаблон является совместным (т.е. для него существует хотя бы одна тестовая программа), то тестовая программа (инициализация плюс инструкции тестового шаблона), построенная по предлагаемому методу, соответствует тестовому шаблону.
}

\newcommand{\FullnessMirror}{
Если тестовый шаблон является совместным (т.е. для него существует
хотя бы одна тестовая программа $P$) %для
%последовательности тестовых ситуаций $(S_1, x_1), (S_2, x_2), ...,
%(S_n, x_n)$ и дополнительного ограничения $P(x_1, x_2, ..., x_n)$
%при некотором начальном состоянии $L_1$ существует удовлетворяющая
%им последовательность тегов $x_1, x_2, ..., x_n$
и стратегия вытеснения позволяет вытеснить любую строку в таблице, то с помощью предлагаемого метода может быть построена система ограничений (constraints), имеющая
решение для той же последовательности ключей обращения, что в $P$.
}

\newcommand{\UpperBoundLRUMirror}{
Если данный тестовый шаблон
является совместным, т.е. для последовательности тестовых ситуаций
$(S_1, x_1)$, $(S_2, x_2)$, ..., $(S_n, x_n)$ и дополнительного
ограничения $P(x_1, x_2, ..., x_n)$ при некотором начальном
состоянии $L_1$ существует удовлетворяющая им последовательность
тегов $x_1, x_2, ..., x_n$, применим зеркальный метод генерации
ограничений и стратегией вытеснения является \LRU, то с помощью
зеркального метода может быть построена система ограничений, имеющая
решение для той же последовательности тегов $x_1, x_2, ..., x_n$,
причем длина последовательности инициализирующих тегов $m$:
  $$0 \leqslant m \leqslant n \cdot w + M$$
  где $M$ -- количество инструкций тестового шаблона с кэш-промахами.}

\newcommand{\PseudoLRUInvariant}{
Пусть ($\alpha_1~\alpha_2~\dots~\alpha_W$)
--- \PseudoLRU-ветвь некоторой позиции $i$. Тогда изменение этой
ветви согласно стратегии вытеснения \PseudoLRU определяется только
относительной позицией (относительно $i$) и происходит следующим
образом при обращении к тегу с (абсолютной) позицией $j$: если
$\pi^i_j \in [\frac{w}{2^k},~\frac{w}{2^{k-1}})$ для некоторого
$k=1,2,\dots,W$, то происходит изменение $\alpha_1 := 0,~\alpha_2 :=
0,~\dots,~ \alpha_{k-1} := 0,~\alpha_k := 1$; если $\pi^i_j = 0$, то
происходит изменение $\alpha_1 := 0,~\alpha_2 := 0,~\dots,~\alpha_W
:= 0$; вытеснение тега на позиции $i$ происходит в том случае, когда
$\alpha_1 = 1~\wedge~\alpha_2 = 1~\wedge~\dots~\wedge~\alpha_W = 1$.
}

\newcommand{\DiapazonLRU}{
Решение системы (тег $x'$)
$$
\left\{
   \begin{array}{l}
    x' = y \\
    R(y) \cap (L \setminus \{x_1, x_2, ..., x_n\} ) = \{y\}\\
   \end{array}
  \right.
$$
где последовательность тегов $y, x_1, x_2, ..., x_n$ -- диапазон
вытеснения, а $L$ -- состояние кэширующего буфера перед концом
диапазона, является вытесняемым тегом для стратегии вытеснения \LRU
согласно определению на списках.
}

\newcommand{\DiapazonFIFO}{
Решение системы (тег $y'$)
$$
\left\{
   \begin{array}{l}
    y' = y \\
    R(y) \cap (L \setminus \{y_1, y_2, ..., y_n\} ) = \{y\}\\
   \end{array}
  \right.
$$
где последовательность тегов $y, y_1, y_2, ..., y_n$ -- диапазон
вытеснения, является вытесняемым тегом для стратегии вытеснения
\FIFO согласно определению на списках.
}

\newcommand{\MaxUpperBoundLRU}{
$$0 \leqslant k \leqslant n \cdot w_1$$
$$0 \leqslant h \leqslant n \cdot (w_1 + w_2 + 2)$$
где $w_1$ -- ассоциативность кэш-памяти первого уровня, $w_2$ --
ассоциативность кэш-памяти второго уровня, $n$ -- количество
инструкций тестового шаблона.
} 