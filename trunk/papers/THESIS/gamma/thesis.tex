% !Mode:: "TeX:UTF-8"
\documentclass[14pt]{extreport}

\usepackage{fix-cm}
%\usepackage[cp1251]{inputenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
%\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{lscape}
\usepackage{makecell}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\usepackage{setspace} % интервалы межстрочные
\pagestyle{plain} \onehalfspacing

%\usepackage[left=3cm,right=2cm,
%top=2cm,bottom=0.5cm,bindingoffset=0cm,  a4paper]{geometry} % поля

\textheight 25.7cm % 29.7-2-2
\textwidth 17cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \headheight 0cm \headsep 0cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел


\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{utv}{Утверждение}
\newtheorem*{sld}{Следствие}

% добавил ненужный комментарий

\newcommand{\LRU}{\textsf{LRU}\xspace}
\newcommand{\FIFO}{\textsf{FIFO}\xspace}
\newcommand{\PseudoLRU}{\textsf{Pseudo-LRU}\xspace}
\newcommand{\MRU}{\textsf{MRU}\xspace}

\newcommand{\lemmatext}[2]{
\noindent\textbf{Лемма~{#1}}. \textit{#2}
}

\newcommand{\theoremtext}[2]{
\noindent\textbf{Теорема~{#1}}. \textit{#2}
}

\newcommand{\theoremtextwname}[3]{
\noindent\textbf{Теорема~{#1}}~(#2). \textit{#3}
}

\begin{document}

\thispagestyle{empty}

\begin{singlespace}
\begin{center}
%МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ\\ РОССИЙСКОЙ ФЕДЕРАЦИИ\\[0.5cm]
%
МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ\\ ИМЕНИ М.~В.~ЛОМОНОСОВА\\[0.5cm]

ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ МАТЕМАТИКИ\\ И КИБЕРНЕТИКИ\\[1cm]
\end{center}

\begin{flushright}
На правах рукописи\\[2cm]
\end{flushright}

\begin{center}
Корныхин Евгений Валерьевич\\[1cm]
\textbf{%\renewcommand{\baselinestretch}{1.8}
%\fontsize{28pt}{50pt} \selectfont
\huge{%\textsc{исследование и разработка методов генерации программ
%для тестирования
%модулей управления памяти микропроцессоров}}\\[0.5cm]}
\textsc{нацеленное построение программ
для тестирования
подсистемы управления памяти микропроцессоров}}\\[0.5cm]}
%\huge{\textsc{ микропроцессоров}}}\\[1.5cm]

Специальность 05.13.11 -- математическое и программное обеспечение
вычислительных машин, комплексов и компьютерных сетей\\[1.5cm]


Диссертация на соискание ученой степени\\
кандидата физико-математических наук
\end{center}

\vspace{0.7cm}

\begin{flushright} Научный руководитель:\\
д.ф-м.н. Петренко Александр Константинович
\end{flushright}

\vspace{1.5cm}

\begin{center}
Москва -- 2010
\end{center}


\end{singlespace}

\pagebreak

\tableofcontents

%%! определение LRU не "на списках", а "на перестановках"! + аналогичные

%%! определиться "последовательность инициализирующих" или "инициализирующая посл-ть"

%%! надо как-то написать, что предлагаемые ограничения недолго разрешаются --
%%      иначе непонятно, зачем это всё, если оно плохо считается

%%! написать, В чем недостаток применения методов типа Монте-Карло для получения
%%  тестовых программ -- ведь их закодировать проще (не поддаются архитектуры, такие вот они вычурные?)
%% (тестовый шаблон может задавать очень маленькую область решений в многомерном
%% пространстве -> мала вероятность в него попасть)

%%! там, где в формулах разъехался "w-1", заменить на "w{-}1"



\include{theorems}

\addcontentsline{toc}{chapter}{Введение}
\chapter*{Введение}

\section*{Актуальность}
%А) микропроцессоры сложные -> в них есть ошибки
Современные микропроцессоры --- это чрезвычайно сложные системы, поэтому вероятность появления ошибки как при проектировании микропроцессора, так и при его производстве высокая. При этом <<цена ошибки>> в готовом микропроцессоре крайне высока. По этим двум причинам актуальность развития методов верификации микропроцессоров очевидна. 

Вероятность ошибки выше там, где выше сложность. К числу наиболее сложных механизмов современных процессоров, использующих конвейеры и многоуровневые кеши, является механизм доступа к памяти – по этой причине в качестве темы диссертации была выбрана тема тестирования ПОДСИСТЕМ УПРАВЛЕНИЯ ПАМЯТИ.


%Б) история вопроса

%В) основная доля ошибок на этапе разработки моделей (design'а)
Современные технологии проектирования микропроцессоров представляют собой средства разработки модели на специальных языках типа VHDL или Verilog. Эти технологии позволяют в конечном итоге построить так называемые <<синтезируемые модели>>, из которых можно получить фотошаблоны. Основная доля ошибок появляется именно на этапе разработки моделей, поэтому основные усилия по их выявлению или даже предотвращению их появления, также приходятся на фазу разработки моделей. Поэтому данная работа также нацелена на выявление ошибок в моделях микропроцессоров.

%Г) модульное и системное тестирование ->
% интересные ситуации нельзя создать инструкциями
Тестирование на модели бывает модульным и системным. Модульное тестирование модели микропроцессора предполагает генерацию тестовых воздействия на входы отдельных блоков микропроцессора, описанных на одном из языков типа VHDL, Verilog, и проверку выходов таких блоков. Системное тестирование проверяет работу всего микропроцессора в целом, тестом здесь является некоторая тестовая программа, которая загружается в память и выполняется микропроцессором (речь все время идет о некоторой программной модели микропроцессора). Поскольку размер и сложность отдельного блока всегда меньше, размера и сложности микропроцессора в целом, потенциально качество модульного тестирования может быть выше, чем системного. Однако для достижения высокого качества тестирования как число модульных тестов, так и совокупная трудоемкость их изготовления, являются очень большими. Это вынуждает часть проверок проводить на модульном уровне, а другую часть на системном. 

При этом есть проблема полного покрытия всех потенциально интересных тестовых ситуаций. Даже при большом числе тестов, не удается проверить работу микропроцессора в тех или иных ситуациях, так как никаких прямых способов создать многие из таких ситуаций нет. Например, интересно, как происходит доступ в память, когда соответствующий адрес имеется в кешэ или не имеется в кешэ. Или еще более тонкий анализ --- адрес имеется/или не имеется во кешэ второго уровня. Среди команд процессора нет команд, которые предназначены специально для того, чтобы создавать такие ситуации. Такие ситуации создаются динамически в ходе выполнения программ. Вопрос (это и есть основная тема исследования), как систематическим образом строить тестовые программы, чтобы в совокупности они воспроизвели все заданные «интересные» ситуации.

%Д) схема системного тестирования, показать здесь смежные вопросы
% (вопросы построения оракула, покрытия и др.)
Рассмотрим традиционную схему системного тестирования, известные подходы к автоматизации построения тестов и выявим проблемы, которые мешают строить более эффективные тесты.

Микропроцессор рассматривается как черный (или серый) ящик (Картинка 1). Входными тестовыми данными является некоторая программа, которая загружается в память. Результатом прогона теста является либо финальное состояние памяти (возможно, включая состояние регистров) или (в случае <<серого ящика>>) трасса изменения значений ячеек памяти или регистров.
В этой общей схеме тестирования пока нет:
\begin{itemize}
	\item	генератора тестов (или набора уже готовых тестов);
	\item	подсистемы проверки корректности полученного результата --- тестового оракула, или арбитра;
	\item	перечня <<интересных>> ситуаций, которые надо воспроизвести в ходе выполнения тестов
	\item	некоторой системы мониторинга, которая фиксирует прохождение <<интересных>> ситуаций --- полноту покрытия
\end{itemize}

Методы генерации можно разделить на рандомизированные/комбинаторные и целенаправленные. В обоих случаях генерация начинается с задания некоторого шаблона тестовой программы, который определяет набор машинных операций, их последовательность, набор операндов. В рандомизированном случае операции, их порядок и их операнды перебираются некоторым комбинаторным способом. Целенаправленная генерация должна подбирать порядок операций и их операндов таким образом, чтобы каждый новый тест покрывал новые, еще не покрытые тестовые ситуации. Целенаправленную генерацию теоретически можно реализовать как выполнение массовой генерации комбинаторных тестов с последующей фильтрацией, с тем чтобы оставлять только те тесты, которые дают дополнительное покрытие. Однако  уже для достаточно коротких шаблонов (длиной 3-4 операции) перебор становится слишком большим.

Тестовый оракул или арбитр строится по схеме с использованием <<эталонной>> модели. (Картинка 2). Тестовая программа выполняется на двух моделях, потом состояние памяти или трасса изменения состояния памяти для целевой и эталонной моделей сравниваются.  Если оракул признает, что трассы не эквивалентны, это свидетельствует о наличии ошибки в целевой системе. Как правило эталонная модель пишется на одном из языков программирования (например, Си или С++) и не загромождается деталями.  На этом основании считается, что такая модель существенно проще целевой, в ней с меньшей вероятностью встречаются ошибки, именно поэтому к ней можно относиться как к «эталонной».

Перечень <<интересных>> ситуаций и мониторинг. В совокупности две эти возможности задают метрику и механизм оценки полноты тестирования. Мониторинг организовать относительно легко, поскольку мы работаем не с реальным процессором, а с его моделями. Как построить «перечень «интересных» ситуаций» --- вопрос открытый --- это одно из направлений моей работы.

%Е) нацеленное/ненацеленное тестирование

\section*{Цель работы}
%Ж) формулирование цели работы - исследование методов построения нацеленных тестов-программ (на память)
Целью исследования является разработка методов целенаправленной генерации системных тестов, которые, в свою очередь, должны предлагать и адекватные методы задания метрики и оценки полноты покрытия в соответствии с предложенными метриками.


\chapter{Известные методы построения нацеленных тестов}

Речь идет о методах построения тестов (тестовых программ), нацеленных на достижение некоторого покрытия. Нельзя говорить о нацеленных тестах, не сказав, на покрытие чего они нацелены. Здесь есть следующие возможности (критерии покрытия):
\begin{itemize}
	\item покрытие по структуре функциональных требований (к разрабатываемому микропроцессору);
	\item покрытие по структуре <<кода>> (под <<кодом>> понимается исходный текст <<синтезируемой модели>> (design'а), который готовят разработчики микропроцессора);
	\item покрытие по модели ошибок (чаще всего под <<ошибкой>> понимается <<замыкание-в-0>> или <<замыкание-в-1>> какого-нибудь вентиля в схеме микропроцессора).
\end{itemize}

Предложенные в научной литературе методы построения нацеленных тестов делятся на два класса в зависимости от того, происходит ли явное выделение элементов покрытия и построение теста только для каждого элемента в отдельности. Сначала будет рассмотрен \emph{класс методов без выделения элементов покрытия} (без выделения тестовых случаев, test case'в). В этих методах после генерации теста проверяется, увеличивает ли он покрытие (соответствует ли он тестовому случаю, который еще не встречался среди построенных тестов). Если тест не увеличивает покрытие, он далее игнорируется. Другой класс методов (\emph{методов с выделением тестовых случаев}), наоборот, предполагает явное выделение тестовых случаев и построение для них тестов. Зачастую, выделение тестовых случаев происходит вручную. Они записываются на некотором языке. А затем некоторый генератор строит тест (или набор тестов) для каждого такого тестового случая. Альтернативой является автоматическое выделение тестовых случаев на основе некоторой модели.

\section{Методы без выделения тестовых случаев}

\begin{figure}[h] \center
  \includegraphics[width=0.45\textwidth]{1.review/methods1}\\
  \caption{Схема методов без выделения тестовых случаев}\label{fig:methods1}
\end{figure}

Схематично эти методы изображены на рисунке~\ref{fig:methods1}. В них чередуются этапы генерации тестов и их фильтрации по факту неувеличения покрытия. В каждом методе определяется своя процедура (массовой) генерации тестов. Профедура фильтрации основана на выбранном критерии покрытия (покрыта ли новая ошибка, покрыто ли новое требование, покрыт ли новая часть кода).

Наиболее очевидный метод генерации тестов --- (псевдо)случайная генерация. Этот метод подходит при любом критерии покрытия.

% авторы статьи, год статьи
% что тестировали ("тесты для такой-то подсистемы")
% из чего состоят тесты ("тесты состояли из .....")
% какое покрытие рассматривали ("тесты нацеливались на ...")
% каким способом генерировали тесты

В статье Д.Вуда, Г.Гибсона и Р.Каца из Университета в Беркли 1990 года описан метод генерации тестов~\cite{Berkeley89}, который использовался для верификации реализации протокола когерентности кэшей микропроцессоров SPUR, разрабатываемых также в Беркли. Тесты нацеливались на различные случаи взаимодействия микропроцессоров. Авторы отметили, что явное построение тестов для каждого отдельного случая взаимодействия микропроцессоров является тяжелой задачей. Вместо этого они предложили генерировать случайным образом программы для каждого микропроцессора в отдельности, аккуратно выбирая адреса ячеек памяти в инструкциях этих программ (чтобы в кэш-памяти разных микропроцессоров оказывались одни и те же <<адреса>> данных). Происходит это следующим образом. Разработчики design'а пишут набор <<скриптов>>. Каждый скрипт состоит из двух программ: <<действия>> и <<проверки>>. В <<действии>> совершается некоторое тестовое воздействие, в <<проверке>> анализируется корректность изменения состояния микропроцессора в ответ на тестовое воздействие. Например, в <<действии>> происходит запись некоторого заданного значения по некоторому заданному адресу, а в <<проверке>> происходит считывание значения по этому адресу и проверка равенства этого значения записанному ранее. Затем генератор в случайном порядке выбирает <<действия>> и <<проверки>>, составляя тестовые программы.

Еще две статьи по случайной генерации тестов для верификации блокировок в конвейере и арифметических алгоритмов (Maur88, Shal87 в статье Berkeley89)...............


- microGP


\section{Методы с выделением тестовых случаев}

\begin{figure}[h] \center
  \includegraphics[width=0.45\textwidth]{1.review/methods2}\\
  \caption{Схема методов с выделением тестовых случаев}\label{fig:methods1}
\end{figure}

%Б) методы, которые выделяют элементы модели в виде шаблонов
можно было бы сделать через предыдущие (фильтровать, пока не получим для заданного test case'а), но это неэффективно. ..... Подход Model-Based Testing~\cite{link!........}, поэтому составляется модель..........

% авторы статьи, год статьи
% что тестировали ("тесты для такой-то подсистемы")
% из чего состоят тесты ("тесты состояли из .....")
% какая модель микропроцессора используется (автоматы, графы, деревья инструкций)
% какое покрытие рассматривали ("тесты нацеливались на ...", что такое test case)
% каким способом генерировали тесты

П.Мишра и Н.Дутт с 2002 года (и по настоящее время) публикуют работы~\cite{MishraDutt, MishraMC09} по генерации тестов с использованием model checking~\cite{ModelChecking} для верификации конвейеров. Авторы предлагают описывать конвейер в виде  А именно, на различные ситуации .............. . Метод построения следующий. Вручную пишется модель конвейера и проверяемые свойства.

П.Мишра и Н.Дутт кроме работ, связанных с model checking, опубликовали работы по генерации тестов для верификации конвейеров~\cite{MishraDuttNotMC}. Авторы предлагают описывать структуру и поведение конвейера в виде графовой модели. Ее вершинами являются функциональыне блоки микропроцессора (например, ALU), запоминающие устройства (например, кэш-память первого уровня), инструкции и их аргументы. Дуги соответствуют отношениям использования и порядка.  Были выделены 4 вида ошибок в конвейерах (чтение после записи в регистр дает другое значение, неверное вычисление операции, ошибки в активизации стадий конвейера, эффект <<параллельного>> исполнения инструкций). Test case'ы строятся автоматически на основе видов ошибок и элементов модели конвейера. Для каждого test case'а тесты строятся следующим образом. Сначала автоматически выделяется характерная последовательность инструкций. И, затем, она дополняется до готовой для тестирования программы (вставляются несущественные инструкции, вычисляются нужные значения параметров и добавляются инструкции инициализации их). Графовая модель конвейера разрабатывается вручную.

методы выделения шаблонов по моделям:
- ручное написание шаблонов
- комбинаторный метод в MicroTESK
- обход дуг конечного автомата в Ur, Yadin
- mVpGen ?

методы построения теста по шаблону:
- ручное написание генератора (MicroTESK)
- random expanding from template (SEGUE, PA-RISC, TSE, Theo, mVpGen)
- constraint-based expanding (Genesys-Pro, RAVEN, MAATG)

\section{Анализ существующих методов построения нацеленных тестов}
%В) анализ: основываться будем на втором классе (почему он лучше? - для памяти подходит!)
% поэтому ставим такие задачи:
% 1. предложить методы описания моделей и инструкций
% 2. предложить структуру и метод построения шаблонов
% 3. предложить метод построения тестовой программы по шаблону

%статья (1996)
%I’m Done Simulating;Now What? Verification Coverage Analysis and CorrectnessChecking of the DECchip 21164 Alpha microprocessor.
%описывает основные виды функциональной верификации:
%* assertions в RTL
%* самопроверяющиеся тесты
%* сравнение с эталоном
%
%В ней указываются методы псевдослучайно генерации тестов:
%
%W. Anderson, "Logical Verification of the NVAX CPU Chip
%Design," Digital Technical Journal, vol. 4, no. 3 (Summer 1992):
%38-46.
%-------------
%SEGUE - инженеры составляют набор шаблонов программ, которые вызывают разные события. В этих шаблонах вместо инструкций могут указываться лишь типы инструкций, вместо аргументов некий "произвольный аргумент".
%Шаблон верхнего уровня указывает, с какими вероятностями должны встречаться шаблоны нижнего уровня (которые писали для возникновения событий).
%Демоны моделируют псевдослучайное поведение среды, в которой работает микропроцессор.
%-------------
%
%4. A. Ahi, G. Burroughs, A. Gore, S. LaMar, C-Y. Lin, and A.
%Wiemann, "Design Verification of the HP 9000 Series 700 PARISC
%Workstations," Hewlett-Packard Journal (August 1992):
%34-42.
%-----
%похожее, но в HP
%-----
%
%5. D. Wood, G. Gibson, and R. Katz, "Verifying a Multiprocessor Cache Controller Using Random Test Generation," IEEE Design and Test of Computers (August 1990): 13-25.
%------------
%"модель" -- all multiprocessor interaction cases
%архитектура SPUR
%-----------
%
%тесты из одной инструкции (1982!):
%D. Bhandarkar, "Architecture Management for Ensuring Software Compatibility in the VAX Family of Computers," IEEE Computer (February 1982): 87-93.
%
%random test generation for check pipeline interlocks and arithmetic algorithms
%[TBD!] Maurer, Design Verification of the WE32106 Math Accelerator Unit
%[TBD!] Shalem Carmon, Testing the Design of the NS32532 Microprocessor
%
%S. Taylor et al. “Functional verification of a multiple-issue, out-of-order, superscalar Alpha processor - the DEC Alpha 21264 microprocessor.” In Proc. DAC, 1998, pp. 638–643.
%----
%SEGUE - но на следующем микропропессоре
%------
%
%2009:Yingpan Wu, Lixin Yu, Wei Zhuang, Jianyong Wang, "A Coverage-Driven Constraint Random-Based Functional Verification Method of Pipeline Unit," icis, pp.1049-1054, 2009 Eigth IEEE/ACIS International Conference on Computer and Information Science (icis 2009), 2009
%
%
%Mishra, Dutt:
%Generation of effective test programs for the self-test of a processor has been studied by several researchers ([2] [18] [20] [21]).
%
%Ur and Yadin [23] presented a method for generation of assembler test programs that systematically probe the micro-architecture of a PowerPC processor.
%
%Iwashita et al. [3] use a FSM based processor modeling to automatically generate test programs.
%
%================
%Alpha 21164 (21264): I’m Done Simulating;Now What? Verification Coverage Analysis and CorrectnessChecking of the DECchip 21164 Alpha microprocessor.
%NVAX: W. Anderson, "Logical Verification of the NVAX CPU Chip Design," Digital Technical Journal, vol. 4, no. 3 (Summer 1992):38-46.
%HP 9000 Series 700 PARISC:  4. A. Ahi, G. Burroughs, A. Gore, S. LaMar, C-Y. Lin, and A. Wiemann, "Design Verification of the HP 9000 Series 700 PARISC Workstations," Hewlett-Packard Journal (August 1992): 34-42.
%PowerPC, VLIW: что-то Genesys 2005
%Intel использует тесты: http://www.cs.rice.edu/~vardi/comp607/bentley.pdf

\include{theor}

\include{experiments}

\include{epilogue}


\pagebreak
\appendix
% \include{appendix/tables}
%TODO!!! \include{appendix/proofs}

\pagebreak
%%%%\bibliographystyle{plain}
%%%%\bibliographystyle{gost71u}
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{thesis}

%% привести оформление в соответствие с требованием: что-то всё время пропадает!

%%! добавить \cite{Pex}, \cite{symbolic_execution}

%%! вписать название препринта и номер тома

\end{document}
