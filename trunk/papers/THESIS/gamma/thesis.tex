% !Mode:: "TeX:UTF-8"
\documentclass[14pt]{extreport}

\usepackage{fix-cm}
%\usepackage[cp1251]{inputenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
%\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{lscape}
\usepackage{makecell}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\usepackage{setspace} % интервалы межстрочные
\pagestyle{plain} \onehalfspacing

%\usepackage[left=3cm,right=2cm,
%top=2cm,bottom=0.5cm,bindingoffset=0cm,  a4paper]{geometry} % поля

\textheight 25.7cm % 29.7-2-2
\textwidth 17cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \headheight 0cm \headsep 0cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел


\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{utv}{Утверждение}
\newtheorem*{sld}{Следствие}

% добавил ненужный комментарий

\newcommand{\LRU}{\textsf{LRU}\xspace}
\newcommand{\FIFO}{\textsf{FIFO}\xspace}
\newcommand{\PseudoLRU}{\textsf{Pseudo-LRU}\xspace}
\newcommand{\MRU}{\textsf{MRU}\xspace}

\newcommand{\lemmatext}[2]{
\noindent\textbf{Лемма~{#1}}. \textit{#2}
}

\newcommand{\theoremtext}[2]{
\noindent\textbf{Теорема~{#1}}. \textit{#2}
}

\begin{document}

\thispagestyle{empty}

\begin{singlespace}
\begin{center}
%МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ\\ РОССИЙСКОЙ ФЕДЕРАЦИИ\\[0.5cm]
%
МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ\\ ИМЕНИ М.~В.~ЛОМОНОСОВА\\[0.5cm]

ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ МАТЕМАТИКИ\\ И КИБЕРНЕТИКИ\\[1cm]
\end{center}

\begin{flushright}
На правах рукописи\\[2cm]
\end{flushright}

\begin{center}
Корныхин Евгений Валерьевич\\[1cm]
\textbf{%\renewcommand{\baselinestretch}{1.8}
%\fontsize{28pt}{50pt} \selectfont
\huge{%\textsc{исследование и разработка методов генерации программ
%для тестирования
%модулей управления памяти микропроцессоров}}\\[0.5cm]}
\textsc{построение программ
для тестирования
модулей управления памяти микропроцессоров}}\\[0.5cm]}
%\huge{\textsc{ микропроцессоров}}}\\[1.5cm]

Специальность 05.13.11 -- математическое и программное обеспечение
вычислительных машин, комплексов и компьютерных сетей\\[1.5cm]


Диссертация на соискание ученой степени\\
кандидата физико-математических наук
\end{center}

\vspace{0.7cm}

\begin{flushright} Научный руководитель:\\
д.ф-м.н. Петренко Александр Константинович
\end{flushright}

\vspace{1.5cm}

\begin{center}
Москва -- 2010
\end{center}


\end{singlespace}

\pagebreak

\tableofcontents

%%! определение LRU не "на списках", а "на перестановках"! + аналогичные

%%! определиться "последовательность инициализирующих" или "инициализирующая посл-ть"

%%! надо как-то написать, что предлагаемые ограничения недолго разрешаются --
%%      иначе непонятно, зачем это всё, если оно плохо считается

%%! написать, В чем недостаток применения методов типа Монте-Карло для получения
%%  тестовых программ -- ведь их закодировать проще (не поддаются архитектуры, такие вот они вычурные?)
%% (тестовый шаблон может задавать очень маленькую область решений в многомерном
%% пространстве -> мала вероятность в него попасть)

%%! там, где в формулах разъехался "w-1", заменить на "w{-}1"



%% от публики может быть вопрос: измерялось ли максимальная длина шаблона,
%% для которого этими методами генерируются тестовые программы за приемлимое время?
%% момент №1: практика показывает, что большинство ошибок обнаруживается
%%  на коротких тестовых шаблонах (3-4 инструкции)

\include{theorems}

\chapter*{Введение}
системное тестирование

отсутствие хороших систематических методов генерации тестов

\chapter{Обзор, постановка задачи}

нацеленная генерация (зачем надо было заниматься решением моей задачи)

имеющиеся инструменты, их плюсы и минусы

постановка задачи

другие предварительные сведения

\chapter{Первая теоретическая глава}

\section{<<Технологическая цепочка>> - плохое название, сменить}
Основные шаги следующие:
\begin{enumerate}
  \item чтение документации по архитектуре;
  \item выделение интересных для тестирования ситуаций;
  \item формализация архитектуры;
  \item подготовка конструктора инициализирующей программы;
  \item запуск генератора для каждой ситуации.
\end{enumerate}

То есть предлагаемый метод следует подходу нацеленной генерации тестов. Для тестируемого микропроцессора всегда есть описание его архитектуры. В этом документе, фактически, описано, как должны действовать, функционировать, разные инструкции. Разработчики тестов сначала размечают эти описания -- выделяют разные случаи исполнения инструкций. Затем на основе выделенных случаев строится шаблон теста, который исходит из идей разработчиков тестов, в какие ситуации надо попасть при исполнении инструкций. Затем для возможности автоматического построения тестов выделенные случаи исполнения инструкций формализуются. Специальный генератор на основе этого формального описания будет строить для шаблона инструкции теста и инициализацию микропроцессора.
Для выражения этой инициализации в виде инструкций надо написать конструктор инициализирующей программы.

\begin{figure}[p] \center
  \includegraphics[width=\textwidth]{2.theor/process.full.eps}\\
  \caption{Предлагаемый метод генерации тестов}\label{process}
\end{figure}

Предлагаемый метод с указанием потоков данных изображен на рисунке~\ref{process}. Действия, которые надо выполнить вручную, помещены в прямоугольники с закругленными краями. Данные помещены в прямоугольники. Программные компоненты помещены в параллелепипеды.

Теперь более подробно будут описаны шаги предлагаемого метода.

\paragraph{шаг <<читать документацию>>} <<Документация по архитектуре>> --- это документ, описывающий семантику инструкций микропроцессора и некоторые структурные характеристики микропроцессора (какие есть разные буферы, кэш-память и др).
В результате чтения документации надо:
\begin{enumerate}
  \item выделить инструкции, их формат (какие возможны аргументы);
  \item выделить в инструкциях варианты исполнения (<<разметить>>, обычно один вариант исполнения описывается в виде последовательности более простых действий), каждому варианту исполнения присвоить идентификатор (метку);
  \item определить для каждого варианта исполнения, в какие блоки микропроцессора происходят в нем обращения (кэш-память некоторых уровней, буфер трансляции адресов и т.п.).
\end{enumerate}

Например, документация по архитектуре MIPS64 описывает инструкцию LW загрузки 32х бит из памяти в регистр; эта инструкция обладает следующими вариантами исполнения (приведены лишь некоторые из них):
\begin{itemize}
    \item возникновение исключения по причине невыровненного виртуального адреса;
    \item неотображаемое исполнение --- в котором физический адрес вычисляется по виртуальному без обращений к каким-либо блокам микропроцессора;
    \item некэшируемое исполнение --- в котором обращение в кэш-память не делается, напрямую идет обращение в оперативную память;
\end{itemize}

На данном шаге описание варианта исполнения этой инструкции может быть таким: 1) вычисляется виртуальный адрес --- сумма аргументов, 2) если <<виртуальный адрес отображаемый>>, вычисляется номер виртуальной страницы, для нее в TLB ищется соответствующая страница физической памяти (<<идет обращение в TLB>>), иначе вычисляется физический адрес как битовая подстрока виртуального адреса и т.д.

\paragraph{шаг <<выделение ситуаций для тестирования>>} предполагает составление <<тестовых шаблонов>>. Напомню, что тестовый шаблон фиксирует интересную для тестирования ситуацию. Ситуация задается вариантами исполнения инструкций и цепочками инструкций. Тем самым шаблоны представляют собой последовательности инструкций с аргументами. Возможно, аргументы в разных инструкциях повторяются. И у каждой инструкции указывается набор идентификаторов, обозначающих вариант исполнения инструкции.

Для тестового шаблона будет строиться тест, в котором инструкции будут исполнены согласно указанным вариантам исполнения. Каждый тест будет состоять из двух частей: вторая часть --- это те же инструкции и аргументы, что были в шаблоне, а первая часть (т.н. \emph{инициализирующая программа}) это тоже набор инструкций, которые подготавливают модель микропроцессора к выполнению инструкций шаблона в заданных вариантах исполнения инструкций.

\begin{figure}[h]
\quad\parbox{0.5\textwidth}{ \tt
LW x, y, c @ l1Hit } \parbox{0.3\textwidth}{ \tt
XOR y, y, y\\
SW x, y, 0x0\\
LW x, y, 0x0\\}
\caption{Тестовый шаблон (слева) и один из возможных тестов для него (справа)}\label{test_template_exmp1}
\end{figure}

Пример шаблона и соответствующего ему теста приведен на рисунке~\ref{test_template_exmp1}. Инструкция LW --- инструкция загрузки 32х бит из памяти, XOR --- инструкция исключающего ИЛИ, SW --- инструкция сохранения 32х бит в памяти. Идентификатором \texttt{l1Hit} было помечено исполнение инструкции LW без трансляции адреса, но с обращением в кэш-память первого уровня с кэш-попаданием в нем. В тесте, во-первых, выбрано значение константы <<c>> (равно 0) и, во-вторых, перед инструкцией LW вставлена инструкция SW с теми же аргументами, что и у LW для того, чтобы данные по этому адресу точно попали в кэш-память первого уровня и при исполнении инструкции LW в кэш-памяти первого уровня произошло кэш-попадание.

\paragraph{шаг <<формализовать архитектуру>>} предполагает построение модели состояния микропроцессора и подготовку формальных описаний вариантов исполнения инструкций (формализовать <<идентификаторы>>, обозначающие варианты исполнения инструкций). Состояние образуют те блоки микропроцессора, к которым обращаются инструкции тестового шаблона. Это могут быть разные регистры, кэш-память разных уровней, буферы трансляции адресов, вспомогательные буферы. Все они обладают состоянием (поскольку в них хранятся и изменяются данные).

Формализация архитектуры нацелена на детализацию описания поведения инструкции с возможностью автоматического построения теста. Формализация выполняется на основе выделенных на первом шаге описаний вариантов исполнения инструкций. Они хотя и не всегда формальные, но зачастую высоко формализованы. Формализованное описание варианта исполнения инструкции представляет из себя последовательность операторов на специальном языке (ниже этот язык и механизмы, которые он предоставляет, будут описаны подробнее).

Рассмотрим пример того, как получается формальное описание варианта исполнения l1Hit инструкции LW архитектуры MIPS64. Формат этой инструкции следующий:
\begin{verbatim}
LW rt, offset(base)
\end{verbatim}

Описание этой инструкции в документации выглядит следующим образом:
\begin{verbatim}
  vAddr <- sign_extend(offset) + GPR[base]
  if vAddr[1..0] != 0^2 then
        SignalException(AddressError)
  endif
  (pAddr, CCA) <- AddressTranslation(vAddr, DATA, LOAD)
  pAddr <- pAddr[PSIZE-1..3] || (pAddr[2..0] xor (ReverseEndian||0^2))
  memdoubleword <- LoadMemory(CCA, WORD, pAddr, vAddr, DATA)
  byte <- vAddr[2..0] xor (BigEndianCPU || 0^2)
  GPR[rt] <- sign_extend(memdoubleword[31+8*byte..8*byte])
\end{verbatim}

Это описание представляет собой последовательность операторов, которые изменяют значения переменных и внутреннее состояние микропроцессора. В этом описании присутствует оператор присваивания (он обозначен обратной стрелкой) и условный оператор, в then-ветви которого находится оператор исключительной ситуации, прерывающий исполнение этой инструкции.

В документации в отдельной главе (2.2 Operation Section Notation and Functions) содержится описание <<функций>> AddressTranslation и LoadMemory. Первая описывает трансляцию виртуального адреса в физический, вторая описывает обращение в оперативную память с учетом кэш-памяти так, как это делается в микропроцессорах архитектуры MIPS64~\cite{MIPS64_II}. Еще из одного документа следует, что при исполнении этих функций задействованы следующие структуры:
\begin{itemize}
  \item кэш-память данных первого уровня (D-cache);
  \item кэш-память инструкций первого уровня (I-cache);
  \item кэш-память второго уровня, совместная для данных и инструкций (L2-cache);
  \item общий буфер трансляции адресов (TLB);
  \item буфер трансляции адресов данных (DTLB);
  \item буфер трансляции адресов инструкций (ITLB).
\end{itemize}

Тем самым для тестового шаблона будет задействована кэш-память данных первого уровня (так определялся вариант исполнения l1Hit), значит, в модель состояния попадет D-cache. I-cache и L2-cache не входит в выбранный вариант исполнения инструкции, равно как и все TLB.

Для подготовки формального описания l1Hit надо в описании инструкции LW:
\begin{enumerate}
  \item выделить аргументы инструкции и их битовые длины;
  \item определить значения <<констант>> (в данном случае это PSIZE, ReverseEndian, BigEndianCPU, WORD);
  \item выделить в потоке управления этого описания путь, соответствующий нужному варианту исполнения;
  \item формализовать <<функции>> AddressTranslation и LoadMemory с учетом выбранного варианта исполнения инструкции и модели состояния;
  \item выразить выделенный путь в потоке управления в виде последовательности операторов на специальном языке.
\end{enumerate}

Аргументов здесь три: offset, GPR[base] и GPR[rt]. Их битовые длины -- 16, 64 и 64 (первое написано также на странице описания LW, а остальные аргументы суть GPR --- регистры общего назначения, чей битовый размер в MIPS64 равен 64). <<Константы>> PSIZE, ReverseEndian, BigEndianCPU являются частью режима работы микропроцессора в момент тестирования. Тем самым их значения надо искать в этом режиме. Путь в потоке управления должен быть таким, чтобы в него попал LoadMemory (чтобы произошло заявленное кэш-попадание в кэш-память первого уровня). Значит, первый оператор остается прежним, во втором операторе -- это условный оператор -- должна сработать else-ветвь (поскольку в then-ветви исполнение инструкции прерывается), остальные операторы остаются без изменений. Формализация <<функций>> и выражение выделенного пути описана в разделе~\ref{state_model_section}.

%vAddr <- sign_extend(offset) + GPR[base]
%vAddr1..0 == 02
%(pAddr, CCA) <- AddressTranslation (vAddr, DATA, LOAD)
%pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02))
%memdoubleword <- LoadMemory (CCA, WORD, pAddr, vAddr, DATA)
%byte <- vAddr2..0 xor (BigEndianCPU || 02)
%GPR[rt] <- sign_extend(memdoubleword31+8*byte..8*byte)

\paragraph{шаг <<написать конструктор инициализирующих программ>>} предполагает подготовку соответствующего конструктора. Тестовый шаблон еще не может быть тестом, поскольку в нем не заданы значения аргументов инструкций и не актуализировано начальное состояние микропроцессора (предполагается, что оно должно быть \emph{таким}, чтобы инструкции выполнялись заданным образом). Поэтому после того, как подготовлен тестовый шаблон, модель состояния и формализованы описания вариантов исполнения инструкций, в работу включаются компоненты, осуществляющие построение недостающих данных и актуализацию начального состояния микропроцессора. Например, для шаблона на рисунке~\ref{test_template_exmp1} было выбрано значение переменной <<c>> (оно равно 0) и актуализировано начальное состояние в виде последовательности инструкций \texttt{XOR y, y, y} и \texttt{SW x, y, 0x0}.

В рассматриваемом методе предлагается актуализировать начальное состояние в виде последовательности инструкций (которые образуют \emph{инициализирующую программу}). Поскольку речь идет о тестировании модулей управления памяти, то эти последовательности инструкций должны затрагивать блоки микропроцессора, отвечающие работе с памятью. Специальные последовательности таких обращений должны подготовить эти блоки к требуемым вариантам исполнения в тестовом шаблоне. Для каждого блока будет своя такая последовательность. И еще одна последовательность для инициализации регистров общего назначения. Инициализирующая программа --- это обычная программа на языке ассемблера, но эта программа должна давать специфический эффект -- инициализировать блоки микропроцессора.

Построение инициализирующей программы было разделено на ряд этапов:
\begin{enumerate}
  \item построение \emph{ограничений} (constraint'ов) по шаблону, модели состояния и описаниям инструкций; речь идет о построении ограничений на \emph{данные}; в эти данные входят значения переменных в описаниях инструкций, атрибуты инструкций инициализирующих инструкций (адреса, к которым производятся обращения, вид обращения и т.п.);
  \item разрешение ограничений (вычисление данных);
  \item конструирование инициализирующей программы на основе вычисленных данных; их надо облечь в вид инструкций тестируемой архитектуры --- этот этап и выполняет конструктор инициализирующих программ; например, для каждой будущей инструкции выбрать регистры-аргументы, вычислить на основе переданных атрибутов инструкции значения аргументов, сгенерировать инструкции, обеспечивающие значения аргументов, и саму инструкцию, для которой это всё делалось.
\end{enumerate}

Иными словами, для построения данных (значений переменных, атрибутов инструкций инициализирующей программы) используется аппарат ограничений (Constraint Satisfaction Problem)~\cite{CSP}. Известно, что время разрешения ограничений сильно зависит от самих ограничений~\cite{isaac05balanced}. Одна и та же задача может быть представлена в виде разных наборов ограничений: одни быстрее разрешаются, другие долго. Ограничения для инструкций работы с памятью, видимо, должны учитывать состояния (содержимое!) различных блоков, размеры которых (количество данных) выражается переменными в количестве $10^4-10^5$ штук. Тем самым ограничения надо строить неким особым способом, чтобы справиться с этим количеством зависимых переменных. В разделе~\ref{constraints_generation_section} подробно разбираются предлагаемые в диссертации методы построения ограничений. Важный вопрос --- является ли метод построения ограничений полным, т.е. дает ли метод построения ограничений гарантию того, что если решатель обнаружил несовместность ограничений, то для такого шаблона не существует теста. В разделе~\ref{constraints_generation_section} предлагается полный метод, его полнота доказана в диссертации формально.

Существенно, что в качестве решателей ограничений в описываемом методе достаточно использовать широко используемые решатели (например, Z3~\cite{Z3}). Это выгодно отличает эту работу от аналогичных~\cite{GenesysPro}, где приходится использовать специальные методы не только построения, но и разрешения ограничений, дабы иметь возможность описывать более сложные инструкции.

При написании конструктора достаточно знания того, как загрузить заданные значения в регистры, как обратиться по заданным адресам в память, загрузить в память заданные значения. Это знание получается в результате знакомства с документацией по архитектуре микропроцессора. Кроме того, нужно использовать знание модели состояния, поскольку последовательности данных об инструкциях инициализирующей программы определяются для ограничений (constraint'ов) в терминах этой модели.

\section{Модель состояния и язык описания инструкций}\label{state_model_section}

Модель состояния подсистемы управления памяти (или просто, модель состояния) представляет из себя набор \emph{таблиц}. Таблица представляет собой набор \emph{регионов}. Каждый регион --- это множество \emph{строк}. Все такие множества для одной таблицы имеют одинаковый размер. Строка состоит из поименованного набора \emph{полей}, каждое поле является битовой строкой. На рисунке~\ref{table_picture} схематически показаны регионы таблицы, строки и поля строк.

\begin{figure}[h] \center
  \includegraphics[width=0.8\textwidth]{2.theor/table.eps}\\
  \caption{Таблица}\label{table_picture}
\end{figure}

Например, буфер трансляции адресов (TLB) в микропроцессорах архитектуры MIPS64~\cite{mips64_III} это таблица из одного региона, каждая его строка состоит из полей \texttt{r}, \texttt{vpn/2}, \texttt{g}, \texttt{asid}, \texttt{pfn}$_0$, \texttt{CCA}$_0$, \texttt{v}$_0$, \texttt{pfn}$_1$, \texttt{CCA}$_1$, \texttt{valid}$_1$ и других. В виде таблиц можно представить и кэш-память любого уровня, и даже оперативную память (хотя формально оперативная память не входит в подсистему управления памяти).

Регионы таблицы отражают \emph{ассоциативность} ее блока. Таблица для полностью ассоциативного блока состоит из одного региона. Таблица для блока прямого доступа состоит из множества регионов, но в каждом регионе всего одна строка.

Поля строки таблицы делятся на \emph{поля ключа} и на \emph{поля данных}. Тем самым отражается смысл строки --- соответствие ключа и данных. Регион не может хранить в разных строках одинаковые ключи.

Таблицы обладают состоянием. Оно состоит из значений, которые хранятся в полях строк. Инструкции микропроцессора осуществляют доступ к таблицам: они используют значения, хранящиеся в таблицах, и изменяют состояния таблиц. Доступ к таблице осуществляется в виде поиска данных, хранящихся по заданному ключу. Поиск может быть успешным, если этот ключ присутствует в какой-либо строке таблицы (при этом будет говориться, что происходит \emph{попадание}), или неуспешным, если этот ключ не присутствует ни в одной из строк таблицы (при этом будет говориться, что происходит \emph{промах}). При промахе инструкция может изменить состояние таблицы, поместив туда (откуда-то взятые) данные по искомому ключу. Чтобы сохранить при этом размер таблицы, какая-то из строк должна быть удалена, <<вытеснена>>. Правило определения такой строки называют \emph{стратегией вытеснения} (replace policy). Примеры стратегий вытеснения: LRU, FIFO, Pseudo-LRU. Если вытеснение не должно выполняться микропроцессором (например, если речь идет о страницах виртуальной памяти, вытеснение которых может быть довольно сложным, хотя бы с учетом своппинга), то стратегия вытеснения не имеет значения.

Описание таблицы включает в себя следующие характеристики:
\begin{itemize}
    \item поля строк (для каждого поля указывается название, битовая длина, поле ли это ключа или поле данных);
    \item количество регионов;
    \item стратегия вытеснения;
    \item количество строк в регионе (ассоциативность);
    \item предикат соответствия ключа обращения и строки, ключом обращения являются те данные инструкции, по которым производится поиск строки в таблице (например, пара \texttt{(r, vpn/2)} является ключом обращения в TLB микропроцессоров MIPS64).
\end{itemize}

Описание уже упомянутого буфера трансляции адресов микропроцессоров архитектуры MIPS64 может выглядеть следующим образом:
\begin{verbatim}
table TLB
{
    line(   r:2,key; vpnd2:28,key; g:1,key; asid:4,key;
            pfn0:24,data; cca0:3,data; valid0:1,data;
            pfn1:24,data; cca1:3,data; valid1:1,data )
    regions = 1
    policy = none
    lines = 48
    keyMatch(r, vpnd2) { .... }
}
\end{verbatim}

Предикат соответствия ключа обращения строке будет приведен чуть позже, когда будет описан для этого язык.

Теперь переходим к языку описания вариантов исполнения инструкций (или просто, языку описания инструкций). Напомним, что вариант исполнения задавался в виде последовательности действий. Описание инструкции будет также повторять эту последовательность, внося лишь ряд уточнений. Описание сделано максимально приближенным к тому, как инструкция описана в документации, в привычных тестировщикам документах. В документации вариант исполнения инструкции описывается в виде последовательности преобразований над битовыми строками. Предлагаемое в диссертации описание следует этому же принципу и для описания работы с подсистемой управления памяти добавляются всего 2 новых оператора.

Описание инструкции состоит из двух частей: объявления аргументов инструкции и собственно последовательности действий-операторов. Объявление аргумента состоит из имени внутри данного описания, битовой длины, флаг запрета изменения значения аргумента (read-only). Флаг вводится для того, чтобы иметь возможность использовать в качестве разных аргументов одной инструкции одинаковые регистры (если они оба не являются read-only, то это должны быть разные регистры). Аргументы следует воспринимать как битовые строки (bit-vector). По ходу инструкции кроме аргументов будут появляются и другие переменные, но они тоже будут битовыми строками.

\emph{Единственным <<типом>> переменных при описании инструкции являются битовые строки.}

Над переменными определены следующие виды выражений-операций:
\begin{itemize}
    \item битовые операции (битовая конкатенация, битовая степень, выделение бита с заданным индексом, выделение диапазона бит в заданных границах, знаковое расширение битового размера);
    \item арифметические операции (суммирование, вычитание, умножение);
    \item отношения сравнения (равенство/неравенство, сравнение на больше-меньше);
    \item логические связки над отношениями сравнения и другими логическими связками (конъюнкция, дизъюнкция).
\end{itemize}

Операторы бывают следующих трех видов:
\begin{itemize}
    \item \emph{оператор объявления нового имени}: в явной форме --- по сути оператор присваивания: \texttt{var <- expr}; в неявной форме описывается лишь предикат над значением: \texttt{let var:LEN\{boolexpr\}};
    \item \emph{оператор допущения} (assume), утверждает истинность некоторого логического выражения: \texttt{assume: boolexpr};
    \item \emph{операторы обращений в таблицы} (\texttt{hit} и \texttt{miss}):
        \begin{itemize}
            \item \emph{попадание} \texttt{hit<table>(key, region)\{[loaded(datafields)]}\\\texttt{[storing(datafields)]\}} фиксирует, что обращении в \texttt{table} с ключом \texttt{key} в регион \texttt{region} должно быть успешным, при этом ещё можно специфицировать поля данных найденной строки (\texttt{datafields} --- список выражений для каждого поля данных в строке таблицы \texttt{table}), кроме того можно специфировать изменение полей данных в найденной строке (\texttt{storefields} --- список выражений для каждого поля данных в строке таблицы \texttt{table}); \texttt{loaded} и \texttt{storing} не являются обязательными;
            \item \emph{промах} \texttt{miss<table>(key, region)\{[replacing(datafields)]\}}\\фиксирует, что обращении в \texttt{table} с ключом \texttt{key} в регион \texttt{region} должно быть неуспешным, блок \texttt{replacing} задает поля данных вытесняющей строки (\texttt{datafields} --- список выражений для каждого поля данных в строке таблицы \texttt{table}); если \texttt{replacing} не задано, то при этом промахе не должно происходить вытеснение.
        \end{itemize}
\end{itemize}


Рассмотрим уже знакомый пример для архитектуры MIPS64:

\texttt{LW x, y, c @ l1Hit}

Потребуется кэш-память первого уровня и данные памяти, поэтому надо составить их модели (для <<стратегии вытеснения>> \texttt{none} предикат \texttt{keyMatch} писать не надо):
\begin{verbatim}
    table l1 {
        line(tag:24,key);
        regions = 128;
        policy = LRU;
        lines = 4;
        keyMatch(key:24) { key = tag };
    }
    table memory {
        line(phys:33,key; memdw:64,data);
        regions = 1;
        policy = none;
        lines = 8589934592;
    }
\end{verbatim}

Для \texttt{l1Hit} оставалось оформить выбранный путь в описании инструкции \texttt{LW} и формализовать <<функции>> \texttt{AddressTranslation} и \texttt{LoadMemory} (с учетом \texttt{l1Hit}!). Объявления аргументов:
\begin{verbatim}
    base : 64, readonly;
    offset : 16, readonly;
    rt : 64, result;
\end{verbatim}

Начало описания пути \texttt{l1Hit} практически дословно повторяет документацию:
\begin{verbatim}
    vAddr <- (64)offset + base;
    assume: vAddr[1..0] = 0^2;
\end{verbatim}

Затем идет <<вызов>> \texttt{AddressTranslation}. В данном варианте исполнения \texttt{LW} трансляция виртуального адреса в физический должна выполняться без обращения к TLB. Это означает, что надо специфицировать условия, при которых трансляция адреса выполняется таким образом, и результат этой трансляции. Условия и результат трансляции описаны в документации. А именно, такая трансляция проводится при специальных виртуальных адресах (например, на таких, где \texttt{vAddr[58] = 0}, \texttt{vAddr[57] = 0}, ..., \texttt{vAddr[36] = 0}). В качестве результата формируется значение новых переменных --- физического адреса \texttt{pAddr} и политики кэширования \texttt{cca}:
\begin{verbatim}
    assume: vAddr[58..36] = 0^23;
    pAddr <- vAddr[35..0];
    cca <- vAddr[63..61];
\end{verbatim}

От политики кэширования будет зависеть работа кэш-памяти и это действительно разные способы работы -- сквозная запись и отложенная запись, где-то производится запись в кэш-память и в оперативную память, где-то только в оперативную память. Но при \texttt{l1Hit} инструкции LW запись не производится и поэтому достаточно, чтобы кэш-память просто была задействована. Согласно документации это означает, что \texttt{cca} не должно равняться 2. Тем самым появляется еще одно уточнение \texttt{AddressTranslation}:
\begin{verbatim}
    assume: cca != 2;
\end{verbatim}

Далее идет изменение физического адреса с учетом \texttt{ReverseEndian}. Напомнию, что эта <<константа>> соответствует режиму, в котором происходит тестирование. Т.е. в момент генерации теста значение \texttt{ReverseEndian} известно, его не нужно искать с помощью ограничений. Если тест будет исполняться в режиме с \texttt{ReverseEndian = 0}, то преобразование выполнять не надо, т.к. \texttt{pAddr <- pАddr[PSIZE-1..3]||(pAddr[2..0] xor (0||0\^2))} эквивалентно \texttt{pAddr <- pАddr[PSIZE-1..0])}, а \texttt{PSIZE = 36} (из документации), т.е. \texttt{pАddr[PSIZE-1..0]} получается то же, что и \texttt{pАddr}. Рассмотрим более сложный случай: \texttt{ReverseEndian = 1} :
\begin{verbatim}
    pAddr2 <- pAddr[35..3] || (pAddr[2]+1) || pAddr[1..0];
\end{verbatim}

Далее идет <<вызов>> \texttt{LoadMemory}. В \texttt{l1Hit} это должно быть лишь обращение в кэш-память первого уровня с попаданием и обращение в память за данными. Надо понять, что является ключами и регионами этих обращений. Читаем документацию по тому, как проводится обращение в кэш-память:
\begin{verbatim}
    tag <- pAddr2[35..12];
    region <- pAddr2[11..5];
    phys <- pAddr2[35..3];
    hit<l1>(tag, region);
    hit<memory>(phys){loaded(memdw)};
\end{verbatim}

Тем самым записано, что при обращении в \texttt{l1} должно быть кэш-попадание и из памяти считывается 64 бита в переменную \texttt{memdw}. Далее из этих 64 бит надо выбрать 32 (поскольку инструкция \texttt{LW} --- load word) --- старшую половину или младшую на основе \texttt{vAddr[2..0]} (см. описание \texttt{LW}):
\begin{verbatim}
    byte <- vAddr[2..0];
    assume: byte = 0 and rt = memdw[31..0]
         or byte = 4 and rt = memdw[63..32];
\end{verbatim}

Описание инструкции \texttt{LW} для \texttt{l1Hit} готово. Целиком оно выглядит следующим образом (справа):

\noindent\parbox{0.4\textwidth}{ \footnotesize \tt
vAddr <- sign\_extend(offset) + GPR[base];\\
assume: vAddr[1..0] = 0\^{}2;\\
(pAddr, CCA) <- AddressTranslation( vAddr, DATA, LOAD );\\
pAddr <- pAddr[PSIZE-1..3] || (pAddr[2..0] xor (ReverseEndian || 0\^{}2 ));\\
memdoubleword <- LoadMemory(CCA, WORD, pAddr, vAddr, DATA);\\
byte <- vAddr[2..0] xor (BigEndianCPU || 0\^{}2);\\
GPR[rt] <- sign\_extend( memdoubleword[ 31+8*byte .. 8*byte ] );\\
} \parbox{0.1\textwidth}{ \quad
} \parbox{0.5\textwidth}{ \footnotesize \tt
base : 64, readonly;\\
offset : 16, readonly;\\
rt : 64, result;\\
\\
vAddr <- (64)offset + base;\\
assume: vAddr[1..0] = 0\^{}2;\\
assume: vAddr[58..36] = 0\^{}23;\\
pAddr <- vAddr[35..0];\\
cca <- vAddr[63..61];\\
assume: cca != 2;\\
pAddr2 <- pAddr[35..3] ||\\
\indent\hspace{1cm}(pAddr[2]+1) || pAddr[1..0];\\
tag <- pAddr2[35..12];\\
region <- pAddr2[11..5];\\
phys <- pAddr2[35..3];\\
hit<l1>(tag, region);\\
hit<memory>(phys)\{loaded(memdw)\};\\
byte <- vAddr[2..0];\\
assume: byte = 0 and rt = memdw[31..0]\\
\indent\hspace{1cm}or byte = 4 and rt = memdw[63..32];\\}

В качестве другого примера приведем keyMatch для TLB микропроцессоров MIPS64: (\texttt{asid} является <<константой>> режима тестирования, для примера допустим, что она равна 10)
\begin{verbatim}
table TLB
{
    line(   r:2,key; vpnd2:28,key; g:1,key; asid:4,key;
            pfn0:24,data; cca0:3,data; valid0:1,data;
            pfn1:24,data; cca1:3,data; valid1:1,data )
    regions = 1
    policy = none
    lines = 48
    keyMatch(r1, vpnd) { r1 = r and vpnd = vpnd2 and
        (g = 1 or asid = 10)}
}
\end{verbatim}

Границы применимости предлагаемых методов описания приведу на следующих примерах.

Методы применимы в следующих случаях:
\begin{itemize}
    \item многоуровневая кэш-память: каждый уровень кэш-памяти становится отдельной таблицей, в описаниях инструкций явно указывается, в какие уровни происходят обращения, а в какие нет;
    \item обращение в память с использованием виртуальной памяти и без ее использования: описывается условие на битовую строку-виртуальный адрес;
    \item сквозная запись в память (write-through) и отложенная запись в память (write-back): в строке таблицы, оисывающей кэш-память, надо определить data-поля и в строке таблицы, описывающей оперативную память, тоже надо определить data-поля и явно указать storing этих полей в каждой таблице;
    \item необходимость в дополнительных условиях (ограничениях) на элементы строк кэш-памяти и других буферов: сначала оператором обращения в память вводим переменные-поля строки, а затем отдельным оператором допущения описываем условия на эти переменные-поля;
    \item virtually indexed virtually tagged - кэш-память, в которой ключ и регион обращения вычисляются по виртуальному, а не физическому адресу: для оператора обращения в таблицу не имеет значения, как вычислены ключ и регион --- по физическому ли, по виртуальному ли адресу;
\end{itemize}

%кэши Pentium, Alpha, PowerPC ? - об этом позже

Методы не применимы для описания:
\begin{itemize}
    \item псевдослучайных действий: псевдослучайное вытеснение, псевдослучайный выбор таблицы, к которой происходит обращение;
    \item временн\'{ы}е ограничения: результат инструкции берется в результате наиболее быстрого обращения среди нескольких параллельно начатых обращений;
    \item циклические действия в описании инструкций: на основе анализа документации по разным архитектурам был сделан вывод, что инструкции, в которых сложный сложный поток управления, крайне редко встречаются в подсистемах управления памяти; например, для описания инструкций сопроцессора, инструкции работы с плавающей запятой, были бы очень удобны и адекватны циклические конструкции (скажем, для описания суммирования рядов для вычисления синуса);
    \item кэш-память инструкций, совместная кэш-память (с данными и инструкциями): для тестирования кэш-памяти инструкций еще не разработана нацеленная генерация, выделение действительно полезных тестовых шаблонов сталкивается с их \emph{нелокальностью}, т.е. зачастую нужны не последовательности инструкций, а отдельные инструкции, которые еще надо поместить в памяти по нужным адресам.
\end{itemize}

\section{Метод построения ограничений}\label{constraints_generation_section}

\subsection{Алгоритмы}
В этом разделе будет описан предлагаемый метод построения ограничений (constraints) по тестовому шаблону, модели состояния и описаниям инструкций для построения атрибутов инициализирующих обращений. Идея использования ограничений для поиска значений состоит в следующем: определяется набор переменных, чьи значения надо вычислить, известно конечное множество значений каждой переменной, известен набор предикатов (ограничений, constraint'ов) на значения переменных (буквально говоря, такие <<ограничения>> <<ограничивают>> значения переменных) --- задача состоит в вычислении (подборе) таких значений для переменных, на которых все предикаты выполнены (значения <<попадают в ограничения>>). В предлагаемом методе в качестве переменных будут выбираться переменные-битовые строки фиксированной битовой длины. Над битовыми строками определены функции (точнее, функциональные символы) и отношения~\cite{QF_BV}. Тем самым генерируемые ограничения не содержат ничего принципиально нового с точки зрения языка -- это те же битовые строки и операции над ними, которые были в описаниях инструкций. Такой подход оказался оправданным, поскольку существуют инструменты разрешения ограничений над битовыми строками~\cite{Z3, Yices}. Итак, по виду генерируемые ограничения будут ограничениями на битовые строки, это оправдано уже существующим инструментарием.

\paragraph{Алгоритм генерации ограничений} следующий:
\begin{enumerate}
    \item слить все описания инструкций в одну последовательность согласно тестовому шаблону (получается единая последовательность операторов для одного тестового шаблона);
    \item разделить полученную последовательность операторов на подпоследовательности:
            \begin{itemize}
                \item одна подпоследовательноть включает все операторы исходной последовательности над битовыми строками;
                \item каждая другая подпоследовательность включает все операторы обращений в какую-нибудь одну таблицу;
            \end{itemize}
    \item объявить переменные для аргументов инструкций и полей строк в операторах обращения к таблицам;
    \item транслировать операторы над битовыми строками без изменений в ограничения на битовые строки;
    \item для каждой оставшейся подпоследовательности последовательно провести следующие
            \begin{itemize}
                \item алгоритм генерации ограничений на ключи обращений;
                \item алгоритм генерации ограничений на загружаемые/сохраняемые данные.
            \end{itemize}
\end{enumerate}

\paragraph{Алгоритм генерации ограничения на ключи обращений для таблицы, стратегия вытеснения которой не \texttt{none}}:
\begin{enumerate}
    \item выбрать длину инициализирующей последовательности $m$;
    \item объявить переменные ключей инициализирующей последовательности $t_1, t_2, ..., t_m$ и их регионов $r_1, r_2, ..., r_m$;
    \item составить ограничение <<все разные $(t_1||r_1), (t_2||r_2), ..., (t_m||r_m)$>> (<<||>> -- операция битовой конкатенации);
    \item составить ограничение для каждого hit($k_n, R_n$), $k_n$ --- ключ обращения, $R_n$ --- регион обращения:
$$\left\{\begin{array}{l}
	(k_n||R_n) \in \{(t_1||r_1), (t_2||r_2), ..., (t_m||r_m), (k_1||R_1), ..., (k_{n-1}||R_{n-1}) \}\\
    (k_n, R_n)~\mbox{\textbf{не} вытеснен к моменту этого обращения}\\
\end{array}\right.$$

где $k_1, ..., k_{n-1}$ --- ключи предыдущих обращений в эту же таблицу,\\ $R_1, ..., R_{n-1}$ --- регионы предыдущих обращений в эту же таблицу;

    \item составить ограничение для каждого miss($k_n, R_n$), $k_n$ --- ключ обращения, $R_n$ --- регион обращения:
$$\left\{\begin{array}{l}
	(k_n||R_n) \in \{(t_1||r_1), (t_2||r_2), ..., (t_m||r_m), (k_1||R_1), ..., (k_{n-1}||R_{n-1}) \}\\
    (k_n, R_n)~\mbox{вытеснен к моменту этого обращения}\\
\end{array}\right.$$

где $k_1, ..., k_{n-1}$ --- ключи предыдущих обращений в эту же таблицу,\\ $R_1, ..., R_{n-1}$ --- регионы предыдущих обращений в эту же таблицу;

    \item TODO!!! <<ограничение мощности>>: в одном регионе не может быть больше различных тегов, чем lines.
\end{enumerate}

Детальное исследование вопроса о том, как выразить свойство <<быть вытесненным к моменту нужного обращения>> дается в главе ???????????????????????

\paragraph{Алгоритм генерации ограничения на ключи обращений для таблицы, стратегия вытеснения которой есть \texttt{none}}: $k_1, ..., k_n$ --- ключи всех обращений в таблицу с попаданиями, $R_1, ..., R_n$ --- регионы этих обращений; $w$ --- количество строк в регионе (т.е. значение параметра таблицы lines)

\begin{enumerate}
    \item для каждого miss($k, R$), $k$ --- ключ обращения, $R$ --- регион обращения, составить ограничение: $$(k||R) \notin \{(k_1||R_1), ..., (k_n||R_n) \}$$

    \item если $n > w$, то для каждого $l = 1, 2, \dots, n$ составить ограничение (<<в каждом регионе не может быть больше различных тегов, чем lines>>)
$$\sum_{i=1}^n c_{R_l} (k_i, R_i) \leqslant w$$
$$c_r (k_i, R_i) \equiv \mbox{~if~} (R_i = r ) \wedge \bigwedge_{j=1}^{i-1} (R_j \neq r \vee k_j \neq k_i) \mbox{~then~} 1 \mbox{~else~} 0 \mbox{~endif}$$
\end{enumerate}

\paragraph{Алгоритм генерации ограничений на поля данных в обращениях к таблицам}:
для каждого обращения с loaded($d_n$) с ключом $k_n$ и регионом $R_n$ составляем ограничения
$$P_{n-1} = \mbox{~true}$$
$$P_{n-1} \equiv (\mbox{if~} (k_n||R_n = k_{n-1}||R_{n-1}) \mbox{~then~} d_n = d_{n-1} \mbox{~else~} P_{n-2} \mbox{~endif})$$
$$P_0 \equiv \mbox{~true}$$

В приложении .... доказана теорема корректности алгоритма генерации ограничений на ключи обращений для таблицы, стратегия вытеснения которой не \texttt{none}

В приложении .... сформулирована и доказана теорема полноты алгоритма генерации ограничений на ключи обращений для таблицы, стратегия вытеснения которой не \texttt{none} для \emph{существенно вытесняющих} стратегий вытеснения. К таким стратегиям вытеснения относятся \LRU, \FIFO и \PseudoLRU, которые используются в большинстве микропроцессоров (см. ???????).

Следующий вопрос, как выбирать длину инициализирующей программы $m$. Из леммы ???????? следует, что такая длина существует для любой последовательности обращений в таблицу. Исследование \emph{существенно вытесняющих} стратегий вытеснения дает ответ на этот вопрос (см. раздел~\ref{sec:essentially_displacing}). Однако в конкретных случаях возможны и более сильные верхние оценки для $m$. Так в разделе ?????????? приведена и доказана верхняя оценка $m$ для стратегии вытеснения \LRU, линейно зависимая от длины последовательности обращений. Этот факт делает эффективным использованием алгоритмов типа дихотомии для поиска минимального значения $m$ для данной последовательности обращений (минимизация ведет к уменьшению размеров будущих тестов и, как следствие, ускорению проведения тестирования).

\subsection{Таблицы вытеснения (policy table)}

Таблицы вытеснения были предложены в 2008 году исследователями из немецкого
университета Саарланда~\cite{policy_tables}. Таблица вытеснения
однозначно описывает изменение порядка и вытеснение тегов в наборе. Тем самым таблица вытеснения есть метод формального описания стратегии вытеснения.

Таблица вытеснения исходит из \emph{перестановочной интерпретации} стратегии вытеснения. Она состоит в том, что строки региона упорядочиваются, каждое обращение к таблице осуществляет перестановку строк региона некоторым образом. Никакие дополнительные данные (счетчики, строки, деревья) не используются. Иными словами, в результате обращения происходи лишь перестановка <<позиций строк>>. Определение вытесняемого элемента тоже осуществляется лишь на основе текущих позиций строк. Таблица вытеснения как раз фиксирует выполняемые перестановки.

Таблица вытеснения представляет собой матрицу $(w{+}1) \times (w{+}1)$, где $w$
--- ассоциативность таблицы (количество строк региона). Первый столбец ---
специальный, он содержит указание позиций от 0 до $w{-}1$ (для обращения с попаданием) и
специальную <<псевдопозицию>> для обращения с промахом (символ $\pi$ помогает указанию того, что речь идет о позициях). Остальными элементами
матрицы являются числа от 0 до $w{-}1$ и специальный символ $m$ для
вытесняющего тега. Пример таблицы вытеснения (для стратегии
вытеснения \LRU) смотрите на рисунке~\ref{PolicyTableLRU8}.

\begin{figure}[h]
$$ \left[
     \begin{array}{c|cccccccc}
       \pi_0 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_1 & 1 & 0 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_2 & 2 & 0 & 1 & 3 & 4 & 5 & 6 & 7 \\
       \pi_3 & 3 & 0 & 1 & 2 & 4 & 5 & 6 & 7 \\
       \pi_4 & 4 & 0 & 1 & 2 & 3 & 5 & 6 & 7 \\
       \pi_5 & 5 & 0 & 1 & 2 & 3 & 4 & 6 & 7 \\
       \pi_6 & 6 & 0 & 1 & 2 & 3 & 4 & 5 & 7 \\
       \pi_7 & 7 & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
       \pi_m & m & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
     \end{array}
   \right]
$$
\caption{Таблица вытеснения для стратегии вытеснения \LRU,
8-ассоциативная таблица}\label{fig:PolicyTableLRU8}
\end{figure}

Строки таблицы вытеснения, кроме последней, описывают перестановку позиций строк региона при обращении с попаданием. Каждой такой строке соответствует попадание на позицию, которая указана в первом столбце строки. Остальная часть строки есть перестановка позиций строк (0~1~...~$w{-}1$). Например, для стратегии вытеснения \LRU,
представленной на рисунке~\ref{fig:PolicyTableLRU8}, при попадании по позиции 5 строки таблицы, пронумерованные как (4 6 5 7 1 0 2 3), будут переставлены (смотрим строку с $\pi_2$, потому что позиция 5 находится на позиции c номером 2) согласно (2 0 1 3 4 5 6 7), что даст в результате новое расположение этих строк как (5 4 6 7 1 0 2 3).

Последняя строка таблицы вытеснения соответствует обращению с промахом. Вытесняющая строка помечается буквой $m$. Позиция вытесняемой строки --- тот элемент набора (0~1~... $w{-}1$), который отсутствует в последней строке таблицы вытеснения. Например, в таблице вытеснения на рисунке~\ref{fig:PolicyTableLRU8} позиция вытесняемой строки равна 7, т.е. вытесняется последняя строка, а вытесняющая помещается в самое начало со сдвигом оставшихся строк.

В качестве другого примера приведем таблицы вытеснений для других двух стратегий вытеснения -- \FIFO и \MRU (см. рис.~\ref{fig:fifo_mru_tables}).

\begin{figure}[h] \centering
\parbox{0.4\textwidth}{
$$ \left[
     \begin{array}{c|cccccccc}
       \pi_0 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_1 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_2 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_3 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_4 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_5 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_6 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_7 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_m & m & 0 & 1 & 2 & 3 & 4 & 5 & 6 \\
     \end{array}
   \right]$$
\center \FIFO} \qquad
\parbox{0.4\textwidth}{
$$ \left[
     \begin{array}{c|cccccccc}
       \pi_0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 0 \\
       \pi_1 & 0 & 2 & 3 & 4 & 5 & 6 & 7 & 1 \\
       \pi_2 & 0 & 1 & 3 & 4 & 5 & 6 & 7 & 2 \\
       \pi_3 & 0 & 1 & 2 & 4 & 5 & 6 & 7 & 3 \\
       \pi_4 & 0 & 1 & 2 & 3 & 5 & 6 & 7 & 4 \\
       \pi_5 & 0 & 1 & 2 & 3 & 4 & 6 & 7 & 5 \\
       \pi_6 & 0 & 1 & 2 & 3 & 4 & 5 & 7 & 6 \\
       \pi_7 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 \\
       \pi_m & 0 & 1 & 2 & 3 & 4 & 5 & 6 & m \\
     \end{array}
   \right]$$
\center \MRU } \caption{Таблицы вытеснения для 8-ассоциативной таблицы}\label{fig:fifo_mru_tables}
\end{figure}

\subsection{Существенно вытесняющие стратегии вытеснения}\label{sec:essentially_displacing}

В ?????????????? сформулирована и доказана теорема полноты алгоритма генерации ограничений для последовательностей обращений в таблицы: ................... <<формулировка теоремы о полнота>>

Стратегию вытеснения будем называть \emph{существенно вытесняющей}, если для любой строки таблицы с этой стратегией вытеснения существует последовательность обращений к 
этой таблице, в результате которых эта строка будет вытеснена. 

Вопрос о полноте алгоритмов генерации ограничений сводится к вопросу о существенном вытеснении стратегии вытеснения. Для ответа на второй вопрос воспользуемся таблицей вытеснения. Предлагается построить орграф, вершинами которого будут всевозможные перестановки позиций строк региона (включая $m$), а дуги снабжены пометками -- числом от 0 до $w{-}1$ или символом
$m$. Две вершины соединены дугой с пометкой-числом, если из одной
вершины в другую осуществляется переход в результате обращения с попаданием с
номером позиции -- пометкой-числом. Две вершины соединены дугой с пометкой $m$,
если из одной вершины в другую осуществляется переход в результате обращения с промахом.

\begin{utv}
Если в построенном графе есть цикл из дуг с пометками $m$, в который
ведет путь из вершины (0~1~...~$w{-}1$), на дугах которого не
встречаются одинаковые пометки-числа, то если цикл не включает
вершину ($m$ $m$ \dots $m$), то в стратегии вытеснения не всегда
возможно вытеснение любого тега набора.
\end{utv}

Назовем этот путь с циклом -- \emph{путем невытеснения}. Значит, наличие
пути невытеснения -- признак неполноты алгоритма генерации ограничений для этой стратегии
вытеснения.

Приведем пример стратегии вытеснения, для которой путь невытеснения
есть:
$$\left[
  \begin{array}{c|cccc}
    \pi_0 & 0 & 1 & 2 \\
    \pi_1 & 1 & 0 & 2 \\
    \pi_2 & 0 & 1 & 2 \\
    \pi_m & 0 & 1 & m \\
  \end{array}
\right]
$$

Соответствующий граф изображен на рисунке~\ref{badpolicy}. В нем
отсутствует какой-либо путь из вершины (0 1 2) в вершину ($m$ $m$
$m$). Пример пути невытеснения в этом графе: 1 $m$ $m \dots$ . Это и
означает невозможность вытеснить некоторые строки (например, строку с позицией 0) с помощью какой бы ни было последовательности обращений.
\begin{figure}[h]\center
  \includegraphics[width=0.7\textwidth]{2.theor/badpolicy}\\
  \caption{Граф для модельной стратегии вытеснения}\label{badpolicy}
\end{figure}

Для определения существования пути невытеснения может применяться
следующий алгоритм: сначала перебираются порядки на множестве чисел
$\{0, 1, ..., w{-}1\}$; обозначим очередной порядок как $i_1, i_2,
..., i_w$; строим множество вершин графа $V_1$, достижимых из (0~1
... $w{-}1$) по путям только с пометками $m$, в которых не встречается вершина ($m$ $m$ ... $m$); если среди таких путей есть путь с циклом,
алгоритм завершается с ответом <<путь невытеснения есть>>; иначе
строим множество вершин $V'_1$, достижимых из $V_1$ по дугам с
пометкой $i_1$; затем строим множество вершин графа $V_2$, достижимых из
вершин $V'_1$ по путям только с пометками $m$, в которых не встречается вершина ($m$ $m$ ... $m$); если среди таких путей есть путь с циклом,
алгоритм завершается с ответом <<путь невытеснения есть>>; иначе
строим множество вершин $V'_2$, достижимых из $V_2$ по дугам с
пометкой $i_2$; и так далее. Если путь с циклом нигде не встретился и все
возможные порядки просмотрены, алгоритм завершается с ответом <<пути
невытеснения нет>>.

В примере для модельной стратегии вытеснения, выбрав $i_1 = 0$, $i_2 = 1$, $i_3 = 2$, получим $V_1 = \{ (0~1~2), (0~1~m) \}$ и имеется путь с циклом: $m$ $m$ ..., в котором не встречается вершина ($m$ $m$ $m$). Тем самым путь невытеснения найден.

Граф для стратегий вытеснения \LRU и \PseudoLRU в случае
двух~-~ассоциативной таблицы (для сокращения пометки заменены
штриховкой: дуга с пометка $m$ обозначена сплошной линией, дуга с
пометкой $0$ обозначена линией из точек, дуга с пометкой $1$
обозначена линией из пунктиров) изображен на
рисунке~\ref{fig:lrupolicy}. В этом графе есть всего один цикл,
состоящий из сплошных дуг -- петля на вершине ($m$ $m$). Поскольку он включает
в себя вершину ($m$ $m$), то в этом графе нет пути невытеснения.
В случае таблиц с б\'{о}льшим количеством строк в регионе ситуация будет
аналогичной.

Аналогичная ситуация будет и со стратегией вытеснения \FIFO (граф
для двух~-~ассоциативной таблицы изображен на рисунке~\ref{fig:fifopolicy}). В этом графе тоже всего один цикл, состоящий из сплошных дуг -- петля на вершине ($m$ $m$). Поскольку
этот цикл включает в себя вершину ($m$ $m$), то в этом графе нет
пути невытеснения. В случае буферов с большим количеством строк в регионе
ситуация будет аналогичной.

\begin{figure}[h]
\parbox{0.5\textwidth}{ \centering
  \includegraphics[width=0.45\textwidth]{2.theor/lrupolicy}
  \caption{Граф для стратегий вытеснения \LRU и \PseudoLRU с ассоциативностью 2}
  \label{fig:lrupolicy}
} \vline
\parbox{0.5\textwidth}{ \centering
  \includegraphics[width=0.45\textwidth]{2.theor/fifopolicy}
  \caption{Граф для стратегии вытеснения \FIFO с ассоциативностью 2}
  \label{fig:fifopolicy}
}
\end{figure}

%% надо ли общее доказательство для этих стратегий вытеснения ?

Предложенный орграф также полезен для получения верхней оценки количества инициализирующих обращений в таблицу (в алгоритме это число было названо $m$). Исходя из доказательства теоремы ?????????????? можно сформулировать

\begin{utv}[Верхняя оценка количества инициализирующих обращений]
$$m \leqslant R \cdot (w + D)$$
где $R$ --- количество различных регионов, задействованных в тестовом шаблоне, $w$ --- ассоциативность таблицы (количество строк в регионе), $D$ --- максимальная длина ациклического пути в вершину ($m$ $m$ ... $m$) орграфа.
\end{utv}

$R$ --- есть атрибут тестового шаблона, $w$ --- атрибут структуры таблицы, $D$ --- атрибут функционирования таблицы.

% Включает в себя метод построения ограничений для последовательности обращений в таблицу и методы записи стратегии вытеснения в виде ограничений

% доказать для алгоритмов теоремы корректности и полноты? что не теряются правильные решения и не появляются неправильные ?

%%%\include{0.intro/intro}
%%%
%%%\include{1.review/review}
%%%
%%%\include{2.theor/theor}
%%%
%%%\include{3.impl/impl}
%%%
%%%\include{4.analysis/analysis}

%! добавить еще результаты экспериментов! :)

\include{epilogue}


\pagebreak
\appendix
\include{appendix/tables}
\include{appendix/proofs}

\pagebreak
%%%%\bibliographystyle{plain}
%%%%\bibliographystyle{gost71u}
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{thesis}

%% привести оформление в соответствие с требованием: что-то всё время пропадает!

%%! добавить \cite{Pex}, \cite{symbolic_execution}

%%! вписать название препринта и номер тома

\end{document}
