% !Mode:: "TeX:UTF-8"
\documentclass[14pt]{extreport}

\usepackage{fix-cm}
%\usepackage[cp1251]{inputenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
%\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{dsfont}
\usepackage{lscape}
\usepackage{makecell}
\usepackage{multirow}
\usepackage{hhline}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\usepackage{setspace} % интервалы межстрочные
\pagestyle{plain} \onehalfspacing

%\usepackage[left=3cm,right=2cm,
%top=2cm,bottom=0.5cm,bindingoffset=0cm,  a4paper]{geometry} % поля

\textheight 25.7cm % 29.7-2-2
\textwidth 17cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \headheight 0cm \headsep 0cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел


\newtheorem{theorem}{Теорема}
\newtheorem{lemma}{Лемма}
\newtheorem{utv}{Утверждение}
\newtheorem*{sld}{Следствие}

% добавил ненужный комментарий

\newcommand{\LRU}{\textsf{LRU}\xspace}
\newcommand{\FIFO}{\textsf{FIFO}\xspace}
\newcommand{\PseudoLRU}{\textsf{Pseudo-LRU}\xspace}
\newcommand{\MRU}{\textsf{MRU}\xspace}

\newcommand{\lemmatext}[2]{
\noindent\textbf{Лемма~{#1}}. \textit{#2}
}

\newcommand{\theoremtext}[2]{
\noindent\textbf{Теорема~{#1}}. \textit{#2}
}

\begin{document}

\thispagestyle{empty}

\begin{singlespace}
\begin{center}
%МИНИСТЕРСТВО ОБРАЗОВАНИЯ И НАУКИ\\ РОССИЙСКОЙ ФЕДЕРАЦИИ\\[0.5cm]
%
МОСКОВСКИЙ ГОСУДАРСТВЕННЫЙ УНИВЕРСИТЕТ\\ ИМЕНИ М.~В.~ЛОМОНОСОВА\\[0.5cm]

ФАКУЛЬТЕТ ВЫЧИСЛИТЕЛЬНОЙ МАТЕМАТИКИ\\ И КИБЕРНЕТИКИ\\[1cm]
\end{center}

\begin{flushright}
На правах рукописи\\[2cm]
\end{flushright}

\begin{center}
Корныхин Евгений Валерьевич\\[1cm]
\textbf{%\renewcommand{\baselinestretch}{1.8}
%\fontsize{28pt}{50pt} \selectfont
\huge{%\textsc{исследование и разработка методов генерации программ
%для тестирования
%модулей управления памяти микропроцессоров}}\\[0.5cm]}
\textsc{построение программ
для тестирования
модулей управления памяти микропроцессоров}}\\[0.5cm]}
%\huge{\textsc{ микропроцессоров}}}\\[1.5cm]

Специальность 05.13.11 -- математическое и программное обеспечение
вычислительных машин, комплексов и компьютерных сетей\\[1.5cm]


Диссертация на соискание ученой степени\\
кандидата физико-математических наук
\end{center}

\vspace{0.7cm}

\begin{flushright} Научный руководитель:\\
д.ф-м.н. Петренко Александр Константинович
\end{flushright}

\vspace{1.5cm}

\begin{center}
Москва -- 2009
\end{center}


\end{singlespace}

\pagebreak

\tableofcontents

%%! определение LRU не "на списках", а "на перестановках"! + аналогичные

%%! определиться "последовательность инициализирующих" или "инициализирующая посл-ть"

%%! надо как-то написать, что предлагаемые ограничения недолго разрешаются --
%%      иначе непонятно, зачем это всё, если оно плохо считается

%%! написать, В чем недостаток применения методов типа Монте-Карло для получения
%%  тестовых программ -- ведь их закодировать проще (не поддаются архитектуры, такие вот они вычурные?)
%% (тестовый шаблон может задавать очень маленькую область решений в многомерном
%% пространстве -> мала вероятность в него попасть)

%%! там, где в формулах разъехался "w-1", заменить на "w{-}1"



%% от публики может быть вопрос: измерялось ли максимальная длина шаблона,
%% для которого этими методами генерируются тестовые программы за приемлимое время?
%% момент №1: практика показывает, что большинство ошибок обнаруживается
%%  на коротких тестовых шаблонах (3-4 инструкции)

\include{theorems}

\chapter*{Введение}
системное тестирование

отсутствие хороших систематических методов генерации тестов

\chapter{Обзор, постановка задачи}

нацеленная генерация (зачем надо было заниматься решением моей задачи)

имеющиеся инструменты, их плюсы и минусы

постановка задачи

другие предварительные сведения

\chapter{Первая теоретическая глава}

\section{<<Технологическая цепочка>> - плохое название, сменить}
Основные шаги следующие:
\begin{enumerate}
  \item чтение документации по архитектуре;
  \item выделение интересных для тестирования ситуаций;
  \item формализация архитектуры;
  \item подготовка конструктора инициализирующей программы;
  \item запуск генератора для каждой ситуации.
\end{enumerate}

То есть предлагаемый метод следует подходу нацеленной генерации тестов. Для тестируемого микропроцессора всегда есть описание его архитектуры. В этом документе, фактически, описано, как должны действовать, функционировать, разные инструкции. Разработчики тестов сначала размечают эти описания -- выделяют разные случаи исполнения инструкций. Затем на основе выделенных случаев строится шаблон теста, который исходит из идей разработчиков тестов, в какие ситуации надо попасть при исполнении инструкций. Затем для возможности автоматического построения тестов выделенные случаи исполнения инструкций формализуются. Специальный генератор на основе этого формального описания будет строить для шаблона инструкции теста и инициализацию микропроцессора.
Для выражения этой инициализации в виде инструкций надо написать конструктор инициализирующей программы.

\begin{figure}[p] \center
  \includegraphics[width=\textwidth]{2.theor/process.full.eps}\\
  \caption{Предлагаемый метод генерации тестов}\label{process}
\end{figure}

Предлагаемый метод с указанием потоков данных изображен на рисунке~\ref{process}. Действия, которые надо выполнить вручную, помещены в прямоугольники с закругленными краями. Данные помещены в прямоугольники. Программные компоненты помещены в параллелепипеды.

Теперь более подробно будут описаны шаги предлагаемого метода.

\paragraph{шаг <<читать документацию>>} <<Документация по архитектуре>> --- это документ, описывающий семантику инструкций микропроцессора и некоторые структурные характеристики микропроцессора (какие есть разные буферы, кэш-память и др).
В результате чтения документации надо:
\begin{enumerate}
  \item выделить инструкции, их формат (какие возможны аргументы);
  \item выделить в инструкциях варианты исполнения (<<разметить>>, обычно один вариант исполнения описывается в виде последовательности более простых действий), каждому варианту исполнения присвоить идентификатор (метку);
  \item определить для каждого варианта исполнения, в какие блоки микропроцессора происходят в нем обращения (кэш-память некоторых уровней, буфер трансляции адресов и т.п.).
\end{enumerate}

Например, документация по архитектуре MIPS64 описывает инструкцию LW загрузки 32х бит из памяти в регистр; эта инструкция обладает следующими вариантами исполнения (приведены лишь некоторые из них):
\begin{itemize}
    \item возникновение исключения по причине невыровненного виртуального адреса;
    \item неотображаемое исполнение --- в котором физический адрес вычисляется по виртуальному без обращений к каким-либо блокам микропроцессора;
    \item некэшируемое исполнение --- в котором обращение в кэш-память не делается, напрямую идет обращение в оперативную память;
\end{itemize}

На данном шаге описание варианта исполнения этой инструкции может быть таким: 1) вычисляется виртуальный адрес --- сумма аргументов, 2) если <<виртуальный адрес отображаемый>>, вычисляется номер виртуальной страницы, для нее в TLB ищется соответствующая страница физической памяти (<<идет обращение в TLB>>), иначе вычисляется физический адрес как битовая подстрока виртуального адреса и т.д.

\paragraph{шаг <<выделение ситуаций для тестирования>>} предполагает составление <<тестовых шаблонов>>. Напомню, что тестовый шаблон фиксирует интересную для тестирования ситуацию. Ситуация задается вариантами исполнения инструкций и цепочками инструкций. Тем самым шаблоны представляют собой последовательности инструкций с аргументами. Возможно, аргументы в разных инструкциях повторяются. И у каждой инструкции указывается набор идентификаторов, обозначающих вариант исполнения инструкции.

Для тестового шаблона будет строиться тест, в котором инструкции будут исполнены согласно указанным вариантам исполнения. Каждый тест будет состоять из двух частей: вторая часть --- это те же инструкции и аргументы, что были в шаблоне, а первая часть (т.н. \emph{инициализирующая программа}) это тоже набор инструкций, которые подготавливают модель микропроцессора к выполнению инструкций шаблона в заданных вариантах исполнения инструкций.

\begin{figure}[h]
\quad\parbox{0.5\textwidth}{ \tt
LW x, y, c @ l1Hit } \parbox{0.3\textwidth}{ \tt
XOR y, y, y\\
SW x, y, 0x0\\
LW x, y, 0x0\\}
\caption{Тестовый шаблон (слева) и один из возможных тестов для него (справа)}\label{test_template_exmp1}
\end{figure}

Пример шаблона и соответствующего ему теста приведен на рисунке~\ref{test_template_exmp1}. Инструкция LW --- инструкция загрузки 32х бит из памяти, XOR --- инструкция исключающего ИЛИ, SW --- инструкция сохранения 32х бит в памяти. Идентификатором \texttt{l1Hit} было помечено исполнение инструкции LW без трансляции адреса, но с обращением в кэш-память первого уровня с кэш-попаданием в нем. В тесте, во-первых, выбрано значение константы <<c>> (равно 0) и, во-вторых, перед инструкцией LW вставлена инструкция SW с теми же аргументами, что и у LW для того, чтобы данные по этому адресу точно попали в кэш-память первого уровня и при исполнении инструкции LW в кэш-памяти первого уровня произошло кэш-попадание.

\paragraph{шаг <<формализовать архитектуру>>} предполагает построение модели состояния микропроцессора и подготовку формальных описаний вариантов исполнения инструкций (формализовать <<идентификаторы>>, обозначающие варианты исполнения инструкций). Состояние образуют те блоки микропроцессора, к которым обращаются инструкции тестового шаблона. Это могут быть разные регистры, кэш-память разных уровней, буферы трансляции адресов, вспомогательные буферы. Все они обладают состоянием (поскольку в них хранятся и изменяются данные).

Формализация архитектуры нацелена на детализацию описания поведения инструкции с возможностью автоматического построения теста. Формализация выполняется на основе выделенных на первом шаге описаний вариантов исполнения инструкций. Они хотя и не всегда формальные, но зачастую высоко формализованы. Формализованное описание варианта исполнения инструкции представляет из себя последовательность операторов на специальном языке (ниже этот язык и механизмы, которые он предоставляет, будут описаны подробнее).

Рассмотрим пример того, как получается формальное описание варианта исполнения l1Hit инструкции LW архитектуры MIPS64. Формат этой инструкции следующий:
\begin{verbatim}
LW rt, offset(base)
\end{verbatim}

Описание этой инструкции в документации выглядит следующим образом:
\begin{verbatim}
  vAddr <- sign_extend(offset) + GPR[base]
  if vAddr[1..0] != 0^2 then
        SignalException(AddressError)
  endif
  (pAddr, CCA) <- AddressTranslation(vAddr, DATA, LOAD)
  pAddr <- pAddr[PSIZE-1..3] || (pAddr[2..0] xor (ReverseEndian||0^2))
  memdoubleword <- LoadMemory(CCA, WORD, pAddr, vAddr, DATA)
  byte <- vAddr[2..0] xor (BigEndianCPU || 0^2)
  GPR[rt] <- sign_extend(memdoubleword[31+8*byte..8*byte])
\end{verbatim}

Это описание представляет собой последовательность операторов, которые изменяют значения переменных и внутреннее состояние микропроцессора. В этом описании присутствует оператор присваивания (он обозначен обратной стрелкой) и условный оператор, в then-ветви которого находится оператор исключительной ситуации, прерывающий исполнение этой инструкции.

В документации в отдельной главе (2.2 Operation Section Notation and Functions) содержится описание <<функций>> AddressTranslation и LoadMemory. Первая описывает трансляцию виртуального адреса в физический, вторая описывает обращение в оперативную память с учетом кэш-памяти так, как это делается в микропроцессорах архитектуры MIPS64~\cite{MIPS64_II}. Еще из одного документа следует, что при исполнении этих функций задействованы следующие структуры:
\begin{itemize}
  \item кэш-память данных первого уровня (D-cache);
  \item кэш-память инструкций первого уровня (I-cache);
  \item кэш-память второго уровня, совместная для данных и инструкций (L2-cache);
  \item общий буфер трансляции адресов (TLB);
  \item буфер трансляции адресов данных (DTLB);
  \item буфер трансляции адресов инструкций (ITLB).
\end{itemize}

Тем самым для тестового шаблона будет задействована кэш-память данных первого уровня (так определялся вариант исполнения l1Hit), значит, в модель состояния попадет D-cache. I-cache и L2-cache не входит в выбранный вариант исполнения инструкции, равно как и все TLB.

Для подготовки формального описания l1Hit надо в описании инструкции LW:
\begin{enumerate}
  \item выделить аргументы инструкции и их битовые длины;
  \item определить значения <<констант>> (в данном случае это PSIZE, ReverseEndian, BigEndianCPU, WORD);
  \item выделить в потоке управления этого описания путь, соответствующий нужному варианту исполнения;
  \item формализовать <<функции>> AddressTranslation и LoadMemory с учетом выбранного варианта исполнения инструкции и модели состояния;
  \item выразить выделенный путь в потоке управления в виде последовательности операторов на специальном языке.
\end{enumerate}

Аргументов здесь три: offset, GPR[base] и GPR[rt]. Их битовые длины -- 16, 64 и 64 (первое написано также на странице описания LW, а остальные аргументы суть GPR --- регистры общего назначения, чей битовый размер в MIPS64 равен 64). <<Константы>> PSIZE, ReverseEndian, BigEndianCPU являются частью режима работы микропроцессора в момент тестирования. Тем самым их значения надо искать в этом режиме. Путь в потоке управления должен быть таким, чтобы в него попал LoadMemory (чтобы произошло заявленное кэш-попадание в кэш-память первого уровня). Значит, первый оператор остается прежним, во втором операторе -- это условный оператор -- должна сработать else-ветвь (поскольку в then-ветви исполнение инструкции прерывается), остальные операторы остаются без изменений. Формализация <<функций>> и выражение выделенного пути описана в разделе~\ref{state_model_section}.

%vAddr <- sign_extend(offset) + GPR[base]
%vAddr1..0 == 02
%(pAddr, CCA) <- AddressTranslation (vAddr, DATA, LOAD)
%pAddr <- pAddrPSIZE-1..3 || (pAddr2..0 xor (ReverseEndian || 02))
%memdoubleword <- LoadMemory (CCA, WORD, pAddr, vAddr, DATA)
%byte <- vAddr2..0 xor (BigEndianCPU || 02)
%GPR[rt] <- sign_extend(memdoubleword31+8*byte..8*byte)

\paragraph{шаг <<написать конструктор инициализирующих программ>>} предполагает подготовку соответствующего конструктора. Тестовый шаблон еще не может быть тестом, поскольку в нем не заданы значения аргументов инструкций и не актуализировано начальное состояние микропроцессора (предполагается, что оно должно быть \emph{таким}, чтобы инструкции выполнялись заданным образом). Поэтому после того, как подготовлен тестовый шаблон, модель состояния и формализованы описания вариантов исполнения инструкций, в работу включаются компоненты, осуществляющие построение недостающих данных и актуализацию начального состояния микропроцессора. Например, для шаблона на рисунке~\ref{test_template_exmp1} было выбрано значение переменной <<c>> (оно равно 0) и актуализировано начальное состояние в виде последовательности инструкций \texttt{XOR y, y, y} и \texttt{SW x, y, 0x0}.

В рассматриваемом методе предлагается актуализировать начальное состояние в виде последовательности инструкций (которые образуют \emph{инициализирующую программу}). Поскольку речь идет о тестировании модулей управления памяти, то эти последовательности инструкций должны затрагивать блоки микропроцессора, отвечающие работе с памятью. Специальные последовательности таких обращений должны подготовить эти блоки к требуемым вариантам исполнения в тестовом шаблоне. Для каждого блока будет своя такая последовательность. И еще одна последовательность для инициализации регистров общего назначения. Инициализирующая программа --- это обычная программа на языке ассемблера, но эта программа должна давать специфический эффект -- инициализировать блоки микропроцессора.

Построение инициализирующей программы было разделено на ряд этапов:
\begin{enumerate}
  \item построение \emph{ограничений} (constraint'ов) по шаблону, модели состояния и описаниям инструкций; речь идет о построении ограничений на \emph{данные}; в эти данные входят значения переменных в описаниях инструкций, атрибуты инструкций инициализирующих инструкций (адреса, к которым производятся обращения, вид обращения и т.п.);
  \item разрешение ограничений (вычисление данных);
  \item конструирование инициализирующей программы на основе вычисленных данных; их надо облечь в вид инструкций тестируемой архитектуры --- этот этап и выполняет конструктор инициализирующих программ; например, для каждой будущей инструкции выбрать регистры-аргументы, вычислить на основе переданных атрибутов инструкции значения аргументов, сгенерировать инструкции, обеспечивающие значения аргументов, и саму инструкцию, для которой это всё делалось.
\end{enumerate}

Иными словами, для построения данных (значений переменных, атрибутов инструкций инициализирующей программы) используется аппарат ограничений (Constraint Satisfaction Problem)~\cite{CSP}. Известно, что время разрешения ограничений сильно зависит от самих ограничений~\cite{isaac05balanced}. Одна и та же задача может быть представлена в виде разных наборов ограничений: одни быстрее разрешаются, другие долго. Ограничения для инструкций работы с памятью, видимо, должны учитывать состояния (содержимое!) различных блоков, размеры которых (количество данных) выражается переменными в количестве $10^4-10^5$ штук. Тем самым ограничения надо строить неким особым способом, чтобы справиться с этим количеством зависимых переменных. В разделе~\ref{constraints_generation_section} подробно разбираются предлагаемые в диссертации методы построения ограничений. Важный вопрос --- является ли метод построения ограничений полным, т.е. дает ли метод построения ограничений гарантию того, что если решатель обнаружил несовместность ограничений, то для такого шаблона не существует теста. В разделе~\ref{constraints_generation_section} предлагается полный метод, его полнота доказана в диссертации формально.

Существенно, что в качестве решателей ограничений в описываемом методе достаточно использовать широко используемые решатели (например, Z3~\cite{Z3}). Это выгодно отличает эту работу от аналогичных~\cite{GenesysPro}, где приходится использовать специальные методы не только построения, но и разрешения ограничений, дабы иметь возможность описывать более сложные инструкции.

При написании конструктора достаточно знания того, как загрузить заданные значения в регистры, как обратиться по заданным адресам в память, загрузить в память заданные значения. Это знание получается в результате знакомства с документацией по архитектуре микропроцессора. Кроме того, нужно использовать знание модели состояния, поскольку последовательности данных об инструкциях инициализирующей программы определяются для ограничений (constraint'ов) в терминах этой модели.

\section{Модель состояния и язык описания инструкций}\label{state_model_section}

Модель состояния подсистемы управления памяти (или просто, модель состояния) представляет из себя набор \emph{таблиц}. Таблица представляет собой набор \emph{регионов}. Каждый регион --- это множество \emph{строк}. Все такие множества для одной таблицы имеют одинаковый размер. Строка состоит из поименованного набора \emph{полей}, каждое поле является битовой строкой. На рисунке~\ref{table_picture} схематически показаны регионы таблицы, строки и поля строк.

\begin{figure}[h] \center
  \includegraphics[width=0.8\textwidth]{2.theor/table.eps}\\
  \caption{Таблица}\label{table_picture}
\end{figure}

Например, буфер трансляции адресов (TLB) в микропроцессорах архитектуры MIPS64~\cite{mips64_III} это таблица из одного региона, каждая его строка состоит из полей \texttt{r}, \texttt{vpn/2}, \texttt{g}, \texttt{asid}, \texttt{pfn}$_0$, \texttt{CCA}$_0$, \texttt{v}$_0$, \texttt{pfn}$_1$, \texttt{CCA}$_1$, \texttt{valid}$_1$ и других. В виде таблиц можно представить и кэш-память любого уровня, и даже оперативную память (хотя формально оперативная память не входит в подсистему управления памяти).

Регионы таблицы отражают \emph{ассоциативность} ее блока. Таблица для полностью ассоциативного блока состоит из одного региона. Таблица для блока прямого доступа состоит из множества регионов, но в каждом регионе всего одна строка.

Поля строки таблицы делятся на \emph{поля ключа} и на \emph{поля данных}. Тем самым отражается смысл строки --- соответствие ключа и данных. Регион не может хранить в разных строках одинаковые ключи.

Таблицы обладают состоянием. Оно состоит из значений, которые хранятся в полях строк. Инструкции микропроцессора осуществляют доступ к таблицам: они используют значения, хранящиеся в таблицах, и изменяют состояния таблиц. Доступ к таблице осуществляется в виде поиска данных, хранящихся по заданному ключу. Поиск может быть успешным, если этот ключ присутствует в какой-либо строке таблицы (при этом будет говориться, что происходит \emph{попадание}), или неуспешным, если этот ключ не присутствует ни в одной из строк таблицы (при этом будет говориться, что происходит \emph{промах}). При промахе инструкция может изменить состояние таблицы, поместив туда (откуда-то взятые) данные по искомому ключу. Чтобы сохранить при этом размер таблицы, какая-то из строк должна быть удалена, <<вытеснена>>. Правило определения такой строки называют \emph{стратегией вытеснения} (replace policy). Примеры стратегий вытеснения: LRU, FIFO, Pseudo-LRU. Если вытеснение не должно выполняться микропроцессором (например, если речь идет о страницах виртуальной памяти, вытеснение которых может быть довольно сложным, хотя бы с учетом своппинга), то стратегия вытеснения не имеет значения.

Описание таблицы включает в себя следующие характеристики:
\begin{itemize}
    \item поля строк (для каждого поля указывается название, битовая длина, поле ли это ключа или поле данных);
    \item количество регионов;
    \item стратегия вытеснения;
    \item количество строк в регионе (ассоциативность);
    \item предикат соответствия ключа обращения и строки, ключом обращения являются те данные инструкции, по которым производится поиск строки в таблице (например, пара \texttt{(r, vpn/2)} является ключом обращения в TLB микропроцессоров MIPS64).
\end{itemize}

Описание уже упомянутого буфера трансляции адресов микропроцессоров архитектуры MIPS64 может выглядеть следующим образом:
\begin{verbatim}
table TLB
{
    line(   r:2,key; vpnd2:28,key; g:1,key; asid:4,key;
            pfn0:24,data; cca0:3,data; valid0:1,data;
            pfn1:24,data; cca1:3,data; valid1:1,data )
    regions = 1
    policy = none
    lines = 48
    keyMatch(r, vpnd2) { .... }
}
\end{verbatim}

Предикат соответствия ключа обращения строке будет приведен чуть позже, когда будет описан для этого язык.

Теперь переходим к языку описания вариантов исполнения инструкций (или просто, языку описания инструкций). Напомним, что вариант исполнения задавался в виде последовательности действий. Описание инструкции будет также повторять эту последовательность, внося лишь ряд уточнений. Описание сделано максимально приближенным к тому, как инструкция описана в документации, в привычных тестировщикам документах. В документации вариант исполнения инструкции описывается в виде последовательности преобразований над битовыми строками. Предлагаемое в диссертации описание следует этому же принципу и для описания работы с подсистемой управления памяти добавляются всего 2 новых оператора.

Описание инструкции состоит из двух частей: объявления аргументов инструкции и собственно последовательности действий-операторов. Объявление аргумента состоит из имени внутри данного описания, битовой длины, флаг запрета изменения значения аргумента (read-only). Флаг вводится для того, чтобы иметь возможность использовать в качестве разных аргументов одной инструкции одинаковые регистры (если они оба не являются read-only, то это должны быть разные регистры). Аргументы следует воспринимать как битовые строки (bit-vector). По ходу инструкции кроме аргументов будут появляются и другие переменные, но они тоже будут битовыми строками.

\emph{Единственным <<типом>> переменных при описании инструкции являются битовые строки.}

Над переменными определены следующие виды выражений-операций:
\begin{itemize}
    \item битовые операции (битовая конкатенация, битовая степень, выделение бита с заданным индексом, выделение диапазона бит в заданных границах, знаковое расширение битового размера);
    \item арифметические операции (суммирование, вычитание, умножение);
    \item отношения сравнения (равенство/неравенство, сравнение на больше-меньше);
    \item логические связки над отношениями сравнения и другими логическими связками (конъюнкция, дизъюнкция).
\end{itemize}

Операторы бывают следующих трех видов:
\begin{itemize}
    \item \emph{оператор объявления нового имени}: в явной форме --- по сути оператор присваивания: \texttt{var <- expr}; в неявной форме описывается лишь предикат над значением: \texttt{let var:LEN\{boolexpr\}};
    \item \emph{оператор допущения} (assume), утверждает истинность некоторого логического выражения: \texttt{assume: boolexpr};
    \item \emph{операторы обращений в таблицы} (\texttt{hit} и \texttt{miss}):
        \begin{itemize}
            \item \emph{попадание} \texttt{hit<table>(key, region)\{[loaded(datafields)]}\\\texttt{[storing(datafields)]\}} фиксирует, что обращении в \texttt{table} с ключом \texttt{key} в регион \texttt{region} должно быть успешным, при этом ещё можно специфицировать поля данных найденной строки (\texttt{datafields} --- список выражений для каждого поля данных в строке таблицы \texttt{table}), кроме того можно специфировать изменение полей данных в найденной строке (\texttt{storefields} --- список выражений для каждого поля данных в строке таблицы \texttt{table}); \texttt{loaded} и \texttt{storing} не являются обязательными;
            \item \emph{промах} \texttt{miss<table>(key, region)\{[replacing(datafields)]\}}\\фиксирует, что обращении в \texttt{table} с ключом \texttt{key} в регион \texttt{region} должно быть неуспешным, блок \texttt{replacing} задает поля данных вытесняющей строки (\texttt{datafields} --- список выражений для каждого поля данных в строке таблицы \texttt{table}); если \texttt{replacing} не задано, то при этом промахе не должно происходить вытеснение.
        \end{itemize}
\end{itemize}


Рассмотрим уже знакомый пример для архитектуры MIPS64:

\texttt{LW x, y, c @ l1Hit}

Потребуется кэш-память первого уровня и данные памяти, поэтому надо составить их модели (для <<стратегии вытеснения>> \texttt{none} предикат \texttt{keyMatch} писать не надо):
\begin{verbatim}
    table l1 {
        line(tag:24,key);
        regions = 128;
        policy = LRU;
        lines = 4;
        keyMatch(key:24) { key = tag };
    }
    table memory {
        line(phys:33,key; memdw:64,data);
        regions = 1;
        policy = none;
        lines = 8589934592;
    }
\end{verbatim}

Для \texttt{l1Hit} оставалось оформить выбранный путь в описании инструкции \texttt{LW} и формализовать <<функции>> \texttt{AddressTranslation} и \texttt{LoadMemory} (с учетом \texttt{l1Hit}!). Объявления аргументов:
\begin{verbatim}
    base : 64, readonly;
    offset : 16, readonly;
    rt : 64, result;
\end{verbatim}

Начало описания пути \texttt{l1Hit} практически дословно повторяет документацию:
\begin{verbatim}
    vAddr <- (64)offset + base;
    assume: vAddr[1..0] = 0^2;
\end{verbatim}

Затем идет <<вызов>> \texttt{AddressTranslation}. В данном варианте исполнения \texttt{LW} трансляция виртуального адреса в физический должна выполняться без обращения к TLB. Это означает, что надо специфицировать условия, при которых трансляция адреса выполняется таким образом, и результат этой трансляции. Условия и результат трансляции описаны в документации. А именно, такая трансляция проводится при специальных виртуальных адресах (например, на таких, где \texttt{vAddr[58] = 0}, \texttt{vAddr[57] = 0}, ..., \texttt{vAddr[36] = 0}). В качестве результата формируется значение новых переменных --- физического адреса \texttt{pAddr} и политики кэширования \texttt{cca}:
\begin{verbatim}
    assume: vAddr[58..36] = 0^23;
    pAddr <- vAddr[35..0];
    cca <- vAddr[63..61];
\end{verbatim}

От политики кэширования будет зависеть работа кэш-памяти и это действительно разные способы работы -- сквозная запись и отложенная запись, где-то производится запись в кэш-память и в оперативную память, где-то только в оперативную память. Но при \texttt{l1Hit} инструкции LW запись не производится и поэтому достаточно, чтобы кэш-память просто была задействована. Согласно документации это означает, что \texttt{cca} не должно равняться 2. Тем самым появляется еще одно уточнение \texttt{AddressTranslation}:
\begin{verbatim}
    assume: cca != 2;
\end{verbatim}

Далее идет изменение физического адреса с учетом \texttt{ReverseEndian}. Напомнию, что эта <<константа>> соответствует режиму, в котором происходит тестирование. Т.е. в момент генерации теста значение \texttt{ReverseEndian} известно, его не нужно искать с помощью ограничений. Если тест будет исполняться в режиме с \texttt{ReverseEndian = 0}, то преобразование выполнять не надо, т.к. \texttt{pAddr <- pАddr[PSIZE-1..3]||(pAddr[2..0] xor (0||0\^2))} эквивалентно \texttt{pAddr <- pАddr[PSIZE-1..0])}, а \texttt{PSIZE = 36} (из документации), т.е. \texttt{pАddr[PSIZE-1..0]} получается то же, что и \texttt{pАddr}. Рассмотрим более сложный случай: \texttt{ReverseEndian = 1} :
\begin{verbatim}
    pAddr2 <- pAddr[35..3] || (pAddr[2]+1) || pAddr[1..0];
\end{verbatim}

Далее идет <<вызов>> \texttt{LoadMemory}. В \texttt{l1Hit} это должно быть лишь обращение в кэш-память первого уровня с попаданием и обращение в память за данными. Надо понять, что является ключами и регионами этих обращений. Читаем документацию по тому, как проводится обращение в кэш-память:
\begin{verbatim}
    tag <- pAddr2[35..12];
    region <- pAddr2[11..5];
    phys <- pAddr2[35..3];
    hit<l1>(tag, region);
    hit<memory>(phys){loaded(memdw)};
\end{verbatim}

Тем самым записано, что при обращении в \texttt{l1} должно быть кэш-попадание и из памяти считывается 64 бита в переменную \texttt{memdw}. Далее из этих 64 бит надо выбрать 32 (поскольку инструкция \texttt{LW} --- load word) --- старшую половину или младшую на основе \texttt{vAddr[2..0]} (см. описание \texttt{LW}):
\begin{verbatim}
    byte <- vAddr[2..0];
    assume: byte = 0 and rt = memdw[31..0]
         or byte = 4 and rt = memdw[63..32];
\end{verbatim}

Описание инструкции \texttt{LW} для \texttt{l1Hit} готово. Целиком оно выглядит следующим образом (справа):

\noindent\parbox{0.4\textwidth}{ \footnotesize \tt
vAddr <- sign\_extend(offset) + GPR[base];\\
assume: vAddr[1..0] = 0\^{}2;\\
(pAddr, CCA) <- AddressTranslation( vAddr, DATA, LOAD );\\
pAddr <- pAddr[PSIZE-1..3] || (pAddr[2..0] xor (ReverseEndian || 0\^{}2 ));\\
memdoubleword <- LoadMemory(CCA, WORD, pAddr, vAddr, DATA);\\
byte <- vAddr[2..0] xor (BigEndianCPU || 0\^{}2);\\
GPR[rt] <- sign\_extend( memdoubleword[ 31+8*byte .. 8*byte ] );\\
} \parbox{0.1\textwidth}{ \quad
} \parbox{0.5\textwidth}{ \footnotesize \tt
base : 64, readonly;\\
offset : 16, readonly;\\
rt : 64, result;\\
\\
vAddr <- (64)offset + base;\\
assume: vAddr[1..0] = 0\^{}2;\\
assume: vAddr[58..36] = 0\^{}23;\\
pAddr <- vAddr[35..0];\\
cca <- vAddr[63..61];\\
assume: cca != 2;\\
pAddr2 <- pAddr[35..3] ||\\
\indent\hspace{1cm}(pAddr[2]+1) || pAddr[1..0];\\
tag <- pAddr2[35..12];\\
region <- pAddr2[11..5];\\
phys <- pAddr2[35..3];\\
hit<l1>(tag, region);\\
hit<memory>(phys)\{loaded(memdw)\};\\
byte <- vAddr[2..0];\\
assume: byte = 0 and rt = memdw[31..0]\\
\indent\hspace{1cm}or byte = 4 and rt = memdw[63..32];\\}

В качестве другого примера приведем keyMatch для TLB микропроцессоров MIPS64: (\texttt{asid} является <<константой>> режима тестирования, для примера допустим, что она равна 10)
\begin{verbatim}
table TLB
{
    line(   r:2,key; vpnd2:28,key; g:1,key; asid:4,key;
            pfn0:24,data; cca0:3,data; valid0:1,data;
            pfn1:24,data; cca1:3,data; valid1:1,data )
    regions = 1
    policy = none
    lines = 48
    keyMatch(r1, vpnd) { r1 = r and vpnd = vpnd2 and
        (g = 1 or asid = 10)}
}
\end{verbatim}

Границы применимости предлагаемых методов описания приведу на следующих примерах.

можно:

Проходит или не проходит трансляция

Успешно ли проходит обращение

с какими свойствами проходит (можно описать доп.ограничение на строки таблиц)

VIVT

сквозная, отложеная запись

кэши Pentium, Alpha, PowerPC

кэши разных уровней

нельзя:

псевдослучайные действия

временнЫе ограничения

циклические действия

кэш инструкций ?


\section{Метод построения ограничений}\label{constraints_generation_section}
 Включает в себя метод построения ограничений для последовательности обращений в таблицу и методы записи стратегии вытеснения в виде ограничений

%%%\include{0.intro/intro}
%%%
%%%\include{1.review/review}
%%%
%%%\include{2.theor/theor}
%%%
%%%\include{3.impl/impl}
%%%
%%%\include{4.analysis/analysis}

%! добавить еще результаты экспериментов! :)

\include{epilogue}


\pagebreak
\appendix
\include{appendix/tables}
\include{appendix/proofs}

\pagebreak
%%%%\bibliographystyle{plain}
%%%%\bibliographystyle{gost71u}
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{thesis}

%% привести оформление в соответствие с требованием: что-то всё время пропадает!

%%! добавить \cite{Pex}, \cite{symbolic_execution}

%%! вписать название препринта и номер тома

\end{document}
