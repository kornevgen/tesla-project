% !Mode:: "TeX:UTF-8"
\newcommand{\ccite}[1]{%
\ifthenelse{\isundefined{\nocites}}{\cite{#1}}{}%
}

\newcommand{\Actuality}{%
Современные микропроцессоры --- сложные многокомпонентные системы. Размеры современных микропроцессоров оцениваются как $10^7-10^8$ вентилей\ccite{HennesyPatterson}. Естественно при разработке таких сложных систем в проекты микропроцессоров вносятся ошибки, порой довольно критичные\ccite{IntelValidation}. Поэтому для обнаружения этих ошибок в цикл разработки микропроцессора в обязательном порядке входят этапы функциональной верификации.

Чем позднее будут обнаружены ошибки в микропроцессорах, тем дороже обойдётся исправление ошибок: сделать это в готовой микросхеме, тем более выпущенной на рынок, практически невозможно. Тем актуальнее становятся методы обнаружения ошибок на ранних этапах разработки микропроцессоров. Цикл разработки предполагает подготовку микропроцессоров в виде исполнимых программных моделей на языках Verilog или VHDL\ccite{VHDL}. Это делает возможным проведение функциональной верификации на таких моделях (т.е. до производства самих микропроцессоров) и актуальным исследование методов такой верификации. Целью функциональной верификации программных моделей микропроцессоров является обнаружение ошибок реализации функциональности в программных моделях микропроцессоров.

Выделяют следующие виды функциональной верификации: экспертизу, имитационное тестирование и формальную верификацию\ccite{KamkinPopular}. Экспертиза предполагает анализ текстов моделей экспертами с целью оценки их корректности и обнаружения ошибок. Этот вид функциональной верификации эффективно применяется на ранних стадиях разработки. Однако ввиду наличия человеческого фактора после экспертизы ошибки в микропроцессоре всё же остаются. Методы формальной верификации позволяют дать исчерпывающий ответ на вопрос о корректности отдельных модулей и всего микропроцессора. Однако трудоемкость формальной верификации чрезвычайно велика. Например, при разработке Intel Pentium 4 были формально верифицированы модуль работы с плавающей точкой (FPU), модуль декодирования инструкции и логика внеочередного выполнения (out-of-order), было найдено порядка 20 новых ошибок, однако трудоемкость этого проекта составила порядка 60 человеко-лет\ccite{IntelValidation}.

Имитационное тестирование позволяет ценой меньших усилий обнаружить значительную часть ошибок, в том числе критичных ошибок. Имитационное тестирование проводят для отдельных модулей (тогда оно называется \emph{модульным тестированием}) и для всего микропроцессора в целом (тогда оно называется \emph{системным тестированием})\ccite{EDAbook}. Модули тестируются подачей на их входы специальных сигналов (\emph{модульных тестов}) со снятием выходных сигналов и последующим анализом выходных сигналов. Входом при системном тестировании являются программы на машинном языке (\emph{тестовые программы}). Проведение модульного тестирования требует кроме подготовки самих входных данных еще и подготовку тестирующей установки (testbench), выделение тестируемого модуля из всего проекта микропроцессора и т.п. Системное тестирование избавлено от этой необходимости. Поскольку размер и сложность отдельного модуля всегда меньше размера и сложности микропроцессора в целом, потенциально качество модульного тестирования может быть выше, чем системного. Однако для достижения высокого качества тестирования как число модульных тестов, так и совокупная трудоемкость их изготовления, получаются очень большими. Это вынуждает часть проверок проводить на модульном уровне, а другую часть на системном. Невысокая стоимость подготовки и проведения системного тестирования определила его наибольшую востребованность среди других методов функциональной верификации. Практически все разработчики микропроцессоров проводят системное тестирование.

Ключевым вопросом, определяющим качество тестирования, является вопрос выбора тестовых программ. Поскольку современные микропроцессоры обладают множеством инструкций (порядка сотен), длины конвейеров имеют порядок десятка стадий, количество различных состояний и ситуаций, в которых надо протестировать микропроцессор, измеряется десятками тысяч. Поэтому для тщательного системного тестирования нужно подобное же и количество тестовых программ. Это определяет актуальность задачи автоматического построения тестовых программ для системного тестирования.

Сложность микропроцессоров растет (увеличивается количество функциональных требований, количество ситуаций, в которых поведение микропроцессора должно обладать заданной спецификой). Это требует тестовых программ для проверки функциональных требований, которые не проверяются имеющимися тестовыми программами, и делает актуальными дальнейшие исследования в области построения тестов.

%%%%! подредактировать про "новое качество" - это непонятно.

К числу наиболее сложных механизмов современных процессоров (поэтому наиболее подверженных ошибкам), использующих конвейеры и многоуровневые буферы типа кэш-памяти, относится механизм доступа к памяти. Поэтому актуальной является задача построения тестовых программ для проверки подсистем управления (механизмами) памяти микропроцессоров.

%%%% тем более, что зачастую нет способов прямого создания ситуаций?

%%% нацеленные методы (итерация-фильтрация, прямые конструкторы, random expansion, csp) - систематичные
%%% ненацеленные методы не тестируют тщательно или не находят ошибки, если микропроцессор не сырой

%%% в обзоре про MMU добавить классификацию ситуаций, которые надо тестировать

%%% цели:
%%% 1) понять, какие тесты "хорошие" (определение)
%%% 2) проанализировать методы их получения
%%% 3) предложить улучшения с целью получения более качественных тестов

%%% NB: ситуации не обязательно задавать шаблонами

%%% в приложение поместить примеры описаний MIPS'овских инструкций в xml ?


%А) микропроцессоры сложные -> в них есть ошибки
%Современные микропроцессоры --- это сложные системы, поэтому вероятность появления ошибки как при проектировании микропроцессора, так и при его производстве становится всё выше. При этом <<цена ошибки>> в готовом микропроцессоре велика (как минимум, это означает перевыпуск микропроцессора заново). Поэтому актуально развитие методов верификации микропроцессоров.

%%В) основная доля ошибок на этапе разработки моделей (design'а)
%Современные технологии проектирования микропроцессоров представляют собой средства разработки \emph{модели (design) на специальных языках} типа VHDL или Verilog~\cite{VerilogDesign}. Эти технологии позволяют в конечном итоге построить так называемые <<синтезируемые модели>>, из которых автоматически получаются фотошаблоны, необходимые для производства. Основная доля ошибок появляется именно на этапе разработки моделей (design), поэтому основные усилия по их выявлению или даже предотвращению их появления, также приходятся на фазу разработки моделей. Поэтому данная работа также нацелена на выявление ошибок в моделях микропроцессоров.

%%Г) модульное и системное тестирование ->
%% интересные ситуации нельзя создать инструкциями
%Тестирование на модели бывает \emph{модульным} (unit-level verification) и \emph{системным} (core-level verification, full-chip level verification)~\cite{UnitCoreLevel}. Модульное тестирование модели микропроцессора предполагает генерацию тестовых воздействий на входы отдельных модулей, блоков, микропроцессора, описанных на одном из языков типа VHDL, Verilog, и проверку выходов таких блоков. В рамках системного тестирования проверяется работа всего микропроцессора в целом --- тестом здесь является некоторая тестовая программа (программа на машинном языке), которая загружается в память и выполняется микропроцессором (речь все время идет о некоторой программной модели микропроцессора). Поскольку размер и сложность отдельного блока всегда меньше, размера и сложности микропроцессора в целом, потенциально качество модульного тестирования может быть выше, чем системного. Однако для достижения высокого качества тестирования как число модульных тестов, так и совокупная трудоемкость их изготовления, являются очень большими. Это вынуждает часть проверок проводить на модульном уровне, а другую часть на системном.

%Сложность микропроцессора определяет количество системных тестов. Если выделить различные аспекты функционирования микропроцессора (конвейер, буферы подсистемы управления памяти), то особое функционирование возникает при различных комбинациях этих аспектов. Это означает, что количество тестов должно быть не меньше произведения количества разных аспектов. Количество инструкций измеряется сотнями, а цепочек инструкций, соответственно, порядками сотен, плюс если учесть возможные аспекты в конвейере, в кэш-памяти, количество тестов получается очень большим. Для избежания проблемы такого <<взрывного>> характера количества тестов, их объединяют в классы эквивалентности --- \emph{тестовые ситуации}.

%При этом есть проблема покрытия всех потенциально интересных тестовых ситуаций. Нет никаких прямых способов создать многие из таких ситуаций нет. Например, интересно, как происходит доступ в память, когда соответствующий адрес имеется в кэш-памяти или не имеется. Или еще более тонкий анализ --- адрес имеется/или не имеется в кэш-памяти второго уровня. Среди инструкций процессора нет таких, которые были бы предназначены специально для создания таких ситуаций. Эти ситуации создаются \emph{динамически} в ходе выполнения программ.


%%Д) схема системного тестирования, показать здесь смежные вопросы
%% (вопросы построения оракула, покрытия и др.)
%Рассмотрим традиционную схему системного тестирования, известные подходы к автоматизации построения тестов и выявим проблемы, которые мешают строить более эффективные тесты.

%Микропроцессор рассматривается как черный (или серый) ящик. Входными тестовыми данными является некоторая программа, которая загружается в память. Результатом прогона теста является либо финальное состояние памяти (возможно, включая состояние регистров) или (в случае <<серого ящика>>) трасса изменения значений ячеек памяти или регистров.
%В этой общей схеме тестирования пока не упомянуты:
%\begin{itemize}
%	\item	генератор тестов (или набор уже готовых тестов);
%	\item	подсистема проверки корректности полученного результата --- тестового оракула, или арбитра;
%	\item	перечень <<интересных>> ситуаций, которые надо воспроизвести в ходе выполнения тестов;
%	\item	некая система мониторинга, которая фиксирует прохождение <<интересных>> ситуаций --- оценивает полноту покрытия.
%\end{itemize}
%
%Тестовый оракул, или арбитр, строится по схеме с использованием <<эталонной>> модели (simulation-based verification)~\cite{SimulationBased}. Каждая тестовая программа выполняется на двух моделях --- на тестируемой (design) и на <<эталонной>>. Потом состояния памяти или трассы изменения состояния памяти для тестируемой и эталонной моделей сравниваются. Если оракул признает, что трассы не эквивалентны, это свидетельствует о наличии ошибки в тестируемой системе (или эталонной, но это происходит реже). Как правило, эталонная модель пишется на одном из языков программирования (например, Си или Си++) и не загромождается деталями.  На этом основании считается, что такая модель существенно проще тестируемой, в ней с меньшей вероятностью встречаются ошибки, именно поэтому к ней можно относиться как к <<эталонной>>.
%
%% критика этого подхода: он не позволяет проверить модули, работающие за счет внешних воздействий - For example, fast interrupt request (FIQ), interrupt request (IRQ), data abort exception (Dabort) and prefetch abort exception (Pabort) of ARM7. Это пишут в статье "Automatic Verification of External Interrupt Behaviors for Microprocessor Design", авторы Fu-Ching Yang, Wen-Kai Huang, Ing-Jer Huang.
%
%
%Методы автоматической генерации тестов делят на псевдослучайные/комбинаторные (pseudo-random) и целенаправленные (что не отменяет возможности использования уже готовых тестов)~\cite{HoPhD}. В случае псевдослучайной генерации инструкции, их порядок и аргументы выбираются случайным образом или перебираются некоторым комбинаторным способом. Целенаправленная генерация начинается с задания некоторого шаблона тестовой программы, который определяет набор инструкций, их последовательность и аргументы. В рамках целенаправленной генерации порядок инструкций и их аргументы должны быть подобраны таким образом, чтобы каждый новый тест покрывал новые, еще не покрытые тестовые ситуации. Целенаправленную генерацию можно реализовать как выполнение массовой генерации комбинаторных тестов с последующей фильтрацией, с тем чтобы оставлять только те тесты, которые дают дополнительное покрытие. Однако уже для достаточно коротких шаблонов (длиной 3-4 инструкции) перебор становится слишком большим.
%
%Целенаправленная генерация тестов дает по тесту на каждую ситуацию. Набор тестов, которые покрывают все ситуации, называют нацеленными тестами (нацеленными на эти ситуации). Набор ситуаций конечен, следовательно и набор нацеленных тестов конечен. Вопрос
%%(это и есть основная тема исследования)
%, как систематическим образом строить тестовые программы, чтобы в совокупности они воспроизвели все заданные <<интересные>> ситуации.
%
%
%Перечень (конечный) <<интересных>> ситуаций и мониторинг. В совокупности две эти возможности задают метрику и механизм оценки полноты тестирования. Мониторинг организовать относительно легко, поскольку мы работаем не с реальным процессором, а с его моделями. Как построить перечень «интересных» ситуаций» --- вопрос открытый --- это одно из направлений моей работы.
%
%%Е) нацеленное/ненацеленное тестирование
}

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\Objective}{%
%Ж) формулирование цели работы - исследование методов построения нацеленных тестов-программ (на память)
%Целью исследования является разработка методов целенаправленной генерации системных тестов, которые, в свою очередь, должны предлагать и адекватные методы задания метрики и оценки полноты покрытия в соответствии с предложенными метриками.

Целью диссертационной работы является исследование и разработка методов и программных средств построения тестовых программ для проверки подсистем управления памяти микропроцессоров.

%%% надо тут, видимо, более точно изложить цель - что целью является улучшение некоторых ппараметров!

Для достижения этой цели были поставлены следующие задачи:
\begin{enumerate}
	\item исследовать описанные в научной литературе методы построения тестовых программ на предмет их применимости для системного тестирования подсистем управления памяти микропроцессоров;
	\item разработать методы построения тестовых программ для системного функционального тестирования подсистем управления памяти.
\end{enumerate}
}

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\Novelty}{%

Научной новизной обладают следующие результаты работы:
\begin{enumerate}
    \item предложен подход к построению тестовых программ для проверки подсистем управления памяти микропроцессоров, сочетающий формализацию документации и технику ограничений;

    \item предложен метод моделирования устройств подсистемы управления памяти, использующий конечные автоматы специального вида;

    \item предложена формальная модель инструкций, описывающая отдельные пути их выполнения в виде утверждений о свойствах параметров инструкций и модельном состоянии устройств;

    \item в рамках предложенного подхода разработан метод формализации механизма вытеснения данных при помощи построения ограничений, эффективно разрешаемых современным инструментарием.
\end{enumerate}

}

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\PracticalValue}{%

Разработанные модели и методы могут быть использованы коллективами, занимающимися разработкой микропроцессоров, для автоматизации построения тестовых программ. Разработанный прототип системы построения тестовых программ использовался для генерации тестов подсистем управления памяти ряда микропроцессоров архитектуры MIPS64. Результаты работы могут быть использованы в исследованиях, которые ведутся в Институте системного программирования РАН, Московском государственном институте электроники и математики, НИИ системных исследований РАН, Институте точной механики и вычислительной техники им. С.А. Лебедева РАН, Институте проблем информатики РАН и других
научных и промышленных организациях.

}

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Pub}{

По материалам диссертации опубликовано одиннадцать работ~\cite{my_syrcose_2008, my_isp_2008, my_lomonosov_2009, my_lomonosov_2010, my_miet_2009, my_nivc_2009, my_syrcose_2009, my_isp_2009, my_ewdts_2009, my_programmirovanie_2010, my_isp_2010}, в том числе одна~\cite{my_programmirovanie_2010} в издании, входящем в перечень ведущих рецензируемых научных журналов и изданий ВАК. Основные положения докладывались на следующих конференциях и семинарах:
\begin{enumerate}
  \item на втором и третьем весеннем коллоквиуме молодых исследователей в области программной инженерии (SYRCoSE) (2008 и 2009 гг.);
  \item на шестнадцатой и семнадцатой международной конференции студентов, аспирантов и молодых ученых <<Ломоносов>> (2009 и 2010 гг.);
  \item на шестнадцатой всероссийской межвузовской научно-технической конференции студентов и аспирантов <<Микроэлектроника и информатика - 2009>> (2009 г.);
  \item на седьмом международном симпозиуме по проектированию и тестированию под эгидой IEEE (EWDTS) (2009 г.);
  \item на российско-ирландской летней школе по научным вычислениям (2009 г.);
  \item на научной конференции <<Тихоновские чтения>> (2009 г.);
  \item на научной конференции <<Ломоносовские чтения>> (2010 г.);
  \item на объединенном научно-исследовательском семинаре имени М.Р. Шура-Бура (2010 г.);
  \item на семинаре Лаборатории вычислительных комплексов факультета вычислительной математики и кибернетики МГУ имени М.В.Ломоносова (2010 г.);
  \item на семинаре отдела Технологий программирования института системного программирования РАН (2009, 2010 гг.).
\end{enumerate}

}

%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\Structure}{%Структура и объем диссертации

Работа состоит из введения, трех глав, заключения, списка литературы и приложений.
Общий объем основной части диссертации составляет 125 страниц.
Список литературы содержит 71 наименование.
}

\newcommand{\Results}{%
\begin{enumerate}
  \item	Предложен подход к построению тестовых программ для проверки подсистем управления памяти микропроцессоров, позволяющий понизить сложность построения некоторых классов тестовых программ. В таких тестовых программах имеется цепочка длиной от 6 до 12 инструкций обращения к памяти. Понижение сложности обосновано при помощи ряда экспериментов на прототипе программного средства построения тестовых программ. Теоретически обоснована корректность алгоритмов в рамках подхода к построения тестовых программ.

%  \item Предложен метод моделирования устройств подсистемы управления памяти, использующий расширенные конечные автоматы с заданным набором операций. Моделью состояния является последовательность ассоциативных массивов, операциями --- операции обращений в устройство при наличии искомого ключа в ассоциативных массивах и при его отсутствии.
%
%  \item Предложена модель инструкций для описания отдельных путей выполнения инструкций в виде набора утверждений о свойствах операндов инструкций и содержимого устройств и изменения содержимого устройств.
%
  \item В рамках предложенного подхода разработан метод моделирования механизма вытеснения данных, позволяющий в отличие от других методов моделирования выразить ряд свойств вытесняемых данных в виде ограничений, эффективно разрешаемых современным инструментарием. Теоретически обоснована корректность метода для ряда стратегий вытеснения.

%  \item На основе предложенных моделей и методов создан прототип системы построения тестовых программ для проверки подсистем управления памяти микропроцессоров архитектуры MIPS64 и проведены эксперименты для оценки эффективности разработанного прототипа.
\end{enumerate}
}
