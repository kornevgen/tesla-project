\section{Обзор работ по системному функциональному тестированию
микропроцессоров}

\begin{figure*}[t]
\center
\includegraphics[width=0.8\textwidth]{test.eps}
\caption{Генерация тестовых программ на основе тестовых
шаблонов}\label{pic_commonprocess}
\end{figure*}

В настоящее время в практике системного функционального тестирования
микропроцессоров можно выделить следующие подходы к построению
тестовых программ:
\begin{itemize}
\item \emph{ручная разработка тестовых программ} хоть и практически неприменима
для полного тестирования микропроцессора, всё же может применяться
для тестирования особых, крайних случаев;
\item \emph{тестирование с использованием кросс-компиляции} применяется часто
из-за невысокой сложности его проведения: после согласования
спецификации микропроцессора можно начинать делать кросс-компилятор,
а код, предназначенный для кросс-компиляции, уже готов. Однако
гарантировать полноту такое тестирование не может;
\item \emph{случайная генерация тестовых программ} применяется так же часто в
силу простоты автоматизации. Сгенерированные таким образом тестовые
программы позволяют быстро обнаружить простые ошибки, однако не
гарантируют полноты тестирования. Разрабатываются и более сложные
варианты случайной генерации~[4];
\item \emph{случайная генерация тестовых программ на основе тестовых
шаблонов} предполагает разделение процесса генерации тестовой
программы на два этапа (см. рис.~\ref{pic_commonprocess}): на первом
подготавливаются тестовые шаблоны -- абстрактные представления
тестовых программ (в тестовых шаблонах для параметров инструкций
вместо значений указываются ограничения на значения) -- а на втором
этапе по тестовым шаблонам генерируются тестовые программы. Второй
этап включает в себя \emph{генерацию тестовых данных}, т.е.
генерацию параметров инструкций (параметров-констант) и начальных
значений регистров, ячеек кэш-памяти, строк TLB и т.д. Иногда выбор
регистров для инструкций задается в тестовом шаблоне, а иногда выбор
регистров может сделать генератор тестовых данных.
\end{itemize}

Тестовые шаблоны описывают последовательность инструкций, параметры
инструкций с указанием происходящих событий (например, переполнение,
промахи или попадания в кэш-памяти). В качестве параметров
инструкции могут быть как явно указаны регистры и константы, так и
предоставлена возможность инструменту самому подобрать регистры.
Последовательность инструкций чаще всего задана явно. Необходимость
в тестовом шаблоне обычно возникает тогда, когда тестирование
проводится нацеленным образом и эта цель выражена
последовательностью инструкций, каждая из которых должна быть
исполнена заданным образом. Пример тестового шаблона для модельной системы команд:

{ \normalsize
\begin{verbatim}
REGISTER reg1:32;
REGISTER reg2:32;
REGISTER reg3:32;
ADD reg1, reg1, reg2 @ overflow
LOAD reg3, reg2, 0 @ hit
MUL reg1, reg2, reg3 @ normal
\end{verbatim}
}

\noindent В этом тестовом шаблоне 3 инструкции -- ADD, LOAD и MUL. У
каждой инструкции указаны параметры -- или 3 регистра, или 2
регистра и константа -- и информация о том, как должна быть
исполнена инструкция: с переполнением (overflow), с кэш-попаданием
(hit) или без исключений (normal). Чтобы получить тестовую
программу по этому шаблону, достаточно задать начальные значения
регистров reg1, reg2 и reg3 и той части кэш-памяти, с которой работает
вторая инструкция (LOAD) (это и будут тестовые данные для данного
шаблона). Это можно сделать, добавив в начало тестового шаблона
инструкции инициализации состояния микропроцессора. Полученную
тестовую программу можно исполнить и проверить, совпадает ли
поведение каждой инструкции с тем, что было заявлено в тестовом
шаблоне.

В данной статье нас будут интересовать лишь инструкции работы с памятью, коих
две:
\begin{itemize}
\item <<LOAD reg, address>> осуществляет загрузку значения в
переменную reg из памяти по адресу в переменной address;
\item <<STORE reg, address>> осуществляет сохранение значения
из переменной reg в памяти по адресу в переменной address.
\end{itemize}

Обратимся к задаче генерации тестовых данных. Среди известных работ
можно выделить следующие методы ее решения:
\begin{itemize}
\item комбинаторные техники;
\item решение задачи ATPG;
\item разрешение ограничений.
\end{itemize}

\emph{Комбинаторные техники} применимы в случае простых тестовых
шаблонов. Такие тестовые шаблоны включают лишь простые ограничения,
а именно указание области значений переменной. Причем все значения
этой области в тестовой программе равноправны. Техника хоть и
простая, но довольно ограниченная в применении, поскольку не всегда
получается привести ограничения на переменные к такому простому
виду. В работе исследователей из Fujitsu Lab.~[5] предлагается
описать тестовые программы в виде выражений (Test Specification
Expressions, TSE), а инструкции микропроцессора -- на языке ISDL.
Специальный генератор строит тестовые программы, удовлетворяющие
TSE. Kohno и Matsumoto~[6] рассматривают задачу верификации
конвейерных микропроцессоров, используя для этого генерацию тестовых
программ с помощью тестовых шаблонов. Области значений переменных в
таких шаблонах складываются из регистров и числовых констант.

Исследователи из Politecnico di Milano~[7] предложили генеровать
тестовые данные с использованием \emph{техник решения задачи ATPG}
(Automatic Test Pattern Generation). ATPG -- задача поиска значений
входных сигналов (<<векторов>>) схемы с целью поиска ее
некорректного поведения. ATPG чаще применяется для модульного
тестирования, если известна RTL-модель микропроцессора. Задача ATPG
известна давно и для ее решения существуют (в том числе
коммерческие) инструменты. Для применения ATPG при генерации
тестовых программ необходимо, чтобы RTL-модель микропроцессора была
готова к моменту генерации тестовых данных. Кроме того,
использование такой методики именно для функционального тестирования
ограничено, поскольку тесты на функционирование микропроцессора
приходится строить с учетом модели спроектированного
микропроцессора, которая сама же при этом будет и тестироваться.

Наиболее впечатляющих результатов достигают инструменты,
использующие для генерации тестовых данных \emph{разрешение
ограничений}. Ограничение с логической точки зрения то же, что и
предикат, а задача разрешения ограничений -- то же, что и задача
выполнимости системы предикатов, но для решения этой задачи
применяются специальные алгоритмы~[1]. В работе~[9] исследователей
из Китайского Национального Университета технологий безопасности
описывается инструмент MAATG. Тестовый шаблон для него может
содержать лишь ограничения равенства или неравенства значений и
указание области значений переменной. Для задания архитектуры
микропроцессора используется описание на языке EXPRESSION. Другой
инструмент -- Genesys-Pro~[8] -- позиционируется компанией IBM как
разработка, впитавшая лучшее из разработок последних 20 лет.
Тестовые шаблоны позволяют задавать тестовые программы переменной
длины. Для любой инструкции в тестовом шаблоне может быть указана
эвристика для выбора значений параметров~[3]. Среди возможных
эвристик есть и эвристики на события в кэш-памяти. Однако в
известных работах не раскрывается содержание таких эвристик, что не
дает возможности понять эффективность генерации программ, нацеленных
на тестирование памяти. Система команд микропроцессора должна быть
описана в виде ограничений (constraint net) на операнды, код
операции, что не является естественным описанием поведения
инструкции, особенно если в рамках нее выполняется несколько
последовательных вычислений на основе параметров инструкции. Для
генерации параметров очередной инструкции Genesys-Pro использует уже
построенную тестовую программу и состояние микропроцессора, которое
известно полностью. Этот подход обеспечил масштабируемость на
большие тестовые шаблоны, но и привел к необходимости использования
механизма возврата (backtracking), если выбрать параметры для
очередной инструкции.

%Кроме того инструмент не использует """функциональные связи"""
%разных команд, а генерирует значения параметров очередной команды,
%исходя из уже построенной части тестовой программы до этой команды.
%Иными словами, тестовая программа строится по-командно, что может
%отрицательно сказаться на эффективности работы Genesys-Pro на
%больших тестовых шаблонах.

% по большому счету Genesys-Pro лишь строит параметры очередной команды,
% а я ставлю более сложную задачу - кроме параметров сгенерировать и
% начальное состояние! В IBM поступают хитрее: самое сложное - начальное
% состояние уже известно (в т.ч. все сеты), а генератор просто "выбирает".
% сравните: cache = [ set1:0,5,10; set2:2,4,7 ], select(set,tag: cache miss)
% -> задача: set isin {1,2}, tag ~isin cache(set). Решаем сначала первый предикат,
% затем второй. Получаем set = 1, tag = 1. Всё просто.
% И сравните это с тем, что у меня: (set,tag): cache miss,.... И все!
% тут надо описать, что такое miss.

В данной работе при решении задачи генерации тестовых данных также
используется разрешение ограничений. В отличие от MAATG тестовые
шаблоны могут содержать не просто ограничения равенства или
неравенства, а более сложные ограничения, например, кэш-промах. А по
сравнению с Genesys-Pro в данной статье делается попытка
транслировать тестовый шаблон в ограничения
целиком~\footnote{Известно, что задача разрешения ограничений (т.е.
задача выполнимости) NP-полна. Это означает, что для больших
тестовых шаблонов предлагаемый в данной статье метод может быть не
столь эффективным. Однако действительно длинные тестовые шаблоны в
практике тестирования микропроцессоров применяются редко.}. При этом
отпадает необходимость в механизме возврата~\footnote{Из-за этого
качественно меняется разрешаемая система ограничений. Genesys-Pro
сводит общую задачу к множеству задач, на порядок меньшей сложности.
Кроме того, в данной статье предлагается более технологичный метод
построения тестовых данных: описание архитектуры микропроцессора
может быть получено из стандарта архитектуры микропроцессора и
представляет собой понятное для человека императивное задание.}.
Особенностью тестовых шаблонов, получаемых в рамках~[2], является
фиксация для каждой инструкции регистров-параметров. Для таких
шаблонов (особенно если в них много зависимостей) Genesys-Pro будет
работать крайне неэффективно, поскольку теряется возможность с
помощью выбора параметров <<подогнать>> исполнение очередной
инструкции под заданные в тестовом шаблоне для нее события. На
тестовых шаблонах из~[2] Genesys-Pro будет работать следующим
образом: выберет некоторое начальное состояние микропроцессора,
начнет исполнять тестовый шаблон (поскольку начальное состояние ему
известно), но как только дойдет до инструкции, которая будет
исполнена не так, как требуется в шаблоне, Genesys-Pro сделает
возврат в самое начало, а именно ему придется выбрать другое
начальное состояние микропроцессора и весь процесс запустить заново.
Такой процесс генерации тестовых данных слишком неэффективен. Кроме
того попытка наивного переноса идей из представленных в обзоре
инструментов (кодирование изменений состояния каждого регистра и
зависимостей между ними в виде ограничений) для инструкций работы с
памятью приводит к очень сложным ограничениям~\footnote{Для
кодирования состояния микропроцессора можно использовать формулу
длиной порядка размера памяти ($mem_0 = var0 \wedge mem_1 = var1
\wedge ...$); каждое изменение производится по неизвестному индексу,
поэтому при записи нового состояния микропроцессора приходится
перебирать все возможные варианты ($mem[i] := x$ приводит к формуле
$(i = 0 \wedge mem_0 = x \wedge mem_1 = var1 \wedge ...) \vee (i = 1
\wedge mem_0 = var0 \wedge mem_1 = x \wedge ...) \vee ...$), а если
таких изменений несколько, то приходится рассматривать все возможные
варианты значений индексов. Получающаяся формула имеет размер
порядка $|L| \cdot 2^n$, где $|L|$ -- размер памяти, а $n$ --
количество изменений памяти. В данной работе предложен метод
кодирования изменений, приводящий к формуле размера порядка $|L| +
n$.}, которые не удается разрешить за приемлемое время.

% отличия от Genesys-Pro:
% 1) другой алгоритм обработки тестового шаблона:
%    тестовый шаблон рассматривается целиком, а не по одной команде
% 2) задача построения тестовых данных (особенно, начального состояния)
%    выражена более логично. Genesys-Pro не ищет их, а выбирает просто числа
%    наобум. Если нельзя выбрать, откат. А у меня именно поиск.
% 3) используются более логичное описание тестовых ситуаций.
%    Не ограничения, а императив.
% 4) ниже сложность написания модели тестовых ситуаций, поскольку они уже
%    описаны в документации на стандарт архитектуры :)
% 5) Genesys-Pro на тестовых шаблонах, где нет возможности что-то подобрать
%   (как, например, в Сашиных шаблонах), будет работать крайне неэффективно,
%   ибо эффективность работы Genesys-Pro достигается и за счет того, что он сам
%   может выбирать аргументы, например, регистры, если в шаблоне нет указания,
%   какой это должен быть регистр. На Сашиных шаблонах Genesys-Pro предположит
%   некоторое начальное состояние микропроцессора, а затем начнет просто исполнять
%   шаблон (поскольку в Сашиных шаблонах все регистры уже выбраны). Можно выбирать
%   значения констант - на этом может сыграть Genesys-Pro. И вот если при исполнении
%   тестового шаблона не происходит указанных тестовых ситуаций, Genesys-Pro
%   откатится к самому началу и выберет другое начальное состояние. Опять исполнит
%   тестовый шаблон. Если не получилось, снова возврат и снова подбор начального значения.
%   Такая схема неэффективна в нашей постановке задачи!
