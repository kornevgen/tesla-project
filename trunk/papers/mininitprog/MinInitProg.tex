\documentclass[conference, 10pt]{IEEEtran}
%\documentclass{article}
\usepackage[cp1251]{inputenc}
\usepackage[russian]{babel}
\usepackage{pscyr}
\usepackage{amsthm}

\title{Алгоритм построения инициализирующей программы для LRU кэш-памяти
минимальной длины}

\author{Евгений Корныхин}

\date{}

\newtheorem{lemma}{Лемма}

\begin{document}
\maketitle

\section{Общая задача генерации тестовых данных при тестировании
микропроцессоров с помощью тестовых программ}

Тестовая программа -- это обычная программа на языке ассемблера
микропроцессора. Целью тестирования, которое будет рассматриваться в
данной статье, является проверка взаимного влияния исполнения разных
инструкций внутри одной тестовой программы. Для этого систематически
перебираются различные варианты наборов инструкций и зависимостей
между ними (например, использование одинаковых/разных регистров,
адресов). Результат очередной итерации перебора записывается в виде
\emph{тестового шаблона} -- последовательности инструкций с
указанием зависимостей между ними и, возможно, с дополнительными
ограничениями внутри одной инструкции (такое ограничение называется
\emph{тестовой ситуацией}). Однако не из любого начального состояния
микропроцессора при исполнении такого тестового шаблона будут
выполнены требуемые тестовые ситуации (например, регистр $s$ имеет
значение 1, а в тестовом шаблоне необходимо, чтобы он имел четное
значение) -- необходимо сгенерировать \emph{инициализирующую
программу}. Исполнение инициализирующей программы приведет
микропроцессор из заданного начального состояния в то состояние, из
которого дальнейшее исполнение тестового шаблона пройдет так, как
задано в нем. Инициализирующая программа может изменять следующие
подсистемы микропроцессора:
\begin{enumerate}
\item регистры (как общего назначения, так и специальные);
\item кэш-память (может содержать несколько уровней);
\item буфер трансляции адресов (TLB).
\end{enumerate}

Зачастую приходится инициализировать и некоторые ячейки оперативной
памяти, поскольку тестовый шаблон может содержать зависимости на
считываемые из памяти данные.

В данной работе будет использован \emph{предикативный} подход к
генерации тестовых данных, т.е. по тестовому шаблону будет построен
предикат, некоторыми свободными переменными которого будут искомые
тестовые данные (начальные значения регистров, ячеек кэш-памяти и
т.д.). Затем специальный solver по этому предикату построит значения
его свободных переменных, на которых предикат истинен.

Задача построения предиката, описывающего тестовый шаблон, может
быть разделена на следующие подзадачи:
\begin{enumerate}
\item задача на регистры (зависимости между значениями регистров);
\item задача на кэш-память (зависимости на физические адреса);
\item задача на TLB (зависимости на виртуальные адреса и элементы
TLB);
\item задача на память (зависимости на данные, с которыми
микропроцессор обращается в память).
\end{enumerate}

Решение \emph{задачи на регистры} приводится в разных статьях
[статьи], поэтому на ней останавливаться не будем. Вычисленное
начальное значение каждого нужного регистра оформляется в
инициализирующей программе в виде инструкций загрузки значений в
регистры (возможно, по частям -- отдельно старшие биты, отдельно
младшие).

Описание инструкции обращения в память может использовать
\emph{трансляцию адреса} -- построение физического адреса по
виртуальному адресу. При этом может использоваться TLB --
Translation Lookaside Buffer -- который содержит соответствие
страниц виртуальной памяти страницам физической памяти. Вместо
описания в виде предиката алгоритма трансляции адресов предлагается
в предикате зафиксировать лишь зависимости переменных-виртуальных
адресов, физических адресов, элементов TLB. Это позволит значительно
снизить сложность строящегося предиката в \emph{задаче на TLB}.

Аналогичные идеи применяются также к \emph{задаче на кэш-память} и к
\emph{задаче на память}. Обе эти задачи описывают эффект от загрузки
данных из памяти или сохранения данных в памяти, поскольку эти
процессы происходят с участием кэш-памяти. В задаче на кэш-память в
виде предикатов формулируются зависимости значений
переменных-физических адресов и ячеек кэш-памяти (например, тегов
кэш-памяти), а в задаче на память формулируются зависимости на
считываемые и записываемые данные у разных инструкций (например,
если по адресу записано некоторое число, то оно же будет считано при
следующем обращении к этому адресу).

Инициализирующую программу для последних трех задач следует
составлять совместно, поскольку зачастую инструкции обращения в
память включают как трансляцию адресов, так и обращение в
кэш-память.

Задачу на кэш-память предлагается решать с использованием систем на
конечные множества натуральных чисел [моя статья с множествами].
Каждое решение такой задачи сопровождается \emph{предусловием} --
предикатом на начальное состояние кэш-памяти. Если предусловие
выполнено, решение можно использовать. Если предусловие не
выполнено, можно либо искать следующее решение, либо строить
инициализирующую программу для получения состояния кэш-памяти, для
которого предусловие выполнено. Предусловие также определено
неоднозначно: оно зависит от того, с частью кэш-памяти какого
размера работает тестовый шаблон. Однако выполнение предусловия еще
не гарантирует совместность всего решения -- возможен случай, когда
решение задачи на кэш-память с выбранным предусловием несовместно с
решением задачи на регистры или TLB.

\section{Задача построения инициализирующей программы для кэш-памяти}
Инициализирующая программа состоит из последовательности инструкций
обращений в память (загрузки или сохранения данных в памяти). Каждая
команда имеет два параметра -- адрес, по которому происходит
обращение, и данные, с которыми надо выполнить инструкцию (данные
могут быть заданы в виде непосредственного значения или регистра, в
котором хранится числовое значение).

Состояние кэш-памяти представляется в виде матрицы значений. Задано
некоторое состояние кэш-памяти и предикат на состояние. Предикат на
заданном состоянии не выполнен. Требуется построить инициализирующую
программу, приводящую кэш из заданного состояния в состояние, в
котором выполнен предикат.

\section{Алгоритм}

Построение инициализирующей программы производится для состояния
кэша, заданного с помощью \emph{предусловием} (предиката на
состояние кэш-памяти). Алгоритм пытается подобрать для заданного
состояния кэш-памяти (\emph{начального состояния кэш-памяти})
последовательность инструкций, приводящих кэш-память к состоянию, в
котором выполнено предусловие (\emph{конечное состояние
кэш-памяти}). В частном случае если предусловие выполнено для
заданного состояния, инициализирующая программа не содержит вообще
инструкций. Сформулированная ниже лемма о построении
инициализирующей программы показывает, что последовательность
инструкций минимальной длины однозначно соответствует конечному
состоянию кэш-памяти, поэтому перебор последовательности инструкций
можно свести к перебору конечных состояний кэш-памяти.

\begin{figure}[b]\label{common}

1: выбрать конечное состояние кэш-памяти $F$

2: если предусловие на $F$ не выполнено, goto 1

3: построить инициализирующую программу по $F$

\caption{Алгоритм построения инициализирующей программы}
\end{figure}

Схема алгоритма приведена на рисунке~\ref{common}. Она состоит из
трех шагов.

Проверку выполнения предусловия (шаг 2) можно выполнять с помощью
SAT-инструмента или constraint solver'а.

\begin{lemma}[Построение инициализирующей
программы]\label{main_lemma} Пусть $W$ -- ассоциативность
кэш-памяти. $x_1, x_2, ..., x_W$ -- начальное состояние LRU
кэш-памяти. $y_1, y_2, ..., y_W$ -- конечное состояние LRU
кэш-памяти. Пусть $N$ -- максимальное такое число ($0 \leq N \leq
W$), что $y_{W-N+1}, y_{W-N+2},..., y_{W}$ является
подпоследовательностью последовательности $x_1, x_2, ..., x_W$ (с
сохранением порядка). Тогда инициализирующая программа минимальной
длины, переводящая кэш из данного начального состояния в данное
конечное, состоит следующей последовательности обращений к адресам:
$y_{W-N}, y_{W-N-1},..., y_1$.
\end{lemma}
\begin{proof}[Доказательство]
надо написать доказательство
\end{proof}

Лемма непосредственно используется при построении инициализирующей
программы по конечному состоянию кэш-памяти (шаг 3): для этого
достаточно просматривать конечное состояние кэш-памяти с конца,
отмечая момент, когда появится элемент, которого не было в начальном
состоянии или нарушится порядок элементов из начального состояния.

\subsection{Перебор конечных состояний кэш-памяти}
Здесь будет предложена процедура перебора конечных состояний
кэш-памяти, гарантирующая первее выбор конечного состояния с
минимальной инициализирующей программой, нежели остальные конечные
состояния кэш-памяти.

Пусть $N$ -- длина инициализирующей программы. Пусть $W$ --
ассоциативность кэш-памяти. Из леммы~\ref{main_lemma} следует, что
$N \leq W$. Последние $N$ элементов конечного состояния кэш-памяти
будем называть \emph{суффиксом}, а первые $W-N$ элементов --
\emph{префиксом}. Алгоритм будет перебирать конечные состояния в
виде \emph{шаблонов} -- последовательностей из чисел и переменных
длины $W$. Каждый шаблон строится под заданное значение $N$.

В процессе алгоритма некоторые элементы шаблона заполняются
элементами из начального состояния кэш-памяти. Оставшиеся элементы
шаблона становятся переменными. На каждом шаблоне проверяется
выполнение предусловия. Если оно выполнено, входящие в шаблон
переменные получают значения, на которых выполнено предусловие. Как
и конечные состояния кэш-памяти, любой шаблон так же можно поделить
на префикс и суффикс. Переменные могут входить только в префикс
шаблона.

Алгоритм осуществляет следующие переборы:
\begin{enumerate}
\item длина инициализирующей программы $N$ (от 0 до $W$);
\item количество констант шаблона $C$ (от $W-N$ до $W$);
\item выбор первого элемента суффикса (из $x_1, x_2, ...,
x_{\max\{C-W+N, 1\}}$), пусть $M$ -- номер этого элемента в
начальном состоянии кэш-памяти;
\item выбираем, переменной или константой является последний элемент
префикса; если $C - W + N = 0$, то это обязательно переменная; если
это константа, то осуществляется выбор последнего элемента префикса
$x_L$ среди элементов $x_{M+1}, x_{M+2},..., x_C$;
\item выбор оставшихся элементов суффикса как подпоследовательностей
длины $W-N-1$ последовательности $x_{M+1},...,x_C$ (перебор
сочетаний без внутренних перестановок) без $x_L$;
\item расположение оставшихся элементов (в количестве $C-W+N-1$, если
последний элемент префикса константа, и в количестве $C-W+N$, если
последний элемент префикса переменная) из $x_1, ..., x_C$ на
оставшихся местах префикса.
\end{enumerate}

На переменные шаблона надо наложить дополнительное ограничение: они
должны иметь отличные значения от друг друга и от значений из
начального состояния кэш-памяти, находящихся в конечном состоянии
кэш-памяти. Если последний элемент префикса является переменной, то
ее значение не должно равняться чему-либо из $x_1, ..., x_M$.

Перебор можно также записать <<в неявной форме>> -- в виде
ограничения, разметкой значений переменных в которой будет
произведен тот же перебор. На рисунке~\ref{eclipse_selections}
приведены ограничения для constraint solver'а ECLiPSe, реализующий
приведенные выше переборы (merge(L1, L2, Lmix) выполнено, если Lmix
является конкатенацией-слиянием L1 и L2 -- все элементы L1 и L2
входят в Lmix c сохранением порядка из исходных списков).

\begin{figure}\label{eclipse_selections}
\small
\begin{verbatim}
select( X, W, Y ) :-
    N #:: [0..W], C #:: [W-N..W],
    length(S, W-N), ordered(S),
    length(P1, C-W+N), ordered(P1),
    all(A, 1, C), merge(S, P1, A),
    elements(X, S, XS), elements(X, P1, X1),
    length(P, N), subset(X1, P),
    notin(P[N], X[1]..X[S[1]]),
    append(Y, P, XS), alldifferent(Y) .
\end{verbatim}
\caption{Перебор конечных состояний в виде ограничений}
\end{figure}

\section{Корректность алгоритма}

\section{Вычислительная сложность алгоритма}

\end{document}
