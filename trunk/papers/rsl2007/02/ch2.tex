\chapter{Определение новых типов. Функции в RSL}

\section{Декартово произведение. Ограничение типа}

В RSL допустимы следующие \emph{типовые выражения} (способы описания
новых типов)\footnote{типовые выражения обозначаются в схемах далее как $typeexpr$}:
\begin{enumerate}
\item встроенный тип
\item подтип (ограничение типа)
\item декартово произведение
\item множество
\item список
\item отображение
\end{enumerate}

Подтип: $\{| var : typeexpr \SuchAs boolexpr|\}$

Декартово произведение: $typeexpr_1 \DP typeexpr_2 \DP ... \DP
typeexpr_n$

\section{Способы задания функций}
Явное задание функции:

\parbox{10cm}{
$fname : typeexpr_1 \rightarrow typeexpr_2\\
fname(var) \Iden expr$ }

Неявное задание функции:

\parbox{10cm}{
$fname : typeexpr_1 \rightarrow typeexpr_2\\
fname(var_1) \As var_2\\
\Post expr $
 }

Аксиоматическое задание функции:

\parbox{10cm}{
$fname : typeexpr_1 \rightarrow typeexpr_2\\
\Axiom boolexpr $
 }

У каждого такого способа задания функции может быть
\emph{предусловие}. Тогда функция называется
\emph{частично-вычислимой}.

\section{Алгебраические спецификации}
Операции над \emph{целевым типом} могут быть описаны в виде
алгебраической спецификации. Она состоит только из сигнатур функций
и раздела аксиом. Каждая операция в ней должна принадлежать одной из
трех категорий:
\begin{enumerate}
\item \emph{функция-<<обсервер>>} -- та, которая не меняет состояние
параметра целевого типа (например, подсчет количества элементов,
если целевой тип - контейнер)
\item \emph{функция-<<генератор>>}
\item \emph{функция-<<трансформер>>} -- та, которая может быть
реализована с использованием только функций-<<генераторов>>
(например, удаление элемента из контейнера, если есть операции
добавления и построение пустого контейнера)
\end{enumerate}
Тогда в алгебраической спецификации обязательно должны
присутствовать аксиомы вида: $$\All var : typeexpr \SuchAs o(g(var))
\Iden ...$$ $$\All var : typeexpr \SuchAs o(t(var)) \Iden ...$$ где
$o(.)$ - очередной обсервер, $g(.)$ - очередной генератор, $t(.)$ -
очередной трансформер.

\section{Простейший формат RSL-спецификации}
$\Scheme schemename = \Class\\
body \End$

$body$ состоит из разделов функций, типов, глобальных переменных и
аксиом. В теле может быть несколько разделов одного такого вида. В
начале каждого раздела ставится специальное ключевое слово: для
раздела функций - $\Value$, типов - $\Type$, глобальных переменных -
$\Variable$, аксиом - $\Axiom$. Элементы внутри раздела
перечисляются через запятую. Разделитель разделов -- пробел.

\section{Задачи}

В занятие входят все задачи из методического пособия + приведённые
ниже. Не решенные на занятии задачи идут в домашнюю работу.

Обратите внимание, что иррациональные константы не могут появляться
в явных (или, что то же самое, исполнимых) спецификациях (по причине
того, что их нельзя вычислить и предъявить для использования за
конечное время). Однако их можно определить неявным или
аксиоматическим образом.

Также обратите внимание на разницу фраз <<вычислить>> и
<<определить>> (<<дать определение>>). Первая означает написание
явной (исполнимой, вычислимой) спецификации, а вторая -- неявной или
аксиоматической (дающей определение, но не способ вычисления).

\subsection{Какие из следующих спецификаций набраны без ошибок?}
Какие ошибки сделаны?
\begin{enumerate}
\item
\begin{verbatim}
vale f Int -> Int
    (f(x) is x)
\end{verbatim}

\item
\begin{verbatim}
value ff -> Int
    f() = 0
\end{verbatim}

\item
\begin{verbatim}
value f: Int => Int
    f x == x + 1
\end{verbatim}

\item
\begin{verbatim}
value f: (Int -> Int) -> Int
    f(g) is g(0)
\end{verbatim}

\item
\begin{verbatim}
value f: (Int -> Int) -> Int
    f(g) is f(0)
\end{verbatim}

\item
\begin{verbatim}
value f: Int -> Bool
    f(x) is f(x)
\end{verbatim}

\item
\begin{verbatim}
value f: Int -> Bool
    f(x) is ~f(x)
\end{verbatim}

\item
\begin{verbatim}
value f: Int -> Int
    1 is f(x)
\end{verbatim}

\item
\begin{verbatim}
value f: Int -> Int
    g(x) is f(x)
\end{verbatim}

\item
\begin{verbatim}
value f: Int -> (Int, Real)
    f(x) is 0 >< 1.0
\end{verbatim}

\item
\begin{verbatim}
value f: Int -> Int
    f(0) is 0
\end{verbatim}

\item
\begin{verbatim}
value f, g: Int -> Int
    f(x) is x, g(x) is x+ 1
\end{verbatim}

\item
\begin{verbatim}
value f: Int -> Int f(x) is x,
    f: Int -> Int f(x) is x + 1
\end{verbatim}

\item
\begin{verbatim}
value f: Int -> Int f(x) is x,
    f: Int -> Int f(x) is x
\end{verbatim}

\item
\begin{verbatim}
value f: Int -> Int f(x) is 0,
    f: Text -> Int f(x) is 1
\end{verbatim}
\end{enumerate}

\subsection{Построить сигнатурную спецификацию для следующих систем}
\emph{Примечание:} сигнатурная спецификация содержит только сигнатуры
функций и определения типов в sort-виде

Спецификация должна без ошибок проходить этап проверки на type checker'е.

\begin{enumerate}
\item Написать спецификацию интерфейса программы-калькулятора.
\end{enumerate}

\subsection{Построить явную и неявную спецификации на RSL для
следующих программ}
\begin{enumerate}
\item Вычисление максимума трех чисел $m = max(x, y, z)$
\item Переставить два числа $(x, y) = swap(u, v)$
\item Сложить два комплексных числа, заданных в алгебраической форме
$z = c\_add(x, y)$ Опишите тип <<Комплексное число>>.
\item Умножить два комплексных числа, заданных в алгебраической форме
$z = c\_mul(x, y)$ Опишите тип <<Комплексное число>>.
\item Вычислить факториал натурального числа $n! = ft(n)$
\item Вычислить НОД двух натуральных чисел $k = HOD(x, y)$
\item Вычислить $n$'е число Фибоначчи $f = fib(n)$
\item Получить два делителя числа минимальной величины $(a, b) =
del(n)$
\item Отсортировать три числа $(a, b, c) = sort3(x, y, z)$
\item$^\star$ Вычислить квадратный корень числа $s =
sqrt(x)$\\\emph{Указание:} в явной спецификации добавить параметр
$epsilon$ -- абсолютную погрешность измерения
\item Вычислить сумму квадратов двух максимальных чисел из трёх
данных $m = max2(x, y, z)$
\item У Маши есть два брата - $x$ и $y$. Первому $n$ лет, второму
$m$. Как зовут старшего брата Маши? $s = older(b_1, b_2), b_i:
Brother$. Опишите тип <<Brother>>.
\item Вычислить случайное число в отрезке между заданными двумя
числами $r = random(x, y)$
\item Вычислить сумму первых $n$ натуральных чисел (числа считаются
с единицы) $s = sum1(n)$
\item Вычислить сумму квадратов первых $n$ натуральных чисел (числа
считаются с единицы) $s = sum2(n)$
    \begin{itemize}
    \item рекурсию использовать можно
    \item а теперь попробуйте без рекурсии
    \end{itemize}
\item Среди шести данных чисел вывести номер максимального числа $n
= max6(x1, x2, x3, x4, x5, x6)$
\item Даны 2 точки $p_1$ и $p_2$, заданные своими координатами в плоской декартовой
системе координат, и число -- радиус $R$. Вычислить координаты
точки, лежащей в круге радиуса $R$, на границе которого лежат
заданные две точки : $p = inside(p_1, p_2, R), p_1, p_2: Point$.
Опишите тип <<Point>>.
\item Даны 2 точки, заданные своими координатами в плоской декартовой
системе координат. Вернуть ту точку, которая ближе к началу
координат $p = nearer(p_1, p_2), p_1, p_2: Point$. Опишите тип
<<Point>>.
\item Дано 6 цифр -- номер автобусного билета, который Вам дал
контролер, пока Вы ехали на занятие в Университет. Проверить,
является ли он <<счастливым>>. Билет называется счастливым, если
    \begin{enumerate}
    \item первые три цифры совпадают с последними тремя
    \item сумма цифр есть полный квадрат
    \end{enumerate}
Опишите тип <<Номер билета>>.
\item Даны 3 цифры. Можно ли из этих цифр собрать
простое число.
    \begin{itemize}
    \item необходимо использовать все цифры
    \item среди данных цифр нет одинаковых
    \item среди данных цифр могут быть одинаковые
    \end{itemize}
\item Определить, к какому классу принадлежит данный IP-адрес $c =
classofip(i), i: IP, c: Char$. Опишите тип <<IP-адрес>>.
\item Проверить, является ли данный IP-адрес <<частным>>
(т.е. является 10.0.0.0/8 или 172.16.0.0/12 или 192.168.0.0/16) $b =
islocal(i), i: IP, c: Char$. Опишите тип <<IP-адрес>>.
\end{enumerate}

\subsection{Построить аксиоматическую спецификации на RSL для
следующих программ и понятий}
\begin{enumerate}
\item Написать определение максимума двух чисел
\item Дана функция-отношение $\varphi(x, y)$. Дать определение того, что
    \begin{enumerate}
    \item $\varphi$ рефлексивно
    \item $\varphi$ симметрично
    \item $\varphi$ транзитивно
    \item $\varphi$ является отношением эквивалентности
    \item $\varphi$ является отношением частичного порядка
    \end{enumerate}
\item Дана функция-<<числовая последовательность>> $x(n)$. Дать на RSL определение следующих математических фактов:
    \begin{enumerate}
    \item $x(n)$ ограничена
    \item $x(n)$ монотонно возрастает
    \item $x(n)$ сходится
    \item$^{\star}$ числовой ряд $\sum\limits_{k=0}^{+\infty} x(k)$ сходится
    \end{enumerate}
\item Дана вещественнозначная функция $f(x)$. Дать на RSL определение следующих математических фактов:
    \begin{enumerate}
    \item $f(x)$ ограничена
    \item $f(x)$ монотонно возрастает
    \item $f(x)$ непрерывна на всей области определения
    \item{$^\star$} $f(x)$ дифференцируема на всей области
    определения
    \end{enumerate}
\item Даны типы X и Y. Дано отображение\footnote{в математическом смысле} $\varphi: X \rightarrow Y$. Дать на RSL определение следующих математических фактов:
    \begin{enumerate}
    \item $\varphi$ тождественно ($\varphi(x) = C$) (попробуйте
    не использовать квантор существования)
    \item $\varphi$ тотально вычислима
    \item $\varphi$ частично вычислима
    \item $\varphi$ инъективно (различным аргументах соответствуют различные
    значения функции)
    \item $\varphi$ сюръективно (у каждого числа из области значений
    есть аргумент, который этому значению соответствует)
    \item $\varphi$ биективно (инъективно и сюръективно
    одновременно)
    \item $\varphi$ самообратимо ($\varphi(x) = \varphi^{-1}(x)$)
    \item $\varphi$ идемпотентно ($\varphi(\varphi(x)) = \varphi(x)$)
    \end{enumerate}
\item\label{list_exmp} Написать алгебраическую спецификацию типа <<Список>> и
операций
    \begin{enumerate}
    \item получение пустого списка
    \item добавления в список
        \begin{itemize}
        \item к голове списка
        \item$^\star$ за конечным элементом списка
        \end{itemize}
    \item получение головы списка
    \item получение хвоста списка
    \item проверка нахождения элемента в списке
    \end{enumerate}
С использованием своего определения определите константный список из
элементов 1, 2, 3.
\item Написать спецификацию функции, вычисляющей длину списка.
Список определить согласно задаче~\ref{list_exmp}.
\item Написать спецификацию функции, конкатенирующую два данных списка.
Список определить согласно задаче~\ref{list_exmp}.
\item Написать алгебраическую спецификацию типа <<Стек>> и операций
    \begin{enumerate}
    \item получение пустого стека
    \item добавление элемента в стек
    \item удаление элемента из стека
    \item получение головы стека
    \end{enumerate}
\item Написать алгебраическую спецификацию типа <<Очередь>> и
операций
    \begin{enumerate}
    \item получение пустой очереди
    \item добавление элемента в очередь
    \item удаление элемента из очереди
    \item получение головы очереди
    \end{enumerate}
\item Написать алгебраическую спецификацию типа <<Двоичное дерево>>
и операций
    \begin{enumerate}
    \item получение пустого двоичного дерева
    \item добавление элемента в двоичное дерево
    \item проверка нахождения элемента в дереве
    \end{enumerate}
Уточнить тип <<Двоичное дерево>> до типа <<Двоичное дерево поиска>>.
\item\label{peano} Написать определение натурального числа в виде схемы языка RSL, используя аксиоматику Пеано:
    \begin{itemize}
    \item определите константу zero и функцию $succ$ (она вычисляет
    следующий элемент)
    \item напишите определение следующих аксиом:
        \begin{enumerate}
        \item zero -- минимальный элемент
        \item <<линейный порядок>>: для равенства последователей
        элементов необходимо равенство самих элементов
        \item <<математическая индукция>>
        \end{enumerate}
    \end{itemize}
\item Пользуясь определением натурального числа из предыдущей
задачи, дать определение операций сложения и умножения двух
натуральных чисел. \\ \textit{Примечание:} Операции сложения и
умножения надо натуральным числами можно описать следующими
аксиомами:
    \begin{enumerate}
    \item $\forall x \in \mathbb{N}~( +(x, 0) = x )$
    \item $\forall x, y \in \mathbb{N}~( +(x, succ(y)) = succ(+(x, y)) )$
    \item $\forall x \in \mathbb{N}~( *(x, 0) = 0)$
    \item $\forall x, y \in \mathbb{N}~( *(x, succ(y)) = +(*(x, y), x) )$
    \end{enumerate}
\item Написать определение предела заданной числовой
последовательности $a(n)$ (например, <<на языке
$\varepsilon-\delta$>>). Считайте, что числовая последовательность
имеет следующее определение: $a: \Nat \to \Real$.
\item Написать определение суммы заданного числового
ряда, составленного из элементов числовой последовательности $a(n)$,
используя определение предела из предыдущей задачи. Считайте, что
числовая последовательность имеет следующее определение: $a: \Nat
\to \Real$. Считайте, что ряд считается с $n = 0$.
\item$^{\star}$ Определите на RSL константу e (неявно) \\
\textit{Примечание:} Представьте, что кто-то вычислил вещественное
число (e). Вам остаётся проверить, что оно действительно есть e.
Например, для этого можно неявным образом использоваться определение
e из теории пределов или числовых рядов: \\ $\textrm{e} =
\lim\limits_{k\to+\infty}(1 + \frac1k)^k =
\sum\limits_{k=0}^{+\infty}\frac{1}{k!}$
\item$^{\star}$ Определите на RSL константу $\pi$ (неявно) \\ \textit{Примечание:} $\frac{\pi}4 = \sum\limits_{k=0}^{+\infty} \frac{(-1)^k}{2k - 1}$
\item$^{\star}$ Дать определение синуса и косинуса числа $s = \sin(x)$,
$t = \cos(x)$ \\ \emph{Примечание:} следующий набор аксиом
однозначно определяет две функции $S(x)$ и $C(x)$, которые равны
синусу и косинусу $x$ соответственно :
$$\mbox{для любых } x, y : S(x+y) = S(x)C(y) + C(x)S(y)$$
$$\mbox{для любых } x, y : C(x+y) = C(x)C(y) - S(x)S(y)$$
$$\mbox{для любого } x : S^2(x) + C^2(x) = 1$$
$$S(\frac\pi2) = 1$$
$$\mbox{для любого } x \in (0,\frac\pi2) : 0 < S(x) < x$$
Обоснование этого факта приведено в книге Ильина, Позняка
<<Математический анализ>>, том 2 \\
\emph{Примечание:} считать константу $\pi$ определенной (например,
из предыдущей задачи)
\item$^{\star\star}$ Определите явным образом на RSL синус с заданной абсолютной погрешностью \\ \textit{Примечание:} $\sin(x) = \sum\limits_{k=0}^{+\infty} \frac{(-x^2)^k}{(2k - 1)!!}$
\end{enumerate}

\subsection{Построить явную спецификацию по неявной}
\begin{enumerate}
\item
\begin{verbatim}
    value f: Nat -> Bool
    f(n) as b
    post
            if exists x:Nat :- exists y:Nat :- n = x + y
                /\ y = x then ~b else b
            end
\end{verbatim}
\item
\begin{verbatim}
    value f: Nat >< Nat -> Bool
    f(x, y) as b
    post
            if all n:Nat :- n - x = n - y \/
                (exists m:Text :- m ~= ""
                => (exists c, d: Nat :- c = 2 ** d))
                then ~b else b
            end
\end{verbatim}
\item
\begin{verbatim}
    value f: Nat -> Nat
    f(n) as k
    post
    (
        (all i:Nat :- i >= 1 /\ i <= n => k \ i = 0)
        /\
        (all i:Nat :- i >= 1 /\ i < n /\ k \ i = 0 =>
            ( exists! j:Nat :- j >= 1 /\ j <= n /\ k \ j = 0
            /\ j > i )
        )
    )
\end{verbatim}
\item
\begin{verbatim}
    value
        f: Nat -> Nat
        f(n) as k
        post g(k, n),

        g: Nat >< Nat -> Bool
        g(n, k) as b
        post
            if k = 0 then b
            elsif n < k then ~b
            else g(n-k, k-1)
            end
\end{verbatim}
\end{enumerate}


\subsection{Спецификация автоматного поведения}
Шаблон спецификации автоматного поведения :

\Type Состояние, Вход, Выход

\Value

\quad старт : Состояние,

\quad переход: Состояние $\times$ Вход $\rightarrow$ Состояние $\times$ Выход

\begin{enumerate}
\item Напишите спецификацию трехцветного автомобильного светофора
\item Напишите спецификацию двухцветного пешеходного светофора
\item Напишите спецификацию ячейки динамической оперативной памяти (сигнал 0 -- обновить значение, сигнал 1 --
сохранить значение)
\item Некая фирма скоро начнёт производство автоматов по продаже
шипучего напитка <<Буратино>>. В автомате в каждый момент находится
некоторое количество бутылок этого бодрящего напитка. Каждая бутылка
стоит некоторое количество денежных единиц. На автомате есть кнопка
с надписью <<Нажми - если загорится зелёная лампочка, значит,
бутылки есть; если красная, то бутылок в автомате сейчас нет>>. Цена
бутылки <<Буратино>> написана на автомате. Для покупки напитка
следует нажать кнопку <<Пуск>> и вставить деньги в соответствующее
отверстие. После чего автомат выдаст максимальное количество бутылок
<<Буратино>> на данные ему деньги, а также выдаст сдачу. В фирме
будет специальный человек, который с некоторой периодичностью будет
приезжать к автомату, загружать его бутылками <<Буратино>> и
забирать из него деньги.

Напишите спецификацию поведения такого автомата по продаже шипучего
напитка <<Буратино>>.
    \begin{enumerate}
    \item как изменится спецификация, когда после выполненной Вами
    работы выяснится, что разработчики автомата решили
    дополнить его такой возможностью: цена бутылки может
    меняться -- менять её сможет тот же самый человек, который
    собирает деньги из автомата ?
    \end{enumerate}
\item За неудовлетворительную работу Московский метрополитен решает
заменить всех женщин в кассах на автоматы. На автомате есть кнопки,
соответствующие тому, на сколько поездок надо купить билет. Автомат
должен принимать деньги, а взамен выдавать билеты и сдачу. К Вам
обратились с просьбой написать спецификацию данного автомата, дабы
пассажиры метрополитена не заметили разницы, а скорость продвижения
очередей сократилась бы. Примите эту просьбу и напишите спецификацию
поведения новых автоматов по продаже билетов в метро.
\item На железнодорожном вокзале решают ввести автоматическую
систему, распределяющую пути по приезжающим поездам. Поезд может
занимать путь на неопределённое время, но о том, занят ли путь,
всегда можно узнать. Количество путей на вокзале в системе не
фиксируется и будет задано на этапе внедрения. Напишите спецификацию
такой автоматической системы.
\item Напишите спецификацию банкомата. Банкомат
при правильном вводе пин-кода может выдавать деньги, выдавать
баланс. Есть человек, который с некоторой периодичностью приезжает к
этому банкомату и кладёт туда деньги.
\item Напишите спецификацию поведения игроков в игре
<<Крестики-Нолики>>.\\ \textit{Примечание:} например, такая
спецификация может содержать определения следующих функций: ход
нолика, ход крестика, выиграл ли кто-либо сейчас?, пустое поле (это
будет константа)
\item Напишите спецификацию поведения в игре <<Виселица>>: один
игрок загадывает слово, а другой, называя буквы, пытается отгадать
его. При этом количество попыток ограничено (правда, каким числом
конкретно специфицировать пока не нужно). Шаг загадывания слова
опишите в sort-виде.
\item Напишите спецификацию поведения в игре <<Палочки>>. Правила
игры такие. Перед двумя игроками лежит некоторое количество палочек.
Поочерёдно они вытаскивают от одной до трёх палочек. Проигрывает
тот, кто берёт последнюю палочку.
\end{enumerate}

\subsection{Предложить уточнение поведения}
Дана алгебраическая спецификация. Предложить уточнение для неё в виде неявной или явной спецификаций.

\begin{enumerate}
\item
    \begin{verbatim}
    value f, g : Int -> Int
    axiom all x: Int :- f(g(x)) is x
    \end{verbatim}
\item
    \begin{verbatim}
    value C: Int, f, g : Int -> Int
    axiom all x: Int :- f(g(x)) is C
    \end{verbatim}
\item
    \begin{verbatim}
    value C: Int, f, g : Int -> Int
    axiom all x: Int :- f(x) is g(C)
    \end{verbatim}
\item
    \begin{verbatim}
    value g : Int -> Int, f: Int -> Bool
    axiom all x: Int :- f(g(x)) is false
    \end{verbatim}
\item
    \begin{verbatim}
    value f : Int -> Int
    axiom all x: Int :- f(x * 2) is f(x) + f(x)
    \end{verbatim}
\item
    \begin{verbatim}
    value f : Int -> Int
    axiom all x: Int :- f(x * 2) is f(x) * f(x)
    \end{verbatim}
\item
    \begin{verbatim}
    value f : Int -> Int
    axiom all x, y: Int :- f(x * x + y * y) is f(x) + f(y)
    \end{verbatim}
\item
    \begin{verbatim}
    value f: Int >< Int -> Bool, g: Int -> Bool
    axiom
        all x, y: Int :- f(x, y) is
            if g(y) then x = 1 else g(x) end,
        all x: Int :- g(x) is
            if f(x, 0) then x = 1 else g(x - 1) end
    \end{verbatim}
\item
    \begin{verbatim}
    value f: Int >< Int -> Bool, g: Int -> Bool
    axiom
        all x, y: Int :- f(x, y) is
            if g(y) then x = 1 else g(0) end,
        all x: Int :- g(x) is
            if f(x, x) then x = 0 else g(x - 1) end
    \end{verbatim}
\end{enumerate}

\subsection{Доказательство корректности уточнения}

Доказать, что схема S2 является уточнением схемы S1

\begin{enumerate}
\item
    \begin{verbatim}
    scheme S1 = class
        type
            A, B, C
        value
            f1 : A >< B -> Bool,
            f2 : A >< B -~-> C,
            f3 : C -~-> A >< B
        axiom
            all a : A, b : B :-
                f3( f2(a,b) ) is (b, a)
            pre f1(a, b)
    end
    \end{verbatim}

    \begin{verbatim}
    scheme S2 = class
        type
            A = Int,
            B = Int,
            C = Int
        value
            f1 : A >< B -> Bool
            f1(i, n) is i + 1 = n,

            f2 : A >< B -~-> C
            f2(i, n) is n,

            f3 : C -~-> A >< B
            f3(x) as (a, b)
            post x = a /\ b = a - 1
    end
    \end{verbatim}

\item
    \begin{verbatim}
    scheme S1 = class
        type
            A, B, C
        value
            f1 : A >< B -> C,
            f2 : B >< A -~-> C,
            f3 : A -> B >< A,
            f4 : B -> A >< B
        axiom
            all a : A, b : B :-
                f1(f4(b)) = f2(f3(a))
            pre f1(a, b) = f2(b, a)
        end
    \end{verbatim}
    \begin{verbatim}
    scheme S2 = class
        type
            A = Int,
            B = Nat,
            C = Int
        value
            f1 : A >< B -> C
            f1(a, b) is a,

            f2 : B >< A -~-> C
            f2(a, b) is a,

            f3 : A -> B >< A
            f3(a) is (a, a),

            f4 : B -> A >< B
            f4(b) is (b, b)
        end
    \end{verbatim}
\end{enumerate}

\subsection{Разное}
\begin{enumerate}
\item Студент Иванов написал такое определение на RSL того факта,
что $\lim\limits_{n \rightarrow + \infty}\frac{n+1}{n} = 1$
\begin{verbatim}
all `epsilon:Real :- `epsilon > 0 =>
exists N: Nat :-
all n > N =>
    abs( (n+1)/n ) - 1 ) < `epsilon
\end{verbatim}
Помогите Иванову получить зачёт по МФСП, т.е. сделать так, чтобы \textsc{RSL Type Checker} на его спецификации не выдавал сообщений об ошибках
\item Какие из приведенных ниже выражений являются правильной спецификацией константы:
    \begin{enumerate}
    \item
\begin{verbatim}
value x = 0
\end{verbatim}
    \item
\begin{verbatim}
value x :- 0
\end{verbatim}
    \item
\begin{verbatim}
value x: Int :- 0
\end{verbatim}
    \item
\begin{verbatim}
value x: Int :- x = 0
\end{verbatim}
    \item
\begin{verbatim}
value x: Int :- true
\end{verbatim}
    \item
\begin{verbatim}
value x: Int :- x = 0 \/ x = 1
\end{verbatim}
    \item
\begin{verbatim}
value x: Int :- x = 0 /\ x = 1
\end{verbatim}
    \end{enumerate}

\item Упростить следующие выражения:
    \begin{enumerate}
    \item
        \begin{verbatim}
value
    f: Int >< Int >< Int -> Bool
    f(x, y, z) is if let x = y then z = y end
        then true else false end
        \end{verbatim}
    \item
        \begin{verbatim}
value
    f: Int >< Int >< Int -> Int
    f(x, y, z) is
        let (x, z) = (x + z, y - x) in
        let (x, y) = (y - z, x) in
            x + y + z
        end end
        \end{verbatim}
    \end{enumerate}
\end{enumerate}
