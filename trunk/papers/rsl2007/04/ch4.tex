\chapter{Списки}\label{lists}

\section{Определения и операции}
Список -- это контейнер элементов одного типа, который обладает
свойствами упорядоченности элементов. Для задания списка надо
указать не только сами элементы, но и их порядок.

Типовое выражение для конечного списка: $typeexpr\List$. Типовое
выражение для бесконечного списка: $typeexpr\Inflist$. Конечный
список -- подтип бесконечного списка.

Операции:
\begin{list}{}{}
\item $=: T\Inflist \DP T\Inflist \Fn \Bool$ -- проверка на равенство
\item $\neq: T\Inflist \DP T\Inflist \Fn \Bool$ -- проверка на не равенство
\item $(.) : T\Inflist \DP \Int \NonDetermFn T$ -- взятие элемента по
индексу ($\Chaos$ для индекса, отсутствующего в списке, индексы
нумеруются \textbf{с единицы})
\item $\Concat: T\List \DP T\Inflist \Fn T\Inflist$ -- конкатенация списков
\item $\Hd: T\Inflist \NonDetermFn T$ -- головной элемент списка ($\Chaos$ для пустого списка)
\item $\Tl: T\Inflist \NonDetermFn T\Inflist$ -- хвостовая часть списка ($\Chaos$ для пустого списка)
\item $\Len: T\Inflist \NonDetermFn \Nat$ -- количество элементов списка ($\Chaos$ для бесконечного списка)
\item $\Elems: T\Inflist \Fn T\Infset$ -- множество элементов списка (без повторений!)
\item $\Inds: T\Inflist \Fn \Nat\Infset$ -- множество индексов элементов списка
\end{list}

Конструктор списка:
\begin{list}{}{}
\item (\emph{пустой список}) $\LL\LR$
\item (\emph{перечисление}) $\LL 0, 1, 2 \LR$ - список, состоящий из трех целых чисел (не
натуральных!) - нуля, единицы и двойки - в порядке увеличения.
\item (\emph{диапазон}) $\LL 0..2 \LR$ -  то же, что и $\LL 0, 1, 2 \LR$;
$\LL 0..0 \LR \Iden \LL 0 \LR$, $\LL 1..0 \LR \Iden \LL\LR$
\item (\emph{<<сокращенная запись>>}) $\LL expr\_with\_var | var \In
listexpr \SuchAs boolexpr\LR$ (например, $\LL 2 \star n | n \In \LL
0..2 \LR \LR$, что эквивалентно $\LL 0, 2, 4 \LR$)
\end{list}

\section{Задачи}

\subsection{Вычислить}
\begin{enumerate}
\item $\LL 1 \LR = \LL 1, 1 \LR$
\item $\LL 1, 2 \LR = \LL 3, 1\LR$
\item $\LL 1, 2\LR = \LL 2, 1\LR$
\item $\LL 1, 2, 3 \LR (2)$
\item $\LL 1 \LR (0)$
\item $\LL 1 \LR (1)$
\item $\LL 1, 2\LR \Concat \LL 3, 4\LR$
\item $\LL 1, 2\LR \Concat \LL 2, 3\LR$
\item $\LL x+10 | x \In \LL 1, 2 \LR \LR = \LL x | x \In \LL 1 \LR \LR$
\item $\Hd \LL 1, 2, 3 \LR$
\item $\Tl \LL 1, 2, 3 \LR$
\item $\Len \LL 1, 2, 3 \LR$
\item $\Elems \LL 1, 2, 3 \LR$
\item $\Inds \LL 1, 2, 3 \LR$
\item $\Len \LL 1..30\LR$
\item $\Let x = \LL 1, 2, 3\LR \In \Elems x \Inter \Inds x \End$
\item $\Let x = \LL 0, 1, 2\LR \In \Elems x \Inter \Inds x \End$
\item $\Let x : \Int\Inflist \SuchAs (\All i_1, i_2: \Nat \SuchAs
\Card \{i_1, i_2\} = \Card \{x(i_1), x(i_2)\}) \In x \End$
\item $\Let x : \Int\Inflist \SuchAs (\All i_1, i_2: \Nat \SuchAs
\Card \{i_1, i_2\} = \Card \{x(i_1), x(i_2)\}) \In \\ \Elems x
\Inter \Inds x\End$
\item $\All x : T\Inflist \SuchAs x(0) = \Hd x$
\item $\All x : T\Inflist \SuchAs x(0) \Iden \Hd x$
\end{enumerate}

\subsection{Решите уравнения}
\begin{enumerate}
\item $\LL 1 \LR \Concat x  = \LL 1 \LR$
\item $\LL 1 \LR \Concat x  = \LL 1, 2, 3 \LR$
\item $\LL 1 \LR \Concat x  = \LL 3, 2, 1 \LR$
\item $\Tl x = \LL 1 \LR$
\item $\Hd x = 1$
\item $x \Concat \Tl x = x$
\item $\Tl x = \LL \Hd x \LR$
\item $\Elems x = \Inds x$
\item $\Elems\Tl x = \Elems x$
\item $\Len x = \Card \Elems x$
\item $\Len x = \Card \Inds x$
\item $\Len x \Iden \Card \Inds x$
\end{enumerate}



\subsection{Записать на RSL следующие константы и определения
типов}

\begin{enumerate}
\item Пустой список
\item Список из чисел 1, 2, 3; сколько решений имеет эта задача?
\item Список всех простых натуральных чисел в порядке увеличения их
значения
\item Список всех пар взаимнопростых натуральных чисел в порядке
увеличения их суммы
\item Список номеров групп 4го курса факультета ВМиК МГУ в порядке
увеличения номера группы
\item Количество простых чисел от 1 до 10 (тремя различными
способами)
\end{enumerate}

\subsection{Напишите явные (неявные) спецификации следующих
функций}

\begin{enumerate}
\item Определить, является ли бесконечным данный список.
\item Вычислить длину списка без использования функции $\Len$.
\item Вычислить сумму элементов списка.
\item Вычислить произведение элементов списка.
\item Дан список. Построить список из элементов исходного списка,
элементы которого идут в обратном порядке по отношению к исходному
списку
\item Дана строка и символ. Определить, встречается ли символ в
данной строке (предложить два различных способа решения).
\item Дана строка. Определить самый часто встречающийся в ней
символ.
\item Отсортировать данный список вещественных чисел в порядке
возрастания.
\item Построить список всех целых чисел в порядке неубывания модуля.
\item Определить $\sup$ списка вещественных чисел (в случае конечного списка это будет и максимум).
\item Выдать число, не встречающееся в данном списке.
\item Дан список чисел. Построить по нему список квадратов,
расположив элементы
    \begin{enumerate}
    \item с сохранением порядка исходного списка
    \item в порядке убывания модуля
    \item так, чтобы не было трёх подряд чисел, расположенных в
    порядке возрастания или убывания.
    \end{enumerate}
\item Дано натуральное число. Построить список степеней его простых
делителей, в котором на местоположение степени есть её основание (а
значение, соответственно, показатель)
\item Дан список показателей степеней (местоположение -- основание
степени). Построить соответствующее натуральное число.
\item Дан список натуральных чисел, отличных от нуля. Вернуть
список, в котором на месте №$i$ находится количество раз, которое
$i$ встречается в исходном списке.
\item Дано множество чисел. Построить из него список, расположив
элементы множества
    \begin{enumerate}
    \item в порядке убывания
    \item в порядке убывания модуля
    \end{enumerate}
\item Дан список чисел. Построить из него новый список, расположив
элементы исходного списка
    \begin{enumerate}
    \item в порядке убывания
    \item в порядке убывания модуля
    \end{enumerate}
\item Дан список из чисел. Построить из него множество, использовав
все элементы данного списка.
\item Дан множество пар (ключ, объект) и список ключей. Построить
соответствующий ему список объектов. Считайте, что во множество пар
ключи не повторяются.
\item Дан список чисел. Можно ли суммой некоторых его элементов
получить
    \begin{enumerate}
    \item четное число (для списка из целых чисел)
    \item простое число (для списка из целых чисел)
    \item целое число (для списка из вещественных чисел)
    \end{enumerate}
\end{enumerate}

\subsection{Упростить выражения}
\begin{enumerate}
\item $\langle x ~|~ x \In \langle \Card \{a..b\} \rangle \rangle$
\item $\langle c ~|~ c \In \langle 'a',~'b' \rangle \rangle$
\item $\langle c ~|~ c \In \langle '$ " $' \rangle \rangle$
\item $\langle c ~|~ c \In \langle \rangle \rangle$
\end{enumerate}

\subsection{Опишите на RSL необходимые типы и спецификации функций
для следующих систем}
\begin{enumerate}
\item Опишите модуль \textsc{ARRAY}, обеспечивающий работу с массивами чисел длины
$N$. Модуль должен поддерживать следующие функции:
    \begin{enumerate}
    \item выдать длину массива
    \item выдать значение массива с по данному индексу
    \item сложить два массива
    \item скалярно перемножить два массива
    \end{enumerate}

\item Опишите модуль \textsc{STRING} со следующими функциями
    \begin{enumerate}
    \item проверка строки на пустоту
    \item константа -- пустая строка
    \item длина строки
    \item конкатенация строк
    \item проверка вхождения подстроки в данную строку
    \item выдача позиции первого вхождени подстроки в данную строку
    \item выдача позиции последнего вхождения подстроки в данную
    строку
    \item выдача количества вхождений данной подстроки в данную
    строку
    \item замена всех вхождений данной подстроки в данную строку,
    начиная с самого первого без наложений, на другую данную строку
    \item убрать из строки начальные и завершающие её пробелы
    \item составить список слов, входящих в данную строку. Слова
    разделяются пробелом, запятой или точкой.
    \end{enumerate}

\item Опишите модуль <<числовая последовательность>> со следующими операциями, возвращающими
\Bool
    \begin{enumerate}
    \item последовательность ограничена
    \item последовательность монотонно возрастает
    \item последовательность сходится
    \item$^{\star}$ числовой ряд из элементов последовательности (взятых в том же
    порядке, что и в последовательности) сходится
    \end{enumerate}

\item Опишите модуль \textsc{PAGE}, обеспечивающий работу со
страницей текста. Текст есть список строк. Строка есть список слов.
Модуль должен поддерживать следующие функции:
    \begin{enumerate}
    \item проверка того, что встречается ли данное слово на странице
    \item количество вхождений данного слова на странице
    \end{enumerate}

\item Опишите модуль поддержки типа-контейнера, в котором все
элементы различны и не упорядочены со следующими функциями
    \begin{enumerate}
    \item проверка контейнера на пустоту
    \item константа -- пустой контейнер
    \item количество элементов в контейнере
    \item добавление в контейнер элемента
    \item проверка вхождения элемента в контейнер
    \item проверка того, что все элементы первого данного контейнера
    присутствуют во втором данном контейнере
    \item построить контейнер, содержащий общие элементы данных двух
    контейнеров
    \item построить контейнер, содержащий все элементы,
    встречающиеся хотя бы в одном из двух данных контейнеров
    \end{enumerate}

\item Опишите модуль поддержки типа-контейнера, в котором операция
удаления изымает последний добавленный элемент, со следующими
функциями
    \begin{enumerate}
    \item проверка контейнера на пустоту
    \item константа -- пустой контейнер
    \item количество элементов в контейнере
    \item добавление в контейнер элемента
    \item удаление элемента из контейнера согласно приведённой
    семантике
    \item проверка вхождения элемента в контейнер
    \end{enumerate}

\item Опишите модуль поддержки типа-контейнера, в котором операция
удаления изымает первый добавленный элемент, со следующими функциями
    \begin{enumerate}
    \item проверка контейнера на пустоту
    \item константа -- пустой контейнер
    \item количество элементов в контейнере
    \item добавление в контейнер элемента
    \item удаление элемента из контейнера согласно приведённой
    семантике
    \item проверка вхождения элемента в контейнер
    \end{enumerate}

\item На основе множества реализуйте на RSL контейнер-список со
следующими функциями
    \begin{enumerate}
    \item проверка контейнера на пустоту
    \item константа -- пустой контейнер
    \item длина контейнера
    \item конкатенация двух данных контейнеров
    \item получение головы контейнера
    \item получение хвоста контейнера
    \item получение множества элементов контейнера
    \end{enumerate}

\item\label{matrix} Матрица задаётся списком списков одинаковой длины. Определите
тип <<Матрица>> и его подтипы:
    \begin{enumerate}
    \item Квадратная матрица
    \item Симметричная матрица
    \item Верхнетреугольная матрица
    \item${^\star}$ Невырожденная матрица \\ \textit{Примечание: } Следующие
    аксиомы\footnote{см. Курош. Курс высшей алгебры} определяют единственную операцию -- детерминант матрицы:
        \begin{enumerate}
        \item если одна из строк матрицы умножается на число $k$, то
        детерминант умножается на $k$
        \item детерминант не меняется, если к одной из строк
        прибавляется другая строка
        \item детерминант единичной матрицы равен 1
        \end{enumerate}
    \end{enumerate}
    Для типа <<Матрица>> определите следующие операции
    \begin{enumerate}
    \item сложение двух данных матриц
    \item вычитание двух данных матриц
    \item произведение двух данных матриц
    \item транспонирование данной матрицы
    \end{enumerate}

\item Граф задаётся своей матрицей смежности. На основе
задачи~\ref{matrix} определите тип <<Граф>> и следующие его
подтипы:
    \begin{enumerate}
    \item ориентированный
    \item неориентированный
    \item полный
    \item линейный (т.е. связный, представляющий собой цепочку вершин)
    \item двудольный
    \item связный
    \item${^\star}$ плоский
    \end{enumerate}

\item Определите тип <<Машина Тьюринга>> \\
    \textit{Примечание: } Машина Тьюринга состоит из
    \begin{enumerate}
    \item множества символов
    \item множества состояний
    \item пустого символа
    \item начального состояния
    \item множества финальных состояний
    \item лента (бесконечный список)
    \item таблицы автомата (старое состояние $\times$ символ
    $\rightarrow$ новое состояние $\times$ символ $\times$ сдвиг
    головки автомата)
    \end{enumerate}
    Запишите в типе ограничение о том, что перед началом работы слово на
    ленте должно иметь конечную длину (конечное число символов,
    отличных от пустого).

\item <<Система учёта продажи билетов в кинотеатр>>. Зал состоит из
$N$ рядов по $M$ мест в каждом. Сеанс задаётся днём (количество
дней, прошедшее с <<сегодня>> - при наступлении нового дня все
номера дней уменьшаются на единицу), названием и информацией о
проданных билетах (= 0 $\Rightarrow$ билет на это место продан; > 0
$\Rightarrow$ не продано, значение и есть цена билета на это место).
Написать определение всех необходимых типов и следующих операций:
    \begin{enumerate}
    \item выдать информацию о непроданных билетах на сегодняшний сеанс
    \item выдать ближайший показ фильма с данным названием
    \item выдать название фильма, идущего сегодня
    \item есть ли места на ближайший показ фильма с данным названием
    \end{enumerate}

\item Реализуйте модуль ассоциативного поиска со следующими
операциями
    \begin{enumerate}
    \item очистка содержимого поиска
    \item добавление пары (ключ, значение) (с проверкой уникальности
    добавляемого ключа)
    \item проверка вхождения данного ключа
    \item поиск значения по заданному ключу
    \end{enumerate}

\item Реализуйте модуль хэшированного хранения данных (размер хэш-таблицы
равен $N$, хэш-функция $f(x) = x~\textrm{mod}~M$, $M$ -- простое
число; при совпадении значения хэш-функции элемент помещается в
конец списка для данного значения хэш-функции) со следующими
операциями
    \begin{enumerate}
    \item очистка содержимого хранения
    \item добавление пары (ключ, значение)
    \item проверка вхождения данного ключа
    \item поиск значения по заданному ключу
    \end{enumerate}

\item${^\star}$ Реализуйте простой <<менеджер динамической памяти>>. Память
представить в виде списка значений. Введите список свободной памяти
и список занятой памяти. Менеджер выдаёт только непрерывные куски
памяти. Если подходящего куска нет, то менеджер выдаёт \Chaos.
Менеджер должен поддерживать следующие операции:
    \begin{enumerate}
    \item new : Amount $\widetilde{\rightarrow}$ Pointer - выделить
    новый объем памяти
    \item delete : Pointer $\widetilde{\rightarrow}$ \Unit - отдать
    кусок памяти, начало которого задаётся аргументом; возвращает
    \Chaos, если память по этому адресу уже была освобождена
    \end{enumerate}
\end{enumerate}

\subsection{Уточнение алгебраической спецификации} Для данных
аксиоматических спецификаций постройте явные или неявные
спецификации

\begin{enumerate}
\item \begin{verbatim}
type
    T, L
value
    C:L,
    f: L >< L -> L,
    g: L -~-> T
axiom
    f(C, C) is C,
    g(C) is chaos,
    all x: L :- f(C, x) is x,
    all x: L :- f(x, C) is x,
    all x, y, z: L :- f(x, f(y, z)) is f(f(x, y), z),
    all x, y : L :- x ~= C => (g(f(x, y)) is g(x))
\end{verbatim}

\item \begin{verbatim}
type
    T, L
value
    C: L,
    f: L -> Nat,
    g: L >< T -> L
axiom
    f(C) is 0,
    all x: L, y: T :- f(g(x, y)) = f(x) + 1,
    all x: L, y: T :- g(x, y) ~= C,
    all x1, x2: L, y1, y2: T :- g(x1, y1) = g(x2, y2)
        => (x1 = x2 /\ y1 = y2)
\end{verbatim}

\item \begin{verbatim}
type
    T, L
value
    f: L >< T -> L,
    g: L -~-> L
axiom
    all x: L, y: T :- g(f(x, y)) is x,
    all x1, x2: L, y1, y2: T :- f(x1, y1) = f(x2, y2)
        => (x1 = x2 /\ y1 = y2)
\end{verbatim}

\item \begin{verbatim}
type
    A, C
value
    empty: C,
    add: A >< C -> C,
    f: C -> C,
    g: C -> Bool
axiom
    f(empty) is empty,
    all x: C, y, z: A :-
        f(add(add(x, y), z)) is add(add(f(x), z), y)
        pre g(z),
    g(empty) is true,
    all x: C, y, z: A :- g(add(add(x, y), z)) is g(x)
\end{verbatim}
\end{enumerate}

%\subsubsection{Доказательство уточнения}

%\subsubsection{Построение явной по неявной}
