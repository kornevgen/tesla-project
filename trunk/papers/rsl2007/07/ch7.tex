\chapter{Недетерминизм. Параллелизм.}

Формальное определение операций смотрите в~\cite{RSLlanguage}.

\section{Модель параллельных вычислений в RSL}

Основное понятие -- \emph{вычислитель}. По-другому, вычислитель
можно называть \emph{выражением}. Поэтому каждый вычислитель имеет
свою \emph{запись} -- вычислитель можно записать на языке RSL.
Примеры вычислителей (каждый вычислитель записан в кавычках, которые
не являются частью вычислителя): <<1>>, <<1 + 3>>, <<x := 1>>.

\emph{Канал} -- некая именованная сущность, для которой определены 2
операции: послать в канал, считать из канала. В RSL для каждой из
этих операций определён свой вычислитель со следующим синтаксисом:
\begin{itemize}
\item <<имя\_канала ! вычислитель>> -- послать в канал с именем
<<имя\_канала>> результат вычисления <<вычислител>>я, результат
вычисления данного вычислителя имеет тип \Unit
\item <<имя\_канала ?>> -- считать из канала с именем <<имя\_канала>>
нечто, что и будет результатом вычисления этого вычислителя
\end{itemize}
В один момент времени канал может хранить только одно значение
определённого типа (и тип этот меняться во времени не может). Любая
посылка в занятый канал будет блокироваться до тех пор, пока канал
не будет освобождён. Любой приём из канала будет блокироваться до
тех пор, пока канал перестанет быть пустым. Ещё примеры вычислителей
(каждый вычислитель записан в кавычках, которые не являются частью
вычислителя): <<a?>>, <<x := a?>>, <<a!1>>.

Вычислители + каналы + общие переменные образуют \emph{среду
вычислений}. \emph{Результат работы} вычислителя -- есть результат
его вычисления + новое состояние среды вычислений (состояние каналов
+ значения общих переменных).

Вычислитель может описываться последовательностью других
вычислителей. Внутренние вычислители соединяются в нужном порядке с
помощью знака <<;>> (без кавычек) и выполняются слева-направо, от
первого к последнему. Тип вычислителя-последовательности есть тип
последнего вычислителя в последовательности. Типы остальных
вычислителей в последовательности должны быть $\Unit$. Примеры: <<x
:= a?; b!1>>, <<x := (x := 2; 1)>>.

Вычислитель может выдавать в разное время разные результаты своей
работы. Для этого в каждом вычислителе есть некий <<чёртик>>,
который по своему разумению выбирает из нескольких известных ему
вариантов один. У каждого чёртика есть только конечный строго
фиксированный набор вариантов. Они разделяются через
\emph{комбинатор неуправляемого выбора} (\emph{неуправляемого} --
потому что чёртик не поддаётся управлению). Обозначение в
графической нотации: $e1 \Nd e2$, обозначение в текстовой нотации:
$e1 | \widehat{\ } | e2$. Такое поведение вычислителя называется
\emph{недерминированным}. Примеры вычислителей с недетерминированным
поведением: <<$1 \Nd 2$>>, <<$x := 1 \Nd x := 2$>>, <<$x := (1 \Nd
2)$>>, <<$a ! 1 \Nd b ! 3$>>, <<$a ! (b ?)$>>.

\section{Параллельная работа вычислителей}

Вычислители могут взаимодействовать через каналы: один вычислитель
посылает в канал нечто, другой вычислитель это нечто считывает. Но
для этого вычислители должны работать \emph{параллельно}.
Параллельно работающие вычислители как раз и образуют среду
вычислений. Для такого выполнения есть соответствующий синтаксис: e1
|| e2 || e3 (это три параллельно работающих вычислителя). Комбинатор
общего паралелльного выполнения (<<||>>) одинакого записывается как
в графической, так и в текстовой нотации. Вычислитель, записанный
таким образом, завершает свою работу только тогда, когда завершат
свою работу все участники параллельной работы. Результаты всех
вычислителей должны иметь тип \Unit. В качестве состояния среды
вычислений после работы параллельного вычислителя выбирается
состояние после работы произвольного участника (во время
параллельной работы все они работают \textbf{с копией} среды
вычислений).

Стоит обратить внимание на поведение такого вычислителя: x := a? ||
a ! 1. Параллельно начинают выполняться оба участника параллельного
выполнения: x := a? , который хочет считать из канала <<a>> и
записать считанное в переменную <<x>>, и a ! 1, который хочет
записать в канал <<a>> число 1. Но при этом в среде \textbf{могут
быть и другие желающие} записать и считать в/из канала <<a>>.
Поэтому не всегда такое выполнение приведёт к тому, что в <<x>>
будет записана 1. Может быть записана и 2, например, в таком
выражении: (x := a? || a ! 1) || a ! 2.

Таким образом, оператор || не исключает вмешательства в работу
вычислителей. Если необходимо оградить параллельную работу
вычислителей от <<чужого параллельного влияния>>, применяется другой
комбинатор -- \emph{комбинатор параллелизма со взаимной
блокировкой}, или \emph{interlock-комбинатор}. Записывается он в
графической нотации так: $e1~\Ilock~e2$, а в текстовой нотации так:
$e1~++~e2$.

Некоторые вычислители записываются в виде ключевого слова. Таковыми
в языке RSL являются:
\begin{enumerate}
\item $\Skip$ -- пустой вычислитель -- ничего не делает, сразу же
завершается
\item $\Stop$ -- deadlock -- вычислитель, пребывающий в состоянии
<<мёртвого блока>>
\item $\Chaos$ -- зацикливающийся вычислитель (почти <<живой блок>> сам с
собой)
\item $\Swap$ -- вычислитель с неспецифицированным поведением
\end{enumerate}

В начале рассказа я всё-таки немного утаил правду. Чёртик бывает и
управляемый. Но только управляемый извне вычислителя -- другим
вычислителем. Поведение вычислителя с управляемым чёртиком
записывается в графической нотации так: $e1 \Exc e2$, а в текстовой
нотации так: e1 \texttt{[]} e2. Вычислитель, работающий в параллели
с таким вычислителем, может приказать управляемому чёртику не
выдавать неудобные ему (не чёртику, естественно) варианты. Например,
$(x := a? \Exc a!1) \Ilock a ! 2$. Внешний вычислитель a!2 запретит
чёртику выбирать вариант a!1, поскольку $a!1 \Ilock a!2$ то же, что
и $\Stop$, т.е. приводит к мёртвой блокировке, ведь это параллелизм
со взаимной блокировкой -- он завершится, когда завершатся все
участники, но сделать они этого не могут, потому что занят канал
<<a>>, а когда туда запишет один из вычислителей, второй записать не
сможет. И освободить канал никто не сможет -- параллелизм же со
взаимной блокировкой !

Два вычислителя называются \emph{эквивалентными}, если на одинаковые
входные данные они отвечают одинаковыми результатами работы.
% или результатами вычислений ??
Пример: $x := (z := 1; 2) \Is z := 1; x := 2$.

\section{Основные эквивалентные преобразования}

\begin{enumerate}

\item $e \Exc \Stop \Is e$
\item $e || \Skip \Is e$
\item $e \Ilock \Skip \Is e$
\item $e \Exc \Chaos \Is \Chaos$
\item $e \Nd \Chaos \Is \Chaos$
\item $e || \Chaos \Is \Chaos$
\item $e \Ilock \Chaos \Is \Chaos$
\item $e \Exc e \Is e$
\item $e \Nd e \Is e$
\item $e1 \Exc (e2 \Nd e3) \Is (e1 \Exc e2) \Nd (e1 \Exc e3)$
\item $e1 || (e2 \Nd e3) \Is (e1 || e2) \Nd (e1 || e3)$
\item $e1 \Ilock (e2 \Nd e3) \Is (e1 \Ilock e2) \Nd (e1 \Ilock e3)$
\item $(e2 \Nd e3); e1 \Is (e2; e1) \Nd (e3; e1)$



\item $x:=c? \Ilock c!e \Is x:=e$
\item $(c1!e1 \Ilock c2!e2) \Is \Stop$
\item $(x := c1? \Ilock x := c2?) \Is \Stop$
\item $(x:=c1? \Exc c2!e2) \Ilock c1!e1 \Is x:=e1$
\item $(e1 \Nd e2) \Ilock e3 \Is (e1 \Ilock e3) \Nd (e2 \Ilock e3)$
\item $(e1 \Nd e2) || e3 \Is (e1 || e3) \Nd (e2 || e3)$
\item $x:=c? || c!e \Is (x:=e) \Nd ((x:= c?; c!e)\Exc (c!e; x:=c?) \Exc
(x:=e))$
\item $c1\NEq c2\Impl\\ (x:=c1? || c2!e \Is (x := c1?; c2 ! e \Exc
c2!e; x := c1?))$
\end{enumerate}

\section{Рекомендации при упрощении выражений с параллелизмом}
\begin{enumerate}
\item Вынести <<наружу>> последовательный комбинатор (например, $x
:= (a!1; 2)$ преобразовать в $a!1; x:=2$)
\item Отдельно упростить все выражения с interlock-комбинатором
\item При упрощении выражения - параллельной комбинации -
рассмотреть все возможные варианты первого взаимодействия (обмена
сообщением по каналу) и все такие варианты поместить в
недетерминированный выбор
\item Не забывать, что в условном операторе (или операторе $\Case$)
сначала необходимо вычислить значение условия и только потом
приступать к вычислению одной из его ветвей, аналогичное утверждение
не надо забывать про арифметические операторы
\end{enumerate}

\section{Задачи}


%\subsubsection{Какие следующие тождественные преобразования верны ?}

\subsection{Выполнить эквивалентные преобразования над следующими
выражениями}

Считать, что все возможные взаимодействия произошли (т.е. в ответе
не должно оставаться подвыражений, в которых возможно
взаимодействие, например, $x := a? || a ! 1$).

\begin{enumerate}
\item $a!(5+a?)\\
|| ((x:=(x:=a?;1)) \Ilock (b!4 || x:=a? || b!6 || a!3 || y:=b?))$

\item $a!(5+(a!5;6))\\
|| ((x:=(x:=a?;1)) \Ilock (x:=a? || b!6 || a!3 || y:=b?))$

\item $(x:=(a? \Nd b?))\\
|| ((x:=(\If \True \Nd \False \Then b!1; 1 \Else x:=a?; 6 \End))
\Ilock (b!4 || a!3 || y:=b?))$

\item $\Case (a? \Nd b?) \Of \\
0 \rightarrow x:= a? + 1, \\
2 \rightarrow x:= b? , \\
3 \rightarrow y:= a? + 3, \\
4 \rightarrow y:= b? + a? \\
\End \\|| a!(b?) || a!0 || b!(a? + 4)$

\item $\Case (a?) \Of \\
0 \rightarrow x:= a? + 1, \\
2 \rightarrow x:= (b? \Nd a?), \\
3 \rightarrow y:= a? + 3, \\
4 \rightarrow y:= b? + a? \\
\End \\|| a!0 || b!(a?) || (a!2 \Nd a!3)$

\item $x:=a? || \\
\Case  (a?+b?) \Of \\
1 \rightarrow x:= 1, \\
2 \rightarrow x:= b?, \\
3 \rightarrow y:= 3, \\
4 \rightarrow y:= b? + a?, \\
5 \rightarrow \Skip\\
\End \\|| a!1 || b!(a?+2) || a!3$

\item $\Case  (a? + a?) \Of\\
1 \rightarrow x:= a? + 1, \\
2 \rightarrow \Skip, \\
3 \rightarrow y:= 3, \\
4 \rightarrow y:= b? , \\
5 \rightarrow x:= (y := a?); y\\
\End\\
  || a! (1 \Nd b?) || a!1 || b!2 || a!3 || b!1$

\item $a!(x = y) \\||
(a!\True \Ilock \\
(    b!4 || y:=x || (x:= (2+b?); (a!(x=y))) || \\
    x:=\If a? \And a? \Then 6+x \Else 0 \End\\
))\\
 || a!(x \geqslant y)$

\item $a! \False \\
|| a! (4 = b?)\\
|| ((x := (\If a? \Then x:=b?; 2 \Else b!6; x:=3; 5 \End) + x)
\Ilock (a!( \True \Nd \False); (y:=b? || b!1))$


\end{enumerate}

%\subsubsection{Для данной параллельной системы написать спецификацию на языке
%RSL}
