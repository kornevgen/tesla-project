% !Mode:: "TeX:UTF-8"
\head{Непротиворечивые алгебраические модели}

Алгебраическая модель непротиворечива, если из нее, как теории, нельзя вывести тождественную ложь.

При исследовании на непротиворечивость не стоит забывать утверждений об операциях и типах, не выраженных явно. Например, для операции f: T1 -> T2, определенной тотальным образом, справедливо, что all x, y: T1 :- f(x) $\Not$= f(y) => x $\Not$= y. Другой случай --- ограничения на типы входных и выходных параметров функции из сигнатуры (например, если тип Nat, то соответтсвующее значение должно быть всегда больше или равно нулю).

\head{Полные алгебраические модели}

В~\cite{mayer} написано: <<Не существует формального определения интуитивно ясного понятия <<полноты>> спецификации абстрактного типа данных. Строго определяемое понятие достаточной полноты как правило обеспечивает удовлетворительный ответ. ... Вопрос о полноте: <<Как узнать, что уже специфицировано достаточно свойств и можно остановиться?>> ... Для математика некоторая теория является полной, если ее аксиомы и правила вывода являются достаточно мощными, чтобы доказать истинность или ложность любой формулы, выразимой в языке данной теории. ... Здесь <<язык теории>> --- это множество правильно построенных выражений, т.е. тех выражений, которые можно построить, используя функции АТД, применяемые к аргументам соответствующих типов.

Спецификация АТД T является \emph{достаточно полной} тогда и только тогда, когда аксиомы ее теории позволяют для каждого выражения expr \textbf{без свободных переменных типа T} решить следующие задачи:

\begin{itemize}
\item[(S1)] Определить, является ли expr корректным (синтаксически и не нарушено не одно предусловие);
\item[(S2)] Если expr обсерверного вида и в пункте S1 установлена его корректность, то представить значение expr в виде, не включающем никаких значений типа T.
\end{itemize}

\head{Метод построения достаточно полных алгебраических спецификаций}

\begin{enumerate}
\item составить список требований на компонент (<<features>>);
\item выделить целевой и нецелевые типы, операции-генераторы, операции-обсерверы: операций должно быть достаточно для спецификации всех требований;
\item составить все аксиомы вида <<обсервер(генератор)>> для всех корректных пар обсерверов и генераторов, не забыв про предусловия;
\item проверить, все ли требования специфицированы; если не все, ввести дополнительные операции-обсерверы или аксиомы над цепочками генераторов и повторить предыдущий шаг.
\end{enumerate}

Написание аксиомы для терма <<обсервер(генератор)>> --- это по сути задание вопроса о поведении специфицируемого компонента (<<как он себя поведет, если сделать сначала это, а потом спросить про это? всегда ли он поведет себя одинаковым образом?>>) и формализация ответа на этот вопрос.

Для задания того, что ни одни данные, которые передаются генераторам, не теряются (т.е. попадают в состояние), удобно использовать тотальный обсервер типа индикатора. Такой обсервер по состоянию и значению данных возвращает истину, если данные присутствуют в состоянии, и ложь в противном случае.

Для задания отношений компонент внутри состояния <<1-к-1>> удобно использовать пару тотальных обсерверов. Первый по состоянию и первой компоненте вычисляет вторую компоненту, а второй обсервер, наоборот, по состоянию и второй компоненте вычисляет первую компоненту.

Для задания упорядоченности компонент внутри состояния удобно использовать обсервер типа итератора. Он по очередной компоненте возвращает следующую компоненту.

Следует помнить следующий <<психологический эффект>>: мы хотим в спецификации выразить одно, а выражаем лишь его часть (это уже не <<однозначная>> спецификация, а <<недоопределенная>>). Выделив обсерверы (т.е. по сути атрибуты состояния), и описав аксиомы, надо проверить, точно ли описаны требования на операцию-обсервер: не описан ли \emph{более общий} или \emph{более частный} случай, нежели требовалось (например, вместо для хранилища элементов без порядка не выражено отсутствие порядка). И не забывать, что термы в спецификациях --- это лишь символы: если автор спецификации предполагает, что эта-та функция добавляет нечто куда-то, эта проверяет вхождение, то, если должным образом не сузить различные варианты совпадений значений различных термов из генераторов, то спецификация окажется неправильной, хотя и составленной автором с полной уверенностью в своей правоте.

\head{Конструкторы}

Зачастую полезно функцию, которая задает <<структуру>> состояния. Например, список --- это всегда цепочка неких элементов. Эту цепочку можно составлять по порядку по одному элементу. Дерево --- это неким образом организованные вершины (а в вершинах полезная информация). Тогда дерево можно составлять, добавляя по одной вершине. Операции по такой <<инициализации>> целевого типа будем называть \emph{конструкторами}.

Цепочка вызовов конструкторов дает значение в целевом типе. Причем конструктором может быть только та операция, термами из которых можно получить все значения в целевом типе.

Аналогами конструкторов в языке Java и некоторых других языках программирования могут быть конструкторы объектов (\texttt{tree = new Tree(n, left, right)}).

Замечено, что если удается выделить конструктор вместо генераторов, то спецификации получаются более качественными. А именно, предлагается определять обсерверы и генераторы через конструкторы, т.е. вместо аксиом вида <<обсервер(генератор)>> нужно написать все аксиомы вида <<обсервер(конструктор)>> и <<генератор(конструктор)>>.

Если конструкторы являются тотальными функциями, удобно объединить их вместе с целевым типом в виде следующего \emph{вариантного определения}, при этом писать отдельно сигнатуры конструкторов не нужно:
\begin{lstlisting}
type E, T == empty | cons(E, T)
\end{lstlisting}

При этом удобно определить сразу же ряд обсерверов для получения данных, с которыми было сконструировано значение целевого типа (в этом примере определяется обсервер elem, возвращающий E по целевому типу T, если T был создан при помощи cons):
\begin{lstlisting}
type E, T == empty | cons(elem:E, T)
\end{lstlisting}

Будьте внимательны! В некоторых изданиях <<генераторами>> называют то, что здесь называется конструкторами, а <<трансформерами>> --- то, что здесь названо генераторами.

