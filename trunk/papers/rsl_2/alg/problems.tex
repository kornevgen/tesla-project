% !Mode:: "TeX:UTF-8"
\zhead{<<Эффект>> операций}
%% приходится добавлять обсерверы, чтобы полностью описать эффект функции

\z В~\cite{tanenbaum_os} описаны операции с файлами, среди них описана операция Create следующим образом: <<\textsf{Create} (создание). Файл создается без данных. Этот системный вызов объявляет о появлении нового файла и позволяет установить некоторые его атрибуты.>> Напишите алгебраическую спецификацию файловой подсистемы с этой операцией. Естественно, вам понадобится сигнатура этой операции. Вот она:  \texttt{int creat(char *path, int mode)}, параметр \texttt{path} содержит полное или относительное имя файла, параметр \texttt{mode} устанавливает атрибуты прав доступа различных категорий пользователей к новому файлу при его создании (если файл уже существовал, то новый не создается), операция возвращает значение файлового дескриптора для открытого файла при нормальном завершении и значение -1 при возникновении ошибки.

Решение:
\begin{lstlisting}
scheme FS = class
  type Path, Mode, FID, FS
  value
        creat : FS >< Path >< Mode -~-> FS >< FID,
        size: FS >< FID -~-> Nat,
        known: FS >< Path -> Bool,
        access: FS >< FID -~-> Mode,
        first: FS >< FID -> FS  first(a,b) is a
  axiom forall path: Path, mode: Mode, fs: FS :-
        size(creat( path, mode, fs )) is 0,
        known(first(creat( path, mode, fs )), path),
        access(creat( path, mode, fs)) is mode
end
\end{lstlisting}
Обратите внимание, что
\begin{enumerate}
  \item для описания эффекта функции \texttt{creat} были введены дополнительные операции-обсерверы;
  \item аксиомы напрямую выражают текст, описывающий операцию \texttt{creat} --- аксиомы формализуют \emph{требования} на эту операцию.
\end{enumerate}
Ответьте на следующие вопросы:
\begin{enumerate}
  \item эта спецификация неполная, почему? является ли она противоречивой? как, добавив 1 аксиому, полностью описать операцию known?
  \item имеют ли смысл сами по себе введенные дополнительные операции или они выполняют лишь вспомогательную для описания \texttt{creat} функцию?
  \item допустим, мы догадываемся, что Path = \textbf{Text}, а Mode = \textbf{Nat}; дополненная этим знанием спецификация, останется ли алгебраической ? станет ли полной ? останется ли непротиворечивой ? будет ли она соответствовать исходной постановке задачи ? не станет ли она допускать того, что не должно бы по условию ?
\end{enumerate}

\z В~\cite{tanenbaum_os} описаны операции с файлами, среди них описана операция Delete следующим образом: <<\textsf{Delete} (удаление). Когда файл уже более не нужен, его удаляют, чтобы освободить пространство на диске. Этот системный вызов присутствует в каждой операционной системе.>> Напишите алгебраическую спецификацию файловой подсистемы с этой операцией. Естественно, вам понадобится сигнатура этой операции. Вот она:  \texttt{void delete(const char *path)}, параметр \texttt{path} содержит абсолютный или относительный путь к файлу.

\z В~\cite{tanenbaum_os} описаны операции с файлами, среди них описана операция Open следующим образом: <<\textsf{Open} (открытие). Прежде чем использовать файл, процесс должен его открыть. Системный вызов open позволяет системе прочитать в оперативную память атрибуты файла и список дисковых адресов для быстрого доступа к содержимому файла при последующих вызовах.>> Напишите алгебраическую спецификацию файловой подсистемы с этой операцией. Естественно, вам понадобится сигнатура этой операции. Вот она:  \texttt{fid open(const char *path)}, параметр \texttt{path} содержит абсолютный или относительный путь к файлу.

\z В~\cite{tanenbaum_os} упомянут системный вызов mmap: <<Системный вызов mmap принимает на входе два параметра: имя фала и виртуальный адрес памяти, по которому операционная система отображает указанный файл. Для реализации отображения файлов на память изменяются системные внутренние таблицы.При обращении к памяти по адресу от 512 до 576К происходит прерывание из-за отсутствия страницы, обработчик которого предоставляет считанную в память страницу 0 файла.Если потом эта страница удаляется из памяти алгоритмом замены страниц, она записывается в соответствующее место файла.>>

%% понять, как описывать недопустимое поведение

%\zhead{Спецификация отношений <<многие-ко-многим>>}
%
%Алгебраические спецификации позволяют описать многие компоненты, осуществляющие отношение <<многие-ко-многим>>, совершенно не задумываясь о том, каким образом это отношение выразить чем-нибудь более известным (например, вспомните, сколько есть различных способов представления этого отношения для реляционной модели данных!)
%
%\z Специфицируйте компонент, отвечающий за хранение и модификацию данных о студентах Университета и спецкурсах. А именно, есть студенты, они добавляются в базу внутри этого компонента. Есть спецкурсы, которые также добавляются. Как-то студенты записываются на спецкурсы. Компонент позволяет

\zhead{Термы, конфлюэнтность}

\z Приведите несколько различных примеров типов и функций, удовлетворяющих спецификации:
\begin{lstlisting}
type E, S
value empty: S,
      add: S >< E -> S
axiom all e: E :- empty ~= add(empty,e)
\end{lstlisting}

\z Приведите несколько различных примеров типов и функций, удовлетворяющих спецификации:
\begin{lstlisting}
type E, S
value empty: S,
      add: S >< E -> S
axiom all e: E :- empty = add(empty,e)
\end{lstlisting}

\z Приведите несколько различных примеров типов и функций, удовлетворяющих спецификации:
\begin{lstlisting}
type E, S
value empty: S,
      add: S >< E -> S
axiom all e: E :- empty ~= add(empty,e),
all e: E :- empty = add(add(empty,e),e),
\end{lstlisting}

\z Приведите несколько различных примеров типов и функций, удовлетворяющих спецификации:
\begin{lstlisting}
type E, S
value empty: S,
      add: S >< E -> S
axiom all e: E :- empty ~= add(empty,e),
all e1,e2: E :- empty = add(add(empty,e1),e2),
\end{lstlisting}

\z Приведите несколько различных примеров типов и функций, удовлетворяющих спецификации:
\begin{lstlisting}
type E, S
value empty: S,
      add: S >< E -> S
axiom all e: E :- empty ~= add(empty,e),
all e1,e2: E :- empty ~= add(add(empty,e1),e2),
\end{lstlisting}

\z Приведите несколько различных примеров типов и функций, удовлетворяющих спецификации:
\begin{lstlisting}
type E, S
value empty: S,
      add: S >< E -> S
axiom all e1,e2: E :- add(empty,e1) = add(empty,e2)
\end{lstlisting}

\z Приведите несколько различных примеров типов и функций, удовлетворяющих спецификации:
\begin{lstlisting}
type E, S
value empty: S,
      add: S >< E -> S
axiom all e1,e2: E :- add(empty,e1) ~= add(empty,e2) pre e1 ~= e2,
all e1,e2: E :- add(empty,e1) = add(add(empty,e2),e1)
\end{lstlisting}


