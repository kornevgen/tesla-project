% !Mode:: "TeX:UTF-8"
Логико-алгебраические модели --- набор свойств, утверждений, аксиом~\cite{kuliamin}. Из этих аксиом путем логического вывода получаются другие свойства.

\head{Логическая модель на RSL}
Это набор аксиом. Аксиомы помещаются в секцию \textbf{axiom}. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y: Int :-
            add(x,y) >= x,
            add(x,y) >= y,
            add(x,0) is x,
            add(10, 45) is 55,
            exists! z : Int :- add(0, z) is x
end
\end{lstlisting}

\head{Алгебраическая модель}
Это набор аксиом вида равенства термов. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y, z: Int :-
            add(add(x,y),z) is add(x, add(y, z)),
            add(x,y) is add(y,x),
            add(x,0) is x
end
\end{lstlisting}

Алгебраические модели тесно связаны с понятием \emph{абстрактных типов данных} (АТД). Собственно, алгебраические модели являются одним из способов задания АТД. Например, <<стек --- это нечто, удовлетворяющее принципу LIFO>>:
\begin{lstlisting}
type Stack, Elem
value push: Stack >< Elem -> Stack,
      pop: Stack -~-> Elem
axiom forall s: Stack, e: Elem :-
      pop( push(s,e) ) is e
\end{lstlisting}

Идея алгебраического моделирования состоит в разделении системы на набор компонентов (похожим образом в рамках объектно-ориентированного анализа выделяются классы анализа), каждый компонент воспринимается как АТД (для них определяется функциональный интерфейс и строятся алгебраические аксиомы).

\head{Области действия, аксиомы с предусловиями}

Важно понимать \emph{область действия} аксиомы. Под такой областью будем понимать значения переменных, находящихся в самом внешнем кванторе всеобщности. Например, в последнем примере это все возможные стеки s и добавляемые элементы e. Но не во всех случаях допустимо использовать все допустимые типом значения. Например, следующая спецификация неверно описывает очередь:
\begin{lstlisting}
type Queue, Elem
value empty: Queue,
      add: Queue >< Elem -> Queue,
      first: Queue -~-> Elem
axiom forall q: Queue, e: Elem :-
      first( add(q,e) ) is e
\end{lstlisting}

Она справедлива, только если q = empty. Для ограничения области действия нужно использовать \emph{предусловия}:
\begin{lstlisting}
axiom forall q: Queue, e: Elem :-
      first( add(q,e) ) is e  pre q = empty
\end{lstlisting}

На самом деле последнюю аксиому можно записать короче:
\begin{lstlisting}
axiom forall e: Elem :-
      first( add(empty,e) ) is e
\end{lstlisting}

Предусловие обязательно для тех термов, которые определены не для всех значений переменных, находящихся под внешним квантором всеобщности.

\head{Непротиворечивые алгебраические модели}

Алгебраическая модель непротиворечива, если из нее, как теории, нельзя вывести тождественную ложь.

При исследовании на непротиворечивость не стоит забывать утверждений об операциях и типах, не выраженных явно. Например, для операции f: T1 -> T2, определенной тотальным образом, справедливо, что all x, y: T1 :- f(x) ~= f(y) => x ~= y.

\head{Полные алгебраические модели}

В~\cite{mayer} написано: <<Не существует формального определения интуитивно ясного понятия <<полноты>> спецификации абстрактного типа данных. Строго определяемое понятие достаточной полноты как правило обеспечивает удовлетворительный ответ. ... Вопрос о полноте: <<Как узнать, что уже специфицировано достаточно свойств и можно остановиться?>> ... Для математика некоторая теория является полной, если ее аксиомы и правила вывода являются достаточно мощными, чтобы доказать истинность или ложность любой формулы, выразимой в языке данной теории. ... Здесь <<язык теории>> --- это множество правильно построенных выражений, т.е. тех выражений, которые можно построить, используя функции АТД, применяемые к аргументам соответствующих типов.

Спецификация АТД T является \emph{достаточно полной} тогда и только тогда, когда аксиомы ее теории позволяют для каждого выражения expr \textbf{без свободных переменных типа T} решить следующие задачи:

\begin{itemize}
\item[(S1)] Определить, является ли expr корректным (синтаксически и не нарушено не одно предусловие);
\item[(S2)] Если expr обсерверного вида и в пункте S1 установлена его корректность, то представить значение expr в виде, не включающем никаких значений типа T.
\end{itemize}

\head{Обсерверы, генераторы}

Даже если для специфицируемого компонента не моделируется состояние, это не означает, что его нет. Оно есть. Это значит, что есть и операции, которые переводят компонент из одного состояния в другой. Будем называть такие операции \emph{генераторами}. Но поскольку идея property-based моделирования в описания эффекта, который осуществляют операции, нужны способы описания состояний. Воспользуемся атрибутным описанием: для состояния будем определять его описывающие атрибуты. Такие операции-атрибуты будем называть \emph{обсерверами}. Их аналогами в языке Java и некоторых других языках программирования являются методы-getter'ы.

В алгебраической спецификации обязательно будет присутствовать тип для состояния компонента --- \emph{целевой тип}. В операции-обсервере одним из аргументов должен быть целевой тип. В операции-генераторе один из возвращаемых значений должен быть целевого типа. Пример:
\begin{lstlisting}[escapeinside=`']
type Queue, - - - `целевой тип'
     Elem - - - `это не целевой тип'
value add: Queue >< Elem -> Queue, - - - `генератор'
      first: Queue -~-> Elem - - - `обсервер'
\end{lstlisting}

% что делать с функциями, у которых два целевых типа на входе?

% что делать с функциями, у которых два целевых типа на выходе? --- их можно разделить на две функции

\head{Метод построения достаточно полных алгебраических спецификаций}

Выделить целевой и нецелевые типы, операции-генераторы, операции-обсерверы и составить все аксиомы вида <<обсервер(генератор)>> для всех корректных пар обсерверов и генераторов, не забыв про предусловия. Спецификация с каждой такой парой --- это по сути задание вопроса о поведении специфицируемого компонента (<<как он себя поведет, если сделать сначала это, а потом спросить про это? всегда ли он поведет себя одинаковым образом?>>) и формализация ответа на этот вопрос.

Может потребоваться введение дополнительных обсерверов, чтобы полностью описать эффект генератора.

\head{Конструкторы}

Зачастую полезно функцию, которая задает <<структуру>> состояния. Например, список --- это всегда цепочка неких элементов. Эту цепочку можно составлять по порядку по одному элементу. Дерево --- это неким образом организованные вершины (а в вершинах полезная информация). Тогда дерево можно составлять, добавляя по одной вершине. Операции по такой <<инициализации>> целевого типа будем называть \emph{конструкторами}.

Цепочка вызовов конструкторов дает значение в целевом типе. Причем конструктором может быть только та операция, термами из которых можно получить все значения в целевом типе.

Аналогами конструкторов в языке Java и некоторых других языках программирования могут быть конструкторы объектов (\texttt{tree = new Tree(n, left, right)}).

Замечено, что если удается выделить конструктор вместо генераторов, то спецификации получаются более качественными. А именно, предлагается определять обсерверы и генераторы через конструкторы, т.е. вместо аксиом вида <<обсервер(генератор)>> нужно написать все аксиомы вида <<обсервер(конструктор)>> и <<генератор(конструктор)>>.

Если конструкторы являются тотальными функциями, удобно объединить их вместе с целевым типом в виде следующего \emph{вариантного определения}, при этом писать отдельно сигнатуры конструкторов не нужно:
\begin{lstlisting}
type E, T == empty | cons(E, T)
\end{lstlisting}

При этом удобно определить сразу же ряд обсерверов для получения данных, с которыми было сконструировано значение целевого типа (в этом примере определяется обсервер elem, возвращающий E по целевому типу T, если T был создан при помощи cons):
\begin{lstlisting}
type E, T == empty | cons(elem:E, T)
\end{lstlisting}

Будьте внимательны! В некоторых изданиях <<генераторами>> называют то, что здесь называется конструкторами, а <<трансформерами>> --- то, что здесь названо генераторами.

\head{Определение рекурсивных типов (деревьев)}
Алгебраические модели и АТД являются удобным способом задания рекурсивных типов и операций их обработки. Для этого представленный только что формальный метод построения достаточно полных алгебраических спецификаций прочитывается следующим способом:
\begin{enumerate}
  \item выделить и составить сигнатуры конструкторов (пустое значение | составление нового <<узла дерева>>);
  \item выделить и составить сигнатуры функций-обработчиков рекурсивного типа;
  \item описать результат обработки для каждого конструктора.
\end{enumerate}

Например, спецификация функции, вычисляющей глубину бинарного дерева, согласно этому методу получается такой:
\begin{lstlisting}
type Node, Tree == empty | mk_tree(Node, Tree, Tree)
value depth: Tree -> Nat
axiom forall n: Node, left: Tree, right: Tree :-
  depth( empty ) is 0,
  depth( mk_tree(n, left, right) ) is
          max( depth(left), depth(right) )
value max: Nat >< Nat -> Nat
   max(x,y) is if x > y then x else y end
\end{lstlisting}

Конструктор предназначена лишь для структурных целей, т.е. определение дерева в виде типа Tree из этого примера пойдет и для бинарного дерева произвольного вида, и для бинарного сбалансированного дерева, и для других бинарных деревьев. А уже менее тривиальные функции составления деревьев (например, чтобы не нарушалась сбалансированность) определяются в виде функций-обработчиков.

\head{Конфлюэнтность}

Хотя специфицируются абстрактные типы данных, множество значений этих типов всё же можно выразить --- в виде множества термов. Например, для базы данных это может быть add(<<Иванов>>, 200, add(<<Петров>>, 500, empty)). Терм соответствует некоторому состоянию моделируемой системы. Проблема того, что два разных терма означают одно и то же состояние, неразрешима\footnote{Взяв первый терм, пытаемся вставить его на место аргументов в аксиомах и применить преобразование из этой аксиомы. Так получаем новый терм. К нему применяем то же правило --- получаем еще один терм. И так делаем до тех пор, пока не получив данный второй терм. Если процесс составления новых термов завершился, значит термы означали одинаковые состояния. А если процесс не завершится, то разные. Получается <<алгоритм>>, который должен зацикливаться. Естественно, это означает отсутствие алгоритма в правильном понимании этого слова.}. Из-за этого не всегда очевидно при анализе системы, проанализировав ее на ряде цепочек, во всех ли состояниях она проанализирована.

Хороши те системы аксиом, которые дают \emph{нормальные формы} термов. Системы с такими аксиомами проще анализировать и проще понимать их смысл, поскольку есть понятная классификация состояний-термов. Например, для списка состоянием является последовательность элементов $\langle x_1, x_2, ..., x_n \rangle$ --- очевидно алгебраическое представление списка, являющееся нормальной формой: \texttt{cons($x_1$, cons($x_2$, ..., cons($x_n$, nil) ... ))}; В случае нормальной формы можно даже сформулировать условия достаточности: для полного анализа достаточно исследовать все свойства только на термах, являющихся нормальными формами.

Итог: при выделении операций-генераторов надо постараться так, чтобы каждое значение целевого типа имело единственной представление в виде терма из этих операций (т.н. \emph{нормальная форма}). В том числе может быть придется добавить дополнительные аксиомы, чтобы было возможно при помощи них доказательно отождествить разные термы.

Но и выделив нормальную форму, при написании аксиом нельзя забывать о существовании термов, не находящихся в нормальной форме: для них аксиома тоже должна быть справедлива. Пример: множество -- не забыть аксиому add(a, add(b,c)) is add(b, add(a,c))   (нормальная форма: add(add(add с возрастающими аргументами, в том числе без повторов). Например, правильной аксиомой для delete(add) будет для множеств такая: delete(x, add(y,s)) is if x = y then delete(x,s) else add(y, delete(x,s)) end (т.е. в then ветви не просто s, а delete(x,s) -- вдруг x встретится \textbf{в терме} еще раз).

