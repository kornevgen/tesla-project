% !Mode:: "TeX:UTF-8"

\emph{Функция} в данном курсе будет пониматься точно так же, как она понимается в математике, а именно, как отображение одного множества на другое. Для простоты можно понимать функцию как совокупность пар (x, y). Функции могут быть однозначные и многозначные (или, на более привычном для программистов языке, детерминированными и недетерминированными), т.е. либо для каждого х есть не более одной пары (x, y), либо таких пар может быть несколько. Каждая функция обладает \emph{областью определения}, т.е. множеством всех x из пар (x, y).

В математике нет понятия <<вызвать функцию>>, есть понятие <<применить функцию>>. Скажем, пусть f --- функция, x' принадлежит области определения f. Тогда применение функции f к x' (обозначать это будем стандартным образом: <<f(x')>>) есть недетерминированный выбор всех таких y', что в f, как совокупности пар, есть пара (x', y').

Эти определения формализуют знакомое всем определение функций, в котором подчеркивается, что функция --- это лишь математический объект, это не процесс, функция (в данном курсе) не исполняется во времени (если так проще понимать, можно считать, что функции <<работают мгновенно>>) и у функций (в отличие, например, от функций в языке Си) есть область определения (функцию в языке программирования можно вызывать с любыми аргументами, которые допустимы согласно статической типизации).

Однако функциям можно сопоставить ряд понятий, знакомых любому программисту. Например, если абстрагироваться от вычислительных и временных свойств, то каждой функции на языке программирования соответствует осуществляемое ею \emph{отображение}, что и есть функция, как она определена в данном разделе. Другой пример: операции пользователя с системой также можно промоделировать при помощи таких функций (хотя напрямую в коде реализации системы таких функций может и не быть, отдельные части таких функций могут быть распределены по различным функциям в коде реализации).

С точки зрения формальных спецификаций нас в этом курсе будут интересовать свойства функций, способы задания свойств функций и способы получения (вывода) новых свойств из имеющихся. Важно понимать, что функция сама по себе есть некий объект с операцией применения, а спецификация функции --- это набор свойств функции (но не сама функция). Одному и тому же набору свойств может соответствовать несколько функций. И, наоборот, для одной функции можно сформулировать массу различных свойств.

Свойства функций поделим на 2 класса --- синтаксические и семантические свойства. Синтаксические свойства функции --- это, проще говоря, сигнатура функции (имя функции, количество и типы её параметров). Важно понимать, что именно при помощи сигнатуры функции задается область определения функции. А именно, все значения параметров, удовлетворяющие своим типам, образуют область определения функции.

Семантические свойства функции --- это свойства отображения входных данных на выходные, которое осуществляет функция. Семантические свойства задаются при помощи предикатов над значениями аргументов функции и значения функции при этих аргументах. Примеры семантических свойств функции для функции $f$ с одним аргументом типа $\Int$ (любое целое число) и результатом тоже типа $\Int$:

\begin{itemize}
  \item $f(0) = 0$ (утверждается значение функции при заданном значении её аргументов);
  \item $\All x: \Int ~\SuchAs~ f(x) = -f(-x)$ (нечетность функции);
  \item $\Exists x: \Int ~\SuchAs~ f(x) \equiv \Chaos$ (функция на каком-то значении аргумента зацикливается);
  \item $f(x) = x + 1$, если $x = 0, 1, 2, .., 10$ (частичное задание функции);
  \item $f(x) = x + 1$, если $x = 0, 1, 2, ..., 10$, $f(x) = 0$, иначе (полное задание функции);
  \item у функции $f$ 1 аргумент (синтаксическое свойство функции);
  \item $f(0)$ может равняться 0 или 1 (это свойство можно трактовать двояко - либо функция $f(x)$ ведет себя \emph{недетерминированно} при $x = 0$ и может вернуть число 0 или число 1 (т.е. при работе программы с такой функцией могут возникнуть оба значения), либо функция $f(x)$ ведет себя детерминированно при $x = 0$ и $f(0)$ равняется одному из чисел 0 или 1 (при работе программы с такой функцией может возникнуть только одно из чисел)).
\end{itemize}

Запись синтаксических свойств функции на языке RSL описана в предыдущем разделе. Для записи семантических свойств функций язык RSL предлагает пользоваться \emph{аксиомами}. Например, свойство $f(0) = 0$ будет записано следующим образом:

\begin{lstlisting}
value f: Int -~-> Int
axiom f(0) is 0
\end{lstlisting}

Свойство нечетности функции:
\begin{lstlisting}
value f: Int -~-> Int
axiom all x: Int :- f(x) is -f(-x)
\end{lstlisting}

Частичное определение функции можно дать следующим образом:
\begin{lstlisting}
value f: Int -~-> Int
axiom all x: Int :- x >= 0 /\ x <= 10 => f(x) is x+1
\end{lstlisting}

Но нагляднее будет воспользоваться \emph{\textbf{pre}-выражением}, ограничивающим область значений подкванторных переменных:
\begin{lstlisting}
value f: Int -~-> Int
axiom all x: Int :-
        f(x) is x + 1 pre x >= 0 /\ x <= 10
\end{lstlisting}

Полное определение можно дать с использованием одной аксиомы:
\begin{lstlisting}
value f: Int -~-> Int
axiom all x: Int :-
    f(x) is (if x >= 0 /\ x <= 10 then x+1 else 0 end)
\end{lstlisting}

или так:

\begin{lstlisting}
value f: Int -~-> Int
axiom all x: Int :-
    (x >= 0 /\ x <= 10 => f(x) is x + 1) /\
    ((x < 0 \/ x > 10) => f(x) is 0)
\end{lstlisting}

или с использованием двух аксиом:
\begin{lstlisting}
value f: Int -~-> Int
axiom
all x: Int :- f(x) is x + 1  pre x >= 0 /\ x <= 10,
all x: Int :- f(x) is 0  pre x < 0 \/ x > 10
\end{lstlisting}

можно воспользоваться конструкцией forall для сокращения количества кванторов всеобщности:
\begin{lstlisting}
value f: Int -~-> Int
axiom forall x: Int :-
    f(x) is x + 1  pre x >= 0 /\ x <= 10,
    f(x) is 0  pre x < 0 \/ x > 10
\end{lstlisting}

\head{Спецификация тотальных функций}

Если рассматривать однопроцессные однопотоковые невзаимодействующие с окружением программы, которые должны результативно завершаться (и только тогда такие программы имеют смысл), то про функции в программах можно говорить следующее:
\begin{itemize}
  \item на некоторых данных функция завершается;
  \item на некоторых данных функция завершается и ее результат детерминирован (т.е. будет точно таким же, если вызвать функцию с теми же аргументами и значениями глобальных переменных);
  \item на некоторых данных функция завершается и ее результат недетерминирован;
  \item на некоторых данных функция зацикливается (программа <<повисла>>);
  \item во время работы функция пытается выполнить недопустимую операцию (программа <<упала>>).
\end{itemize}

Для работы программы важно, чтобы ее функции не зацикливались и не <<падали>> как минимум на некотором <<нужном>> множестве входных данных (в противном случае этой функцией нельзя будет пользоваться). Аналогом таких функций в программах (которые не должны зацикливаться и <<падать>>) являются тотальные функции.

Будем называть функцию \emph{тотальной}, если в этой функции каждому значению из области определения соответствует единственное значение.

Переводя это на язык функций в языках программирования, можно сказать, что таким функциям в спецификации следует писать тотальную функцию, если для исходной функции на всех значениях входных параметров, соответствующих их типам, выполнены оба следующих свойства:
\begin{enumerate}
  \item она результативно завершима (т.е. не зацикливается и не падает ни при каком значении аргументов и глобальных переменных);
  \item её результат детерминирован (если функция вызывается в разное время с теми же аргументами и в том же состоянии глобальных переменных, то она возвращает одинаковые значения и одинаковым образом изменяет глобальные переменные).

%  \item она всюду определена (функция возвращает какое-либо значение на каждом значении аргументов и глобальных переменных, согласно их типам);
\end{enumerate}

Тотальность функции является синтаксическим свойством и входит в сигнатуру функции. А именно, в функции, которая должна быть тотальной, вместо стрелки $\NonDetermFn$ ставится стрелка $\Fn$. Однако спецификация может не содержать требования функции быть тотальной, но в коде реализации эта функция в действительности будет тотальной. Иначе говоря, \textit{стрелка $\NonDetermFn$ в сигнатуре не означает, что функция не является тотальной}. Стрелка $\NonDetermFn$ означает, что функция может быть какой угодно, как тотальной, так и нетотальной.

\head{Полное определение функции. Случай недоспецификации}

Набор синтаксических и семантических свойств будем называть \emph{определением} функции, если семантические свойства дают возможность однозначно судить о значениях функции при всех входных данных, допустимых сигнатурой функции (грубо говоря, спецификация функции является определением, если этой спецификации соответствует единственная функция, и поэтому можно даже вычислить значение функции при любом заданном значении входных параметров; единственная функция не означает единственного значения при каком-либо аргументе функции, т.е. существуют спецификации, дающие определение недетерминированных функций).

Спецификацию функции будем называть \emph{полной}, если она позволяет сделать вывод о значении функции при \textbf{каждом} значении ее аргументов и глобальных переменных (т.е. если эта спецификация дает определение функции). Остальные спецификации будем называть \emph{неполными}, или \emph{частичными}. При частичном задании удобно использовать \textbf{pre}-выражения (примеры были даны выше).

Пример полной спецификации:
\begin{lstlisting}
value f: Int >< Int -> Int
axiom forall x, y: Int :-
    f(x, y) is x + y pre x > y,
    f(x, y) is x - y pre x <= y
\end{lstlisting}
При каждом значении пары (x, y) в этой спецификации задано значение функции f. Тем самым эта спецификация функции f является полной.

Пример неполной спецификации:
\begin{lstlisting}
value f: Int >< Int -> Int
axiom forall x, y: Int :-
    f(x, y) is x + y pre x > y
\end{lstlisting}
Из этой спецификации можно сделать вывод о значении функции f на тех парах (x, y), где x > y, но нельзя сделать вывод  о значениях функции f на остальных парах. Тем самым, эта спецификация функции f является неполной. Эту спецификацию можно \emph{доопределить} до полной спецификации бесконечным числом способов (не нарушая требования тотальности функции f). Спецификацию, в которой есть неполная спецификаций какой-либо функции (или глобальной переменной --- полной спецификацией глобальной переменной назовем ту, в которой указано начальное значение переменной), будем называть \emph{недоспецификацией}.

Следующая спецификация также является недоспецификацией, хотя ее доопределение во многих случаях не делается:
\begin{lstlisting}
value f: Int >< Int -> Int
axiom forall x, y: Int :-
    f(x, y) is x / y pre y ~= 0
\end{lstlisting}

%"моделью" является полная спецификация..... но слово "модель" плохое, т.к. оно в русском языке используется много где. Class - это класс моделей: всевозможные доопределения до полной спецификации.

\head{Явные и неявные спецификации}

Спецификацию функции $f$ будем называть \emph{явной}, если эта спецификация имеет вид $f(x_1, x_2, ..., x_n) ~\Is~ e$, где $x_1, ..., x_n$ --- (свободные) переменные, $e$ --- выражение от этих переменных (возможно с некоторым пре-выражением). Явная спецификация дает возможность указать (явно) выражение для вычисления значения функции. Явная спецификация всегда является определением функции.

Спецификацию функции будем называть \emph{неявной}, если эта спецификация имеет вид предиката от значений входных и выходных значений функции. Неявная спецификация является определением функции только в том случае, если предикат однозначно разрешается в значения выходных данных.

Для записи неявных спецификаций используется \emph{\textbf{post}-выражение}:
\begin{lstlisting}
value f: Int >< Int -> Int
axiom forall x, y: Int :-
    f(x, y) as z  post z > 0
\end{lstlisting}
Последняя строчка является корректным \textbf{логическим} выражением в языке RSL. Оно означает, что функция f на аргументах x и y должна \textbf{завершаться детерминированно}, обозначаем z возвращенное функцией значение, и это значение должно быть положительным числом. Эта неявная спецификация не является определением, поскольку может быть доопределена до полной спецификации несколькими способами. Вот пример полной неявной спецификации:
\begin{lstlisting}
value f: Int >< Int -> Int
axiom forall x, y: Int :-
    f(x, y) as z  post z = x + y
\end{lstlisting}
Как и любое логическое выражение, post-выражение может быть помещено внутрь pre-выражения:
\begin{lstlisting}
value f: Int >< Int -> Int
axiom forall x, y: Int :-
    f(x, y) as z  post z > 0 pre x > y,
    f(x, y) as z  post z = x - y pre x <= y
\end{lstlisting}

Кроме явных и неявных спецификаций могут быть спецификации, не являющиеся явными и не являющиеся неявными (например, свойство нечетности результата не является свойством результата одного вычисления функции).

\head{Детерминированные и недетерминированные функции}

Недетерминированная функция в языке RSL задается только при помощи следующих выражений:
\begin{enumerate}
  \item неявный let (по определению, значение для определяемой в let переменной выбирается случайным недетерминированным образом);
  \item одна из форм case (не будем вдаваться в детали, что это за форма);
  \item комбинатор недетерминированного выбора.
\end{enumerate}

Пример:
\begin{lstlisting}
value f: Int >< Int -~-> Int
axiom forall x, y: Int :-
    f(x, y) is let z : Int :- z > 0 in z end
\end{lstlisting}

Эта спецификация содержит требование того, что все возможные вычисления функции f равны всем возможным вычислениям выражения \textbf{let} z : \textbf{Int} $~\SuchAs~$ z > 0 \textbf{in} z \textbf{end} (потому что между ними находится оператор тождественности is). Этот неявный let возвращает произвольное значение, удовлетворяющее соответствующему предикату, недетерминированным образом. Иными словами, спецификация утверждает, что функция f должна быть недетерминированной (обратите внимание на стрелку в сигнатуре) и возвращать произвольное положительное число.

Стоит отметить, что неполное определение при помощи post-выражения не является спецификацией недетерминированной функции (наоборот, оно \textbf{по определению} описывать только детерминированные функции). Например, следующая спецификация описывает детерминированную функцию (по определению post-выражения), просто про ее результат известно, что он положительный, но он будет ровно тем же положительным числом, если эту функцию вызывать несколько раз с одними и теми же аргументами.
\begin{lstlisting}
value f: Int >< Int -~-> Int
axiom forall x, y: Int :-
    f(x, y) as z post z > 0
\end{lstlisting}

Недетерминированная функция не является тотальной, поэтому в сигнатурах недетерминированных функций всегда ставится стрелка $\NonDetermFn$.


\head{Примеры спецификаций. Краткая форма некоторых аксиом.}

Итак, спецификации (т.е. <<наборы свойств>>) бывают:
\begin{itemize}
  \item требующими тотальности / не требующими тотальности;
  \item полными / неполными;
  \item явными / неявными / просто набор аксиом.
\end{itemize}

Ряд спецификаций дают определение функции, ряд спецификаций не дают определений (просто формулируют набор свойств).

Пример тотальной полной явной спецификации функции:
\begin{lstlisting}
value add: Int >< Int -> Int
axiom forall x, y : Int :- add(x,y) is x+y
\end{lstlisting}

Это же определение удобно записывать более кратко следующим образом:
\begin{lstlisting}
value add: Int >< Int -> Int
    add(x,y) is x+y
\end{lstlisting}
Эту запись можно понимать двояко: как прототипный алгоритм вычисления функции add, и как следующее требование (или, свойство): <<функция add должна возвращать то же значение, что и значения выражения x+y>>. Важное замечание: в языке RSL тип $\Int$ включает в себя как представимые в ЭВМ целые числа, так и непредставимые. Этот факт следует учитывать при написании спецификаций.

Пример нетотальной полной явной спецификации функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
\end{lstlisting}
Эта спецификация утверждает, что функция при y $\neq 0$ должна быть детерминированно завершима. При y = 0 эта функция должна вести себя так же, как вычисляется выражение x$/0$ в RSL, т.е. <<зацикливаться/падать>> (иными словами, спецификация предписывает функции <<зациклиться/упасть>>).

Пример нетотальной неполной явной спецификации функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
axiom forall x, y : Int :- add(x,y) is x/y pre y ~= 0
\end{lstlisting}
Или более кратко следующим образом:
\begin{lstlisting}
value add: Int >< Int -~-> Int
    add(x,y) is x/y
    pre y ~= 0
\end{lstlisting}

Эта спецификация требует, чтобы функция add при y $\neq 0$ детерминированно завершалась. При y = 0 эта функция может себя вести как угодно (т.е. может даже завершиться результативно, например, возвратить 0).

Еще один пример нетотальной полной явной спецификации функции:
\begin{lstlisting}
value some: Int -~-> Int
some(x) is
    local variable n:Int := x in
        while n ~= 1 do
            if n \ 2 = 0 then n := n/2
                else n := 3 * n + 1 end
        end;
        n
    end
\end{lstlisting}
Про эту функцию именно что неизвестно, завершима ли она при любом целом значении аргумента.

И еще один пример нетотальной полной явной спецификации функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x+y
\end{lstlisting}
Ничего не мешает объявить эту функцию тотальным образом, но допустимо ее определение и нетотальным (например, по причине того, что на момент написания функции неизвестно, должны ли для нее быть выполнены свойства тотальной спецификации).

Пример нетотальной неполной явной спецификации функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
pre x > 2 /\ y > 4
\end{lstlisting}

Эта спецификация не запрещает вызывать функцию с аргументами, на которых \textbf{pre}-выражение ложно. Просто, для этих значений аргументов спецификация ничего не требует от функции --- она может возвращать любые значения, она может зацикливаться, она может <<падать>>, она может вести себя недетерминированно. 