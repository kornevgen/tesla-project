% !Mode:: "TeX:UTF-8"
% !TeX root = rslbook.tex
%\pagebreak
\section*{Зачем нужен этот курс (вместо вступления)}
\addcontentsline{toc}{chapter}{Зачем нужен этот курс (вместо вступления)}

Данный сборник задач написан в поддержку курса <<Формальная спецификация и верификация программ>>, который читается студентам последних курсов факультета ВМК МГУ.

Бытует точка зрения, что профессия программиста --- писать код, конструировать программу на языке программирования. Чем больше качественного кода ты пишешь (в срок!), тем более ты профессионален, как программист. А те, кто код не пишут, занимаются проектированием (<<дизайном>>) программы, чтобы написание программы было удобным, сам дизайн гибким и прочее, и прочее, и прочее. При всём при этом \emph{неявно предполагается}, что все предварительные действия для проектирования и кодирования очевидны и не стоят обстоятельного внимания программиста. В первую очередь в такое, неявное, может уходить тщательная проработка логической части программы. Это, во-первых, задачи, которую должна решать программа, во-вторых, те термины и их взаимосвязи, которые должна обеспечивать и поддерживать программа, в-третьих, то, как программа должна себя вести в различных ситуациях, какие ситуации программа не должна допускать, какие соотношения между оперируемыми понятиями программы она должна поддерживать. Глубокой ошибкой программиста будет думать, что эти вещи просты, тривиальны, очевидны, а, следовательно, не должны его сильно занимать. При таком отношении на финальных стадиях кодирования и отладки может оказаться, что что-то недодумано, что-то неучтено, из-за чего приходится хорошо если просто переделать некую небольшую часть программы, а то и, возможно, придется переписывать всё с нуля. А какие-то проблемы (например, неучтенные ситуации в поведении программы) могут выявиться только на этапе эксплуатации... (и чем выше цена ошибки, тем горше будет ее результат)

В рамках курса постараемся поработать, проанализировать как постановку задачи, так и (на понятийном уровне) тот проект (дизайн) кода, который будет предлагать программист. В двух словах, проанализировать --- значит, как минимум, выделить и зафиксировать, над какими понятиями работает программа, какие действия над ними совершает, частично описать эти действия теоретически, описать решаемую программой задачу (требования), описать в виде предикатов (<<декларативно>>) достижимые и разрешенные состояния (значения) этих понятий (в виде инвариантов), описать требуемые изменения значений при помощи действий на более общем уровне, чем это было бы в коде программы. Построив такую \emph{формальную модель программы}, взглянув на свою программу <<по-другому>> (как минимум, декларативно вместо конструктивно), есть гипотеза, что программист сможет увидеть больше особенностей в той задаче, которую решает программа, и в том, как она решает эту задачу.

Итак, цель курса --- видеть свойства программ, уметь представить эти свойства в проверяемой форме. Под свойствами программ в первую очередь понимаются свойства корректности. 

Профессионализм программиста, на самом деле, не только в том, сколько строчек качественного кода он выдает в сутки, но и в том, насколько глубоко он задумался над логикой работы программы, сколько вопросов он поставил перед собой (или другими, кто участвует в написании программы) по поводу поведения и результатов работы программы и насколько он ответил на эти вопросы.

%Основная задумка авторов курса --- чтобы в будущем студент при разработке крупных и ответственных программ задумывался не только над тем, какими технологиями, фреймворками и библиотеками воспользоваться и как организовать производственный процесс (что тоже, конечно, важно), но и над более декларативными вопросами: какими функциональными свойствами должна обладать разрабатываемая система, какие ограничения она должна поддерживать, какие ситуации она не должна допускать и какие ситуации составляют все возможные для нее --- что может повлиять на выбор тех или иных конструкторских решений, повысив корректность, взглянуть на уже написанную программу <<под другим углом>>, обнаружив, тем самым, неучтенные случаи, или составив (в голове или на бумаге) ясную картину того, как должна себя вести программа, что становится не так тривиально представить после долгого срока жизни программы и изменения требований к ней.

Курс <<Формальной спецификации и верификации программ>> практически не касается \emph{формальных методов} разработки программ (которые сегодня представляются в виде разработки, основанной на моделях, где программный код получается автоматически из модели, и использования утверждений специального вида для автоматизации тестирования программ), поскольку это тема отдельного практического курса.

%Под <<формальной>> спецификацией понимается строгое однозначное задание (описание) интерфейса или поведения программы. До сих пор необходимость доведения описаний до строгих однозначных форм ставится под сомнение, если речь идет о совершенно произвольных программах (как минимум, это сталкивается с высокой трудоемкостью формальной спецификации и особенной квалификацией тех, кто эту спецификацию составляет). Хотя полезность (и даже необходимость) строгого однозначного задания \emph{критичных} систем сомнений не вызывает. И тем не менее понижение трудоемкости и сближение формальных спецификаций с программистами-инженерами (т.е. существенное расширение области реального использования формальных спецификаций) является актуальной задачей в области технологий программирования (software engineering).
%
%Однако дабы не попадать в дискуссионную область, курс следует иному принципу. Реалии таковы, что кроме написания программ необходимо, чтобы эти программы были корректными, чтобы они удовлетворяли стандартам. Для решения задач обеспечения таких характеристик применяются \emph{в том числе и} математические методы. Это означает, что программа выражается в математических терминах в виде \emph{математической теории}, или \emph{математической модели}, и задача уже решается в рамках этой математической теории с применением математического аппарата. Эта идея может показаться малоприменимой на практике, поскольку обычно математики и программисты-инженеры живут <<в разных мирах>>. На самом же деле математические методы решения задач над программами (их еще называют \emph{формальными методами}, подчеркивая, что <<обычный>> программист-инженер работает в своем <<неформальном>> мире представления о своей программе) исторически возникли практически сразу с возникновением практического программирования (это 50-е годы ХХ века) и развиваются по настоящее время.
%
%Математическая теория, создаваемая для программы, это и есть формальная спецификация. От природы этой спецификации будут зависеть и математические методы, применяемые для решения задачи. Математическая теория не создается сама по себе --- она создается для конкретных целей, для решения определенных задач: формализация требований с целью, во-первых, их прояснения, во-вторых, для выяснения в них противоречий и неполных требований, автоматизация тестирования, чёткая документация, формальная верификация и даже разработка программ при помощи формальных моделей. Единожды проведя формализацию, можно существенно снизить <<человеческий>> фактор на последующих этапах жизненного цикла программы.
%
%Эта часть курса посвящена тому, какие на данный момент придуманы виды моделей, какой природы математические теории используются для описания программ. Вторая часть курса посвящена одному из применений формальных спецификаций --- формальной верификации программ.
%
%Читатели могут столкнуться с <<моделями программ>> не впервые. Студенты ВМиК МГУ слушают перед этим курсом курс по объектно-ориентированному анализу и проектированию программ и курс по верификации программ на моделях (model checking). Отличия этого курса от уже прослушанных заключаются в следующем. Курс ООАП также работает с моделями, но многие из этих моделей ориентированы только на последующее кодирование, а не на анализ программ. Грубо говоря, речь идет о моделировании структуры кода, а не семантики программы. Кроме того, строгий, формальный, подход практически никак не отражен в этом курсе. В курсе верификации на моделях рассматривается инструмент SPIN и моделирование на языке PROMELA. Остальные виды моделей программ в этом курсе не рассматриваются, но рассматриваются в данном курсе.
%
%Согласно одной из принятых классификаций выделяют следующие основные виды моделей программ:
%\begin{itemize}
%  \item логико-алгебраические модели (interface specification: property-based / state-based);
%  \item исполнимые модели (behavior specification);
%\end{itemize}
%Кроме того, выделяют модели, совмещающие в себя характеристики логико-алгебраических и исполнимых моделей.
%
%Исполнимые спецификации дают модель в виде программы для некоторой виртуальной машины, может быть, достаточно абстрактной. В основном, это различные виды конечных автоматов и систем переходов (LTS). К таким моделям относятся модели на PROMELA, уже знакомые читателям. Кроме того, с конечными автоматами они сталкивались достаточно часто в предыдущих курсах. Поэтому в этом курсе исполнимые модели не будут рассматриваться подробно.
%
%Логико-алгебраические модели рассматривают операции программы в математическом смысле, как отображения аргументов и пре-состояния на значения-результаты операций и пост-состояния\footnote{потому такие модели не являются исполнимыми в общем случае --- попробуйте для любой функции, заданной отображением, автоматически построить программу, которая ее исполняет!}. Чистые \emph{логические модели} представляют собой набор аксиом, из которых следуют эти отображения. \emph{Алгебраические модели} описывают эквивалентности суперпозиций операций (грубо говоря, эти модели состоят из требований эквивалентности разных термов--цепочек действий). К неисполнимым спецификациями принадлежат и такие виды моделей как \emph{программные контракты} --- набор логических свойств, которые должны быть выполнены при корректных входных данных и вычисленных по ним выходных. Грубо говоря, для задания семантики программы в неисполнимом виде применяются два подхода: <<чистый операционный>> (функциональный) подход (property-based) и подход, основанный на моделировании состояния программы (model-based, state-based). В функциональном подходе состояние не моделируется! И тем не менее, семантику операций удается задать. Вторая глава задачника посвящена функциональному подходу. Третья глава --- подходу, основанному на моделировании состояния программы. А первая глава посвящена тому языку, на котором все эти модели можно выражать --- языку RSL. Авторы языка попытались создать язык, который был бы языком программирования и языком спецификации одновременно\footnote{На самом деле обе эти цели можно воспринимать как моделирование --- первое является исполнимым моделированием, а второе неисполнимым.}. Единый языка выражения программы и ее семантики позволяют легче провести обучение языку и верификацию программы на такой модели.
%
%На практике для реализации алгоритмов в большинстве случаев всё же язык RSL не применяют. Тем не менее успешно применяемые языки спецификации проектируются таким образом, чтобы приблизить их к языкам программирования (что как минимум облегчит верификацию реализации). Язык RSL нацелен на такие языки программирования, как Си и Ада, за исключением некоторых их особенностей (указателей и динамической памяти). Языки спецификации имеют определенную область применения, где их использование наиболее эффективно, и при решении практических задач стоит аккуратно подбирать язык спецификации с учетом целевого языка программирования. Поэтому читателя не должно смущать в дальнейшем изложении отсутствие объектно-ориентированных возможностей, механизмов распараллеливания вычислений --- для спецификации этих возможностей подходят другие языки спецификации. 