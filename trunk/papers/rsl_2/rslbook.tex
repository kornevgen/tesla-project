% !Mode:: "TeX:UTF-8"
\documentclass[14pt, twoside]{extreport}
\usepackage{cmap}

%\usepackage{fix-cm}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{dsfont}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\usepackage{clrscode}

\pagestyle{headings}

\textheight 23cm % 29.7-2-2
\textwidth 16cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \evensidemargin 0cm  \headheight 0cm \headsep 1.5cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел

\usepackage[off]{auto-pst-pdf}
\usepackage{vaucanson-g}

\usepackage{ifpdf}

\ifpdf
% we are running pdflatex, so convert .eps files to .pdf
% run pdflatex with --shell-escape and thesis.aux
%\usepackage[pdftex]{graphicx}
\usepackage{epstopdf}
\else
% we are running LaTeX, not pdflatex
\usepackage{graphicx}
\fi

% Подправим команду \appendix : нумерация русскими буквами,
% а не латинскими.
\makeatletter
\renewcommand\appendix{\par
  \setcounter{chapter}{0}%
  \setcounter{section}{0}%
  \def\@chapapp{\appendixname}%
  \def\thechapter{\@Asbuk\c@chapter}}
\makeatother

% "русифицируем" окружение enumerate:
\makeatletter
\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
\def\labelenumii{\theenumii)}    % а не латинские буквы
\def\p@enumii{\theenumi}         % а это для \ref
\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
\let\theenumiii\relax            % и отдельных ссылок на него не будет
\def\p@enumiii{\theenumi\theenumii}
\makeatother

\usepackage{rsl}

\usepackage{listingsutf8}
\lstloadlanguages{RSL}
\lstset{numbers=left, language=RSL, extendedchars=true, numberstyle=\tiny, inputencoding=utf8%,
%commentstyle=\itshape, stringstyle=\bfseries
}

\author{Евгений Корныхин}
\title{\huge{\textbf{\textsc{Формальная спецификация функциональных свойств конечноавтоматных моделей программ}}}}
%\date{Москва --- 2010}

\newcounter{problem_type}[chapter]
\newcounter{zadacha}[problem_type]
\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
\textit{\arabic{chapter}.\arabic{problem_type}.\arabic{zadacha}}~~  }

%\newcounter{problem_type}[section]
%\newcounter{zadacha}[problem_type]
%\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
%\textit{\arabic{section}.\arabic{problem_type}.\arabic{zadacha}}~~  }

\newcommand{\head}[1]{\vspace{1cm}\subsubsection*{#1}}
\newcommand{\zhead}[1]{\head{#1} \refstepcounter{problem_type}}


\begin{document}

\maketitle

\tableofcontents

\input{intro}


%%%%%%%%%% Общая структура %%%%%%%%%%%
%%  0. "Введение". (см. igoogle) Создание формальной модели поведения системы как способ уточнения требований
%%  1. "Основные определения" (спецификация, модель, полнота, тотальность, непротиворечивость, явность).
%%      Нулевая задачка экзамена. Детерминированные функции, недетерминированные функции на примерах чисел.
%%      Первая задачка экзамена в том случае, когда всё состояние скрыто (т.е. про состояние пока что не думаем).
%%  2. "Языки спецификации". Сначала RSL (множества, списки, отображения). Потом ACSL (модель памяти, функции с указателями)
%%  3. "Модельные спецификации". Кроме самих данных, специфицируем состояние системы (модель состояния, инварианты).
%%      Первая задачка экзамена в полном объеме. Выделение ветвей функциональности при записи постусловий.
%%      Согласованность модельных спецификаций (инвариант не пуст после каждой функции, нет вызовов функций вне их предусловий)
%%  4. "Алгебраические спецификации". Понятие алгебраической спецификации (новая вторая задачка экзамена).
%%      Согласованность алгебраических спецификаций (бывшая вторая задачка экзамена).
%%  5. "Автоматные спецификации". Тут про третью задачку экзамена.
%%  6. ......... может быть сюда включить формальную верификацию...........

\chapter{Основные понятия}

\section{Конечноавтоматные модели программ}

В рамках этого курса будут рассматриваться только такие программы, для которых есть конечноавтоматные модели.

Что такое конечноавтоматная модель................

Термин <<операция>>

картинка с прямоугольником и стрелками в него и из него

\section*{Задачи}
	\zhead{Для следующих программ и программных систем привести несколько примеров конечноавтоматных моделей; какие возможны реализации этих систем, более мощные, чем конечные автоматы?}
		\z Стек.
		\z Почтовый клиент (например, Mozilla Thunderbird или веб-клиент Gmail).
		\z Электронный будильник.
		\z Компьютерная игра <<крестики-нолики>>.
		\z Подсистема работы с вкладками в веб-браузере.
		\z Веб-сайт микроблога (например, Twitter).
		\z Компиляторы gcc.
		\z Игровой веб-сервер для игры в покер. 

\section{Корректность конечноавтоматных моделей программ}
вычленить и сформулировать словами по-русски, например, для игры судоку в Ubuntu

\section{RSL для императивного программирования}

    \input{prog/about}

    \section*{Задачи}

    \input{prog/problems}

\section{Функции в языках спецификации}

    \input{basis/funcs}

    \section*{Задачи}

    \input{alg/formal}

    \input{basis/im2ex}




\chapter{Уточнение функциональных требований}

%\section{Операции и ветви функциональности}

%% спецификация логики работы системы и характерных особенностей данных

Данный курс посвящён формальной спецификации программно-ап-паратных систем (далее, просто <<систем>>) и их компонентов. С точки зрения пользователя система даёт возможность выполнить с её помощью ряд \emph{операций} (например, банкомат дает возможность снять деньги со счета). Аналогично, каждый отдельный компонент даёт возможность остальным компонентам выполнять с его помощью ряд операций. Операция обладает рядом \emph{аргументов} и \emph{результатов операции}, непосредственно доступных тому, кто запросил данную операцию (например, чтобы выполнить операцию снятия денег со счета при помощи банкомата надо указать сумму снимаемых денег - это один из аргументов, в качестве одного из результатов операции мы получим сами деньги). Во время выполнения операции система (или её отдельный компонент) ведут себя строго определённым образом в зависимости от значений аргументов, внутреннего состояния системы и состояния среды, в которой работает система (будем их называть \emph{входными параметрами} операции)\footnote{Пока что под состоянием среды понимается значение всех глобальных переменных}.

Предположим, что система ещё не реализована, для неё составляется набор требований, по которым будет осуществлена реализация. От того, насколько точно будут сформулированы эти требования, будет зависеть и качество реализованной системы. Основные проблемы в требованиях следующие:
\begin{itemize}
  \item несогласованность (противоречивость) требований: набор требований содержит как минимум несовместное подмножество требований;
  \item неполнота: набор требований ничего не говорит о том, каким должно быть поведение некоторой операции при некоторых значениях входных параметров;
  \item неоднозначность требований: некоторое требование можно трактовать несколькими способами.
\end{itemize}

Эти проблемы приводят в последствии к тому, что система в целом ведет себя не так, как этого хотел бы пользователь, что система вообще не может работать, поскольку при реализации её компонентов разработчики по-разному поняли требования, что срываются сроки, отведённые на реализацию, нарушается бюджет проекта и т.д. и т.п.

В качестве одного из методов обнаружения и избавления от таких проблем в данном курсе рассматриваются формальные спецификации. Идея заключается в том, чтобы описать логику выполнения операций на некотором уровне абстракции на формальном языке (в частности с использованием пре- и пост- выражений зафиксировать в виде формальной спецификации, что изменяется в системе, какой результат операции при этом верный, при каких входных аргументах операция допустима и т.д.). Кроме того, что при составлении таких формальных выражений разработчик лучше разбирается в требованиях, он может еще и применить строгие методики для анализа того, всё ли известно для реализации с точки зрения логики работы системы и нет ли внутренних конфликтов в сформулированных требованиях).

На профессиональном языке такое формальное описание логики выполнения операций называют \emph{формальной моделью поведения}. Поскольку можно выбирать разные уровни абстракции, акцентировать рассмотрение на некоторых характеристиках, игнорируя остальные, то и формальных моделей поведения системы может быть несколько. На самом деле лучше иметь несколько небольших обозримых формальных моделей поведения одной и той же системы, чем одну большую и тяжело воспринимаемую формальную модель. Следует придерживаться мысли о множестве небольших формальных моделей в рамках всего данного курса: получаемый навык заключается в умении формально (или строго) описать поведение системы с точки зрения некоторого (важного) аспекта и анализировать такие формальные описания, выводить новые факты о том, как себя ведет система, и насколько тщательно описаны требования на её поведение.

\section{Строгий подход к формализации поведения системы}

В двух словах, этот подход заключается в систематическом выделении фактов вида <<в 'такой-то' ситуации если выполнить при помощи системы 'такую-то' операцию, то пользователь получит в качестве результата 'то-то', а система перейдет в 'такое-то' состояние>>. На языке логики один такой факт выражается при помощи импликации $$\forall x~ ( ~p(x)~ \Rightarrow ~q(f(x)) ~)$$ а набор фактов --- конъюнкцией таких импликаций. Например, при выполнении операции перехода по ссылке в одном из табов веб-браузера открывается новый таб или открывается новое окно с одним табом, или не открывается ни одного окна, ни одного таба (операция перехода по ссылке выполнилась --- и мы видим \emph{эффект этой операции}: открытие таба или открытие окна, или неоткрытие таба и неоткрытие новых окон, эффект операции в формуле выше обозначен как $q$). В этой модели нас будут интересовать только работа с табами при выполнении различных операций.

Под <<ситуацией>> можно понимать совокупность значений входных параметров, некие условия, при которых эффект операции обладает заданной спецификой (ситуация обозначена в формуле выше как $p$). Например, в ситуации, когда достигнут максимальный предел одновременно показываемых табов, при переходе по ссылке всегда открывается одно новое окно с одним табом. В этом \emph{функциональном требовании} операцией является <<переход по ссылке>>, ситуацией --- <<достигнут предел максимально показываемых табов и потребовано открытие нового таба>>, эффектом операции является <<открыто новое окно с одним новым табом>> (по-хорошему, этот эффект требует дополнения).

Еще несколько примеров. <<При выполнении операции закрытия таба все остальные табы остаются без изменений>> --- ситуация <<таб открыт>>, операция <<закрытие таба>>, эффект <<все табы, кроме закрываемого, не изменились>> (не изменилось их содержимое, заголовок и т.п., в зависимости от того, какие из характеристик таба входят в формальную модель). Заметьте, этот почти очевидный факт неполный. Он позволяет при закрытии таба изменить порядок табов. Тем самым, формальная модель системы с требованием <<при выполнении операции закрытия таба все остальные табы остаются без изменений>> содержит логику выполнения операции по закрытию таба с сохранением порядка и без сохранения порядка. Этот важный вывод о поведении системы получен чисто путем анализа формальной модели. Например, из этого следует, что нельзя утверждать, что если один таб создан позже другого, то всегда будет сохранен их относительный порядок один после другого. Это замечание может оказаться важным при проектировании других операций с табами, которые будут предполагать сохранение относительного расположения табов.

Возникает вопрос, какие факты нужно выделять, сколько фактов нужно выделять (когда фактов достаточно). Если к выделению фактов подойти <<с особым рвением>>, то на каждое состояние системы и значения аргументов операций надо выписать отдельный факт: <<если система находится в 'таком-то' состоянии и аргументы равны 'тому-то', то при выполнении операции произойдет 'то-то'>> (например, если открыт один таб, то при выполнении операции закрытия табов в окне не останется ни одного таба - раз; если открыто два таба и закрывается первый таб, то при выполнении операции закрытия табов в окне остается бывший второй таб - два; если открыто два таба и закрывается второй таб, то при выполнении операции закрытия табов в окне остается бывший первый таб - три; уже получено три факта и это не предел!). Понятно, что так мельчить ситуации не имеет смысла как минимум, если эффект операции в этих ситуациях обладает некоторой общностью. Например, для операции закрытия таба может быть важно, в том же окне находится закрываемый таб, как и интересующие нас таб, или в другом (в первом случае, изменяется набор табов в окне, во втором случае не изменяется). Как минимум, следует выделить все ситуации для операции, в которых поведение системы обладает спецификой (чем-то важным отличается от поведения системы при выполнении операции в других ситуациях)\footnote{под поведением системы при выполнении операции понимается эффект операции}. Поскольку ситуации выражены на формальном языке, можно точно определить, покрывают ли эти ситуации все возможные ситуации, в которых будет выполняться операция. Например, если выделена только ситуация закрытия таба для своего окна, то <<для полноты картины>> нужна ситуация закрытия таба для окна без этого таба (если такие окна обладают дополнительной спецификой, влияющей на эффект закрытия таба, то требуется выделение для них дополнительных ситуаций). Полное выделение ситуаций --- первый залог того, что поведение системы в спецификации описано полно.

Следующий важный момент --- это слежение за замкнутостью модели. Речь идет вот, о чем. В правильной спецификации не может быть такого, что в результате выполнения операции в некоторой ситуации система приходит в такое состояние, про которое неизвестно, как себя будут вести операции, выполняющиеся из полученного состояния. Грубо говоря, есть строго определенное множество допустимых состояний системы, или \emph{инвариант} состояния системы, за которые операции не имеют права выводить систему. Например, инвариантами могут быть следующие факты: <<количество табов в окне не должно превысить максимально допустимое>>, <<в каждом окне должен быть как минимум один таб>>. Однако при проектировании операций придерживаются более гибкого подхода и допускается пересматривание инварианта, но в этом случае приходится перепроверять уже спроектированные операции для выявления того, во всех ли ситуациях описано их поведение и не требуется ли дополнительно определить поведение системы при выполнении операции из новых состояний, вошедших теперь в инвариант.

В некоторых ситуациях операция не может быть выполнена (например, нельзя закрыть единственный таб в окне --- это приведет к нарушению инварианта (в окне не останется ни одного таба). Знание о том, когда операция невозможна, так же важно, как и знание эффекта операции там, где операция возможна.

Подводя итог, сформулируем следующий подход к формализации поведения системы.

\begin{enumerate}
    \item сформулировать уровень абстракции (например, ограничиваемся рассмотрением логики работы с табами в рамках одного окна браузера);
    \item выделить множество операций и составить их сигнатуры (например, открытие нового таба, переход по ссылке, закрытие таба);
    \item сформулировать наиболее общий инвариант на состояние системы (под <<системой>> в данном случае понимается окно браузера с табами; например, в каждом окне должен быть как минимум 1 таб);
    \item далее действовать итеративно до получения полного замкнутого описания поведения системы при выполнении всех операций во всех ситуациях:
        \begin{itemize}
          \item выделить набор ситуаций на очередную операцию и описать эффект операции в этих ситуациях (как минимум, выделить ситуации, в которых операция невозможна);
          \item проверить, что эффект всех операций согласуется с инвариантом;
          \item при необходимости уточнить (усилить) инвариант или расширить (ослабить) инвариант --- при этом снова проверить соответствие эффекта операций во всех ситуациях.

%              все функции вызываются в согласии с предусловием
        \end{itemize}
\end{enumerate}

%% следить за тем, чтобы каждая формальная фраза могла быть неформально интерпретирована: общение между людьми ведь осуществляется неформальными фразами

В результате применения этого подхода к примеру с табами может получиться, например, следующая заготовка для функциональных требований:

{\sf
\textbf{Понятия}: Окно, Таб, Адрес

\textbf{Инварианты}:
\begin{enumerate}
  \item Окно есть совокупность табов;
  \item Табы в окне упорядочены;
  \item Все табы считаются различными;
  \item Табы содержатся в окнах, в табах окон нет;
  \item Каждому табу соответствует не более одного окна;
  \item В окне не может быть открыто табов больше некоторого максимума;
  \item Каждому табу соответствует некоторый один адрес или не соответствует никакого адреса.
\end{enumerate}

\textbf{Операция <<Открытие нового таба>>}

\begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
  \hline
  сигнатура & open: Окно $\NonDetermFn$ Окно $\times$ Таб \\ \hline
  тотальность & не требуется \\ \hline
  ситуации, когда операция невозможна & В Окне достигнут максимум одновременно открытых табов \\ \hline
  эффект операции в разных ситуациях & появляется один таб, в этом табе нет адреса, \underline{место этого таба пока не решено}, все остальные табы и их порядок остаются без изменений \\ \hline
\end{tabular}

\textbf{Операция <<Переход по ссылке>>}

\begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
  \hline
  сигнатура & go: Окно $\times$ Адрес $\times$ Таб $\NonDetermFn$ Окно \\ \hline
  тотальность & не требуется \\ \hline
  ситуации, когда операция невозможна & Таб не входит в Окно \\ \hline
  эффект операции в разных ситуациях & \begin{itemize}\item В ситуации, когда достигнут максимум одновременно открытых табов, заменяется адрес в Табе на Адрес, остальные табы и их порядок не меняются; \item В остальных ситуациях открывается новый таб и ему прописывается Адрес\end{itemize} \\ \hline
\end{tabular}

\textbf{Операция <<Закрытие существующего таба>>}

\begin{tabular}{|p{0.3\textwidth}|p{0.6\textwidth}|}
  \hline
  сигнатура & close: Окно $\times$ Таб $\NonDetermFn$ Окно \\ \hline
  тотальность & не требуется \\ \hline
  ситуации, когда операция невозможна & Таб не входит в Окно \\ \hline
  эффект операции в разных ситуациях & \begin{itemize}\item В ситуации, когда это единственный открытый таб, табу не соответствует никакой адрес;\item В остальных ситуациях Таб отсутствует, все остальные табы и их порядок сохраняются \end{itemize} \\ \hline
\end{tabular}
}

В рамках этого подхода фигурируют условия на состояние системы, аргументы и результаты операций. Чтобы суметь их записать в виде выражений некоторого формального языка, надо выразить на этом языке, какая информация входит в состояние системы в этой формальной модели (например, какие табы входят в какие окна в данный момент), и, используя конструкции языка, выразить необходимые условия. На этом моменте временно прервемся, чтобы познакомиться с самим языком, способами определения состояний и с конструкциями языка.


%понятие предусловия, постусловия:
%
%[Большая цитата из статьи В.Кулямина, 14(1)й том трудов ИСП]
%
%Программный контракт операции состоит из предусловия и постусловия. Первое фиксирует требования к корректному использованию этой операции со стороны окружения системы — при каких ограничениях на аргументы обращение к этой операции корректно. Второе определяет обязательства системы по отношению к результатам вызовов этой операции — какие ограничения на результаты работы операции должны быть выполнены при корректной работе системы, если обращение к ней было правильным. При нарушении предусловия операции обращение к ней может иметь любые последствия, поведение системы в этом случае не определено. Совместно пред- и постусловия строго определяют требования к работе системы.
%
%При анализе сложной системы с большим количеством интерфейсных операций крайне неудобно рассматривать их все вместе как однородный набор, необходимо разбиение этих операций на какие-то логические группы по реализуемым ими функциям. Эти группы почти всегда соответствуют компонентам или модулям системы, ответственным за реализацию этих функций. Часто такие компоненты имеют внутреннее состояние, недоступное для непосредственного наблюдения извне системы, но влияющее на поведение вызываемых операций компонента и изменяемое ими.
%
%Поэтому для описания ограничений в пред- и постусловиях необходимо как-
%то учитывать внутреннее состояние компонента, операции которого
%описываются. Чтобы сделать это возможным, контракты операций одного
%компонента объединяются в спецификацию этого компонента вместе с
%описанием структуры его модельного состояния.
%Структура модельного состояния компонента не обязана совпадать со
%структурой его реального состояния, зафиксированной в его коде, например,
%компонент, реализующий список, может использовать ссылочную структуру
%данных, в том время, как структура его модельного состояния в
%спецификациях может быть основана на массиве. В структуре модельного
%состояния могут совсем отсутствовать некоторые части реального состояния
%компонента, слабо связанные с его функциональностью, например,
%различного рода кэши и другие данные, используемые для увеличения
%производительности. Важно, что структура модельного состояния компонента
%должна содержать данные, достаточные для полного описания
%функциональности в пред- и постусловиях операций этого компонента. При
%этом предусловие зависит от аргументов вызова операции и данных
%модельного состояния при этом вызове, или пре-состояния. Постусловие
%зависит как от аргументов и пре-состояния, так и от результата и данных
%модельного состояния после вызова, или пост-состояния.
%Наличие сложной структуры модельного состояния приводит к
%необходимости учитывать в контрактах операций ограничения на его данные,
%которые должны выполняться в стабильных состояниях системы, когда ни
%одна из операций не выполняется. Такие ограничения оформляются в виде
%инвариантов модельного состояния. Инварианты являются общими частями
%пред- и постусловий всех операций, как-то затрагивающих соответствующие
%компоненты — они должны выполняться как в пре-состоянии любого вызова,
%так и в его пост-состоянии.
%
%
%Обычно постусловие операции описывает несколько разных режимов ее
%функционирования. Предусловие запрещает все комбинации значений
%параметров, при которых поведение операции не определено. Однако среди
%разрешаемых предусловием ситуаций могут остаться такие, в которых
%выполнить свою основную функцию операция не может. Вместо этого она
%должна вернуть некоторый код ошибки, создать исключительную ситуацию
%или как-то иначе сигнализировать о том, что ее основная задача не может
%быть решена в такой ситуации. Помимо режимов сигнализации о
%невозможности выполнить основную функцию, само ее выполнение может
%идти разными путями. Например, операция конкатенации двух строк может
%проверять, не является ли один из ее аргументов пустой строкой, и в этом
%случае просто возвращать копию другого аргумента, не выполняя никаких
%действий над ней. Если же оба аргумента не пусты, копия одного из них
%должна быть подвергнута модификации, чтобы получить результат операции.
%
%При написании постусловий удобно выделять такие разные режимы, иначе
%постусловие превращается в большую и сложную формулу, трудную для
%анализа и понимания, что противоречит основной цели создания формальных
%спецификаций. Различные режимы работы операции описываются в виде
%импликаций с несовместными посылками (постусловие при этом выглядит как формула
%(X1 => Y1) /\ (X2 => Y2) /\ ... (Xn => Yn)
%или в виде разных выражений для
%возвращаемого результата при разных исходных условиях, т.е. результат
%постусловия вычисляется в разных ветвях некоторого условного оператора
%или оператора выбора по-разному. Поэтому эти разные режимы называют
%ветвями функциональности (или функциональными ветвями) операции.

\section*{Задачи}

\zhead{Описать функциональность операций}

В задачах этого типа требуется составить описание подобное тому, какое было составлено для <<Окон с Табами>>. Если данных в задаче недостаточно, требуется определить те ситуации, в которых поведение системы не описано, и доопределить поведение в таких ситуациях адекватным образом. В большинстве задач требуется выделить операции пользователя, которые выполняются посредством системы. У системы практически всегда есть внутреннее состояние. Если у сеанса работы с системой есть границы, то система не должна позволять работать вне этих границ (до того, как начат сеанс, и после того, как становится известно, что сеанс закончен), например, играть в игру можно только до тех пор, пока игра не будет закончена. Не забыть про операции инициализации системы (например, когда начинается игра).

% декабрь-2009

\z <<Неазартное 'Двадцать одно'>>. Задача системы --- визуализировать поле игры в <<21>> (это карточная игра) и модифицировать его в ответ на команды игрока (т.е. в этой задаче не надо думать о всей программной системе для игры в Двадцать одно, надо думать только о том, по каким правилам должно <<работать>> содержимое поля игры). В колоде 36 карт разных мастей, каждая карта имеет свою стоимость. Играют двое: банкир и его соперник. Сначала соперник берет из колоды карт себе карты, затем банкир берет из колоды себе карты. Если сумма набранных баллов по картам у соперника равна 21, он выиграл; больше 21 - проиграл; иначе если у банкира 21, он выиграл; если больше 21 - проиграл; в противном случае выигрывает тот, кто набрал большую сумму баллов.

\z <<Шашки>>. Задача системы --- визуализировать поле игры в шашки и модифицировать это поле в ответ на команды игрока (т.е. в этой задаче не надо думать о всей программной системе для игры в шашки, надо думать только о том, по каким правилам надо работать с содержимым поля игры). Поле 8 на 8. У каждого игрока 12 шашек. Отличия от стандартных шашек: 1) бить назад нельзя, 2) бить несколько шашек нельзя, 3) дамок нет.


\z <<Домино>>. Задача системы --- визуализировать поле игры в домино и модифицировать это поле в ответ на команды игрока (т.е. в этой задаче не надо думать о всей программной системе для игры в домино, надо думать только о том, по каким правилам надо работать с содержимым поля игры). Играют двое. Вначале каждый игрок произвольным образом получает половину всех доминошек. Ход игрока заключается в выборе доминошки из своей кучи и вставки его линию с подходящего конца. Если игроку нечем походить, он проигрывает.

\z <<Пятнашки>>. Задача системы --- визуализировать поле игры в пятнашки и модифицировать это поле в ответ на команды игрока (т.е. в этой задаче не надо думать о всей программной системе для игры в домино, надо думать только о том, по каким правилам надо работать с содержимым поля игры). Поле 4 на 4 клетки. Все клетки, кроме одной, содержат фишку. Ход игрока состоит в том, что нужно передвинуть одну из фишек, соседствующих с пустой клеткой на пустое место. Цель игры --- выстроить фишки в соответствии с их номерами.

% январь-2010

% октябрь-2010

% декабрь-2010

% январь-2011
..............TODO


\section{Множества, списки, отображения}

.......TODO вступление, что для выражения свойств данных нужно промоделировать эти данные при помощи простейших средств типа множеств, списков, отображений....

\input{model/setlist}  % with problems

\section{Уточнение требований при помощи модельных спецификаций}
%\section{Уточнение требований при помощи моделеориентированных спецификаций}

Как сказано в предыдущем разделе, уточнение требований выполняется путем выделения ветвей функциональности, т.е. классов значений входных параметров. В данном разделе предлагается использовать язык множеств, списков и отображений для описания типов параметров и выражений над значениями параметров. При этом для описания ветвей функциональности отдельных операций будет применяться явное или неявное описание. В данном случае оно называется \emph{моделеориентированным} описанием (потому что для параметров задается <<модель>> на языке множеств, списков и отображений).


.............TODO предусловие, запись в явном или неявном виде, замкнутое описание (включает ли выходное состояние....), инвариант.......


\subsection*{Задачи}
.....TODO первая задачка экзамена

%\zhead{Формализация требований согласно моделе-ориентированному подходу}

\z Написать спецификацию функции библиотеки POSIX \texttt{int fork()}. Эта функция позволяет создать дочерний процесс. Если дочерний процесс создан успешно, возвращается его идентификатор. В противном случае функция возвращает -1.

\textbf{Решение:}
\begin{lstlisting}
type Processes = Nat-set
value fork: Processes -~-> Processes >< Int
   fork(ps) as (ps2, pid)
   post pid = -1 /\ ps2 = ps
   	\/ pid >= 0 /\ pid ~isin ps /\ ps2 = ps union {pid}
\end{lstlisting}

Обратите внимание:
\begin{enumerate}
  \item поскольку в требованиях говорится только об идентификаторах, то только эта часть отражается в модели типа Processes. Для этой модели выбрано множество, т.к. все идентификаторы должны быть разными;
  \item эту функцию нельзя определить в явном виде с использованием выбранной модели типа Processes, т.к. неизвестен алгоритм генерации идентификаторов дочерних процессов;
  \item в случае неуспешного создания процесса таблица процессов не меняется (явно это в требованиях не описано, но такое свойство имеет место);
  \item поскольку ничего не известно о детерминированности алгоритма генерации идентификаторов дочерних процессов, то использовано нетотальное определение.
\end{enumerate}

\z Написать спецификацию функции библиотеки POSIX \texttt{int fork()}. Эта функция позволяет создать дочерний процесс. Если дочерний процесс создан успешно, возвращается его идентификатор. В противном случае функция возвращает -1. После создания сегменты кода, данных и стека обоих процессов идентичны. Совпадают и счетчики инструкции. Необработанные сигналы родительского процесса в дочерний не наследуются. Считать, что для получения идентификатора текущего процесса есть функция \texttt{int getpid()}.

\textbf{Решение:}
\begin{lstlisting}
type Segment, Signal
type Process ::
		code : Segment,
		data : Segment,
		stack : Segment,
		instr_pntr : Nat,
		signals : Signal-list

type Processes = Nat -m-> Process

value getpid: Processes -~-> Int

value fork: Processes -~-> Processes >< Int
   fork(ps) as (ps2, pid)
   post pid = -1 /\ ps2 = ps
   	\/ pid >= 0 /\ pid ~isin dom ps /\ ps2 \ {pid} = ps /\
	let parent_id = getpid(ps), child = ps2(pid),
	     parent = ps(parent_id) in
   	       code(child) = code(parent) /\
   	       data(child) = data(parent) /\
   	       stack(child) = stack(parent) /\
   	       instr_pntr(child) = instr_pntr(parent) /\
   	       signals(child) = <..>
   	   end
\end{lstlisting}

Обратите внимание:
\begin{enumerate}
  \item по сравнению с предыдущей задачей модель типа Processes полностью изменилась (хотя требования лишь добавлялись), этот момент показывает важную особенность моделе-ориентированных спецификаций в отличие от алгебраических: модели типов могут меняться существенным образом при добавлении новых требований;
  \item на использование явного \textbf{let} для введения <<читабельных>> имен выражениям и повышения <<читабельности>> всего пост-выражения.
\end{enumerate}

\z Написать спецификацию функции библиотеки POSIX \texttt{int getpid()}. Эта функция позволяет получить идентификатор процесса, вызвавшего эта функцию.

\textbf{Решение:}
\begin{lstlisting}
type Processes = Nat-set
value getpid: Processes -~-> Int >< Processes
   getpid(ps) as (pid, ps2)
   post pid >= 0 /\ pid isin ps /\ ps2 = ps
\end{lstlisting}

Обратите внимание, что
\begin{enumerate}
  \item данная модель не позволяет дать алгоритм вычисления функции getpid (поэтому используется неявная спецификация), но позволяет тем не менее задать те свойства, которые перечислены в постановке задачи;
  \item хоть модель и довольно простая, но она наглядная и позволяет ее читать и делать выводы относительно функции getpid даже тому, кто не знает POSIX;
  \item пост-выражение можно эквивалентным образом сократить до такого: pid $\Isin$ ps $\wedge$ ps = ps2, поскольку в ps входят только натуральные числа.
\end{enumerate}

% \z exec
% остальные функции ........

\section{Согласованность модельных спецификаций}

..........TODO

% \zhead задачи на анализ спецификаций (а то зачем же они нужны, если, кроме как написать, с ними ничего не сделать!)

\subsection*{Задачи}
.........TODO



\section{Уточнение требований при помощи алгебр}

\section{Согласованность алгебраических спецификаций}

\section{Алгебраические спецификации и конечные автоматы}

\chapter{Аналитическая верификация}

\section{Методы Флойда}

\section*{Задачи}

Во всех задачах $x_1, x_2, ...$ --- входные переменные, $y_1, y_2, ...$ --- промежуточные переменные, $z_1, z_2, ...$ --- выходные переменные. Если не сказано противное, входные переменные обладают целыми неотрицательными значениями.

Если в алгоритмах не указано условие у оператора цикла, значит это условие --- тождественная истина (т.е. цикл бесконечный).

\zhead{Доказать частичную корректность следующих числовых алгоритмов\footnote{Часть задач взяты из~\cite{Shen}, часть задач составлены Алексеем Хорошиловым}}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = x_1 \cdot x_2)$

\begin{codebox}
\Procname{$\proc{Multiply}(x_1,x_2)$}
\li $y_1 \gets 0$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_2$
\li \Do $(y_1,~y_2) \gets (y_2 + x_1,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1)~is~true$, $post(x_1, z)~is~(z = x_1 \cdot (x_1 + 1))$

\begin{codebox}
\Procname{$\proc{Arithmetic}(x_1)$}
\li $y_1 \gets 0$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_1$
\li \Do $(y_1,~y_2) \gets (y_1 + 2y_2,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1)~is~true$, $post(x_1, z)~is~(z = x_1 \cdot (x_1 + 1) \cdot (2x_1 + 1))$

\begin{codebox}
\Procname{$\proc{SumSquare}(x_1)$}
\li $y_1 \gets 0$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_1$
\li \Do $(y_1,~y_2) \gets (y_1 + 6y_2\cdot y_2,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = x_1^{x_2})$

\begin{codebox}
\Procname{$\proc{Power}(x_1,x_2)$}
\li $y_1 \gets 1$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_2$
\li \Do $(y_1,~y_2) \gets (y_1 * x_1,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~(x_2 > 0)$, $post(x_1, x_2, z)~is~(z = x_1^{x_2})$

\begin{codebox}
\Procname{$\proc{Power}(x_1,x_2)$}
\li $y_1 \gets x_1$
\li $y_2 \gets 1$
\li \While $y_2 < x_2$
\li \Do \If $2y_2 \leq x_2$
\li \Then $(y_1,~y_2) \gets (y_1 * y_1,~2y_2)$
\li \Else $(y_1,~y_2) \gets (y_1 * x_1,~y_2 + 1)$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = x_1^{x_2})$

\begin{codebox}
\Procname{$\proc{Power}(x_1,x_2)$}
\li $y_1 \gets 1$
\li $y_2 \gets 0$
\li \While $y_2 < x_2$
\li \Do \If $y_2 = 0$
\li \Then $(y_1,~y_2) \gets (x_1,~1)$
\li \Else \If $2y_2 \leq x_2$
\li \Then $(y_1,~y_2) \gets (y_1 * y_1,~2y_2)$
\li \Else $(y_1,~y_2) \gets (y_1 * x_1,~y_2 + 1)$ \End \End \End
\li $z \gets y_1$
\end{codebox}

% НОД
\z (<<GCD>> -- greatest common divisor) $pre(x_1, x_2)~is~(x_1 + x_2 > 0)$, $post(x_1, x_2, z)~is~(z = \gcd(x_1,x_2))$

\begin{codebox}
\Procname{$\proc{GCD}(x_1,x_2)$}
\li \If $x_1 > x_2$
\li \Then $y_1 \gets x_1$
\li \Else $y_1 \gets x_2$ \End
\li \While $x_1 \mod y_1 \neq 0 ~\vee~ x_2 \mod y_1 \neq 0$
\li \Do $y_1 \gets y_1 - 1$ \End
\li $z \gets y_1$
\end{codebox}

\z (<<GCD>> -- greatest common divisor) $pre(x_1, x_2)~is~(x_1 + x_2 > 0)$, $post(x_1, x_2, z)~is~(z = \gcd(x_1,x_2))$

\begin{codebox}
\Procname{$\proc{GCD}(x_1,x_2)$}
\li $y_1 \gets x_1$
\li $y_2 \gets x_2$
\li \While $y_1 > 0 ~\wedge~ y_2 > 0$
\li \Do \If $y_1 \geq y_2$
\li     \Then $y_1 \gets y_1 - y_2$
\li     \Else $y_2 \gets y_2 - y_1$ \End \End
\li \If $y_1 = 0$
\li \Then $z \gets y_2$
\li \Else $z \gets y_1$ \End
\end{codebox}

\z (<<LCM>> -- least common multiple) $pre(x_1, x_2)~is~(x_1 + x_2 > 0)$, $post(x_1, x_2, z)~is~(z = 2\cdot \mbox{lcm}(x_1,x_2))$

\begin{codebox}
\Procname{$\proc{2LCM}(x_1,~x_2)$}
\li $(y_1,~y_2,~y_3,~y_4) \gets (x_1,~x_2,~x_2,~x_1)$
\li \While $y_1 \neq 0 ~\wedge~ y_2 \neq 0$
\li \Do \If $y_1 \geq y_2$
\li     \Then $(y_1,~y_4) \gets (y_1 - y_2,~y_3 + y_4)$
\li     \Else $(y_2,~y_3) \gets (y_2 - y_1,~y_3 + y_4)$ \End \End
\li \If $y_1 = 0$
\li \Then $z \gets y_4$
\li \Else $z \gets y_3$ \End
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z = x^2)$

\begin{codebox}
\Procname{$\proc{Square}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~0)$
\li \While $y_1 < x$
\li \Do $(y_1,~y_2,~y_3) \gets (y_1 + 1,~y_2 + 2,~y_2 + y_3)$ \End
\li $z \gets y_1 + y_3$
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z^2 \leq x < (z+1)^2)$

\begin{codebox}
\Procname{$\proc{Sqrt}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~1)$
\li \While
\li \Do $y_2 \gets y_2 + y_3$
\li \If $y_2 > x$
\li \Then break
\li \Else $(y_1,~y_3) \gets (y_1 + 1,~y_3 + 2)$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~(x_1 > 0)~\wedge~(x_2 > 0)$, $post(x_1, x_2, z_1, z_2)~is~(0 \leq z_2 < x_2)~\wedge~(x_1 = z_1 \cdot x_2 + z_2)$

\begin{codebox}
\Procname{$\proc{Division}(x_1, x_2)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~x_1)$
\li \While $y_3 \neq 0$
\li \Do $y_1 \gets if~(y_2 + 1 = x_2)~then~(y_1 + 1)~else~y_1$
\li     $y_2 \gets if~(y_2 + 1 = x_2)~then~0~else~(y_2 + 1)$
\li     $y_3 \gets y_3 - 1$ \End
\li $(z_1,~z_2) \gets (y_1,~y_2)$
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z = x^2)$

\begin{codebox}
\Procname{$\proc{Square}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~1,~1-x)$
\li \While $y_3 < x$
\li \Do \If $odd(y_2)$
\li     \Then $y_1 \gets y_1 + y_2$ \End
\li     $(y_2,~y_3) \gets (y_2 + 1,~y_3 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

$odd(x)$ истинно тогда и только тогда, когда $x$ нечетно.

\z $pre(x)~is~true$, $post(x, z)~is~(z^3 \leq x < (z+1)^3)$

\begin{codebox}
\Procname{$\proc{Cubert}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~1)$
\li \While
\li \Do $y_2 \gets y_2 + y_3$
\li     \If $y_2 > x$
\li     \Then break
\li     \Else $y_1 \gets y_1 + 1$
\li             $y_3 \gets y_3 + 6y_1$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x)~is~(x < 102)$, $post(x, z)~is~(z = 91)$

\begin{codebox}
\Procname{$\proc{Century}(x)$}
\li $(y_1,~y_2) \gets (x,~1)$
\li \While $y_1 < 101 ~\vee~ y_2 \neq 1$
\li \Do \If $y_1 > 100$
\li     \Then $(y_1,~y_2) \gets (y_1 - 10,~y_2 - 1)$
\li     \Else $(y_1,~y_2) \gets (y_1 + 11,~y_2 + 1)$ \End \End
\li $z \gets y_1 - 10$
\end{codebox}

\z $pre(x)~is~(x > 1)$, $post(x, z)~is~(z = x^3)$

\begin{codebox}
\Procname{$\proc{Qube}(x)$}
\li $(y_1,~y_2,~y_3) \gets (x,~1,~x)$
\li \While
\li \Do \If $y_2 < y_3$
\li     \Then $(y_1,~y_2) \gets (y_1 + x,~y_2 + 1)$
\li     \Else \If $y_3 = x$
\li         \Then $y_3 \gets y_1$
\li         \Else break \End \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z = x^2)$

\begin{codebox}
\Procname{$\proc{Square}(x)$}
\li $(y_1,~y_2) \gets (x,~1)$
\li \While $y_2 < x$
\li \Do \If $2y_2 \leq x$
\li     \Then $(y_1,~y_2) \gets (2y_1,~2y_2)$
\li     \Else $(y_1,~y_2) \gets (y_1 + x,~y_2 + 1)$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = {x_1}^{x_2})$ ($0^0~is~1$)

\begin{codebox}
\Procname{$\proc{Power}(x)$}
\li $(y_1,~y_2,~y_3) \gets (x_1,~x_2,~1)$
\li \While $y_2 \neq 0$
\li \Do \If $odd(y_2)$
\li     \Then $(y_2,~y_3) \gets (y_2 - 1,~y_1 \cdot y_3)$
\li     \Else $(y_1,~y_2) \gets (y_1 \cdot y_1,~y_2 / 2)$ \End \End
\li $z \gets y_3$
\end{codebox}

$odd(x)$ истинно тогда и только тогда, когда $x$ нечетно.



% дискретное логарифмирование

\section{Инструмент PVS}
...........TODO

%%%\chapter{Поведенческие спецификации}
%%%TBD
%%



%\chapter{Формальные спецификации в различных предметных областях}


%%\chapter{Специфицирование систем реального размера}
%%Спецификация для функции append в <<исполнимой>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value append: L >< L -> L
%%    append(x, y) is x ^ y
%%\end{lstlisting}
%%
%%Спецификация для функции append в <<логической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value append: L >< L -> L
%%    append(x, y) as z
%%    post
%%        len z = len x + len y /\
%%        (all i: Nat :- i isin inds x => z(i) = x(i)) /\
%%        (all i: Nat :- i isin inds y => z(i+len x) = y(i))
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<исполнимой>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%    reverse(x) is
%%        local variable y : L :- y = <..> in
%%            for xi in x do
%%                y := <.xi.> ^ y
%%            end;
%%            y;
%%        end
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<логической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%  reverse(x) as y
%%  post len x = len y /\
%%    (all i: Nat :- i isin inds x => y(i) = x(len x + 1 - i))
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<алгебраической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%axiom
%%    reverse(<..>) is <..>,
%%    all x, y: L :- reverse(x^y) is reverse(y) ^ reverse(x)
%%\end{lstlisting}
%%
%%Что из этого короче? Что понятнее? Что лучше? (зависит от задачи)
%
%% задача - выбрать и правильно смоделировать самое главное в алгоритме:
%% gzip, протокол MESI, map/reduce, mp3, google chrome... (в зависимости от варианта задания--посмотреть,что интересует молодежь на Хабре) -- так, чтобы другой человек мог сам понять и получить это новое знание. В качестве примера, можно рассмотреть то, что я писал в диссертации - поймут студенты?
%% DOM:
%%http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-184E7107–???DOM Core 3
%%http://ru.wikipedia.org/wiki/Document_Object_Model-

\appendix
\include{rslprior}

\pagebreak
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{rslbooks}

\end{document}
