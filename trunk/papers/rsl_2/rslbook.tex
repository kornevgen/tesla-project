% !Mode:: "TeX:UTF-8"
\documentclass[14pt, twoside]{extreport}
\usepackage{cmap}

%\usepackage{fix-cm}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{dsfont}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\usepackage{clrscode}

\pagestyle{headings}

\textheight 23cm % 29.7-2-2
\textwidth 16cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \evensidemargin 0cm  \headheight 0cm \headsep 1.5cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел

\usepackage{ifpdf}

\ifpdf
% we are running pdflatex, so convert .eps files to .pdf
% run pdflatex with --shell-escape and thesis.aux
\usepackage[pdftex]{graphicx}
\usepackage{epstopdf}
\else
% we are running LaTeX, not pdflatex
\usepackage{graphicx}
\fi

% Подправим команду \appendix : нумерация русскими буквами,
% а не латинскими.
\makeatletter
\renewcommand\appendix{\par
  \setcounter{chapter}{0}%
  \setcounter{section}{0}%
  \def\@chapapp{\appendixname}%
  \def\thechapter{\@Asbuk\c@chapter}}
\makeatother

% "русифицируем" окружение enumerate:
\makeatletter
\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
\def\labelenumii{\theenumii)}    % а не латинские буквы
\def\p@enumii{\theenumi}         % а это для \ref
\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
\let\theenumiii\relax            % и отдельных ссылок на него не будет
\def\p@enumiii{\theenumi\theenumii}
\makeatother

\usepackage{rsl}

\usepackage{listingsutf8}
\lstloadlanguages{RSL}
\lstset{numbers=left, language=RSL, extendedchars=true, numberstyle=\tiny}
%, inputencoding=utf8/latin1, commentstyle=\itshape, stringstyle=\bfseries}

\author{Евгений Корныхин}
\title{\huge{\textbf{\textsc{Задачи по формальной спецификации программ на RSL}}}}
%\date{Москва --- 2010}

\newcounter{problem_type}[chapter]
\newcounter{zadacha}[problem_type]
\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
\textit{\arabic{chapter}.\arabic{problem_type}.\arabic{zadacha}}~~  }

\newcommand{\head}[1]{\vspace{1cm}\subsubsection*{#1}}
\newcommand{\zhead}[1]{\head{#1} \refstepcounter{problem_type}}


\begin{document}

\maketitle

\tableofcontents

\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}

Данный сборник задач написан в поддержку курса <<Формальной спецификации и верификации программ>>, который читается студентам последних курсов факультета ВМиК МГУ.

Под <<формальной>> спецификацией в первую очередь понимается строгое однозначное задание (описание) интерфейса или поведения программы. До сих пор необходимость доведения описаний до строгих однозначных форм ставится под сомнение, если речь идет о совершенно произвольных программах (как минимум, это сталкивается с высокой трудоемкостью формальной спецификации и особенной квалификацией тех, кто эту спецификацию составляет). Хотя полезность (и даже необходимость) строгого однозначного задания \emph{критичных} систем сомнений не вызывает. И тем не менее понижение трудоемкости и сближение формальных спецификаций с программистами-инженерами (т.е. существенное расширение области реального использования формальных спецификаций) является актуальной задачей в области технологий программирования (software engineering).

Однако дабы не попадать в дискуссионную область, курс следует иному принципу. Реалии таковы, что кроме написания программ необходимо, чтобы эти программы были корректными, чтобы они удовлетворяли стандартам. Для решения задач обеспечения таких характеристик применяются \emph{в том числе и} математические методы. Это означает, что программа выражается в математических терминах в виде \emph{математической теории}, или \emph{математической модели}, и задача уже решается в рамках этой математической теории с применением математического аппарата. Эта идея может показаться малоприменимой на практике, поскольку обычно математики и программисты-инженеры живут <<в разных мирах>>. На самом же деле математические методы решения задач над программами (их еще называют \emph{формальными методами}, подчеркивая, что <<обычный>> программист-инженер работает в своем <<неформальном>> мире представления о своей программе) исторически возникли практически сразу с возникновением практического программирования (это 50-е годы ХХ века) и развиваются по настоящее время.

Математическая теория, создаваемая для программы, это и есть формальная спецификация. От природы этой спецификации будут зависеть и математические методы, применяемые для решения задачи. Математическая теория не создается сама по себе --- она создается для конкретных целей, для решения определенных задач: формализация требований с целью, во-первых, их прояснения, во-вторых, для выяснения в них противоречий и неполных требований, автоматизация тестирования, чёткая документация, формальная верификация и даже разработка программ при помощи формальных моделей. Единожды проведя формализацию, можно существенно снизить <<человеческий>> фактор на последующих этапах жизненного цикла программы.

Эта часть курса посвящена тому, какие на данный момент придуманы виды моделей, какой природы математические теории используются для описания программ. Вторая часть курса (не вошедшая в этот сборник задач) посвящена одному из применений формальных спецификаций --- формальной верификации программ.

Читатели могут столкнуться с <<моделями программ>> не впервые. Студенты ВМиК МГУ слушают перед этим курсом курс по объектно-ориентированному анализу и проектированию программ и курс по верификации программ на моделях (model checking). Отличия этого курса от уже прослушанных заключаются в следующем. Курс ООАП также работает с моделями, но многие из этих моделей ориентированы только на последующее кодирование, а не на анализ программ. Грубо говоря, речь идет о моделировании структуры кода, а не семантики программы. Кроме того, строгий, формальный, подход практически никак не отражен в этом курсе. В курсе верификации на моделях рассматривается инструмент SPIN и моделирование на языке PROMELA. Остальные виды моделей программ в этом курсе не рассматриваются, но рассматриваются в данном курсе.

Согласно одной из принятых классификаций выделяют следующие основные виды моделей программ:
\begin{itemize}
  \item логико-алгебраические модели (interface specification: property-based / state-based);
  \item исполнимые модели (behavior specification);
\end{itemize}
Кроме того, выделяют модели, совмещающие в себя характеристики логико-алгебраических и исполнимых моделей.

Исполнимые спецификации дают модель в виде программы для некоторой виртуальной машины, может быть, достаточно абстрактной. В основном, это различные виды конечных автоматов и систем переходов (LTS). К таким моделям относятся модели на PROMELA, уже знакомые читателям. Кроме того, с конечными автоматами они сталкивались достаточно часто в предыдущих курсах. Поэтому в этом курсе исполнимые модели не будут рассматриваться подробно.

Логико-алгебраические модели рассматривают операции программы в математическом смысле, как отображения аргументов и пре-состояния на значения-результаты операций и пост-состояния\footnote{потому такие модели не являются исполнимыми в общем случае --- попробуйте для любой функции, заданной отображением, автоматически построить программу, которая ее исполняет!}. Чистые \emph{логические модели} представляют собой набор аксиом, из которых следуют эти отображения. \emph{Алгебраические модели} описывают эквивалентности суперпозиций операций (грубо говоря, эти модели состоят из требований эквивалентности разных термов--цепочек действий). К неисполнимым спецификациями принадлежат и такие виды моделей как \emph{программные контракты} --- набор логических свойств, которые должны быть выполнены при корректных входных данных и вычисленных по ним выходных. Грубо говоря, для задания семантики программы в неисполнимом виде применяются два подхода: <<чистый операционный>> (функциональный) подход (property-based) и подход, основанный на моделировании состояния программы (model-based, state-based). В функциональном подходе состояние не моделируется! И тем не менее, семантику операций удается задать. Вторая глава задачника посвящена функциональному подходу. Третья глава --- подходу, основанному на моделировании состояния программы. А первая глава посвящена тому языку, на котором все эти модели можно выражать --- языку RSL. Авторы языка попытались создать язык, который был бы языком программирования и языком спецификации одновременно\footnote{На самом деле обе эти цели можно воспринимать как моделирование --- первое является исполнимым моделированием, а второе неисполнимым.}. Единый языка выражения программы и ее семантики позволяют легче провести верификацию программы на такой модели. Но вопросы верификации лежат уже за пределами данного сборника задач.

\chapter{RSL для императивного программирования}

\input{prog/about}

\section*{Задачи}

\input{prog/problems}


\chapter{Логико-алгебраические спецификации}

\section{Логические модели}

Логико-алгебраические модели --- набор свойств, утверждений, аксиом~\cite{kuliamin}. Из этих аксиом путем логического вывода получаются другие свойства.

\head{Логическая модель на RSL}
Это набор аксиом. Аксиомы помещаются в секцию \textbf{axiom}. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y: Int :-
            add(x,y) >= x,
            add(x,y) >= y,
            add(x,0) is x,
            add(10, 45) is 55,
            exists! z : Int :- add(0, z) is x
end
\end{lstlisting}

\section*{Задачи}

\input{alg/formal}

\section{Алгебраические спецификации}

\input{alg/theor}

\section*{Задачи}

\input{alg/calc}

\input{alg/find_errors}

\input{alg/unformal}

\input{alg/problems}

\section{Полнота и непротиворечивость алгебраических спецификаций}

\input{alg/compness}

\section*{Задачи}

\input{alg/comprobs}

\section{Cпецификация рекурсивных типов}

%\head{Рекурсивное определение типов (деревьев)}
Алгебраические модели и АТД являются удобным способом рекурсивного задания типов и операций их обработки. Для этого представленный только что формальный метод построения достаточно полных алгебраических спецификаций прочитывается следующим способом:
\begin{enumerate}
  \item выделить и составить сигнатуры конструкторов (пустое значение | составление нового <<узла дерева>>);
  \item выделить и составить сигнатуры функций-обработчиков рекурсивного типа;
  \item описать результат обработки для каждого конструктора.
\end{enumerate}

Например, спецификация функции, вычисляющей глубину бинарного дерева, согласно этому методу получается такой:
\begin{lstlisting}
type Node, Tree == empty | mk_tree(Node, Tree, Tree)
value depth: Tree -> Nat
axiom forall n: Node, left: Tree, right: Tree :-
  depth( empty ) is 0,
  depth( mk_tree(n, left, right) ) is
          max( depth(left), depth(right) )
value max: Nat >< Nat -> Nat
   max(x,y) is if x > y then x else y end
\end{lstlisting}

Конструктор предназначена лишь для структурных целей, т.е. определение дерева в виде типа Tree из этого примера пойдет и для бинарного дерева произвольного вида, и для бинарного сбалансированного дерева, и для других бинарных деревьев. А уже менее тривиальные функции составления деревьев (например, чтобы не нарушалась сбалансированность) определяются в виде функций-обработчиков.

\section*{Задачи}
%
\zhead{}%Рекурсивные типы}
%
\z Специфицируйте операцию проверки вхождения элемента в бинарное дерево.

\textbf{Решение:}
\begin{lstlisting}
type Node, Tree == empty | add(Node, Tree, Tree)
value check: Node >< Tree -> Bool
axiom forall n, n1:Node, left, right: Tree :-
   ~check( empty ),
   check(n, add(n1,left,right) ) is (n = n1) \/
             check(n, left) \/ check(n, right)
\end{lstlisting}

\z Специфицируйте операцию вычисления высоты бинарного дерева.

\z Специфицируйте операцию проверки бинарного дерева на сбалансированность.

\z Специфицируйте операцию получения предка элемента бинарного дерева.

\z Специфицируйте добавление элемента в двоичное дерево поиска.

\z Специфицируйте удаление элемента из двоичного дерева поиска.

\z Специфицируйте добавление элемента в АВЛ-дерево. Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из АВЛ-дерева. Определение операции предполагается найти самостоятельно.

\z Специфицируйте добавление элемента в 2-3-дерево. Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из 2-3-дерева. Определение операции предполагается найти самостоятельно.

\z Специфицируйте добавление элемента в декартово дерево. Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из декартова дерева. Определение операции предполагается найти самостоятельно.

\z Специфицируйте добавление элемента в красно-чёрное дерево.  Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из красно-чёрного дерева.  Определение операции предполагается найти самостоятельно.



%
%
%\chapter{Моделе-ориентированные спецификации}
%
% код хаффмана! отображения + рекурсивные типы данных
%\z Формализуйте определения терминов, приведенных в этом тексте --- они выделены курсивом (он взят из~\cite{structures_algorithms}). \emph{Дерево} --- это совокупность элементов, называемых \emph{узлами} (один из которых определен как \emph{корень}), и отношений (<<родительских>>), образующих иерархическую структуру узлов. Узлы, так же, как и элементы списков, могут быть элементами любого типа. Мы часто будем изображать узлы буквами, строками или числами. Формально дерево можно рекуррентно определить следующим образом.
%\begin{enumerate}
%\item Один узел является деревом. Этот же узел также является корнем этого дерева.
%\item Пусть $n$ --- это узел, а $T_1, T_2, ..., T_k$ --- деревья с корнями $n_1, n_2, ..., n_k$ соответственно. Можно построить новое дерево, сделав $n$ родителем узлов $n_1, n_2, ..., n_k$. В этом дереве $n$ будет корнем, а $T_1, T_2, ..., T_k$ --- \emph{поддеревьями} этого корня. Узлы $n_1, n_2, ..., n_k$ называются \emph{сыновьями} узла $n$.
%\end{enumerate}
%
%Часто в это определение включают понятие \emph{нулевого дерева}, т.е. <<дерева>> без узлов.
%
% http://informatics.mccme.ru/moodle/course/view.php?id=18

%%\chapter{Поведенческие спецификации}
%%TBD
%
%\chapter{Специфицирование систем реального размера}
%Спецификация для функции append в <<исполнимой>> манере:
%\begin{lstlisting}
%type E, L = E*
%value append: L >< L -> L
%    append(x, y) is x ^ y
%\end{lstlisting}
%
%Спецификация для функции append в <<логической>> манере:
%\begin{lstlisting}
%type E, L = E*
%value append: L >< L -> L
%    append(x, y) as z
%    post
%        len z = len x + len y /\
%        (all i: Nat :- i isin inds x => z(i) = x(i)) /\
%        (all i: Nat :- i isin inds y => z(i+len x) = y(i))
%\end{lstlisting}
%
%Спецификация для функции reverse в <<исполнимой>> манере:
%\begin{lstlisting}
%type E, L = E*
%value reverse: L -> L
%    reverse(x) is
%        local variable y : L :- y = <..> in
%            for xi in x do
%                y := <.xi.> ^ y
%            end;
%            y;
%        end
%\end{lstlisting}
%
%Спецификация для функции reverse в <<логической>> манере:
%\begin{lstlisting}
%type E, L = E*
%value reverse: L -> L
%  reverse(x) as y
%  post len x = len y /\
%    (all i: Nat :- i isin inds x => y(i) = x(len x + 1 - i))
%\end{lstlisting}
%
%Спецификация для функции reverse в <<алгебраической>> манере:
%\begin{lstlisting}
%type E, L = E*
%value reverse: L -> L
%axiom
%    reverse(<..>) is <..>,
%    all x, y: L :- reverse(x^y) is reverse(y) ^ reverse(x)
%\end{lstlisting}
%
%Что из этого короче? Что понятнее? Что лучше? (зависит от задачи)

% задача - выбрать и правильно смоделировать самое главное в алгоритме: gzip, map/reduce, mp3, google chrome... (в зависимости от варианта задания--посмотреть,что интересует молодежь на Хабре) -- так, чтобы другой человек мог сам понять и получить это новое знание. В качестве примера, можно рассмотреть то, что я писал в диссертации - поймут студенты?


\appendix
\include{rslprior}

\pagebreak
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{rslbooks}

\end{document}
