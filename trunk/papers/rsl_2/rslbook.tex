% !Mode:: "TeX:UTF-8"
\documentclass[14pt, twoside]{extreport}
\usepackage{cmap}

%\usepackage{fix-cm}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{dsfont}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\usepackage{clrscode}

\pagestyle{headings}

\textheight 23cm % 29.7-2-2
\textwidth 16cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \evensidemargin 0cm  \headheight 0cm \headsep 1.5cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел

\usepackage{vaucanson-g}

\usepackage{ifpdf}

\ifpdf
% we are running pdflatex, so convert .eps files to .pdf
% run pdflatex with --shell-escape and thesis.aux
\usepackage[pdftex]{graphicx}
\usepackage{epstopdf}
\else
% we are running LaTeX, not pdflatex
\usepackage{graphicx}
\fi

% Подправим команду \appendix : нумерация русскими буквами,
% а не латинскими.
\makeatletter
\renewcommand\appendix{\par
  \setcounter{chapter}{0}%
  \setcounter{section}{0}%
  \def\@chapapp{\appendixname}%
  \def\thechapter{\@Asbuk\c@chapter}}
\makeatother

% "русифицируем" окружение enumerate:
\makeatletter
\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
\def\labelenumii{\theenumii)}    % а не латинские буквы
\def\p@enumii{\theenumi}         % а это для \ref
\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
\let\theenumiii\relax            % и отдельных ссылок на него не будет
\def\p@enumiii{\theenumi\theenumii}
\makeatother

\usepackage{rsl}

\usepackage{listingsutf8}
\lstloadlanguages{RSL}
\lstset{numbers=left, language=RSL, extendedchars=true, numberstyle=\tiny, inputencoding=utf8%,
%commentstyle=\itshape, stringstyle=\bfseries
}

\author{Евгений Корныхин}
\title{\huge{\textbf{\textsc{Семинарские занятия по формальной функциональной спецификации программ}}}}
%\date{Москва --- 2010}

\newcounter{problem_type}[chapter]
\newcounter{zadacha}[problem_type]
\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
\textit{\arabic{chapter}.\arabic{problem_type}.\arabic{zadacha}}~~  }

%\newcounter{problem_type}[section]
%\newcounter{zadacha}[problem_type]
%\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
%\textit{\arabic{section}.\arabic{problem_type}.\arabic{zadacha}}~~  }

\newcommand{\head}[1]{\vspace{1cm}\subsubsection*{#1}}
\newcommand{\zhead}[1]{\head{#1} \refstepcounter{problem_type}}


\begin{document}

\maketitle

\tableofcontents

\input{intro}


%%%%%%%%%% Общая структура %%%%%%%%%%%
%%  0. "Введение". (см. igoogle) Создание формальной модели поведения системы как способ уточнения требований
%%  1. "Основные определения" (спецификация, модель, полнота, тотальность, непротиворечивость, явность).
%%      Нулевая задачка экзамена. Детерминированные функции, недетерминированные функции на примерах чисел.
%%      Первая задачка экзамена в том случае, когда всё состояние скрыто (т.е. про состояние пока что не думаем).
%%  2. "Языки спецификации". Сначала RSL (множества, списки, отображения). Потом ACSL (модель памяти, функции с указателями)
%%  3. "Модельные спецификации". Кроме самих данных, специфицируем состояние системы (модель состояния, инварианты).
%%      Первая задачка экзамена в полном объеме. Выделение ветвей функциональности при записи постусловий.
%%      Согласованность модельных спецификаций (инвариант не пуст после каждой функции, нет вызовов функций вне их предусловий)
%%  4. "Алгебраические спецификации". Понятие алгебраической спецификации (новая вторая задачка экзамена).
%%      Согласованность алгебраических спецификаций (бывшая вторая задачка экзамена).
%%  5. "Автоматные спецификации". Тут про третью задачку экзамена.
%%  6. ......... может быть сюда включить формальную верификацию...........

\chapter{Основные понятия}

\section{RSL для императивного программирования}

    \input{prog/about}

    \section*{Задачи}

    \input{prog/problems}

\section{Функции в языках спецификации}

    \input{basis/funcs}

    \section*{Задачи}

    \input{alg/formal}

    \input{basis/im2ex}




\chapter{Уточнение функциональных требований}

\section{Операции и ветви функциональности}

Данный курс посвящён формальной спецификации программно-ап-паратных систем (далее, просто <<систем>>) и их компонентов. С точки зрения пользователя система даёт возможность выполнить с её помощью ряд \emph{операций}. Аналогично, каждый отдельный компонент даёт возможность остальным компонентам выполнять с его помощью ряд операций. Операция обладает рядом \emph{аргументов} и \emph{результатов операции}, непосредственно доступных тому, кто запросил данную операцию. Во время операции система (или её отдельный компонент) ведут себя строго определённым образом в зависимости от значений аргументов, внутреннего состояния системы и состояния среды, в которой работает система (будем их называть \emph{входными параметрами} операции).

Предположим, что система ещё не реализована, для неё составляется набор требований, по которым будет осуществлена реализация. От того, насколько точно будут сформулированы эти требования, будет зависеть и качество реализованной системы. Основные проблемы в требованиях следующие:
\begin{itemize}
  \item несогласованность (противоречивость): набор требований содержит как минимум несовместное подмножество требований;
  \item неполнота: набор требований ничего не говорит о том, каким должно быть поведение некоторой операции при некоторых значениях входных параметров;
  \item неоднозначность: некоторое требование можно трактовать несколькими способами.
\end{itemize}

Эти проблемы приводят в последствие к тому, что система в целом ведет себя не так, как этого хотел бы пользователем, что система вообще не может работать, поскольку при реализации её компонентов разработчики по-разному поняли требования, что срываются сроки, отведённые на реализацию, нарушается бюджет проекта и т.д. и т.п.

В качестве одного из методов обнаружения и избавления от таких проблем в данном курсе рассматриваются формальные спецификации. Идея заключается в том, что разработчик требований должен составить одну или несколько \emph{формальных моделей} поведения компонентов и системы (под \emph{поведением системы} понимается .........., для краткости будем называть \emph{поведением операции} поведение системы при выполнении операции). Такие модели дают однозначное задание поведения с возможностью применения математических методов для выяснения наличия противоречий и неполно описанных требований. В очень простых случаях такие формальные модели могут стать основой для реализации систем, но в общем случае сложность системы не позволяет получить такую модель. Вместо этого создают несколько небольших формальных моделей, описывающих поведение системы с отдельных точек зрения, игнорируя ряд деталей. Процесс создания формальной модели будем называть \emph{уточнением требований}, поскольку модель составляется, исходя из некоторого неформального представления о поведении системы, а в результате построения формальной модели получается однозначное, формальное, описание поведения системы.

Каждой операции сопоставим отдельную функцию на RSL с определенной сигнатурой:
$$op : S \times I ~\NonDetermFn~access~ S \times O$$
где $S$ --- состояние системы (слева от стрелки это состояние до выполнения операции, \emph{пре-состояние}, справа от стрелки это состояние после выполнения операции, \emph{пост-состояние}), $I$ --- аргументы операции, $O$ --- результаты операции (та информация, которая становится известной/актуальной только после выполнения операции), $access$ --- указание глобальных переменных, к которым осуществляется доступ в рамках выполнения операции.

Назовем класс значений входных параметров операции, при котором её поведение с некоторой точки зрения одинаковое, \emph{ветвью функциональности} операции. Например, операция добавления элемента в список работает по-разному, если список пустой и если список непустой (в первом случае создаётся новый <<объект>>-список, во втором случае --- не создаётся, только происходит дополнение его элементов). Поэтому для этой операции можно выделить такие две ветви функциональности: при пустой списке и при непустом списке.

Ветви функциональности можно получать следующим \emph{комбинаторным способом}. Для операции выделяется набор элементарных характеристик, обладающих конечным числом значений. В каждой ветви функциональности каждая характеристика обладает своим значением, а каждая ветвь функциональности представляется вектором значений, отдельные элемент такого вектора соответствует отдельной характеристике.

При некоторых значениях входных параметров операция может быть не определена (например, операция нахождения максимального элемента в списке не определена для пустого списка). Такие входные параметры мы в дальнейшем будем выделять особо и не называть их ветвями функциональности.


%понятие предусловия, постусловия:
%
%[Большая цитата из статьи В.Кулямина, 14(1)й том трудов ИСП]
%
%Программный контракт операции состоит из предусловия и постусловия. Первое фиксирует требования к корректному использованию этой операции со стороны окружения системы — при каких ограничениях на аргументы обращение к этой операции корректно. Второе определяет обязательства системы по отношению к результатам вызовов этой операции — какие ограничения на результаты работы операции должны быть выполнены при корректной работе системы, если обращение к ней было правильным. При нарушении предусловия операции обращение к ней может иметь любые последствия, поведение системы в этом случае не определено. Совместно пред- и постусловия строго определяют требования к работе системы.
%
%При анализе сложной системы с большим количеством интерфейсных операций крайне неудобно рассматривать их все вместе как однородный набор, необходимо разбиение этих операций на какие-то логические группы по реализуемым ими функциям. Эти группы почти всегда соответствуют компонентам или модулям системы, ответственным за реализацию этих функций. Часто такие компоненты имеют внутреннее состояние, недоступное для непосредственного наблюдения извне системы, но влияющее на поведение вызываемых операций компонента и изменяемое ими.
%
%Поэтому для описания ограничений в пред- и постусловиях необходимо как-
%то учитывать внутреннее состояние компонента, операции которого
%описываются. Чтобы сделать это возможным, контракты операций одного
%компонента объединяются в спецификацию этого компонента вместе с
%описанием структуры его модельного состояния.
%Структура модельного состояния компонента не обязана совпадать со
%структурой его реального состояния, зафиксированной в его коде, например,
%компонент, реализующий список, может использовать ссылочную структуру
%данных, в том время, как структура его модельного состояния в
%спецификациях может быть основана на массиве. В структуре модельного
%состояния могут совсем отсутствовать некоторые части реального состояния
%компонента, слабо связанные с его функциональностью, например,
%различного рода кэши и другие данные, используемые для увеличения
%производительности. Важно, что структура модельного состояния компонента
%должна содержать данные, достаточные для полного описания
%функциональности в пред- и постусловиях операций этого компонента. При
%этом предусловие зависит от аргументов вызова операции и данных
%модельного состояния при этом вызове, или пре-состояния. Постусловие
%зависит как от аргументов и пре-состояния, так и от результата и данных
%модельного состояния после вызова, или пост-состояния.
%Наличие сложной структуры модельного состояния приводит к
%необходимости учитывать в контрактах операций ограничения на его данные,
%которые должны выполняться в стабильных состояниях системы, когда ни
%одна из операций не выполняется. Такие ограничения оформляются в виде
%инвариантов модельного состояния. Инварианты являются общими частями
%пред- и постусловий всех операций, как-то затрагивающих соответствующие
%компоненты — они должны выполняться как в пре-состоянии любого вызова,
%так и в его пост-состоянии.
%
%
%Обычно постусловие операции описывает несколько разных режимов ее
%функционирования. Предусловие запрещает все комбинации значений
%параметров, при которых поведение операции не определено. Однако среди
%разрешаемых предусловием ситуаций могут остаться такие, в которых
%выполнить свою основную функцию операция не может. Вместо этого она
%должна вернуть некоторый код ошибки, создать исключительную ситуацию
%или как-то иначе сигнализировать о том, что ее основная задача не может
%быть решена в такой ситуации. Помимо режимов сигнализации о
%невозможности выполнить основную функцию, само ее выполнение может
%идти разными путями. Например, операция конкатенации двух строк может
%проверять, не является ли один из ее аргументов пустой строкой, и в этом
%случае просто возвращать копию другого аргумента, не выполняя никаких
%действий над ней. Если же оба аргумента не пусты, копия одного из них
%должна быть подвергнута модификации, чтобы получить результат операции.
%
%При написании постусловий удобно выделять такие разные режимы, иначе
%постусловие превращается в большую и сложную формулу, трудную для
%анализа и понимания, что противоречит основной цели создания формальных
%спецификаций. Различные режимы работы операции описываются в виде
%импликаций с несовместными посылками (постусловие при этом выглядит как формула
%(X1 => Y1) /\ (X2 => Y2) /\ ... (Xn => Yn)
%или в виде разных выражений для
%возвращаемого результата при разных исходных условиях, т.е. результат
%постусловия вычисляется в разных ветвях некоторого условного оператора
%или оператора выбора по-разному. Поэтому эти разные режимы называют
%ветвями функциональности (или функциональными ветвями) операции.

\section*{Задачи}

\zhead{Составить сигнатуры функций и выделить ветви функциональности каждой из них}

..............TODO


\section{Множества, списки, отображения}

.......TODO вступление, что для выражения свойств данных нужно промоделировать эти данные при помощи простейших средств типа множеств, списков, отображений....

\input{model/setlist}  % with problems

\section{Уточнение требований при помощи моделеориентированных спецификаций}

Как сказано в предыдущем разделе, уточнение требований выполняется путем выделения ветвей функциональности, т.е. классов значений входных параметров. В данном разделе предлагается использовать язык множеств, списков и отображений для описания типов параметров и выражений над значениями параметров. При этом для описания ветвей функциональности отдельных операций будет применяться явное или неявное описание. В данном случае оно называется \emph{моделеориентированным} описанием (потому что для параметров задается <<модель>> на языке множеств, списков и отображений).


.............TODO предусловие, запись в явном или неявном виде, замкнутое описание (включает ли выходное состояние....), инвариант.......

.....TODO первая задачка экзамена


\section{Уточнение требований при помощи алгебр}


\chapter{Аналитическая верификация}

\section{Методы Флойда}

\section*{Задачи}

Во всех задачах $x_1, x_2, ...$ --- входные переменные, $y_1, y_2, ...$ --- промежуточные переменные, $z_1, z_2, ...$ --- выходные переменные. Если не сказано противное, входные переменные обладают целыми неотрицательными значениями.

Если в алгоритмах не указано условие у оператора цикла, значит это условие --- тождественная истина (т.е. цикл бесконечный).

\zhead{Доказать частичную корректность следующих числовых алгоритмов\footnote{Часть задач взяты из~\cite{Shen}, часть задач составлены Алексеем Хорошиловым}}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = x_1 \cdot x_2)$

\begin{codebox}
\Procname{$\proc{Multiply}(x_1,x_2)$}
\li $y_1 \gets 0$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_2$
\li \Do $(y_1,~y_2) \gets (y_2 + x_1,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1)~is~true$, $post(x_1, z)~is~(z = x_1 \cdot (x_1 + 1))$

\begin{codebox}
\Procname{$\proc{Arithmetic}(x_1)$}
\li $y_1 \gets 0$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_1$
\li \Do $(y_1,~y_2) \gets (y_1 + 2y_2,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1)~is~true$, $post(x_1, z)~is~(z = x_1 \cdot (x_1 + 1) \cdot (2x_1 + 1))$

\begin{codebox}
\Procname{$\proc{SumSquare}(x_1)$}
\li $y_1 \gets 0$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_1$
\li \Do $(y_1,~y_2) \gets (y_1 + 6y_2\cdot y_2,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = x_1^{x_2})$

\begin{codebox}
\Procname{$\proc{Power}(x_1,x_2)$}
\li $y_1 \gets 1$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_2$
\li \Do $(y_1,~y_2) \gets (y_1 * x_1,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~(x_2 > 0)$, $post(x_1, x_2, z)~is~(z = x_1^{x_2})$

\begin{codebox}
\Procname{$\proc{Power}(x_1,x_2)$}
\li $y_1 \gets x_1$
\li $y_2 \gets 1$
\li \While $y_2 < x_2$
\li \Do \If $2y_2 \leq x_2$
\li \Then $(y_1,~y_2) \gets (y_1 * y_1,~2y_2)$
\li \Else $(y_1,~y_2) \gets (y_1 * x_1,~y_2 + 1)$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = x_1^{x_2})$

\begin{codebox}
\Procname{$\proc{Power}(x_1,x_2)$}
\li $y_1 \gets 1$
\li $y_2 \gets 0$
\li \While $y_2 < x_2$
\li \Do \If $y_2 = 0$
\li \Then $(y_1,~y_2) \gets (x_1,~1)$
\li \Else \If $2y_2 \leq x_2$
\li \Then $(y_1,~y_2) \gets (y_1 * y_1,~2y_2)$
\li \Else $(y_1,~y_2) \gets (y_1 * x_1,~y_2 + 1)$ \End \End \End
\li $z \gets y_1$
\end{codebox}

% НОД
\z (<<GCD>> -- greatest common divisor) $pre(x_1, x_2)~is~(x_1 + x_2 > 0)$, $post(x_1, x_2, z)~is~(z = \gcd(x_1,x_2))$

\begin{codebox}
\Procname{$\proc{GCD}(x_1,x_2)$}
\li \If $x_1 > x_2$
\li \Then $y_1 \gets x_1$
\li \Else $y_1 \gets x_2$ \End
\li \While $x_1 \mod y_1 \neq 0 ~\vee~ x_2 \mod y_1 \neq 0$
\li \Do $y_1 \gets y_1 - 1$ \End
\li $z \gets y_1$
\end{codebox}

\z (<<GCD>> -- greatest common divisor) $pre(x_1, x_2)~is~(x_1 + x_2 > 0)$, $post(x_1, x_2, z)~is~(z = \gcd(x_1,x_2))$

\begin{codebox}
\Procname{$\proc{GCD}(x_1,x_2)$}
\li $y_1 \gets x_1$
\li $y_2 \gets x_2$
\li \While $y_1 > 0 ~\wedge~ y_2 > 0$
\li \Do \If $y_1 \geq y_2$
\li     \Then $y_1 \gets y_1 - y_2$
\li     \Else $y_2 \gets y_2 - y_1$ \End \End
\li \If $y_1 = 0$
\li \Then $z \gets y_2$
\li \Else $z \gets y_1$ \End
\end{codebox}

\z (<<LCM>> -- least common multiple) $pre(x_1, x_2)~is~(x_1 + x_2 > 0)$, $post(x_1, x_2, z)~is~(z = 2\cdot \mbox{lcm}(x_1,x_2))$

\begin{codebox}
\Procname{$\proc{2LCM}(x_1,~x_2)$}
\li $(y_1,~y_2,~y_3,~y_4) \gets (x_1,~x_2,~x_2,~x_1)$
\li \While $y_1 \neq 0 ~\wedge~ y_2 \neq 0$
\li \Do \If $y_1 \geq y_2$
\li     \Then $(y_1,~y_4) \gets (y_1 - y_2,~y_3 + y_4)$
\li     \Else $(y_2,~y_3) \gets (y_2 - y_1,~y_3 + y_4)$ \End \End
\li \If $y_1 = 0$
\li \Then $z \gets y_4$
\li \Else $z \gets y_3$ \End
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z = x^2)$

\begin{codebox}
\Procname{$\proc{Square}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~0)$
\li \While $y_1 < x$
\li \Do $(y_1,~y_2,~y_3) \gets (y_1 + 1,~y_2 + 2,~y_2 + y_3)$ \End
\li $z \gets y_1 + y_3$
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z^2 \leq x < (z+1)^2)$

\begin{codebox}
\Procname{$\proc{Sqrt}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~1)$
\li \While
\li \Do $y_2 \gets y_2 + y_3$
\li \If $y_2 > x$
\li \Then break
\li \Else $(y_1,~y_3) \gets (y_1 + 1,~y_3 + 2)$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~(x_1 > 0)~\wedge~(x_2 > 0)$, $post(x_1, x_2, z_1, z_2)~is~(0 \leq z_2 < x_2)~\wedge~(x_1 = z_1 \cdot x_2 + z_2)$

\begin{codebox}
\Procname{$\proc{Division}(x_1, x_2)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~x_1)$
\li \While $y_3 \neq 0$
\li \Do $y_1 \gets if~(y_2 + 1 = x_2)~then~(y_1 + 1)~else~y_1$
\li     $y_2 \gets if~(y_2 + 1 = x_2)~then~0~else~(y_2 + 1)$
\li     $y_3 \gets y_3 - 1$ \End
\li $(z_1,~z_2) \gets (y_1,~y_2)$
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z = x^2)$

\begin{codebox}
\Procname{$\proc{Square}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~1,~1-x)$
\li \While $y_3 < x$
\li \Do \If $odd(y_2)$
\li     \Then $y_1 \gets y_1 + y_2$ \End
\li     $(y_2,~y_3) \gets (y_2 + 1,~y_3 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

$odd(x)$ истинно тогда и только тогда, когда $x$ нечетно.

\z $pre(x)~is~true$, $post(x, z)~is~(z^3 \leq x < (z+1)^3)$

\begin{codebox}
\Procname{$\proc{Cubert}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~1)$
\li \While
\li \Do $y_2 \gets y_2 + y_3$
\li     \If $y_2 > x$
\li     \Then break
\li     \Else $y_1 \gets y_1 + 1$
\li             $y_3 \gets y_3 + 6y_1$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x)~is~(x < 102)$, $post(x, z)~is~(z = 91)$

\begin{codebox}
\Procname{$\proc{Century}(x)$}
\li $(y_1,~y_2) \gets (x,~1)$
\li \While $y_1 < 101 ~\vee~ y_2 \neq 1$
\li \Do \If $y_1 > 100$
\li     \Then $(y_1,~y_2) \gets (y_1 - 10,~y_2 - 1)$
\li     \Else $(y_1,~y_2) \gets (y_1 + 11,~y_2 + 1)$ \End \End
\li $z \gets y_1 - 10$
\end{codebox}

\z $pre(x)~is~(x > 1)$, $post(x, z)~is~(z = x^3)$

\begin{codebox}
\Procname{$\proc{Qube}(x)$}
\li $(y_1,~y_2,~y_3) \gets (x,~1,~x)$
\li \While
\li \Do \If $y_2 < y_3$
\li     \Then $(y_1,~y_2) \gets (y_1 + x,~y_2 + 1)$
\li     \Else \If $y_3 = x$
\li         \Then $y_3 \gets y_1$
\li         \Else break \End \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z = x^2)$

\begin{codebox}
\Procname{$\proc{Square}(x)$}
\li $(y_1,~y_2) \gets (x,~1)$
\li \While $y_2 < x$
\li \Do \If $2y_2 \leq x$
\li     \Then $(y_1,~y_2) \gets (2y_1,~2y_2)$
\li     \Else $(y_1,~y_2) \gets (y_1 + x,~y_2 + 1)$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = {x_1}^{x_2})$ ($0^0~is~1$)

\begin{codebox}
\Procname{$\proc{Power}(x)$}
\li $(y_1,~y_2,~y_3) \gets (x_1,~x_2,~1)$
\li \While $y_2 \neq 0$
\li \Do \If $odd(y_2)$
\li     \Then $(y_2,~y_3) \gets (y_2 - 1,~y_1 \cdot y_3)$
\li     \Else $(y_1,~y_2) \gets (y_1 \cdot y_1,~y_2 / 2)$ \End \End
\li $z \gets y_3$
\end{codebox}

$odd(x)$ истинно тогда и только тогда, когда $x$ нечетно.



% дискретное логарифмирование


%%%\chapter{Поведенческие спецификации}
%%%TBD
%%



%\chapter{Формальные спецификации в различных предметных областях}


%%\chapter{Специфицирование систем реального размера}
%%Спецификация для функции append в <<исполнимой>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value append: L >< L -> L
%%    append(x, y) is x ^ y
%%\end{lstlisting}
%%
%%Спецификация для функции append в <<логической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value append: L >< L -> L
%%    append(x, y) as z
%%    post
%%        len z = len x + len y /\
%%        (all i: Nat :- i isin inds x => z(i) = x(i)) /\
%%        (all i: Nat :- i isin inds y => z(i+len x) = y(i))
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<исполнимой>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%    reverse(x) is
%%        local variable y : L :- y = <..> in
%%            for xi in x do
%%                y := <.xi.> ^ y
%%            end;
%%            y;
%%        end
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<логической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%  reverse(x) as y
%%  post len x = len y /\
%%    (all i: Nat :- i isin inds x => y(i) = x(len x + 1 - i))
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<алгебраической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%axiom
%%    reverse(<..>) is <..>,
%%    all x, y: L :- reverse(x^y) is reverse(y) ^ reverse(x)
%%\end{lstlisting}
%%
%%Что из этого короче? Что понятнее? Что лучше? (зависит от задачи)
%
%% задача - выбрать и правильно смоделировать самое главное в алгоритме:
%% gzip, протокол MESI, map/reduce, mp3, google chrome... (в зависимости от варианта задания--посмотреть,что интересует молодежь на Хабре) -- так, чтобы другой человек мог сам понять и получить это новое знание. В качестве примера, можно рассмотреть то, что я писал в диссертации - поймут студенты?
%% DOM:
%%http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-184E7107–???DOM Core 3
%%http://ru.wikipedia.org/wiki/Document_Object_Model-

\appendix
\include{rslprior}

\pagebreak
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{rslbooks}

\end{document}
