% !Mode:: "TeX:UTF-8"
\documentclass[14pt]{extreport}
\usepackage{cmap}

\usepackage{fix-cm}
%\usepackage[cp1251]{inputenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{dsfont}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\pagestyle{plain}

\textheight 25.7cm % 29.7-2-2
\textwidth 16cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \headheight 0cm \headsep 0cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел


%
% Подправим команду \appendix : нумерация русскими буквами,
% а не латинскими.
\makeatletter
\renewcommand\appendix{\par
  \setcounter{chapter}{0}%
  \setcounter{section}{0}%
  \def\@chapapp{\appendixname}%
  \def\thechapter{\@Asbuk\c@chapter}}
\makeatother

%% Теперь "русифицируем" окружение enumerate:
%\makeatletter
%\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
%\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
%\def\labelenumii{\theenumii)}    % а не латинские буквы
%\def\p@enumii{\theenumi}         % а это для \ref
%\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
%\let\theenumiii\relax            % и отдельных ссылок на него не будет
%\def\p@enumiii{\theenumi\theenumii}
%\makeatother

\usepackage{rsl}

\usepackage{listingsutf8}
\lstloadlanguages{RSL}
\lstset{numbers=left, language=RSL, extendedchars=true}
%, inputencoding=utf8/latin1, commentstyle=\itshape, stringstyle=\bfseries}

\author{Евгений Корныхин}
\title{\huge{\textbf{\textsc{Задачи по формальной спецификации программ на RSL}}}}
\date{Москва --- 2010}

\newcommand{\head}[1]{\vspace{1cm}\subsubsection{#1}}

\newcounter{problem_type}[chapter]
\newcounter{zadacha}[problem_type]
\newcommand{\z}{\vspace{0.3cm}\par\addtocounter{zadacha}{1}%
\arabic{chapter}.\arabic{problem_type}.\arabic{zadacha}  }

\begin{document}

\maketitle

\tableofcontents

\pagebreak

\section*{Введение}

Данный сборник задач написан в поддержку курса <<Формальной спецификации и верификации программ>>, который читается студентам последних курсов факультета ВМиК МГУ.

Под <<формальной>> спецификацией в первую очередь понимается строгое однозначное задание (описание) интерфейса или поведения программы. До сих пор необходимость доведения описаний до строгих однозначных форм ставится под сомнение, если речь идет о совершенно произвольных программах (как минимум, это сталкивается с высокой трудоемкостью формальной спецификации и особенной квалификацией тех, кто эту спецификацию составляет). Хотя полезность (и даже необходимость) строгого однозначного задания \emph{критичных} систем сомнений не вызывает. И тем не менее понижение трудоемкости и сближение формальных спецификаций с программистами-инженерами (т.е. существенное расширение области реального использования формальных спецификаций) является актуальной задачей в области технологий программирования (software engineering).

Однако дабы не попадать в дискуссионную область, курс следует иному принципу. Реалии таковы, что кроме написания программ необходимо, чтобы эти программы были корректными, чтобы они удовлетворяли стандартам. Для решения задач обеспечения таких характеристик применяются \emph{в том числе и} математические методы. Это означает, что программа выражается в математических терминах в виде \emph{математической теории}, или \emph{математической модели}, и задача уже решается в рамках этой математической теории с применением математического аппарата. Эта идея может показаться малоприменимой на практике, поскольку обычно математики и программисты-инженеры живут <<в разных мирах>>. На самом же деле математические методы решения задач над программами (их еще называют \emph{формальными методами}, подчеркивая, что <<обычный>> программист-инженер работает в своем <<неформальном>> мире представления о своей программе) исторически возникли практически сразу с возникновением практического программирования (это 50-е годы ХХ века) и развиваются по настоящее время.

Математическая теория, создаваемая для программы, это и есть формальная спецификация. От природы этой спецификации будут зависеть и математические методы, применяемые для решения задачи. Математическая теория не создается сама по себе --- она создается для конкретных целей, для решения определенных задач: формализация требований с целью, во-первых, их прояснения, во-вторых, для выяснения в них противоречий и неполных требований, автоматизация тестирования, чёткая документация, формальная верификация и даже разработка программ с помощью формальных моделей. Единожды проведя формализацию, можно существенно снизить <<человеческий>> фактор на последующих этапах жизненного цикла программы.

Эта часть курса посвящена тому, какие на данный момент придуманы виды моделей, какой природы математические теории используются для описания программ. Вторая часть курса (не вошедшая в этот сборник задач) посвящена одному из применений формальных спецификаций --- формальной верификации программ.

Читатели могут столкнуться с <<моделями программ>> не впервые. Студенты ВМиК МГУ слушают перед этим курсом курс по объектно-ориентированному анализу и проектированию программ и курс по верификации программ на моделях (model checking). Отличия этого курса от уже прослушанных заключаются в следующем. Курс ООАП также работает с моделями, но многие из этих моделей ориентированы только на последующее кодирование, а не на анализ программ. Грубо говоря, речь идет о моделировании структуры кода, а не семантики программы. Кроме того, строгий, формальный, подход практически никак не отражен в этом курсе. В курсе верификации на моделях рассматривается инструмент SPIN и моделирование на языке PROMELA. Остальные виды моделей программ в этом курсе не рассматриваются, но рассматриваются в данном курсе.

Согласно одной из принятых классификаций выделяют следующие основные виды моделей программ:
\begin{itemize}
  \item логико-алгебраические модели (interface specification: property-based / state-based);
  \item исполнимые модели (behavior specification);
\end{itemize}
Кроме того, выделяют модели, совмещающие в себя характеристики логико-алгебраических и исполнимых моделей.

Исполнимые спецификации дают модель в виде программы для некоторой виртуальной машины, может быть, достаточно абстрактной. В основном, это различные виды конечных автоматов и систем переходов (LTS). К таким моделям относятся модели на PROMELA, уже знакомые читателям. Кроме того, с конечными автоматами они сталкивались достаточно часто в предыдущих курсах. Поэтому в этом курсе исполнимые модели не будут рассматриваться подробно.

Логико-алгебраические модели рассматривают операции программы в математическом смысле, как отображения аргументов и пре-состояния на значения-результаты операций и пост-состояния\footnote{потому такие модели не являются исполнимыми в общем случае --- попробуйте для любой функции, заданной отображением, автоматически построить программу, которая ее исполняет!}. Чистые \emph{логические модели} представляют собой набор аксиом, из которых следуют эти отображения. \emph{Алгебраические модели} описывают эквивалентности суперпозиций операций (грубо говоря, эти модели состоят из требований эквивалентности разных цепочек действий). К неисполнимым спецификациями принадлежат и такие виды моделей как \emph{программные контракты} --- набор логических свойств, которые должны быть выполнены при корректных входных данных и вычисленных по ним выходных. Грубо говоря, для задания семантики программы в неисполнимом виде применяются два подхода: <<чистый операционный>> (функциональный) подход (property-based) и подход, основанный на моделировании состояния программы (model-based, state-based). В функциональном подходе состояние не моделируется! И тем не менее, семантику операций удается задать. Вторая глава задачника посвящена функциональному подходу. Третья глава --- подходу, основанному на моделировании состояния программы. А первая глава посвящена тому языку, на котором все эти модели можно выражать --- языку RSL. Авторы языка попытались создать язык, который был бы языком программирования и языком спецификации одновременно\footnote{На самом деле обе эти цели можно воспринимать как моделирование --- первое является исполнимым моделированием, а второе неисполнимым.}. Единый языка выражения программы и ее семантики позволяют легче провести верификацию программы на такой модели. Но вопросы верификации лежат уже за пределами данного сборника задач.

\chapter{RSL для императивного программирования}

\head{Описание сигнатуры функции на RSL:}

\begin{lstlisting}
value add: Int >< Int -> Int
\end{lstlisting}
Имеется одна функция \texttt{add} с двумя аргументами типа Int (аргументы разделяются символом $\Fn$), функция является тотальной (стрелка ->). Функция вычисляет одно значение и это значение типа Int (несколько значений так же разделяются символом $\times$). Функция не имеет побочного эффекта.

\head{Описание функции целиком:}
\begin{lstlisting}
value add: Int >< Int -> Int
add(x,y) is x+y
\end{lstlisting}
После сигнатуры идет тело функции. Вначале идет имя функции с формальными параметрами, затем символ $\Is$ и затем выражение. Вычислением функции является вычисление этого выражения (в данном случае, сложение двух чисел-аргументов).

\head{Встроенные типы}
Int, Nat (целые неотрицательные числа), Real, Bool, Char, Text (список Char'в), Unit (аналог \textit{void}).

\head{Операции над встроенными типами:} ........................................

\head{Выражения} -- ............... (последовательность, if, while )

\head{Побочный эффект в функции} -- ...........

\head{Тотальная функция}
Это функция, для которой выполнены все 3 свойства:
\begin{enumerate}
  \item она детерминирована (если функция вызывается в разное время с теми же аргументами и в том же состоянии глобальных переменных, то она возвращает одинаковые значения и одинаковым образом изменяет глобальные переменные);
  \item она всюду определена (функция возвращает какое-либо значение на каждом значении аргументов и глобальных переменных, согласно их типам);
  \item она завершима (т.е. не зацикливается ни при каком значении аргументов и глобальных переменных)
\end{enumerate}
Функция является \emph{нетотальной}, если для нее \textbf{неизвестно}, выполнены ли свойства тотальной функции\footnote{Позже мы будем говорить более точно о том, что для нетотальных функций выполнение этих трех свойств \emph{не специфицировано}. Но может быть специфицировано позднее.}. В сигнатуре нетотальной функции вместо стрелки $\Fn$ ставится стрелка $\NonDetermFn$.

Пример тотальной функции:
\begin{lstlisting}
value add: Int >< Int -> Int
add(x,y) is x+y
\end{lstlisting}

Пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
\end{lstlisting}
Эта функция не определена при y = 0.

Пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
\end{lstlisting}
Эта функция не определена при y = 0.

Еще один пример нетотальной функции:
\begin{lstlisting}
value some: Int -~-> Int
some(x) is
    local variable n:Int := x in
        while n ~= 1 do
            if n \% 2 = 0 then n := n/2
                else n := 3 * n + 1 end
        end;
        n
    end
\end{lstlisting}
Про эту функцию именно что неизвестно, завершима ли она при любом целом значении аргумента.

И еще один пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x+y
\end{lstlisting}
Ничего не мешает объявить эту функцию как тотальную, но допустимо ее определение и как нетотальной (например, по причине того, что на момент написания функции неизвестно, должны ли для нее быть выполнены 3 свойства тотальной функции).

Для нетотальной функции может быть указано \emph{предусловие}\footnote{Именно <<может быть>>, но не обязательно, как считают авторы некоторых пособий по RSL в противоречие с авторами самого RSL.}. Оно задает ту область значений аргументов и глобальных переменных, на которых определяется функция. Вне этой области функция по определению считается незаданной (поэтому любая функция с нетождественным \texttt{true} предусловием будет нетотальной). Пример функции с предусловием:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
pre x > 2 /\ y > 4
\end{lstlisting}


\head{Массивы} -- ..........

\head{Структуры} ---

\section*{Задачи}



\chapter{Логико-алгебраические спецификации}

Логико-алгебраические модели --- набор свойств, утверждений, аксиом~\cite{kuliamin}. Из этих аксиом путем логического вывода получаются другие свойства.

\head{Логическая модель на RSL}
Это набор аксиом. Аксиомы помещаются в секцию \textbf{axiom}. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y: Int :-
            add(x,y) >= x,
            add(x,y) >= y,
            add(x,0) is x,
            add(10, 45) is 55,
            exists! z : Int :- add(0, z) is x
end
\end{lstlisting}

\head{Алгебраическая модель}
Это набор аксиом вида равенства термов. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y, z: Int :-
            add(add(x,y),z) is add(x, add(y, z)),
            add(x,y) is add(y,x),
            add(x,0) is x
end
\end{lstlisting}

Алгебраические модели тесно связаны с понятием \emph{абстрактных типов данных} (АТД). Собственно, алгебраические модели являются одним из способов определения АТД. Например, <<стек --- это нечто, удовлетворяющее принципу LIFO>>:
\begin{lstlisting}
scheme Addition = class
        type Stack, Elem
        value push: Stack >< Elem -> Stack,
                 pop: Stack -~-> Elem
        axiom forall s: Stack, e: Elem :-
                pop( push(s,e) ) is e
end
\end{lstlisting}

// аксиомы с предусловиями: ограничение области действия аксиомы

\head{Непротиворечивые алгебраические модели}

\head{Полные алгебраические модели}

// полнота и непротиворечивость модели

\head{Обсерверы, генераторы}

// обсерверы-генераторы и формальный метод построения полных алгебраических моделей (о, г, аксиомы, особые случаи, предусловия)

целевой тип - это состояние системы (абстрактный тип!)

обсерверы - это атрибуты состояния

генераторы - это переходы между состояниями

алгебраическая аксиома описывает атрибуты после перехода 

Каждый формальный метод хорош в своем месте. Не надо применять то, что само противится этому применению. RAISE (c оттенками VDM) мы будем применять для последовательных детерминированных систем. Изначальная цель - сформулировать предметную область.

Итак, шаги следующие:

1. Выделить термины - оформить их как абстрактные типы.

2. Выделить видимые свойства и атрибуты терминов - оформить их как функции-обсерверы.

3. Выделить инварианты (сonstraint'ы) в терминах.

4. Выделить видимые преобразования терминов - оформить их как функции-генераторы.

шаги 1-4 подробно документировать: что, синтаксис, семантика

5. Описать ВСЕ аксиомы вида "обсервер(генератор)", рассуждая при этом так: как изменится такое-то свойство после такого-то воздействия. Например, как изменится длина при добавлении элемента - увеличится на единицу! Если результат изменения атрибута неизвестен из постановки задачи, это означает неполноту исходных требований - в этом случае результат узнается у заказчика ("как изменится профиль струи при таком-то на нее воздействии", например).

При этом может потребоваться выделение дополнительных атрибутов. Они тоже включаются в общий список и для них выполняется этап описания их изменения другими функциями.

6. Если позволяет постановка задачи, то специфицировать изменение атрибутов после пар операций, троек и т.д. 


\head{Определение рекурсивных типов (деревьев)}
Алгебраические модели и АТД являются удобным способом задания рекурсивных типов и функций их обработки. Для этого представленный только что формальный метод построения полных алгебраических спецификаций прочитывается следующим способом:
\begin{enumerate}
  \item выделить и составить сигнатуры функций-конструкторов (пустое значение | составление нового <<узла дерева>>);
  \item выделить и составить сигнатуры функций-обработчиков;
  \item описать результат обработки для каждого конструктора.
\end{enumerate}
Например, спецификация функции, вычисляющей глубину бинарного дерева, согласно этому методу получается такой:
\begin{lstlisting}
scheme BTree = class
   type Node, Tree == empty | mk_tree(Node, Tree, Tree)
   value depth: Tree -> Nat
   axiom forall n: Node, left: Tree, right: Tree :-
            depth( empty ) is 0,
            depth( mk_tree(n, left, right) ) is
                  max( depth(left), depth(right) )
   value max: Nat >< Nat -> Nat
   max(x,y) is if x > y then x else y end
end
\end{lstlisting}
Важно понять, что функция-конструктор предназначена лишь для структурных целей, т.е. в данном примере то же определение дерева пойдет и для бинарного дерева произвольного вида, и для бинарного сбалансированного дерева, и для других бинарных деревьев. А уже менее тривиальные функции составления деревьев (например, чтобы не нарушалась сбалансированность) определяются в виде функций-обработчиков. Функции-конструкторы напоминают конструкторы объектов (\texttt{tree = new Tree(n, left, right)}).

\section*{Задачи}

Первые задачи несложные, в них надо формализовать указанные утверждения. Большинство задач взяты из~\cite{nepeivoda}.

\textbf{Пример решения задачи}

<<Ни одному лысому не нужна расческа>>

\begin{lstlisting}
scheme Exmp = class
  type Lys, R4
  value need: Lys >< R4 -> Bool
  axiom all l:Lys, r:R4 :- ~need(l,r)
end
\end{lstlisting}

\addtocounter{problem_type}{1}

\z Все мои тетки не справедливы.
\z Ни один кошмарный сон не приятен.
\z  Все битвы сопровождаются страшным шумом.
\z Не все двоечники ленивы.
\z  Каждый, кто упорно работает, добивается успеха.
\z  Ни один бездельник не станет знаменитостью.
\z  Некоторые художники не бездельники.
\z  Некоторые бездельники не художники.
\z  Некоторые подушки мягкие.
\z  Тот, кто может укрощать крокодилов, заслуживает уважения.
\z  Ни одна лягушка не имеет поэтической внешности.
\z  Ни одна тачка не комфортабельна.
\z  Всякий орел умеет летать.
\z  Некоторые свиньи не умеют летать.
\z  Некоторые свиньи --- не орлы.
\z  Ни один судья не справедлив.
\z  Ни один ребенок не любит прилежно заниматься.
\z  Все шутки для того и предназначены, чтобы смешить людей.
\z  Ни один парламентский акт не шутка.
\z  Пауки ткут паутину.
\z  Все лекарства имеют отвратительный вкус.
\z  Ни у одной ящерицы нет волос.
\z  Все свиньи прожорливы.
\z  Все, что сделано из золота, драгоценно.
\z  Некоторые секретари --- птицы.
\z  Все секретари заняты полезным делом.
\z  Ничто разумное не ставит меня в тупик.
\z  Логика часто ставит меня в тупик.
\z  Некоторые цыплята --- не кошки.
\z Точки A, B, C являются вершинами равнобедренного треугольника.
\z Иванов, Петров, Васильев и Сидоров могут вытащить эту машину из ямы, если они трезвы и видят бутылку.
\z Иванов, Петров, Васильев и Сидоров не могут решать квадратные уравнения, даже если они трезвы, но видят бутылку.
\z Не все углы, синус которых больше 1/2, больше $\pi$/6.
\z Квадратные корни из некоторых рациональных чисел иррациональны.
\z Синус и косинус равны друг другу тогда и только тогда, когда равны тангенс и котангенс.
\z  Когда кто-то поет больше часа, он надоедает.
\z Все девочки боятся лягушек и мышей.
\z Кошки бывают только белые и серые.
\z  Все ораторы либо честолюбивы, либо скучны.
\z Число делится на 25 в том и только том случае, когда оно делится на 50 либо дает при делении на 50 остаток 25.
\z Все комплексные числа действительны или становятся действительными после умножения на i.
\z Не все студенты отличники или спортсмены.
\z Для того чтобы выполнялось равенство $x = \sqrt{x^2}$, необходимо и достаточно, чтобы $x$ было положительным действительным числом.
\z Не все, что рассказывал барон К. Ф. И. фон Мюнхгаузен, ложь.
\z Некоторые людоеды — плохие люди.
\z Некоторые финансисты — мошенники, но не все.
\z Прапорщики любят порядок, и не только они.
\z Милиционеры замешаны в преступлениях, но не все.
\z Некоторые замки не отпираются, но запираются.
\z Если будешь хорошо учиться, поступишь в вуз, а иначе
провалишься.
\z Ничего не вижу, ничего не слышу, ничего не знаю.
\z Молодо—зелено.
\z Взялся за гуж --- не говори, что не дюж.
\z Чтобы не быть собакой, достаточно быть кошкой.
\z Чтобы не быть человеком, необходимо быть свиньей.
\z Некоторые кошки поют по ночам.
\z Все компакты совершенно нормальны.
\z Некоторые мюмзики не куздры.
\z Три точки A, B, C лежат на одной окружности.
\z Три точки A, B, C не лежат на одной прямой.
\z Числа a и b имеют одинаковый знак.
\z Одно из чисел a, b равно 0.
\z Числа a и b имеют разные знаки.
\z Ромео и Джульетта любят друг друга.
\z Гамлет и Клавдий ненавидят друг друга.
\z Мери любила Печорина, но не взаимно.
\z Чтобы прийти на свадьбу, необходимо приглашение жениха или невесты.
\z Некоторые лентяи не оптимисты, но жизнелюбы.
\z Все замки отпираются и запираются.
\z Никто из нашего класса не поехал в Москву и Париж.
\z Все мои одноклассники поехали в Москву и Париж.
\z Некоторые числа четные.
\z Некоторые лекции невозможно понять.
\z Всякому в Москве не перекланяешься.

\addtocounter{problem_type}{1}

\head{Более сложные задачи:}

\z Весна, и вы говорите: «Все парни и девушки сейчас влюблены друг в друга». Что это означает?
\z Когда Ясон кинул в середину войска, выросшего из зубов дракона, камень, все воины передрались и перебили друг друга.
Переведите это утверждение на формальный язык.
\z Ограниченная сверху и снизу на [a, b] функция непрерывна на нем.
\z Функция $f$ имеет разрыв 2-го рода в точке 0.
\z Функция, имеющая точку разрыва, не может быть непрерывной.
\z Монотонная на [a, b] функция ограничена снизу на [a, b].
\z Если последовательность ограничена, то она имеет предельную точку.
\z Чтобы установить рекорд, необходимо иметь способности, и прилежно тренироваться, и найти хорошего тренера.
\z Чтобы победить, нам необходимы и хорошие нападающие, и хорошие защитники, и хорошие вратари.
\z Если вчера Петров прогулял два занятия, то сегодня только одно.
\z Все члены Политбюро, избранного на XIV съезде ВКП(б), ненавидели друг друга.
\z Все философы критиковали друг друга.
\z Все рыцари сражались друг с другом на поединках.
\z Все начальники подсиживают друг друга.
\z Все мужчины --- подонки, а мой муж --- хороший человек.
\z Сдай экзамен на <<отлично>>, и поступишь в аспирантуру.


\head{Конфлюэнтность}

Хотя специфицируются абстрактные типы данных, множество значений этих типов всё же можно выразить --- в виде множества термов. Например, для базы данных это может быть \texttt{add("Иванов", 200, add("Петров", 500, empty))}. Терм соответствует некоторому состоянию моделируемой системы. Проблема того, что два разных терма означают одно и то же состояние, неразрешима\footnote{Взяв первый терм, пытаемся вставить его на место аргументов в аксиомах и применить преобразование из этой аксиомы. Так получаем новый терм. К нему применяем то же правило --- получаем еще один терм. И так делаем до тех пор, пока не получив данный второй терм. Если процесс составления новых термов завершился, значит термы означали одинаковые состояния. А если процесс не завершится, то разные. Получается <<алгоритм>>, который должен зацикливаться. Естественно, это означает отсутствие алгоритма в правильном понимании этого слова.}. Хороши те системы аксиом, которые дают нормальные формы. Системы с такими аксиомами проще анализировать и проще понимать их смысл, поскольку есть понятная классификация состояний-термов. Например, для списка состоянием является последовательность элементов $\langle x_1, x_2, ..., x_n \rangle$ --- очевидно алгебраическое представление списка, обладающее нормальной формой: \texttt{cons($x_1$, cons($x_2$, ..., cons($x_n$, nil) ... ))}; поэтому для списка достаточно исследовать все свойства только на таких термах, а не на всех произвольных.

Итог: при выделении операций-генераторов надо постараться так, чтобы каждое значение целевого типа имело единственной представление в виде терма из этих операций (т.н. \emph{нормальная форма}). Если такие генераторы построить не удается, то нужны выделить и добавить аксиомы, определяющие эквивалентный переход от многих форм 

Пример: множество -- не забыть аксиому add(a, add(b,c)) is add(b, add(a,c))   (нормальная форма: add(add(add с возрастающими аргументами)

аксиомы должны "работать" для всех форм, и нормальных, и не являющихся нормальными.

delete(x, add(y,s)) is if x = y then s else add(y, delete(x,s)) end -- логично? да. правильно ? нет, т.к. ...
delete(1, add(1, add(1, empty))) is add(1, empty) по этой аксиоме, но тогда
isin(1, delete(1, add(1, add(1, empty)))) is isin(1, add(1, empty)) is true, а должен быть false, т.к. 1 должны были удалить.

delete(x, add(y,s)) is if x = y then delete(x,s) else add(y, delete(x,s)) end -- теперь правильно

другое дело, что при выводе свойств достаточно рассматривать такие s, которые представлены нормальной формой.


попробовать описать такие функции для множества как длина, вложение, вхождение элемента во множество


 
\chapter{Моделе-ориентированные спецификации}

%\chapter{Поведенческие спецификации}
%TBD

\appendix
\include{rslprior}

\pagebreak
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{rslbooks}

\end{document}
