% !Mode:: "TeX:UTF-8"
\documentclass[14pt, twoside]{extreport}
\usepackage{cmap}

%\usepackage{fix-cm}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{dsfont}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\usepackage{clrscode}

\pagestyle{headings}

\textheight 23cm % 29.7-2-2
\textwidth 16cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \evensidemargin 0cm  \headheight 0cm \headsep 1.5cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел

\usepackage{ifpdf}

\ifpdf
% we are running pdflatex, so convert .eps files to .pdf
% run pdflatex with --shell-escape and thesis.aux
\usepackage[pdftex]{graphicx}
\usepackage{epstopdf}
\else
% we are running LaTeX, not pdflatex
\usepackage{graphicx}
\fi

% Подправим команду \appendix : нумерация русскими буквами,
% а не латинскими.
\makeatletter
\renewcommand\appendix{\par
  \setcounter{chapter}{0}%
  \setcounter{section}{0}%
  \def\@chapapp{\appendixname}%
  \def\thechapter{\@Asbuk\c@chapter}}
\makeatother

% "русифицируем" окружение enumerate:
\makeatletter
\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
\def\labelenumii{\theenumii)}    % а не латинские буквы
\def\p@enumii{\theenumi}         % а это для \ref
\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
\let\theenumiii\relax            % и отдельных ссылок на него не будет
\def\p@enumiii{\theenumi\theenumii}
\makeatother

\usepackage{rsl}

\usepackage{listingsutf8}
\lstloadlanguages{RSL}
\lstset{numbers=left, language=RSL, extendedchars=true, numberstyle=\tiny}
%, inputencoding=utf8/latin1, commentstyle=\itshape, stringstyle=\bfseries}

\author{Евгений Корныхин}
\title{\huge{\textbf{\textsc{Задачи по формальной спецификации программ на RSL}}}}
%\date{Москва --- 2010}

\newcounter{problem_type}[chapter]
\newcounter{zadacha}[problem_type]
\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
\textit{\arabic{chapter}.\arabic{problem_type}.\arabic{zadacha}}~~  }

\newcommand{\head}[1]{\vspace{1cm}\subsubsection*{#1}}
\newcommand{\zhead}[1]{\head{#1} \refstepcounter{problem_type}}


\begin{document}

\maketitle

\tableofcontents

\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}

Данный сборник задач написан в поддержку курса <<Формальной спецификации и верификации программ>>, который читается студентам последних курсов факультета ВМиК МГУ.

Под <<формальной>> спецификацией в первую очередь понимается строгое однозначное задание (описание) интерфейса или поведения программы. До сих пор необходимость доведения описаний до строгих однозначных форм ставится под сомнение, если речь идет о совершенно произвольных программах (как минимум, это сталкивается с высокой трудоемкостью формальной спецификации и особенной квалификацией тех, кто эту спецификацию составляет). Хотя полезность (и даже необходимость) строгого однозначного задания \emph{критичных} систем сомнений не вызывает. И тем не менее понижение трудоемкости и сближение формальных спецификаций с программистами-инженерами (т.е. существенное расширение области реального использования формальных спецификаций) является актуальной задачей в области технологий программирования (software engineering).

Однако дабы не попадать в дискуссионную область, курс следует иному принципу. Реалии таковы, что кроме написания программ необходимо, чтобы эти программы были корректными, чтобы они удовлетворяли стандартам. Для решения задач обеспечения таких характеристик применяются \emph{в том числе и} математические методы. Это означает, что программа выражается в математических терминах в виде \emph{математической теории}, или \emph{математической модели}, и задача уже решается в рамках этой математической теории с применением математического аппарата. Эта идея может показаться малоприменимой на практике, поскольку обычно математики и программисты-инженеры живут <<в разных мирах>>. На самом же деле математические методы решения задач над программами (их еще называют \emph{формальными методами}, подчеркивая, что <<обычный>> программист-инженер работает в своем <<неформальном>> мире представления о своей программе) исторически возникли практически сразу с возникновением практического программирования (это 50-е годы ХХ века) и развиваются по настоящее время.

Математическая теория, создаваемая для программы, это и есть формальная спецификация. От природы этой спецификации будут зависеть и математические методы, применяемые для решения задачи. Математическая теория не создается сама по себе --- она создается для конкретных целей, для решения определенных задач: формализация требований с целью, во-первых, их прояснения, во-вторых, для выяснения в них противоречий и неполных требований, автоматизация тестирования, чёткая документация, формальная верификация и даже разработка программ при помощи формальных моделей. Единожды проведя формализацию, можно существенно снизить <<человеческий>> фактор на последующих этапах жизненного цикла программы.

Эта часть курса посвящена тому, какие на данный момент придуманы виды моделей, какой природы математические теории используются для описания программ. Вторая часть курса (не вошедшая в этот сборник задач) посвящена одному из применений формальных спецификаций --- формальной верификации программ.

Читатели могут столкнуться с <<моделями программ>> не впервые. Студенты ВМиК МГУ слушают перед этим курсом курс по объектно-ориентированному анализу и проектированию программ и курс по верификации программ на моделях (model checking). Отличия этого курса от уже прослушанных заключаются в следующем. Курс ООАП также работает с моделями, но многие из этих моделей ориентированы только на последующее кодирование, а не на анализ программ. Грубо говоря, речь идет о моделировании структуры кода, а не семантики программы. Кроме того, строгий, формальный, подход практически никак не отражен в этом курсе. В курсе верификации на моделях рассматривается инструмент SPIN и моделирование на языке PROMELA. Остальные виды моделей программ в этом курсе не рассматриваются, но рассматриваются в данном курсе.

Согласно одной из принятых классификаций выделяют следующие основные виды моделей программ:
\begin{itemize}
  \item логико-алгебраические модели (interface specification: property-based / state-based);
  \item исполнимые модели (behavior specification);
\end{itemize}
Кроме того, выделяют модели, совмещающие в себя характеристики логико-алгебраических и исполнимых моделей.

Исполнимые спецификации дают модель в виде программы для некоторой виртуальной машины, может быть, достаточно абстрактной. В основном, это различные виды конечных автоматов и систем переходов (LTS). К таким моделям относятся модели на PROMELA, уже знакомые читателям. Кроме того, с конечными автоматами они сталкивались достаточно часто в предыдущих курсах. Поэтому в этом курсе исполнимые модели не будут рассматриваться подробно.

Логико-алгебраические модели рассматривают операции программы в математическом смысле, как отображения аргументов и пре-состояния на значения-результаты операций и пост-состояния\footnote{потому такие модели не являются исполнимыми в общем случае --- попробуйте для любой функции, заданной отображением, автоматически построить программу, которая ее исполняет!}. Чистые \emph{логические модели} представляют собой набор аксиом, из которых следуют эти отображения. \emph{Алгебраические модели} описывают эквивалентности суперпозиций операций (грубо говоря, эти модели состоят из требований эквивалентности разных термов--цепочек действий). К неисполнимым спецификациями принадлежат и такие виды моделей как \emph{программные контракты} --- набор логических свойств, которые должны быть выполнены при корректных входных данных и вычисленных по ним выходных. Грубо говоря, для задания семантики программы в неисполнимом виде применяются два подхода: <<чистый операционный>> (функциональный) подход (property-based) и подход, основанный на моделировании состояния программы (model-based, state-based). В функциональном подходе состояние не моделируется! И тем не менее, семантику операций удается задать. Вторая глава задачника посвящена функциональному подходу. Третья глава --- подходу, основанному на моделировании состояния программы. А первая глава посвящена тому языку, на котором все эти модели можно выражать --- языку RSL. Авторы языка попытались создать язык, который был бы языком программирования и языком спецификации одновременно\footnote{На самом деле обе эти цели можно воспринимать как моделирование --- первое является исполнимым моделированием, а второе неисполнимым.}. Единый языка выражения программы и ее семантики позволяют легче провести верификацию программы на такой модели. Но вопросы верификации лежат уже за пределами данного сборника задач.

\chapter{RSL для императивного программирования}

\input{prog/about}

\section*{Задачи}

\input{prog/problems}


\chapter{Логико-алгебраические спецификации}

\section{Логические модели}

Логико-алгебраические модели --- набор свойств, утверждений, аксиом~\cite{kuliamin}. Из этих аксиом путем логического вывода получаются другие свойства.

Если количество состояний системы невелико, ее удобно моделировать в виде конечного автомата. При возрастании количества состояний конечные автоматы становятся неудобными как для моделирования, так и для работы с такими моделями. До некоторого момента и для некоторых задач помогают расширенные конечные автоматы (EFSM), модели Крипке, но для систем более реальных размеров и они могут стать неудобными. Тогда вместо такого (явного) указания состояний и переходов между ними предлагается задавать \emph{правила}: о структуре состояния, о свойствах состояния, о свойствах переходов\footnote{Аналогично совершается переход от задания формальных языков перечислением его слов к формальным грамматикам, т.е. правилам конструирования слов}. Одним из основных механизмов теперь будет логический вывод новых свойств и правил из заданных в спецификации.

\head{Логическая модель на RSL}
Это набор аксиом. Аксиомы помещаются в секцию \textbf{axiom}. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y: Int :-
            add(x,y) >= x,
            add(x,y) >= y,
            add(x,0) is x,
            add(10, 45) is 55,
            exists! z : Int :- add(0, z) is x
end
\end{lstlisting}

\section*{Задачи}

\input{alg/formal}

\section{Алгебраические спецификации}

\input{alg/theor}

\section*{Задачи}

\input{alg/calc}

\input{alg/find_errors}

\input{alg/unformal}

\input{alg/problems}

\section{Полнота и непротиворечивость алгебраических спецификаций}

\input{alg/compness}

\section*{Задачи}

\input{alg/comprobs}

\section{Cпецификация рекурсивных типов}

%\head{Рекурсивное определение типов (деревьев)}
Алгебраические модели и АТД являются удобным способом рекурсивного задания типов и операций их обработки. Для этого представленный только что формальный метод построения достаточно полных алгебраических спецификаций прочитывается следующим способом:
\begin{enumerate}
  \item выделить и составить сигнатуры конструкторов (пустое значение | составление нового <<узла дерева>>);
  \item выделить и составить сигнатуры функций-обработчиков рекурсивного типа;
  \item описать результат обработки для каждого конструктора.
\end{enumerate}

Например, спецификация функции, вычисляющей глубину бинарного дерева, согласно этому методу получается такой:
\begin{lstlisting}
type Node, Tree == empty | mk_tree(Node, Tree, Tree)
value depth: Tree -> Nat
axiom forall n: Node, left: Tree, right: Tree :-
  depth( empty ) is 0,
  depth( mk_tree(n, left, right) ) is
          max( depth(left), depth(right) )
value max: Nat >< Nat -> Nat
   max(x,y) is if x > y then x else y end
\end{lstlisting}

Конструктор предназначена лишь для структурных целей, т.е. определение дерева в виде типа Tree из этого примера пойдет и для бинарного дерева произвольного вида, и для бинарного сбалансированного дерева, и для других бинарных деревьев. А уже менее тривиальные функции составления деревьев (например, чтобы не нарушалась сбалансированность) определяются в виде функций-обработчиков.

\section*{Задачи}
%
\zhead{}%Рекурсивные типы}
%
\z Специфицируйте операцию проверки вхождения элемента в бинарное дерево.

\textbf{Решение:}
\begin{lstlisting}
type Node, Tree == empty | add(Node, Tree, Tree)
value check: Node >< Tree -> Bool
axiom forall n, n1:Node, left, right: Tree :-
   ~check( empty ),
   check(n, add(n1,left,right) ) is (n = n1) \/
             check(n, left) \/ check(n, right)
\end{lstlisting}

\z Специфицируйте операцию вычисления высоты бинарного дерева.

\z Специфицируйте операцию проверки бинарного дерева на сбалансированность.

\z Специфицируйте операцию получения предка элемента бинарного дерева.

\z Специфицируйте добавление элемента в двоичное дерево поиска.

\z Специфицируйте удаление элемента из двоичного дерева поиска.

\z Специфицируйте добавление элемента в АВЛ-дерево. Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из АВЛ-дерева. Определение операции предполагается найти самостоятельно.

\z Специфицируйте добавление элемента в 2-3-дерево. Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из 2-3-дерева. Определение операции предполагается найти самостоятельно.

\z Специфицируйте добавление элемента в декартово дерево. Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из декартова дерева. Определение операции предполагается найти самостоятельно.

\z Специфицируйте добавление элемента в красно-чёрное дерево.  Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из красно-чёрного дерева.  Определение операции предполагается найти самостоятельно.

% специфицировать стратегии вытеснения



\chapter{Моделе-ориентированные спецификации}

\section{Множества, списки, отображения}

\head{Множества}
Множество -- это контейнер элементов одного типа, который обладает свойствами уникальности и неупорядоченности его элементов. Множества бывают конечными и бесконечными.

Типовое выражение для конечного множества: $typeexpr\Set$. Типовое выражение для бесконечного множества: $typeexpr\Infset$. Конечное множество -- подтип бесконечного множества.

Операции над множествами:
\begin{list}{}{}
\item $= : T\Infset \DP T\Infset \Fn \Bool$ -- сравнение на равенство
\item $\neq : T\Infset \DP T\Infset \Fn \Bool$ -- сравнение на не равенство
\item $\Union: T\Infset \DP T\Infset \Fn T\Infset$ -- объединение множеств
\item $\Inter: T\Infset \DP T\Infset \Fn T\Infset$ -- пересечение множеств
\item $\Minus: T\Infset \DP T\Infset \Fn T\Infset$ -- вычитание множеств
\item $\Isin: T \DP T\Infset \Fn \Bool$ -- проверка на принадлежность
\item $\NotIsin: T \DP T\Infset \Fn \Bool$ -- проверка на непринадлежность
\item $\SetL: T\Infset \DP T\Infset \Fn \Bool$ -- проверка вложения
\item $\SetG: T\Infset \DP T\Infset \Fn \Bool$ -- проверка вложения
\item $\SetLE: T\Infset \DP T\Infset \Fn \Bool$ -- проверка вложения
\item $\SetGE: T\Infset \DP T\Infset \Fn \Bool$ -- проверка вложения
\item $\Card: T\Infset \NonDetermFn \Nat$ -- количество элементов
($\Chaos$ для бесконечных множеств)
\end{list}


Конструкторы множеств:
\begin{list}{}{}
\item (\emph{пустое множество}) \{\}
\item (\emph{перечисление}) \{0, 1, 2\} - множество, состоящее из трех целых чисел (не
натуральных!) - нуля, единицы и двойки.
\item (\emph{диапазон}) \{0..2\} -  то же, что и \{0, 1, 2\};
\{0..0\} $\Iden$ \{0\}, \{1..0\} $\Iden$ \{\}
\item (\emph{<<сокращенная запись>>}) $\{ expr\_with\_var | var : typeexpr
\SuchAs boolexpr\}$ (например, $\{2 \star n | n : \Nat \SuchAs n < 3
\}$, что эквивалентно \{0, 2, 4\})
\end{list}

\head{Списки}
Список -- это контейнер элементов одного типа, который обладает свойствами упорядоченности элементов. Для задания списка надо указать не только сами элементы, но и их порядок. Списки бывают конечными и бесконечными.

Типовое выражение для конечного списка: $typeexpr\List$. Типовое выражение для бесконечного списка: $typeexpr\Inflist$. Конечный список -- подтип бесконечного списка.

Операции:
\begin{list}{}{}
\item $=: T\Inflist \DP T\Inflist \Fn \Bool$ -- проверка на равенство
\item $\neq: T\Inflist \DP T\Inflist \Fn \Bool$ -- проверка на не равенство
\item $(.) : T\Inflist \DP \Int \NonDetermFn T$ -- взятие элемента по
индексу ($\Chaos$ для индекса, отсутствующего в списке, индексы
нумеруются \textbf{с единицы})
\item $\Concat: T\List \DP T\Inflist \Fn T\Inflist$ -- конкатенация списков
\item $\Hd: T\Inflist \NonDetermFn T$ -- головной элемент списка ($\Chaos$ для пустого списка)
\item $\Tl: T\Inflist \NonDetermFn T\Inflist$ -- хвостовая часть списка ($\Chaos$ для пустого списка)
\item $\Len: T\Inflist \NonDetermFn \Nat$ -- количество элементов списка ($\Chaos$ для бесконечного списка)
\item $\Elems: T\Inflist \Fn T\Infset$ -- множество элементов списка (без повторений!)
\item $\Inds: T\Inflist \Fn \Nat\Infset$ -- множество индексов элементов списка
\end{list}

Конструкторы списков:
\begin{list}{}{}
\item (\emph{пустой список}) $\LL\LR$
\item (\emph{перечисление}) $\LL 0, 1, 2 \LR$ - список, состоящий из трех целых чисел (не натуральных!) - нуля, единицы и двойки - в порядке увеличения.
\item (\emph{диапазон}) $\LL 0..2 \LR$ -  то же, что и $\LL 0, 1, 2 \LR$; $\LL 0..0 \LR \Iden \LL 0 \LR$, $\LL 1..0 \LR \Iden \LL\LR$
\item (\emph{<<сокращенная запись>>}) $\LL expr\_with\_var | var \In listexpr \SuchAs boolexpr\LR$ (например, $\LL 2 \star n | n \In \LL 0..2 \LR \LR$, что эквивалентно $\LL 0, 2, 4 \LR$)
\end{list}


\head{Отображения}
Отображение -- это множество пар элементов, у которого первые компоненты не повторяются. Отображения бывают конечными и бесконечными, детерминированными и недетерминированными (это те, в которых первые компоненты всё же могут повторяться в разных парах).

Типовое выражение для детерминированного отображения: $$typeexpr_1 \Map typeexpr_2$$ Типовое выражение для недетерминированного отображения: $$typeexpr_1 \NonDeterMap typeexpr_2$$

Операции:
\begin{list}{}{}
\item $=: (T_1 \Map T_2) \DP (T_1 \Map T_2) \Fn \Bool$ -- сравнение отображений на равенство
\item $\neq: (T_1 \Map T_2) \DP (T_1 \Map T_2) \Fn \Bool$ -- сравнение отображений на не равенство
\item $(.): (T_1 \Map T_2) \DP T_1 \NonDetermFn T_2$ -- взятие значения по индексу ($\Chaos$, если значение по этому индексу не
определено)
\item $\Dom: (T_1 \Map T_2) \Fn T_1\Infset$ -- \emph{область определения} отображения
\item $\Rng: (T_1 \Map T_2) \Fn T_2\Infset$ -- \emph{область значения} отображения
\item $\Upd: (T_1 \Map T_2) \DP (T_1 \Map T_2) \Fn (T_1 \Map T_2)$ -- обновление отображения
\item $\Union: (T_1 \Map T_2) \DP (T_1 \Map T_2) \Fn (T_1 \NonDeterMap T_2)$ -- объединение отображений
\item $\Minus: (T_1 \Map T_2) \DP T_1\Infset \Fn (T_1 \Map T_2)$ -- уменьшение отображения
\item $/: (T_1 \Map T_2) \DP T_1\Infset \Fn (T_1 \Map T_2)$ -- проекция отображения
\item $\Superp: (T_2 \Map T_3) \DP (T_1 \Map T_2) \Fn (T_1 \Map T_2)$ -- композиция отображений
\end{list}

Конструкторы отображений:
\begin{list}{}{}
\item (\emph{пустое отображение}) []
\item (\emph{перечисление}) $[0 \mapsto 1, 1 \mapsto 2]$ -- отображение, состоящий из двух пар целых чисел (не натуральных!) - из 0 в 1 и из 1 в 2.
\item (\emph{<<сокращенная запись>>}) $[expr_1\_with\_var \mapsto expr_2\_with\_var | var : typeexpr \SuchAs boolexpr]$ (например, $[n \mapsto n+1 | n : \Nat \SuchAs n < 3]$, что эквивалентно $[0 \mapsto 1, 1 \mapsto 2, 2 \mapsto 3]$)
\end{list}


\section*{Задачи}

\zhead{Вычислить выражения с множествами}

\z $\{1, 2\} = \{3, 1\}$
\z $\{1, 2\} = \{2, 1\}$
\z $\{1, 2, 1\} = \{2, 2, 1\}$
\z $\{1, 2\} \Union \{3, 4\}$
\z $\{1, 2\} \Union \{2, 3\}$
\z $\{1, 2\} \Inter \{3, 4\}$
\z $\{1, 2\} \Inter \{2, 3\}$
\z $\{1..30\} \Union \{10..-10\}$
\z $\{1..30\} \Inter \{10..-10\}$
\z $\{1..30\} \Union \{x~|~ x: \Int \SuchAs \Abs x < 11 \}$
\z $\{1..30\} \Inter \{x~|~ x: \Int \SuchAs \Abs x < 11 \}$
\z $\{x+10 ~|~ x: \Int \} = \{x ~|~ x: \Int\}$
\z $\{5*k + 2 ~|~ k : \Int \} \Inter \{3*k - 1 ~|~ k : \Int\}$
\z $\{5*k + 2 ~|~ k : \Int \} \Minus \{3*k - 1 ~|~ k : \Int\}$
\z $\{5*k + 2 ~|~ k : \Int \} \SetL \{3*k - 1 ~|~ k : \Int\}$
\z $\{5*k + 2 ~|~ k : \Int \} \SetGE \{3*k - 1 ~|~ k : \Int\}$
\z $\Not (\{1, 2\} \SetLE \{2, 1, 1\})$
\z $\Card \{1..30\}$
\z $\Card \{5*k + 2 ~|~ k : \Int \SuchAs k * k \Isin \{-10..10\}\}$
\z $\Card \{5*k + 2 ~|~ k : \Int \SuchAs k * k \Isin \{10..-10\}\}$
\z $\Card \{k*k - 2 * k ~|~ k : \Int \SuchAs k * k \Isin \{-10..10\}\}$
\z $\All x: \Nat ~\SuchAs~ x \Isin \{x ~|~ x : \Int\}$
\z $\All x: \Int ~\SuchAs~ x \Isin \{x ~|~ x : \Nat\}$


\zhead{Решите уравнения}

\z $\{1\} \Union x = \{\}$
\z $\{1\} \Union x = \{1\}$
\z $\{1\} \Union x = \{1, 2\}$
\z $\{1\} \Inter x = \{\}$
\z $\{1\} \Inter x = \{1\}$
\z $\{1\} \Inter x = \{1, 2\}$
\z $\{2, 1\} \Minus x = \{1\}$
\z $\Card~x = 0$
\z $\Card~x = 1$


\zhead{Какие из следующих выражений истинные}
Считайте, что свободные переменные располагаются под квантором
всеобщности

\z $(A \cup B) \setminus C = (A \setminus C) \cup (B \setminus C)$
\z $(A \setminus B) \cap C = (A \cap C) \setminus B$
\z $(A \cup B) \setminus C \Iden (A \setminus C) \cup (B \setminus C)$
\z $A \cup \{\} = A$
\z $\{\} \cup A = A$
\z $(A \cup B) \cap C = (A \cap C) \cup (B \cap C)$
\z $\Card \Nat < \Card \Int$
\z $\Card \Nat = \Card \Int$
\z $\Card \Nat > \Card \Int$
\z $\Card \Nat \Iden \Card \Int$
\z $\Card \{n ~|~ n:\Nat\} \Iden \Card \{n ~|~ n:\Int\}$


\zhead{Записать на RSL следующие множества}

\z Пустое множество;
\z Множество чисел 1, 2, 3 (а также множество чисел от 1 до 3);
\z Множество всех чётных чисел;
\z Множество всех чётных чисел, не превышающих 10 (привести в виде перечисления и нескольких различных сокращённых формах);
\z Множество всех простых натуральных чисел;
\z Множество всех пар взаимнопростых натуральных чисел;
\z Множество всех троек, в каждой из которых есть одинаковые элементы;
\z Множество всех степеней двойки, не превышающих 100 (привести в виде перечисления и нескольких сокращённых формах);
\z Множество всех IP-адресов класса А (B, C, D, E);
\z Множество всех точек плоскости, образующих
    \begin{enumerate}
    \item Прямую -- биссектрису I и III квадрантов;
    \item Правую полуплоскость;
    \item Нижнюю полуплоскость;
    \item Единичную окружность;
    \item Единичный круг;
    \item Единичный квадрат со сторонами, параллельными осям
    координат.
    \end{enumerate}

\zhead{Построить явную спецификацию на RSL для следующих задач}

В этих задачах, если удаётся, следует привести два варианта решения: с использованием сокращённой записи множества
и с помощью рекурсии.

\z Дано множество чисел. Вернуть множество квадратов чисел данного множества.
\z Дано множество чисел. Вернуть множество чисел, представимых суммами каких-либо двух элементов исходного множества.
\z Дано множество точек, заданных координатами в плоской декартовой системе координат. Получить проекцию этого множества на ось \textsc{Ox}.
\z Дано множество всех простых чисел. Для данного числа вернуть множество его простых делителей, используя множество всех простых чисел.
\z Дано множество чисел. Дано число. Существует ли подмножество данного множества чисел, сумма элементов которого, равна данному числу.
\z Дано множество множеств. Вернуть множество всех элементов внутренних множеств.
\z \textit{(Задача о рюкзаке)} Дано множество предметов. Каждый предмет имеет массу (массы заданы множеством пар предмет >< масса). Есть $n$ рюкзаков. Каждый рюкзак имеет вместимость $K$ кг. Распределить все предметы по рюкзакам, не превышая вместимости каждого рюкзака.
\z Рабочая группа компьютеров задаётся IP-адресом (4 целых числа, каждое от 0 до 255) и маской (целое число от 0 до 32). Программа по данному заданию строит множество всех возможных в ней IP-адресов.


\zhead{Вычислить выражения со списками}
\z $\LL 1 \LR = \LL 1, 1 \LR$
\z $\LL 1, 2 \LR = \LL 3, 1\LR$
\z $\LL 1, 2\LR = \LL 2, 1\LR$
\z $\LL 1, 2, 3 \LR (2)$
\z $\LL 1 \LR (0)$
\z $\LL 1 \LR (1)$
\z $\LL 1, 2\LR \Concat \LL 3, 4\LR$
\z $\LL 1, 2\LR \Concat \LL 2, 3\LR$
\z $\LL x+10 | x \In \LL 1, 2 \LR \LR = \LL x | x \In \LL 1 \LR \LR$
\z $\Hd \LL 1, 2, 3 \LR$
\z $\Tl \LL 1, 2, 3 \LR$
\z $\Len \LL 1, 2, 3 \LR$
\z $\Elems \LL 1, 2, 3 \LR$
\z $\Inds \LL 1, 2, 3 \LR$
\z $\Len \LL 1..30\LR$
\z $\Let~x = \LL 1, 2, 3\LR~\In~\Elems~x~\Inter~\Inds~x~\rslEnd$
\z $\Let~x = \LL 0, 1, 2\LR~\In~\Elems~x~\Inter~\Inds~x~\rslEnd$
\z $\Let~x : \Int\Inflist~\SuchAs~(\All i_1, i_2: \Nat~\SuchAs~\Card \{i_1, i_2\} = \Card \{x(i_1), x(i_2)\})\\\In~x~\rslEnd$
\z $\Let~x : \Int\Inflist~\SuchAs~(\All i_1, i_2: \Nat~\SuchAs~\Card \{i_1, i_2\} = \Card \{x(i_1), x(i_2)\})\\\In~\Elems~x~\Inter~\Inds~x~\rslEnd$
\z $\All x : T\Inflist~\SuchAs~x(0) = \Hd x$
\z $\All x : T\Inflist~\SuchAs~x(0) \Iden \Hd x$

\zhead{Решите уравнения}
\z $\LL 1 \LR \Concat x  = \LL 1 \LR$
\z $\LL 1 \LR \Concat x  = \LL 1, 2, 3 \LR$
\z $\LL 1 \LR \Concat x  = \LL 3, 2, 1 \LR$
\z $\Tl x = \LL 1 \LR$
\z $\Hd x = 1$
\z $x \Concat \Tl x = x$
\z $\Tl x = \LL \Hd x \LR$
\z $\Elems x = \Inds x$
\z $\Elems\Tl x = \Elems x$
\z $\Len x = \Card \Elems x$
\z $\Len x = \Card \Inds x$
\z $\Len x \Iden \Card \Inds x$


\zhead{Записать на RSL следующие выражения}

\z Пустой список;
\z Список из чисел 1, 2, 3 (попробуйте привести как можно больше различных решений);
\z Список всех простых натуральных чисел в порядке увеличения их значения;
\z Список всех пар взаимнопростых натуральных чисел в порядке увеличения их суммы;
\z Список номеров групп 5го курса факультета ВМиК МГУ в порядке увеличения номера группы;
\z Количество простых чисел от 1 до 10 (тремя различными способами).

\zhead{Напишите явные спецификации следующих функций}

\z Определить, является ли бесконечным данный список.
\z Вычислить длину списка без использования функции $\Len$.
\z Вычислить сумму элементов списка.
\z Вычислить произведение элементов списка.
\z Дан список. Построить список из элементов исходного списка, элементы которого идут в обратном порядке по отношению к исходному списку
\z Дана строка и символ. Определить, встречается ли символ в данной строке (предложить два различных способа решения).
\z Дана строка. Определить самый часто встречающийся в ней символ.
\z Отсортировать данный список вещественных чисел в порядке возрастания.
\z Построить список всех целых чисел в порядке неубывания модуля.
\z Определить $\sup$ списка вещественных чисел (в случае конечного списка это будет и максимум).
\z Выдать число, не встречающееся в данном списке.
\z Дан список чисел. Построить по нему список квадратов, расположив элементы
    \begin{enumerate}
    \item с сохранением порядка исходного списка
    \item в порядке убывания модуля
    \item так, чтобы не было трёх подряд чисел, расположенных в  порядке возрастания или убывания.
    \end{enumerate}
\z Дано натуральное число. Построить список степеней его простых делителей, в котором на местоположение степени есть её основание (а значение, соответственно, показатель).
\z Дан список показателей степеней (местоположение -- основание степени). Построить соответствующее натуральное число.
\z Дан список натуральных чисел, отличных от нуля. Вернуть список, в котором на месте №$i$ находится количество раз, которое $i$ встречается в исходном списке.
\z Дано множество чисел. Построить из него список, расположив элементы множества
    \begin{enumerate}
    \item в порядке убывания
    \item в порядке убывания модуля
    \end{enumerate}
\z Дан список чисел. Построить из него новый список, расположив элементы исходного списка
    \begin{enumerate}
    \item в порядке убывания
    \item в порядке убывания модуля
    \end{enumerate}
\z Дан список из чисел. Построить из него множество, использовав все элементы данного списка.
\z Дан множество пар (ключ, объект) и список ключей. Построить соответствующий ему список объектов. Считайте, что во множество пар ключи не повторяются.
\z Дан список чисел. Можно ли суммой некоторых его элементов получить
    \begin{enumerate}
    \item четное число (для списка из целых чисел)
    \item простое число (для списка из целых чисел)
    \item целое число (для списка из вещественных чисел)
    \end{enumerate}


\zhead{Упростить выражения}
\z $\langle x ~|~ x~\In~\langle \Card \{a..b\} \rangle \rangle$
\z $\langle c ~|~ c~\In~\langle 'a',~'b' \rangle \rangle$
\z $\langle c ~|~ c~\In~\langle '$ " $~' \rangle \rangle$
\z $\langle c ~|~ c~\In~\langle \rangle \rangle$

\newcommand{\Masha}{\mbox{\textrm{<<Маша>>}}}
\newcommand{\Sveta}{\mbox{\textrm{<<Света>>}}}
\newcommand{\Misha}{\mbox{\textrm{<<Миша>>}}}
\newcommand{\Slava}{\mbox{\textrm{<<Слава>>}}}
\newcommand{\Anna}{\mbox{\textrm{<<Аня>>}}}
\newcommand{\Petr}{\mbox{\textrm{<<Петя>>}}}
\newcommand{\Lesha}{\mbox{\textrm{<<Леша>>}}}
\newcommand{\Victor}{\mbox{\textrm{<<Витя>>}}}

\zhead{Вычислить}

\z $\map{n \mapsto 1}{n : \Nat \SuchAs n \Isin \{1..3\} }$
\z $\map{n \mapsto n}{n : \Nat \SuchAs n \Isin \{5..5\} }$
\z $\map{n \mapsto n+1}{n : \Nat \SuchAs n \Isin \{100..90\} }$
\z $\map{n \mapsto m}{n, m : \Nat \SuchAs n \backslash m = 0 \And m > 2}$
\z $\map{n \mapsto m}{n, m : \Nat \SuchAs n \Isin \{1..3\} \And m \Isin \{1..n\}}$
\z $\map{n \mapsto (p, q)}{n, p, q : \Nat \SuchAs n \Isin \{1..100\} \And p + q = n \And p \backslash q = 0}$
\z $[1 \mapsto 2,~2 \mapsto 3,~ 3 \mapsto 1] (3)$
\z $[1 \mapsto 2,~2 \mapsto 3,~ 3 \mapsto 1] (4)$
\z $[ \Masha \mapsto 30, \Sveta \mapsto 15, \Masha \mapsto 30] (\Masha)$
\z $[ \Masha \mapsto 30,  \Sveta \mapsto 15, \Masha \mapsto 10 ] (\Masha)$
\z $[1 \mapsto [1 \mapsto 1,~ 2 \mapsto 2,~ 3 \mapsto 3], 2 \mapsto [1 \mapsto 4,~ 2 \mapsto 5,~ 3 \mapsto 6]~]~ (2)~(1)$
\z $\Dom [3 \mapsto 1, 5 \mapsto 0, 2 \mapsto 88]$
\z $\Rng [3 \mapsto 1, 5 \mapsto 0, 2 \mapsto 88]$
\z $\Dom \map{n \mapsto 2 * n}{n : \Nat}$
\z $\Rng \map{n \mapsto 2 * n}{n : \Nat}$
\z $[1 \mapsto 20, 2 \mapsto 30] \Union [1 \mapsto 30, 2 \mapsto 20]$
\z $[1 \mapsto 20, 2 \mapsto 30] \Upd [1 \mapsto 30, 2 \mapsto 20]$
\z $[ \Misha \mapsto 170, \Slava \mapsto 200, \Victor \mapsto 195 ] ~\backslash \\ \{\Misha, \Petr\}$
\z $[ \Misha \mapsto 170, \Slava \mapsto 200, \Victor \mapsto 195 ] ~/ \\\{\Misha, \Petr\}$
\z Пусть Friend = $[\Misha \mapsto \Anna, \Anna \mapsto \Lesha, \Lesha \mapsto \Misha]$. Найти Friend $\Superp$ Friend. Какой смысл этого значения ?
\z $\Card~\Dom~[1 \mapsto 2, 1 \mapsto 3, 2 \mapsto 3]$
\z $\Dom ([10 \mapsto 100, 20 \mapsto 50] \Upd [20 \mapsto 60, 30 \mapsto 90])$
\z $\Card~\Rng~( [1 \mapsto 2] \Superp [3 \mapsto 2, 4 \mapsto 1] \Superp [1 \mapsto 2, 3 \mapsto 4])$

\zhead{Какие из следующих выражений истинны}

Если выражение ложно, привести контпример и дополнительные ограничения на входящие переменные, чтобы условие стало верным. Считать, что все переменные стоят под кванторами всеобщности.

\z $\Dom~ (X \Union Y) \Iden \Dom X ~\Union~ \Dom Y$
\z $\Rng~ (X \Union Y) \Iden \Rng X ~\Union~ \Rng Y$
\z $\Dom~ (X \Upd Y) \Iden \Dom X ~\Upd~ \Dom Y$
\z $\Rng~ (X \Upd Y) \Iden \Rng X ~\Upd~ \Rng Y$
\z $X = Y ~\Impl~ \Dom X = \Dom Y$
\z $X \NEq Y ~\Impl~ \Dom X ~\NEq~ \Dom Y$
\z $X \NEq Y ~\Impl~ \Rng X ~\NEq~ \Rng Y$
\z $\Dom (X \backslash Y) ~\Iden~ (\Dom X) \backslash Y$
\z $\Dom (X / Y) ~\Iden~ Y$
\z $\Dom (X \Upd Y) ~\Iden~ \Dom X \Union Y$
\z $(X \Union Y) \Union Z ~\Iden~ X \Union (Y \Union Z)$
\z $(X \Upd Y) \Upd Z ~\Iden~ X \Upd (Y \Upd Z)$
\z $(X \Superp Y) \Superp Z ~\Iden~ X \Superp (Y \Superp Z)$
\z $X \Union Y ~\Iden~ Y \Union X$

\zhead{Записать на RSL следующие константы и определения типов}
\z Записать отображение -- перестановку первых $N$ натуральных чисел. Считать $N$ константой с sort-определением.
\z Записать отображение-<<сдвиг>> : [1 $\mapsto$ 2, 2 $\mapsto$ 3, ..., $N \mapsto$ 1]. Считать $N$ константой с sort-определением.
\z Записать отображение всех полных квадратов в своё основание. [1 $\mapsto$ 1, 4 $\mapsto$ 2, 9 $\mapsto$ 3, ...]
\z Записать отображение из любого натурального числа в его простой делитель.
\z Записать отображение любого натурального числа в большее его простое натуральное число. [1 $\mapsto$ 5, 2 $\mapsto$ 7, 3 $\mapsto$ 5, ...]
\z Записать отображение <<бесконечная перестановка>>.
\z Записать отображение любого натурального числа в своё <<зеркало>> -- число из цифр исходного числа, записанных в обратном порядке. [1 $\mapsto$ 1, ..., 12 $\mapsto$ 21, ..., 832 $\mapsto$ 238, ...]
\z Записать отображение любого текста в его реверсию. $[..., \mbox{\textrm{"стол"}} \mapsto \mbox{\textrm{"лотс"}}, \mbox{\textrm{"книга"}} \mapsto \mbox{\textrm{"агинк"}}, ...]$
\z Не меняя описания предыдущей константы, описать новое отображение любого текста, начинающегося с 'a', в его реверсию.
\z Записать тип <<Англо-русский словарь>> так, как Вы его представляете. Учтите, что слово может иметь несколько переводов.

\zhead{Запишите спецификацию функций в явном виде}
\z Подсчитать количество элементов в данном отображении, если оно
    \begin{enumerate}
    \item детерминированное
    \item ${^\star}$ недетерминированное
    \end{enumerate}
\z По отображению \{[$a \mapsto b$]\} построить отображение \{[$a^2 \mapsto b^2$]\}.
\z Дано отображение \Nat $\Map$ \Nat. Вернуть количество элементов, отображающих в 0.
\z По данному отображению \{[$a \mapsto b$]\} построить отображение \{[$b \mapsto x$]\}, где $b$ - правая часть некоторого элемента исходного отображения, а $x$ - количество раз, которое $b$ встретилось в исходном отображении.
\z Дано отображение \Nat $\Map$ \Nat. Вернуть количество различных элементов, в которые осуществляется отображение.
\z Дано отображение \Nat $\Map$ \Real, представляющее основание и показатель степени в разложении числа на простые множители. Вернуть число, которое представлено таким отображением.
\z Дано натуральное число. Построить по нему отображение \Nat $\Map$ \Real, представляющее основание и показатель степени в разложении его на простые сомножители.
\z Дано отображение строк \{[$s \mapsto t$]\}. Оставить в нём только те элементы, левая часть которого начинается с $s_0$.
\z Проверить, является ли данное отображение детерминированным.
\z Проверить, является ли данное отображение конечным.
\z Проверить, является ли данное отображение взаимнооднозначным.
\z Проверить, есть ли в данном отображении элемент $x \mapsto y$, где $x$ -- наибольший из всех левых частей, а $y$ -- наименьший среди всех правых частей.
\z Проверить, является ли данное отображение перестановкой.
\z Проверить, является ли данное отображение перестановкой первых $N$ натуральных чисел.
\z Дано отображение \{[$(x, y) \mapsto L$]\} ($L$ -- множество). Проверить, верно ли, что все элементы в $L$ не больше $y$ и не меньше $x$.
\z Дано отображение. Построить его максимальное детерминированное подотображение.
\z Реляционное отношение задано отображением $T \Map A \DP B \DP C$. Проверить, есть ли среди атрибутов $A$, $B$, $C$ возможные ключи. Домены атрибутов считать sort-определенными.
\z Реализуйте функцию $lower$, переводящую символы в нижний регистр. Какова, по Вашему, будет сигнатура этой функции?


\section{Моделирование данных}
TODO

% турнир

% генеалогическое дерево

% кэш-память с ассоциативностями и секциями, тегами и строками

% код хаффмана! отображения + рекурсивные типы данных

%\z Формализуйте определения терминов, приведенных в этом тексте --- они выделены курсивом (он взят из~\cite{structures_algorithms}). \emph{Дерево} --- это совокупность элементов, называемых \emph{узлами} (один из которых определен как \emph{корень}), и отношений (<<родительских>>), образующих иерархическую структуру узлов. Узлы, так же, как и элементы списков, могут быть элементами любого типа. Мы часто будем изображать узлы буквами, строками или числами. Формально дерево можно рекуррентно определить следующим образом.
%\begin{enumerate}
%\item Один узел является деревом. Этот же узел также является корнем этого дерева.
%\item Пусть $n$ --- это узел, а $T_1, T_2, ..., T_k$ --- деревья с корнями $n_1, n_2, ..., n_k$ соответственно. Можно построить новое дерево, сделав $n$ родителем узлов $n_1, n_2, ..., n_k$. В этом дереве $n$ будет корнем, а $T_1, T_2, ..., T_k$ --- \emph{поддеревьями} этого корня. Узлы $n_1, n_2, ..., n_k$ называются \emph{сыновьями} узла $n$.
%\end{enumerate}
%
%Часто в это определение включают понятие \emph{нулевого дерева}, т.е. <<дерева>> без узлов.
%
% http://informatics.mccme.ru/moodle/course/view.php?id=18

0. крестики-нолики.  (координата1 >< координата2 >< отметка в клетке)-set - это первый взгляд, но когда мы будем писать функции, можем понять, что лучше (координата1 >< координата2) -m-> отметка в клетке.

1. SMS. У нее есть текст и номер, кому она отправлена. Кроме того, у SMS есть идентификатор, он присваивается в момент регистрации SMS, чтобы идентифицировать SMS с одинаковым текстом и  и изначально его нет. Кроме того, у SMS есть статус (например, обработана/не обработана). Статус может меняться. Задача состоит в том, чтобы описать термины "SMS" и "база SMS" на RSL (а именно, модель + инварианты).

1) генеалогическое дерево. Дерево должно удовлетворять следующим ограничениям:

    * каждый человек имеет не более двух родителей;
    * родители каждого человека имеют разный пол;
    * каждый человек младше каждого из своих родителей;
    * даты жизни родителей каждого человека пересекаются; * а что если родителей меньше 2х?
    * в корне дерева стоит один человек.
2) военная система. Подчиненные, единственный генерал, у солдат нет подчиненных. воинского подразделения. Иерархия должна удовлетворять следующим ограничениям:
- военнослужащие могут иметь только следующие звания (в порядке возрастания старшинства):
     - рядовой солдат (soldier)
     - лейтенант (lieutenant)
     - капитан (captain)
     - майор (major)
     - полковник (colonel)
     - генерал (general)
- у каждого военнослужащего, за исключением рядовых солдат, есть подчиненные
- у каждого военнослужащего, за исключением генералов, есть командир, причем ровно
один, звание которого выше звания военнослужащего
- все непосредственные подчиненные одного военнослужащего имеют одинаковые звания
- во главе подразделения стоит один военнослужащий. У него нет командиров
***возможно тут сформулированы не все требования - надо выделить их самим.



\section{Программные контракты}

Программный контракт --- это указание свойств результата, а не алгоритма его вычисления.

В оригинале: предусловие --- это


\head{Правильная трактовка предусловий}


\head{Советы по написанию постусловий}

RSL позволяет описывать меньший список через большой. Если f(x) меньше х, то описываем f(x) через перебор элементов х -- если f(x) больше x, то описываем x через перебор элементов f(x) (см. пример - вставка символа при повторе).

При спецификации функций, генерирующих одни множества по другим, полезно специфицировать пересечения и разницы этих множеств (как раз постоянная и меняющаяся часть).

Операторы inds, hd и tl используйте и тогда, когда не помните, с "1" или с "0" считаются индексы в списке. Плюс оператор inds дает дополнительную семантику переменной - что это индекс!

Композиция -- это способ построить выборку по двум критериям.

Не бояться использовать бесконечные сущности в спецификации.

Есть предположение, что если для структуры нужно делать поиск и добавление, то для ее моделирования лучше всего использовать отображение. Критерий поиска становится ключом, а добавляемые элементы - значениями.

\head{Схемы сокращения записи}

Следующие схемы рекомендуется применять в случае требований выполнения/невыполнения нескольких условий одновременно. Справа в схеме

\paragraph{схема пересечения}

$$x~\Inter~ \{f(t) ~|~ t:T\}$$ вместо $$\{a ~|~ a: X ~\SuchAs~ a \Isin x ~\And~ ( \Exists t: T  ~\SuchAs~ x = f(t) ) \}$$

\paragraph{схема вычитания-1}

$$x ~\Minus~ \{f(t) ~|~ t:T\}$$ вместо $$\{a ~|~ a: X ~\SuchAs~ a \Isin x ~\And~  \Not( \Exists t: T  ~\SuchAs~ x = f(t) ) \}$$

\paragraph{схема вычитания-2}

$$\{f(t) ~|~ t:T\} ~\Minus~ x$$ вместо $$\{a ~|~ a: X ~\SuchAs~ a ~\Isin x ~\And~ ( \Exists t: T  ~\SuchAs~ x = f(t) ) \}$$

\paragraph{схема выборки по ключам (на примере)}
Из исходного отображения выделить подотображение с определенными ключами:
$$t / \{1, 2\}$$ вместо $$[a \mapsto t(a) ~|~ a:X ~\SuchAs~ a \Isin \Dom x ~\And~ a \Isin \{1, 2\} ]$$

\paragraph{схема выборки по значению}
Из исходного отображения выделить подотображение с определенными значениями:
$$[1 \mapsto 1,~ 2 \mapsto 2] \Superp t$$ вместо $$[a \mapsto t(a) ~|~ a:X ~\SuchAs~ a \Isin \Dom x ~\And~ t(a) \Isin \{1,2\} ]$$

%(( all x:X :- ~exists y1, y2: X-set :- y1 ~= y2 /\ x isin y1 inter y2 )) можно записать короче:
%(( ~exists y1, y2: X-set :- y1 ~= y2 /\ y1 inter y2 ~= {} ))
%
%all x:X :- ~exists y:X-set :- x isin y ::::::: ~exists y:X-set :- y ~={} ::::::: all y:X-set :- y = {}

Простая задачка: выстроить в каком угодно порядке элементы множества в список (каждый элемент в списке будет повторяться
  * а) любое число раз
  * б) всего 1 раз
value
    set2list: T-set -> T-list
    set2list( s ) as l
    post
    a)    elems l = s             -- недоспецификация (неизвестен порядок и количество)
    б)    elems l = s /\ len l = card s    -- тоже недоспецификация (неизвестен порядок)

\head{Советы по получению понятных спецификаций}

\begin{itemize}
    \item Выбирать <<говорящие>> имена для параметров, функций, имен переменных и типов.
    \item Строить дополнительные функции, позволяющие <<читать>> выражения, в которых они встречаются.
    \item Выбирать одну из наиболее коротких форм записи выражений.
\end{itemize}

Пример: специфицируется система <<Электронное школьное расписание>>, в ней есть операция добавления нового класса (класс --- это имя и некая дополнительная информация); надо проверить, что имя класса еще не встречалось. Неудачный вариант спецификации этой проверки:
\begin{lstlisting}
check: Class-set >< ClassName >< ClassInfo -~-> Class-set
check(cset, cn, ci) is cset union {(cn,ci)}
pre (all c: Class :- c isin cset =>  let (cn2, ci2) = c in cn ~= cn2 )
\end{lstlisting}

Тут есть две проблемы:
\begin{enumerate}
    \item нечитабельные имена;
    \item длинная запись условия в предикате.
\end{enumerate}

Улучшенная версия:
\begin{lstlisting}
check: Class-set >< ClassName >< ClassInfo -~-> Class-set
check(classes, classname, classinfo) is
    classes union {(classname,classinfo)}
pre classname ~isin names(classes),

names: Class-set -> ClassName-set
names(classes) is
    { name(class) | class : Class :- class isin classes },

name: Class -> ClassName
name((classname,_)) is classname
\end{lstlisting}

Выбраны <<говорящие>> имена для параметров и добавлены 2 новые функции, с помощью которых предусловие стало возможным <<читать>>.

Еще пример для того же <<электронного расписания>>: пусть есть тип <<База данных>>, в нем несколько согласованных частей (одна хранит классы учащихся, другая учителей, третья аудитории); специфицируется функция, вносящая изменение в одну из частей (добавление нового класса учащихся). Неудачный вариант спецификации этой функции:
\begin{lstlisting}
add_class: DB >< Class -> DB
add_class(db, class) is
   let (classes, teachers, rooms, ....... ) = db in
        (classes union {class}, teachers, rooms, .... )
   end
\end{lstlisting}

текста получается много, взгляд разбегается, не знает, за что ухватиться, самое главное не высвечено.

Удачный вариант спецификации этой функции:
\begin{lstlisting}
add_class: DB >< Class -> DB
add_class(db, class) as db2
post
    classes(db2) = classes(db) union {class} /\
    teachers(db2) = teachers(db) /\
    rooms(db2) = rooms(db) /\ ....
\end{lstlisting}

Здесь постусловие (вместо явного задания) и выбор дополнительных <<говорящих>> функций позволяет выделить важное и кратко их записать.



\section*{Задачи}

\zhead{Написать неявную спецификацию следующих функций}

\zhead{Написать спецификацию функции без использования рекурсии}

\z Вычислить максимум множества натуральных чисел

\textbf{Решение:}
\begin{lstlisting}
type T = Nat
value max: T-set -~-> T
max(ns) as n
post  n isin ns /\ (all x: T :- x isin ns => x <= n)
pre   ns ~= {}
\end{lstlisting}
а теперь более короткое решение:
\begin{lstlisting}
value max:T-set -~-> T
max(ns) as n
post n isin ns /\ {0..n} >>= ns
pre ns ~= {}
\end{lstlisting}

\z Вычислить минимум множества натуральных чисел
%\begin{lstlisting}
%value min:T-set -~-> T
%min(ns) as n
%post n isin ns /\ {0..n-1} inter ns = {}
%pre ns ~= {}
%\end{lstlisting}

\z <<особые фамилии>>

Отобрать фамилии из данного списка, заканчивающиеся на <<ов>>.

%value f : Text-set -> Text-set
%длинное решение:
%f(x) is {y | y: Text :- y isin x /\ (exists z : Text :- y = z ^ "ов") }
%короткое решение (применена "схема пересечения"):
%f(x) is x inter {z ^ "ов" | z: Text}
%
%1. сортировка (++)
%
%type T = Real
%value sort: T-list -> T-list
%sort(x) as y
%post
%(all t:T :- <.tt|tt in x :- tt = t.> = <.tt|tt in y :- tt=t.>) /\
%(all i,j : Nat :- i <= j  /\ {i,j} << inds y =>  y(i) <= y(j) )
%
%вариант первой строчки через отображения:
%( exists m: T-m->T :- dom m = rng m /\ dom m = inds x /\ y(i) = m(x(i)) ) /\
%
%2. все подстроки (+)
%
%value allsubstr: Text -> Text-set
%allsubstr(full) is
%{ sub | sub : Text :- exists i : Nat :- i isin inds sub /\ (all k: Nat :- k < len sub => full(i+k) = sub(k+1)) }
%запись внутреннего квантора короче:
%{ s | s: Text :- exists i:Nat :- i < len full - len s /\  s = <.full(k)|k in <.i+1..i+1+len s.>.> }
%или так:
%{ s | s: Text :- exists i:Nat :- s is <.full(k)|k in <.i..i+len s.>.> }
%более короткое решение:
%{<.full(i)|i in <.1..len full.> :- b(i).> | b : Bool-list :- len b = len full }
%
%одна подстрока:
%value substr: Text >< Text -> Bool
%substr(sub, full) is
%(exists i:Nat :- sub is <.full(k)|k in <.i..i+len sub.>.>)
%
%
%[задача о рюкзаке]
%
%дано множество предметов, информация о них (вес (и стоимость)), ограничение на вес рюкзака
%построить множество предметов из данного множества, дающих максимум стоимости
%или: построить множество множеств предметов (распределение) так, чтобы минимизировать количество рюкзаков
%// ничего сложного, просто много писанины
%
%value  rucksack: (T-set) >< (T-m-> Nat) >< Nat -> T-set-set
%rucksack( objs, ws, w ) as rs
%post
%rs = {
%
%
%3. объединение классов (задача взята из Software Engineering I, Dines Bjorner)  (++)
%
%type A, P = (A-set)-set
%value mergeC: P >< A >< A -~-> P
%mergeC(p1, a1, a2) as p2
%post
%(all s: A-set :- s isin p1 /\ s inter {a1, a2} = {} => s isin p2) /\  ////вариант: p1 inter p2 = { s | s : A-set :- s isin p1 /\ s inter {a1, a2} = {} } /\
%card p2 = card p1 - 1 /\ (all s1, s2: A-set :- {s1, s2} <<= p1 /\ a1 isin s1 /\ a2 isin s2 => (s1 union s2) isin p2)
%короче:
%(exists s1, s2: A-set :- p1\p2 = {s1, s2} /\ s1 ~= s2 /\ a1 isin s1 /\ a2 isin s2 /\ p2\p1 = {s1 union s2})
%pre
%(exists s1,s2: A-set :- {s1,s2} <<= p1 /\ s1 ~= s2 /\ a1 isin s1 /\ a2 isin s2)
%
%4.  разметка текста-I (+)
%
%если встречается буква 'a', заменить ее на 'b'
%
%value replace1: Text >< Char >< Char -> Text
%replace1(x, a, b) as y
%post
%len x = len y /\
%(all i: Nat :- i isin inds x => y(i) = b /\ x(i) = a \/ y(i) = x(i) /\ x(i) ~= a)
%
%5. разметка текста-II
%
%если встречается слово "abc", заменить его на "def"
%
%type TextTuplet = {| tl:Text-list :- len(tl) = 2 |}
%value
%  replace2 : Text >< Text >< Text -> Text
%  replace2(txt, str, res) as newtxt
%  post
%      if txt = "" then newtxt = ""
%      else
%         (exists lst : TextTuplet-list :-
%            hd lst = <. txt, "" .> /\
%   lst(len lst) = <."", newtxt.> /\
%            (all i : Nat :- {i,i+1} << inds lst =>
%if (exists t:Text :- lst(i)(1) = str ^ t)
%then (exists t:Text :- lst(i)(1) = str ^ t /\ lst(i+1)(1) = t /\ lst(i+1)(2) = lst(i)(2) ^ res)
%else lst(i+1)(1) = tl lst(i)(1) /\ lst(i+1)(2) = lst(i)(2) ^ <.hd lst(i)(1) .>
%end
%   )
%         )
%      end
%
%
%
%6. слияние (+)
%
%даны два упорядоченных списка чисел, построить упорядоченный список из объединения этих чисел
%
%type T = Real
%value merge: T-list >< T-list -~-> T-list
%merge(x,y) as z
%post
%(all i,j:Nat :- {i,j} <<= inds z => (i <= j => z(i) <= z(j))) /\
%(all t: T :- <.tt|tt in x :- tt = t.> ^ <.tt|tt in y :- tt = t.>  = <.tt|tt in z :- tt = t.> )
%pre
%(all i,j:Nat :- {i,j} << inds x => (i <= j => x(i) <= x(j))) /\
%(all i,j:Nat :- {i,j} << inds y => (i <= j => y(i) <= y(j)))
%
%7. выделение слов из текста (++)
%
%разделитель задается в качестве параметра
%
%value parse: Text >< Char -> Text-set
%parse(t,d) is { w | w : Text :-
%<.d.> ^ w ^ <.d.> isin allsubstr(<.d.> ^ t ^ <.d.>) /\ d ~isin elems w }
%
%8. факториал без рекурсии (++)
%
%value f: Nat -> Nat
%f(x) as y
%post
%(exists n : Nat-list :- len n = x /\ hd n = 1 /\
%(all i : Nat :- i < len n - 1 => n(i+2) = n(i+1)*(i+2)) /\ y = n(len n))
%
%9? количество раз, которое подстрока встречается в другой строке
%
%10 инъектирование (+)
%
%после каждого вхождения в строку заданного символа вставить другой символ
%
%value inject: Text >< Char >< Char -> Text
%inject(t, c1, c2) as t2
%post
%if c1 ~= c2 then t = <. t2(i) | i in <.1 .. len t2.> :- ~(t2(i-1) = c1 /\ t2(i) = c2) .>  ////не работает при c1 = c2
%else t = <. t2(i) | i in <.1 .. len t2.> :- t2(i) ~= c1 \/ (exists ll:Nat :- len <.t2(j)|j in <. i-ll+1 .. i .>.> = 1 /\ t2(i-ll) ~= c1 /\ ll \ 2 = 1 .>) end
%
%
%11 представители (+)
%
%для каждого символа в строке оставить только первое его вхождение
%
%value m: Text -> Text
%m(t) as t2
%post
%/////////elems t = elems t2 /\ card elems t2 = len t2 /\ сохраняется порядок первых вхождений ??????????
%t2 = <. t(i) | i in <.1 .. len t.> :- t(i) ~isin {t(j)|j : Nat :- j isin {1..i-1}} .>
%
%12. Set Intersection—Returns a new array containing elements common to the two arrays, with no duplicates.
%[ 1, 1, 3, 5 ] & [ 1, 2, 3 ] #=> [ 1, 3 ]
%value intersection : T-list >< T-list -> T-list
%intersection(a, b) as c
%post elems c = elems a inter elems b /\ len c = card elems c
%
%13-14. Repetition—With a String argument, equivalent to self.join(str). Otherwise, returns a new array built by concatenating the int copies of self.
%int_repetion: [ 1, 2, 3 ] * 3 #=> [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
%str_repetion: [ 1, 2, 3 ] * "," #=> "1,2,3"
%value int_repetion: T-list >< Nat -> T-list
%int_repetion( t, c ) as t2
%post len t2 = len t * c /\ all m : Nat :- m isin inds t  => { t2[n*len t + m] | n : Nat :- n < c } = { t2[m] }
%
%value str: T -> Text,
%str_repetion: T-list >< Text -> Text
%str_repetion( t, c ) as t2
%post  ????
%
%http://ruby-doc.org/core/classes/Array.html
%
%**** Проверить, что заданная строчка является правильным скобочным выражением.
%value parmatch: Text -> Bool
%parmatch(t) is elems t <<= elems "()" /\ ( t = "" \/ (exists t1, t2 : Text :- t = "("^t1^")"^t2 /\ parmatch(t1) /\ parmatch(t2)))
%
%
%**) получение строкового представления числа
%пишется именно что спецификация, а не реализация! т.е. как проверить данную строку. Плохой симптом, если постусловие пишется в стиле "ответ равен результату работы такого-то другого алгоритма". Иными словами, хотели проверить один алгоритм, а вместо этого пишем другой - и везде можем совершить ошибку. Вместо этого надо заниматься не вычислением, а определением, т.е. выделением набора характеристик и их сравнением.
%
%value
%    digit : Char -m-> Int = ['0'+> 0, ...., '9' +> 9 ],
%    itoa: Int -> Text
%    itoa(x) as s
%    post
%        elems s <<= elems "-0123456789" /\ s ~= "" /\
%        "-" ~isin tl s /\  ( x < 0  is  hd s = "-" ) /\
%        let s1 = if x < 0 then tl s else s end, s2 = reverse(s1) in
%            all i : Nat :- i isin inds s2 => digit(s2(i)) = (abs x \ 10**i) / 10**(i-1)
%        end
%
%обратная задача: вернуть целое число из строки
%    atoi : Text -~-> Int
%    atoi(s) as x
%    post
%        ( x < 0  is  hd s = "-" ) /\
%        let s1 = if x < 0 then tl s else s end, s2 = reverse(s1) in
%            all i : Nat :- i isin inds s2 => digit(s2(i)) = (abs x \ 10**i) / 10**(i-1)
%        end
%    pre
%        elems s <<= elems "-0123456789" /\ s ~= "" /\ "-" ~isin tl s
%
%=======================================================
%
%граф задан отображением V -m-> V-set
%
%задействованы операторы: \ dom rng () # /
%не задействованы (1): !!
%
%12 поиск пути в графе (++)
%
%type G = {| g : V -m-> V-set :- all v : V :- v isin dom g => g(v) <<= dom g |}
%type G = {| g : V -m-> V-set :- union rng g <<= dom g |} ///более короткая запись, но rsltc не поддерживает префиксный union:(
%
%value path : G >< V >< V -> V-list
%path(g, v1, v2) as p
%post
%elems p <<= dom g /\ hd p = v1 /\ p(len p) = v2 /\
%(all i:Nat :- i < len p - 1 => p(i+2) isin g(p(i+1)))
%/// вариант последней строки: (all i: Nat :- {i, i+1} <<= inds p => p(i+1) isin g(p(i)))
%
%12a. построение гамильтонова пути (+)
%
%value gpath : G-> V-list
%path(g) as p
%post
%elems p = dom g /\ len p = card elems p /\
%(all i:Nat :- i < len p - 1 => p(i+2) isin g(p(i+1)))
%
%13. проверка, что граф является деревом (т.е. без циклов с одним корнем)
%
%value istree: G -> Bool
%istree(g) is
%// корень - это вершина, на которую никто не указывает
%card { v | v : V :- v isin dom g =>  ~exists x: V :- x isin dom g /\ v isin g(x) } = 1 /\ ?????????? [[ без циклов ]]
%короче:
%card { v | v : V :- v isin dom g =>  [vs+>0|vs: V-set :- v isin vs] # g = [] } = 1 /\ ?????????? [[ без циклов ]]
%еще короче:
%card (dom g \ {v|v : V :- exists vs : V-set :- vs isin rng g /\ v isin vs }) = 1 /\
%
%~exists vs: V-list :- ( elems vs << dom g /\ len vs > 1 /\ vs(1) = vs(len vs) /\
%all i:Nat :- i < len vs - 1 => vs(i+2) isin g(vs(i+1)) )                                                           ////переписать отсутствие цикла как-то более просто
%//// ацикличность: недостижимость любой вершины из самой себя
%
%/// надо еще добавить, что граф должен быть связным! (с одной компонентой связности)
%
%14. ограниченная достижимость (++)
%
%построить множество вершин, достижимых из данной вершины с не более N промежуточными вершинами
%value  med: G >< V >< Nat -~-> V-set
%med(g, v, n) as vs
%post
%(exists r: (V-m->V-set)-list :- len r = n /\ hd r = g /\ (all i :- Nat :- i < n-1 => r(i+2) = g#r(i+1)) /\ vs =  union elems <. e(v) | e in r.>)
%другой вариант на основе префиксного union (получилось короче?):
%(exists r: (V-set)-list :- len r = n /\ hd r = g(v) /\ (all i: Nat :- i < n-1 => r(i+2) = union rng g/r(i+1)) /\ vs = union elems r)
%или без композиции, но это более длинная спецификация:
%(all a: V-set :- a isin dom g => (a isin vs = ( exists path: V-list :- elems path <<= dom g /\ len path <= n /\ hd path =  v /\ path(len path) = a /\ (all i:Nat :- {i,i+1} <<= inds path => path(i+1) isin g(path(i)) )) ))
%
%частный случай для n=1:
%post  vs = g(v) union (g#g)(v)
%или vs = g(v) union union rng (g/g(v))
%или (переписан префиксный union) vs = g(v) union { v1| v1 : V :- v1 isin rng (g/g(v))}
%pre v isin dom g
%
%15. добавление элемента в дерево поиска
%
%16. инвертирование дуг графа


\zhead{По данной явной спецификации построить эквивалентную неявную спецификацию}

\z \begin{lstlisting}
variable lst: Int-list
value f: Unit -> write lst Int-list
  f() is local variable lst2:Int-list := <..> in
    for e in lst do
      if e ~isin elems lst2 then lst2 := lst2 ^ <.e.> end
    end; lst2  end
\end{lstlisting}

\textbf{Решение:} Функция возвращает список первых вхождений в обратном порядке. Идея записи постусловия: для каждого элемента списка-результата:
\begin{itemize}
    \item все предыдущие элементы не должны встречаться перед первым его вхождением;
    \item все последующие элементы должны встретиться перед первым его вхождением.
\end{itemize}

\begin{lstlisting}
variable lst: Int-list
value f: Unit -> write lst Int-list
f() as lst2
post lst = lst` /\
  let lst2 = card elems lst /\ elems lst2 = elems lst /\
  ( all i:Nat :- i isin inds lst2 =>
    ( exists j: Nat :- j isin inds lst /\ lst(j) = lst2(i) /\
               lst(j) ~isin { lst(k) | k:Nat :- k isin {1..j-1} } /\
       (all p:Nat :- p isin inds lst2 /\ p < i =>
         lst2(p) ~isin { lst(k) | k:Nat :- k isin {1..i-1} } ) /\
       (all p:Nat :- p isin inds lst2 /\ p > i =>
         lst2(p)  isin { lst(k) | k:Nat :- k isin {1..i-1} } ) ) )
\end{lstlisting}

\z \begin{lstlisting}
variable lst: Int-list
value f: Unit -> write lst Int-list
   f() is
    local variable lst2:Int-list := <..>, lst3: Int-list := lst in
    for e in lst do
        if lst3 ~= <..> then
           lst3 := tl lst3;
           if e ~isin elems lst3 then lst2 := lst2 ^ <.e.> end
       end
   end; lst2  end
\end{lstlisting}

\z \begin{lstlisting}
value f: Int-list -> Nat
  f(lst) is local variable m:Nat := 0,
         m2:Nat := 0, b:Bool := true in
    for i in <.1 .. len lst.> do
        m := 1; b := true;
        for j in <.i+1 .. len lst.> do
          if b /\ lst(j) >= lst(j-1)
            then m := m + 1
            else b := false end
          end;
          if m2 < m then m2 := m end
       end; m2 end
\end{lstlisting}

\z \begin{lstlisting}
value f: Nat-list -> Nat
  f(lst) is local variable lst2:Nat-list := lst,
             k:Nat := 0, m:Nat := 0 in
     for e in lst do
        if e > k then m := m + 1; k := e end;
    end; m end
\end{lstlisting}

\zhead{По данной алгебраической спецификации предложить модели типов и явные или неявные определения функций}
Выделить наислабейшие предусловия для функций.

% спецификация функций стандартной библиотеки Си: http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf

% спецификация протоколов (формат сообщений и правила преобразования сообщений)

% описание недетерминированности в детерминированных предусловиях (разное поведение, мы еще не выбрали из них окончательное)
% --- как в играх ("крестики-нолики")


%%\chapter{Поведенческие спецификации}
%%TBD
%
%\chapter{Специфицирование систем реального размера}
%Спецификация для функции append в <<исполнимой>> манере:
%\begin{lstlisting}
%type E, L = E*
%value append: L >< L -> L
%    append(x, y) is x ^ y
%\end{lstlisting}
%
%Спецификация для функции append в <<логической>> манере:
%\begin{lstlisting}
%type E, L = E*
%value append: L >< L -> L
%    append(x, y) as z
%    post
%        len z = len x + len y /\
%        (all i: Nat :- i isin inds x => z(i) = x(i)) /\
%        (all i: Nat :- i isin inds y => z(i+len x) = y(i))
%\end{lstlisting}
%
%Спецификация для функции reverse в <<исполнимой>> манере:
%\begin{lstlisting}
%type E, L = E*
%value reverse: L -> L
%    reverse(x) is
%        local variable y : L :- y = <..> in
%            for xi in x do
%                y := <.xi.> ^ y
%            end;
%            y;
%        end
%\end{lstlisting}
%
%Спецификация для функции reverse в <<логической>> манере:
%\begin{lstlisting}
%type E, L = E*
%value reverse: L -> L
%  reverse(x) as y
%  post len x = len y /\
%    (all i: Nat :- i isin inds x => y(i) = x(len x + 1 - i))
%\end{lstlisting}
%
%Спецификация для функции reverse в <<алгебраической>> манере:
%\begin{lstlisting}
%type E, L = E*
%value reverse: L -> L
%axiom
%    reverse(<..>) is <..>,
%    all x, y: L :- reverse(x^y) is reverse(y) ^ reverse(x)
%\end{lstlisting}
%
%Что из этого короче? Что понятнее? Что лучше? (зависит от задачи)

% задача - выбрать и правильно смоделировать самое главное в алгоритме:
% gzip, протокол MESI, map/reduce, mp3, google chrome... (в зависимости от варианта задания--посмотреть,что интересует молодежь на Хабре) -- так, чтобы другой человек мог сам понять и получить это новое знание. В качестве примера, можно рассмотреть то, что я писал в диссертации - поймут студенты?
% DOM:
%http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-184E7107–???DOM Core 3
%http://ru.wikipedia.org/wiki/Document_Object_Model-

\appendix
\include{rslprior}

\pagebreak
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{rslbooks}

\end{document}
