% !Mode:: "TeX:UTF-8"
\documentclass[14pt, twoside]{extreport}
\usepackage{cmap}

%\usepackage{fix-cm}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{dsfont}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\usepackage{clrscode}

\pagestyle{headings}

\textheight 23cm % 29.7-2-2
\textwidth 16cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \evensidemargin 0cm  \headheight 0cm \headsep 1.5cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел

\usepackage{vaucanson-g}

\usepackage{ifpdf}

\ifpdf
% we are running pdflatex, so convert .eps files to .pdf
% run pdflatex with --shell-escape and thesis.aux
\usepackage[pdftex]{graphicx}
\usepackage{epstopdf}
\else
% we are running LaTeX, not pdflatex
\usepackage{graphicx}
\fi

% Подправим команду \appendix : нумерация русскими буквами,
% а не латинскими.
\makeatletter
\renewcommand\appendix{\par
  \setcounter{chapter}{0}%
  \setcounter{section}{0}%
  \def\@chapapp{\appendixname}%
  \def\thechapter{\@Asbuk\c@chapter}}
\makeatother

% "русифицируем" окружение enumerate:
\makeatletter
\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
\def\labelenumii{\theenumii)}    % а не латинские буквы
\def\p@enumii{\theenumi}         % а это для \ref
\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
\let\theenumiii\relax            % и отдельных ссылок на него не будет
\def\p@enumiii{\theenumi\theenumii}
\makeatother

\usepackage{rsl}

\usepackage{listingsutf8}
\lstloadlanguages{RSL}
\lstset{numbers=left, language=RSL, extendedchars=true, numberstyle=\tiny, inputencoding=utf8%,
%commentstyle=\itshape, stringstyle=\bfseries
}

\author{Евгений Корныхин}
\title{\huge{\textbf{\textsc{Задачи по формальной спецификации программ на RSL}}}}
%\date{Москва --- 2010}

\newcounter{problem_type}[chapter]
\newcounter{zadacha}[problem_type]
\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
\textit{\arabic{chapter}.\arabic{problem_type}.\arabic{zadacha}}~~  }

\newcommand{\head}[1]{\vspace{1cm}\subsubsection*{#1}}
\newcommand{\zhead}[1]{\head{#1} \refstepcounter{problem_type}}


\begin{document}

\maketitle

\tableofcontents

\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}

Данный сборник задач написан в поддержку курса <<Формальной спецификации и верификации программ>>, который читается студентам последних курсов факультета ВМиК МГУ.

Под <<формальной>> спецификацией в первую очередь понимается строгое однозначное задание (описание) интерфейса или поведения программы. До сих пор необходимость доведения описаний до строгих однозначных форм ставится под сомнение, если речь идет о совершенно произвольных программах (как минимум, это сталкивается с высокой трудоемкостью формальной спецификации и особенной квалификацией тех, кто эту спецификацию составляет). Хотя полезность (и даже необходимость) строгого однозначного задания \emph{критичных} систем сомнений не вызывает. И тем не менее понижение трудоемкости и сближение формальных спецификаций с программистами-инженерами (т.е. существенное расширение области реального использования формальных спецификаций) является актуальной задачей в области технологий программирования (software engineering).

Однако дабы не попадать в дискуссионную область, курс следует иному принципу. Реалии таковы, что кроме написания программ необходимо, чтобы эти программы были корректными, чтобы они удовлетворяли стандартам. Для решения задач обеспечения таких характеристик применяются \emph{в том числе и} математические методы. Это означает, что программа выражается в математических терминах в виде \emph{математической теории}, или \emph{математической модели}, и задача уже решается в рамках этой математической теории с применением математического аппарата. Эта идея может показаться малоприменимой на практике, поскольку обычно математики и программисты-инженеры живут <<в разных мирах>>. На самом же деле математические методы решения задач над программами (их еще называют \emph{формальными методами}, подчеркивая, что <<обычный>> программист-инженер работает в своем <<неформальном>> мире представления о своей программе) исторически возникли практически сразу с возникновением практического программирования (это 50-е годы ХХ века) и развиваются по настоящее время.

Математическая теория, создаваемая для программы, это и есть формальная спецификация. От природы этой спецификации будут зависеть и математические методы, применяемые для решения задачи. Математическая теория не создается сама по себе --- она создается для конкретных целей, для решения определенных задач: формализация требований с целью, во-первых, их прояснения, во-вторых, для выяснения в них противоречий и неполных требований, автоматизация тестирования, чёткая документация, формальная верификация и даже разработка программ при помощи формальных моделей. Единожды проведя формализацию, можно существенно снизить <<человеческий>> фактор на последующих этапах жизненного цикла программы.

Эта часть курса посвящена тому, какие на данный момент придуманы виды моделей, какой природы математические теории используются для описания программ. Вторая часть курса (не вошедшая в этот сборник задач) посвящена одному из применений формальных спецификаций --- формальной верификации программ.

Читатели могут столкнуться с <<моделями программ>> не впервые. Студенты ВМиК МГУ слушают перед этим курсом курс по объектно-ориентированному анализу и проектированию программ и курс по верификации программ на моделях (model checking). Отличия этого курса от уже прослушанных заключаются в следующем. Курс ООАП также работает с моделями, но многие из этих моделей ориентированы только на последующее кодирование, а не на анализ программ. Грубо говоря, речь идет о моделировании структуры кода, а не семантики программы. Кроме того, строгий, формальный, подход практически никак не отражен в этом курсе. В курсе верификации на моделях рассматривается инструмент SPIN и моделирование на языке PROMELA. Остальные виды моделей программ в этом курсе не рассматриваются, но рассматриваются в данном курсе.

Согласно одной из принятых классификаций выделяют следующие основные виды моделей программ:
\begin{itemize}
  \item логико-алгебраические модели (interface specification: property-based / state-based);
  \item исполнимые модели (behavior specification);
\end{itemize}
Кроме того, выделяют модели, совмещающие в себя характеристики логико-алгебраических и исполнимых моделей.

Исполнимые спецификации дают модель в виде программы для некоторой виртуальной машины, может быть, достаточно абстрактной. В основном, это различные виды конечных автоматов и систем переходов (LTS). К таким моделям относятся модели на PROMELA, уже знакомые читателям. Кроме того, с конечными автоматами они сталкивались достаточно часто в предыдущих курсах. Поэтому в этом курсе исполнимые модели не будут рассматриваться подробно.

Логико-алгебраические модели рассматривают операции программы в математическом смысле, как отображения аргументов и пре-состояния на значения-результаты операций и пост-состояния\footnote{потому такие модели не являются исполнимыми в общем случае --- попробуйте для любой функции, заданной отображением, автоматически построить программу, которая ее исполняет!}. Чистые \emph{логические модели} представляют собой набор аксиом, из которых следуют эти отображения. \emph{Алгебраические модели} описывают эквивалентности суперпозиций операций (грубо говоря, эти модели состоят из требований эквивалентности разных термов--цепочек действий). К неисполнимым спецификациями принадлежат и такие виды моделей как \emph{программные контракты} --- набор логических свойств, которые должны быть выполнены при корректных входных данных и вычисленных по ним выходных. Грубо говоря, для задания семантики программы в неисполнимом виде применяются два подхода: <<чистый операционный>> (функциональный) подход (property-based) и подход, основанный на моделировании состояния программы (model-based, state-based). В функциональном подходе состояние не моделируется! И тем не менее, семантику операций удается задать. Вторая глава задачника посвящена функциональному подходу. Третья глава --- подходу, основанному на моделировании состояния программы. А первая глава посвящена тому языку, на котором все эти модели можно выражать --- языку RSL. Авторы языка попытались создать язык, который был бы языком программирования и языком спецификации одновременно\footnote{На самом деле обе эти цели можно воспринимать как моделирование --- первое является исполнимым моделированием, а второе неисполнимым.}. Единый языка выражения программы и ее семантики позволяют легче провести верификацию программы на такой модели. Но вопросы верификации лежат уже за пределами данного сборника задач.

\chapter{RSL для императивного программирования}

\input{prog/about}

\section*{Задачи}

\input{prog/problems}


\chapter{Логико-алгебраические спецификации}

\section{Логические модели}

Логико-алгебраические модели --- набор свойств, утверждений, аксиом~\cite{kuliamin}. Из этих аксиом путем логического вывода получаются другие свойства.

Если количество состояний системы невелико, ее удобно моделировать в виде конечного автомата. При возрастании количества состояний конечные автоматы становятся неудобными как для моделирования, так и для работы с такими моделями. До некоторого момента и для некоторых задач помогают расширенные конечные автоматы (EFSM), модели Крипке, но для систем более реальных размеров и они могут стать неудобными. Тогда вместо такого (явного) указания состояний и переходов между ними предлагается задавать \emph{правила}: о структуре состояния, о свойствах состояния, о свойствах переходов\footnote{Аналогично совершается переход от задания формальных языков перечислением его слов к формальным грамматикам, т.е. правилам конструирования слов}. Одним из основных механизмов теперь будет логический вывод новых свойств и правил из заданных в спецификации.

\head{Логическая модель на RSL}
Это набор аксиом. Аксиомы помещаются в секцию \textbf{axiom}. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y: Int :-
            add(x,y) >= x,
            add(x,y) >= y,
            add(x,0) is x,
            add(10, 45) is 55,
            exists! z : Int :- add(0, z) is x
end
\end{lstlisting}

\section*{Задачи}

\input{alg/formal}

\section{Алгебраические спецификации}

\input{alg/theor}

\section*{Задачи}

\input{alg/calc}

\input{alg/find_errors}

\input{alg/unformal}

\input{alg/problems}

\section{Полнота и непротиворечивость алгебраических спецификаций}

\input{alg/compness}

\section*{Задачи}

\input{alg/comprobs}

\input{alg/fsm}

\section{Cпецификация рекурсивных типов}

%\head{Рекурсивное определение типов (деревьев)}
Алгебраические модели и АТД являются удобным способом рекурсивного задания типов и операций их обработки. Для этого представленный только что формальный метод построения достаточно полных алгебраических спецификаций прочитывается следующим способом:
\begin{enumerate}
  \item выделить и составить сигнатуры конструкторов (пустое значение | составление нового <<узла дерева>>);
  \item выделить и составить сигнатуры функций-обработчиков рекурсивного типа;
  \item описать результат обработки для каждого конструктора.
\end{enumerate}

Например, спецификация функции, вычисляющей глубину бинарного дерева, согласно этому методу получается такой:
\begin{lstlisting}
type Node, Tree == empty | mk_tree(Node, Tree, Tree)
value depth: Tree -> Nat
axiom forall n: Node, left: Tree, right: Tree :-
  depth( empty ) is 0,
  depth( mk_tree(n, left, right) ) is
          max( depth(left), depth(right) )
value max: Nat >< Nat -> Nat
   max(x,y) is if x > y then x else y end
\end{lstlisting}

Конструктор предназначена лишь для структурных целей, т.е. определение дерева в виде типа Tree из этого примера пойдет и для бинарного дерева произвольного вида, и для бинарного сбалансированного дерева, и для других бинарных деревьев. А уже менее тривиальные функции составления деревьев (например, чтобы не нарушалась сбалансированность) определяются в виде функций-обработчиков.

\section*{Задачи}
%
\zhead{}%Рекурсивные типы}
%
\z Специфицируйте операцию проверки вхождения элемента в бинарное дерево.

\textbf{Решение:}
\begin{lstlisting}
type Node, Tree == empty | add(Node, Tree, Tree)
value check: Node >< Tree -> Bool
axiom forall n, n1:Node, left, right: Tree :-
   ~check( empty ),
   check(n, add(n1,left,right) ) is (n = n1) \/
             check(n, left) \/ check(n, right)
\end{lstlisting}

\z Специфицируйте операцию вычисления высоты бинарного дерева.

\z Специфицируйте операцию проверки бинарного дерева на сбалансированность.

\z Специфицируйте операцию получения предка элемента бинарного дерева.

\z Специфицируйте добавление элемента в двоичное дерево поиска.

\z Специфицируйте удаление элемента из двоичного дерева поиска.

\z Специфицируйте добавление элемента в АВЛ-дерево. Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из АВЛ-дерева. Определение операции предполагается найти самостоятельно.

\z Специфицируйте добавление элемента в 2-3-дерево. Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из 2-3-дерева. Определение операции предполагается найти самостоятельно.

\z Специфицируйте добавление элемента в декартово дерево. Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из декартова дерева. Определение операции предполагается найти самостоятельно.

\z Специфицируйте добавление элемента в красно-чёрное дерево.  Определение операции предполагается найти самостоятельно.

\z Специфицируйте удаление элемента из красно-чёрного дерева.  Определение операции предполагается найти самостоятельно.

% специфицировать стратегии вытеснения



\chapter{Моделе-ориентированные спецификации}

Моделе-ориентированные спецификации, как и алгебраические, описывают семантику интерфейсов программных компонент. Они основываются на \emph{абстракции алгоритмов} и \emph{абстракции данных}.

Абстракция алгоритмов предполагает, что для функций задаются (\emph{специфицируются}) не алгоритмы, их реализующие, а дается определение осуществляемого функцией отображения входных данных на выходные. Для этого зачастую используется аппарат \emph{программных контрактов}.

Абстракция данных предполагает, что для состояния компонента и типов параметров функций компонента (входных и выходных) указывается не их выражение в терминах целевого языка программирования (или их эквивалентов), а смысл, семантику этих данных, исходя из логического содержания и требований на внутренние отношения составляющих частей состояния. Например, если эти части \emph{<<по логике>>} должны быть неупорядочены и без повторов, то для моделирования таких частей следует использовать \emph{множества}. Если важен порядок и возможны повторы, то \emph{списки}. Если логически выделяются отображение одних данных в другие (отображение ключа в данные), то \emph{отображения}. Отображения являются наиболее адекватным представлением данных, которые по сути представляются <<реляционным отношением>> с первичным ключом.

В тексте реализации типы (наверняка) будут иметь другое представление, адекватное языку программирования (например, если система реализуется на Си, то вместо множеств или списков будут указатели), но логически функция в реализации должна принимать те же параметры (синтаксически функции передается указатель, а на самом деле этот указатель будет обозначать множество или список) и осуществлять то же отображение входных на выходные параметры, как это указано в спецификации.

\section{Множества, списки, отображения}

\head{Множества}
Множество -- это контейнер элементов одного типа, который обладает свойствами уникальности и неупорядоченности его элементов. Множества бывают конечными и бесконечными.

Типовое выражение для конечного множества: $typeexpr\Set$. Типовое выражение для бесконечного множества: $typeexpr\Infset$. Конечное множество -- подтип бесконечного множества.

Операции над множествами:
\begin{list}{}{}
\item $= : T\Infset \DP T\Infset \Fn \Bool$ -- сравнение на равенство
\item $\neq : T\Infset \DP T\Infset \Fn \Bool$ -- сравнение на не равенство
\item $\Union: T\Infset \DP T\Infset \Fn T\Infset$ -- объединение пары множеств
\item $\Union: T\Infset\Infset \Fn T\Infset$ -- объединение множества множеств
\item $\Inter: T\Infset \DP T\Infset \Fn T\Infset$ -- пересечение пары множеств
\item $\Inter: T\Infset\Infset \Fn T\Infset$ -- пересечение множества множеств
\item $\Minus: T\Infset \DP T\Infset \Fn T\Infset$ -- вычитание множеств
\item $\Isin: T \DP T\Infset \Fn \Bool$ -- проверка на принадлежность
\item $\NotIsin: T \DP T\Infset \Fn \Bool$ -- проверка на непринадлежность
\item $\SetL: T\Infset \DP T\Infset \Fn \Bool$ -- проверка вложения
\item $\SetG: T\Infset \DP T\Infset \Fn \Bool$ -- проверка вложения
\item $\SetLE: T\Infset \DP T\Infset \Fn \Bool$ -- проверка вложения
\item $\SetGE: T\Infset \DP T\Infset \Fn \Bool$ -- проверка вложения
\item $\Card: T\Infset \NonDetermFn \Nat$ -- количество элементов
($\Chaos$ для бесконечных множеств)
\end{list}

Обратите внимание на отсутствие операции выбора произвольного элемента из множества!

Только операция \textbf{card} дает целое число от множеств, т.е. любое целочисленное выражение над множествами будет мощностью некоторого множества.

Конструкторы множеств:
\begin{list}{}{}
\item (\emph{пустое множество}) \{\}
\item (\emph{перечисление}) \{0, 1, 2\} - множество, состоящее из трех целых чисел (не
натуральных!) - нуля, единицы и двойки.
\item (\emph{диапазон}) \{0..2\} -  то же, что и \{0, 1, 2\};
\{0..0\} $\Iden$ \{0\}, \{1..0\} $\Iden$ \{\}
\item (\emph{<<сокращенная запись>>}) $\{ expr\_with\_var | var : typeexpr
\SuchAs boolexpr\}$ (например, $\{2 \star n | n : \Nat \SuchAs n < 3
\}$, что эквивалентно \{0, 2, 4\})
\end{list}

\head{Списки}
Список -- это контейнер элементов одного типа, который обладает свойствами упорядоченности элементов. Для задания списка надо указать не только сами элементы, но и их порядок. Списки бывают конечными и бесконечными.

Типовое выражение для конечного списка: $typeexpr\List$. Типовое выражение для бесконечного списка: $typeexpr\Inflist$. Конечный список -- подтип бесконечного списка.

Операции:
\begin{list}{}{}
\item $=: T\Inflist \DP T\Inflist \Fn \Bool$ -- проверка на равенство
\item $\neq: T\Inflist \DP T\Inflist \Fn \Bool$ -- проверка на не равенство
\item $(.) : T\Inflist \DP \Int \NonDetermFn T$ -- взятие элемента по
индексу ($\Chaos$ для индекса, отсутствующего в списке, индексы
нумеруются \textbf{с единицы})
\item $\Concat: T\List \DP T\Inflist \Fn T\Inflist$ -- конкатенация списков
\item $\Hd: T\Inflist \NonDetermFn T$ -- головной элемент списка ($\Chaos$ для пустого списка)
\item $\Tl: T\Inflist \NonDetermFn T\Inflist$ -- хвостовая часть списка ($\Chaos$ для пустого списка)
\item $\Len: T\Inflist \NonDetermFn \Nat$ -- количество элементов списка ($\Chaos$ для бесконечного списка)
\item $\Elems: T\Inflist \Fn T\Infset$ -- множество элементов списка (без повторений!)
\item $\Inds: T\Inflist \Fn \Nat\Infset$ -- множество индексов элементов списка
\end{list}

Конструкторы списков:
\begin{list}{}{}
\item (\emph{пустой список}) $\LL\LR$
\item (\emph{перечисление}) $\LL 0, 1, 2 \LR$ - список, состоящий из трех целых чисел (не натуральных!) - нуля, единицы и двойки - в порядке увеличения.
\item (\emph{диапазон}) $\LL 0..2 \LR$ -  то же, что и $\LL 0, 1, 2 \LR$; $\LL 0..0 \LR \Iden \LL 0 \LR$, $\LL 1..0 \LR \Iden \LL\LR$
\item (\emph{<<сокращенная запись>>}) $\LL expr\_with\_var | var \In listexpr \SuchAs boolexpr\LR$ (например, $\LL 2 \star n | n \In \LL 0..2 \LR \LR$, что эквивалентно $\LL 0, 2, 4 \LR$)
\end{list}


\head{Отображения}
Отображение -- это множество пар элементов, у которого первые компоненты не повторяются. Отображения бывают конечными и бесконечными, детерминированными и недетерминированными (это те, в которых первые компоненты всё же могут повторяться в разных парах).

Типовое выражение для детерминированного отображения: $$typeexpr_1 \Map typeexpr_2$$ Типовое выражение для недетерминированного отображения: $$typeexpr_1 \NonDeterMap typeexpr_2$$

Операции:
\begin{list}{}{}
\item $=: (T_1 \Map T_2) \DP (T_1 \Map T_2) \Fn \Bool$ -- сравнение отображений на равенство
\item $\neq: (T_1 \Map T_2) \DP (T_1 \Map T_2) \Fn \Bool$ -- сравнение отображений на не равенство
\item $(.): (T_1 \Map T_2) \DP T_1 \NonDetermFn T_2$ -- взятие значения по индексу ($\Chaos$, если значение по этому индексу не
определено)
\item $\Dom: (T_1 \Map T_2) \Fn T_1\Infset$ -- \emph{область определения} отображения
\item $\Rng: (T_1 \Map T_2) \Fn T_2\Infset$ -- \emph{область значения} отображения
\item $\Upd: (T_1 \Map T_2) \DP (T_1 \Map T_2) \Fn (T_1 \Map T_2)$ -- обновление отображения
\item $\Union: (T_1 \Map T_2) \DP (T_1 \Map T_2) \Fn (T_1 \NonDeterMap T_2)$ -- объединение отображений
\item $\Minus: (T_1 \Map T_2) \DP T_1\Infset \Fn (T_1 \Map T_2)$ -- уменьшение отображения
\item $/: (T_1 \Map T_2) \DP T_1\Infset \Fn (T_1 \Map T_2)$ -- проекция отображения
\item $\Superp: (T_2 \Map T_3) \DP (T_1 \Map T_2) \Fn (T_1 \Map T_2)$ -- композиция отображений
\end{list}

Конструкторы отображений:
\begin{list}{}{}
\item (\emph{пустое отображение}) []
\item (\emph{перечисление}) $[0 \mapsto 1, 1 \mapsto 2]$ -- отображение, состоящий из двух пар целых чисел (не натуральных!) - из 0 в 1 и из 1 в 2.
\item (\emph{<<сокращенная запись>>}) $[expr_1\_with\_var \mapsto expr_2\_with\_var | var : typeexpr \SuchAs boolexpr]$ (например, $[n \mapsto n+1 | n : \Nat \SuchAs n < 3]$, что эквивалентно $[0 \mapsto 1, 1 \mapsto 2, 2 \mapsto 3]$)
\end{list}


\section*{Задачи}

\zhead{Вычислить выражения с множествами}

\z $\{1, 2\} = \{3, 1\}$
\z $\{1, 2\} = \{2, 1\}$
\z $\{1, 2, 1\} = \{2, 2, 1\}$
\z $\{1, 2\}~\Union~\{3, 4\}$
\z $\{1, 2\}~\Union~\{2, 3\}$
\z $\{1, 2\}~\Inter~\{3, 4\}$
\z $\{1, 2\}~\Inter~\{2, 3\}$
\z $\{1..30\}~\Union~\{10..-10\}$
\z $\{1..30\}~\Inter~\{10..-10\}$
\z $\{1..30\}~\Union~\{x~|~ x: \Int~\SuchAs~\Abs x < 11 \}$
\z $\{1..30\}~\Inter~\{x~|~ x: \Int~\SuchAs~\Abs x < 11 \}$
\z $\{x+10 ~|~ x: \Int \} = \{x ~|~ x: \Int\}$
\z $\{5*k + 2 ~|~ k : \Int \}~\Inter~\{3*k - 1 ~|~ k : \Int\}$
\z $\{5*k + 2 ~|~ k : \Int \}~\Minus~\{3*k - 1 ~|~ k : \Int\}$
\z $\{5*k + 2 ~|~ k : \Int \} \SetL \{3*k - 1 ~|~ k : \Int\}$
\z $\{5*k + 2 ~|~ k : \Int \} \SetGE \{3*k - 1 ~|~ k : \Int\}$
\z $\Not (\{1, 2\} \SetLE \{2, 1, 1\})$
\z $\Card \{1..30\}$
\z $\Card \{5*k + 2 ~|~ k : \Int~\SuchAs~k * k \Isin \{-10..10\}\}$
\z $\Card \{5*k + 2 ~|~ k : \Int~\SuchAs~k * k \Isin \{10..-10\}\}$
\z $\Card \{k*k - 2 * k ~|~ k : \Int~\SuchAs~k * k \Isin \{-10..10\}\}$
\z $\All x: \Nat ~\SuchAs~ x \Isin \{x ~|~ x : \Int\}$
\z $\All x: \Int ~\SuchAs~ x \Isin \{x ~|~ x : \Nat\}$


\zhead{Решите уравнения}

\z $\{1\} \Union x = \{\}$
\z $\{1\} \Union x = \{1\}$
\z $\{1\} \Union x = \{1, 2\}$
\z $\{1\} \Inter x = \{\}$
\z $\{1\} \Inter x = \{1\}$
\z $\{1\} \Inter x = \{1, 2\}$
\z $\{2, 1\} \Minus x = \{1\}$
\z $\Card~x = 0$
\z $\Card~x = 1$


\zhead{Какие из следующих выражений истинные}
Считайте, что свободные переменные располагаются под квантором
всеобщности

\z $(A \cup B) \setminus C = (A \setminus C) \cup (B \setminus C)$
\z $(A \setminus B) \cap C = (A \cap C) \setminus B$
\z $(A \cup B) \setminus C \Iden (A \setminus C) \cup (B \setminus C)$
\z $A \cup \{\} = A$
\z $\{\} \cup A = A$
\z $(A \cup B) \cap C = (A \cap C) \cup (B \cap C)$
\z $\Card \Nat < \Card \Int$
\z $\Card \Nat = \Card \Int$
\z $\Card \Nat > \Card \Int$
\z $\Card \Nat \Iden \Card \Int$
\z $\Card \{n ~|~ n:\Nat\} \Iden \Card \{n ~|~ n:\Int\}$


\zhead{Записать на RSL следующие множества}

\z Пустое множество;
\z Множество чисел 1, 2, 3 (а также множество чисел от 1 до 3);
\z Множество всех чётных чисел;
\z Множество всех чётных чисел, не превышающих 10 (привести в виде перечисления и нескольких различных сокращённых формах);
\z Множество всех простых натуральных чисел;
\z Множество всех пар взаимнопростых натуральных чисел;
\z Множество всех троек, в каждой из которых есть одинаковые элементы;
\z Множество всех степеней двойки, не превышающих 100 (привести в виде перечисления и нескольких сокращённых формах);
\z Множество всех IP-адресов класса А (B, C, D, E);
\z Множество всех точек плоскости, образующих
    \begin{enumerate}
    \item Прямую -- биссектрису I и III квадрантов;
    \item Правую полуплоскость;
    \item Нижнюю полуплоскость;
    \item Единичную окружность;
    \item Единичный круг;
    \item Единичный квадрат со сторонами, параллельными осям
    координат.
    \end{enumerate}

%\zhead{Построить явную спецификацию на RSL для следующих задач}
%
%В этих задачах, если удаётся, следует привести два варианта решения: с использованием сокращённой записи множества
%и с помощью рекурсии.
%
%\z Дано множество чисел. Вернуть множество квадратов чисел данного множества.
%\z Дано множество чисел. Вернуть множество чисел, представимых суммами каких-либо двух элементов исходного множества.
%\z Дано множество точек, заданных координатами в плоской декартовой системе координат. Получить проекцию этого множества на ось \textsc{Ox}.
%\z Дано множество всех простых чисел. Для данного числа вернуть множество его простых делителей, используя множество всех простых чисел.
%\z Дано множество чисел. Дано число. Существует ли подмножество данного множества чисел, сумма элементов которого, равна данному числу.
%\z Дано множество множеств. Вернуть множество всех элементов внутренних множеств.
%\z \textit{(Задача о рюкзаке)} Дано множество предметов. Каждый предмет имеет массу (массы заданы множеством пар предмет >< масса). Есть $n$ рюкзаков. Каждый рюкзак имеет вместимость $K$ кг. Распределить все предметы по рюкзакам, не превышая вместимости каждого рюкзака.
%\z Рабочая группа компьютеров задаётся IP-адресом (4 целых числа, каждое от 0 до 255) и маской (целое число от 0 до 32). Программа по данному заданию строит множество всех возможных в ней IP-адресов.


\zhead{Вычислить выражения со списками}
\z $\LL 1 \LR = \LL 1, 1 \LR$
\z $\LL 1, 2 \LR = \LL 3, 1\LR$
\z $\LL 1, 2\LR = \LL 2, 1\LR$
\z $\LL 1, 2, 3 \LR (2)$
\z $\LL 1 \LR (0)$
\z $\LL 1 \LR (1)$
\z $\LL 1, 2\LR \Concat \LL 3, 4\LR$
\z $\LL 1, 2\LR \Concat \LL 2, 3\LR$
\z $\LL x+10~|~x~\In~\LL 1, 2 \LR \LR = \LL x~|~x~\In~\LL 1 \LR \LR$
\z $\Hd \LL 1, 2, 3 \LR$
\z $\Tl \LL 1, 2, 3 \LR$
\z $\Len \LL 1, 2, 3 \LR$
\z $\Elems \LL 1, 2, 3 \LR$
\z $\Inds \LL 1, 2, 3 \LR$
\z $\Len \LL 1..30\LR$
\z $\Let~x = \LL 1, 2, 3\LR~\In~\Elems~x~\Inter~\Inds~x~\rslEnd$
\z $\Let~x = \LL 0, 1, 2\LR~\In~\Elems~x~\Inter~\Inds~x~\rslEnd$
\z $\Let~x : \Int\Inflist~\SuchAs~(\All i_1, i_2: \Nat~\SuchAs~\Card \{i_1, i_2\} = \Card \{x(i_1), x(i_2)\})\\\In~x~\rslEnd$
\z $\Let~x : \Int\Inflist~\SuchAs~(\All i_1, i_2: \Nat~\SuchAs~\Card \{i_1, i_2\} = \Card \{x(i_1), x(i_2)\})\\\In~\Elems~x~\Inter~\Inds~x~\rslEnd$
\z $\All x : T\Inflist~\SuchAs~x(0) = \Hd x$
\z $\All x : T\Inflist~\SuchAs~x(0) ~\Iden~ \Hd x$

\zhead{Решите уравнения}
\z $\LL 1 \LR \Concat x  = \LL 1 \LR$
\z $\LL 1 \LR \Concat x  = \LL 1, 2, 3 \LR$
\z $\LL 1 \LR \Concat x  = \LL 3, 2, 1 \LR$
\z $\Tl x = \LL 1 \LR$
\z $\Hd x = 1$
\z $x \Concat \Tl x = x$
\z $\Tl x = \LL \Hd x \LR$
\z $\Elems x = \Inds x$
\z $\Elems~\Tl x = \Elems x$
\z $\Len x = \Card \Elems x$
\z $\Len x = \Card \Inds x$
\z $\Len x \Iden \Card \Inds x$


\zhead{Записать на RSL следующие выражения}

\z Пустой список;
\z Список из чисел 1, 2, 3 (попробуйте привести как можно больше различных решений);
\z Список всех простых натуральных чисел в порядке увеличения их значения;
\z Список всех пар взаимнопростых натуральных чисел в порядке увеличения их суммы;
\z Список номеров групп 5го курса факультета ВМиК МГУ в порядке увеличения номера группы;
\z Количество простых чисел от 1 до 10 (тремя различными способами).

%\zhead{Напишите явные спецификации следующих функций}
%
%\z Определить, является ли бесконечным данный список.
%\z Вычислить длину списка без использования функции $\Len$.
%\z Вычислить сумму элементов списка.
%\z Вычислить произведение элементов списка.
%\z Дан список. Построить список из элементов исходного списка, элементы которого идут в обратном порядке по отношению к исходному списку
%\z Дана строка и символ. Определить, встречается ли символ в данной строке (предложить два различных способа решения).
%\z Дана строка. Определить самый часто встречающийся в ней символ.
%\z Отсортировать данный список вещественных чисел в порядке возрастания.
%\z Построить список всех целых чисел в порядке неубывания модуля.
%\z Определить $\sup$ списка вещественных чисел (в случае конечного списка это будет и максимум).
%\z Выдать число, не встречающееся в данном списке.
%\z Дан список чисел. Построить по нему список квадратов, расположив элементы
%    \begin{enumerate}
%    \item с сохранением порядка исходного списка
%    \item в порядке убывания модуля
%    \item так, чтобы не было трёх подряд чисел, расположенных в  порядке возрастания или убывания.
%    \end{enumerate}
%\z Дано натуральное число. Построить список степеней его простых делителей, в котором на местоположение степени есть её основание (а значение, соответственно, показатель).
%\z Дан список показателей степеней (местоположение -- основание степени). Построить соответствующее натуральное число.
%\z Дан список натуральных чисел, отличных от нуля. Вернуть список, в котором на месте №$i$ находится количество раз, которое $i$ встречается в исходном списке.
%\z Дано множество чисел. Построить из него список, расположив элементы множества
%    \begin{enumerate}
%    \item в порядке убывания
%    \item в порядке убывания модуля
%    \end{enumerate}
%\z Дан список чисел. Построить из него новый список, расположив элементы исходного списка
%    \begin{enumerate}
%    \item в порядке убывания
%    \item в порядке убывания модуля
%    \end{enumerate}
%\z Дан список из чисел. Построить из него множество, использовав все элементы данного списка.
%\z Дан множество пар (ключ, объект) и список ключей. Построить соответствующий ему список объектов. Считайте, что во множество пар ключи не повторяются.
%\z Дан список чисел. Можно ли суммой некоторых его элементов получить
%    \begin{enumerate}
%    \item четное число (для списка из целых чисел)
%    \item простое число (для списка из целых чисел)
%    \item целое число (для списка из вещественных чисел)
%    \end{enumerate}


\zhead{Упростить выражения}
\z $\langle x ~|~ x~\In~\langle \Card \{a..b\} \rangle \rangle$
\z $\langle c ~|~ c~\In~\langle 'a',~'b' \rangle \rangle$
\z $\langle c ~|~ c~\In~\langle '$ " $~' \rangle \rangle$
\z $\langle c ~|~ c~\In~\langle \rangle \rangle$

\newcommand{\Masha}{\mbox{\textrm{<<Маша>>}}}
\newcommand{\Sveta}{\mbox{\textrm{<<Света>>}}}
\newcommand{\Misha}{\mbox{\textrm{<<Миша>>}}}
\newcommand{\Slava}{\mbox{\textrm{<<Слава>>}}}
\newcommand{\Anna}{\mbox{\textrm{<<Аня>>}}}
\newcommand{\Petr}{\mbox{\textrm{<<Петя>>}}}
\newcommand{\Lesha}{\mbox{\textrm{<<Леша>>}}}
\newcommand{\Victor}{\mbox{\textrm{<<Витя>>}}}

\zhead{Вычислить}

\z $\map{n \mapsto 1}{n : \Nat \SuchAs n \Isin \{1..3\} }$
\z $\map{n \mapsto n}{n : \Nat \SuchAs n \Isin \{5..5\} }$
\z $\map{n \mapsto n+1}{n : \Nat \SuchAs n \Isin \{100..90\} }$
\z $\map{n \mapsto m}{n, m : \Nat \SuchAs n \backslash m = 0 \And m > 2}$
\z $\map{n \mapsto m}{n, m : \Nat \SuchAs n \Isin \{1..3\} \And m \Isin \{1..n\}}$
\z $\map{n \mapsto (p, q)}{n, p, q : \Nat \SuchAs n \Isin \{1..100\} \And p + q = n \And p \backslash q = 0}$
\z $[1 \mapsto 2,~2 \mapsto 3,~ 3 \mapsto 1] (3)$
\z $[1 \mapsto 2,~2 \mapsto 3,~ 3 \mapsto 1] (4)$
\z $[ \Masha \mapsto 30, \Sveta \mapsto 15, \Masha \mapsto 30] (\Masha)$
\z $[ \Masha \mapsto 30,  \Sveta \mapsto 15, \Masha \mapsto 10 ] (\Masha)$
\z $[1 \mapsto [1 \mapsto 1,~ 2 \mapsto 2,~ 3 \mapsto 3], 2 \mapsto [1 \mapsto 4,~ 2 \mapsto 5,~ 3 \mapsto 6]~]~ (2)~(1)$
\z $\Dom [3 \mapsto 1, 5 \mapsto 0, 2 \mapsto 88]$
\z $\Rng [3 \mapsto 1, 5 \mapsto 0, 2 \mapsto 88]$
\z $\Dom \map{n \mapsto 2 * n}{n : \Nat}$
\z $\Rng \map{n \mapsto 2 * n}{n : \Nat}$
\z $[1 \mapsto 20, 2 \mapsto 30] \Union [1 \mapsto 30, 2 \mapsto 20]$
\z $[1 \mapsto 20, 2 \mapsto 30] \Upd [1 \mapsto 30, 2 \mapsto 20]$
\z $[ \Misha \mapsto 170, \Slava \mapsto 200, \Victor \mapsto 195 ] ~\backslash \\ \{\Misha, \Petr\}$
\z $[ \Misha \mapsto 170, \Slava \mapsto 200, \Victor \mapsto 195 ] ~/ \\\{\Misha, \Petr\}$
\z Пусть Friend = $[\Misha \mapsto \Anna, \Anna \mapsto \Lesha, \Lesha \mapsto \Misha]$. Найти Friend $\Superp$ Friend. Какой смысл этого значения ?
\z $\Card~\Dom~[1 \mapsto 2, 1 \mapsto 3, 2 \mapsto 3]$
\z $\Dom ([10 \mapsto 100, 20 \mapsto 50] \Upd [20 \mapsto 60, 30 \mapsto 90])$
\z $\Card~\Rng~( [1 \mapsto 2] \Superp [3 \mapsto 2, 4 \mapsto 1] \Superp [1 \mapsto 2, 3 \mapsto 4])$

\zhead{Какие из следующих выражений истинны}

Если выражение ложно, привести контрпример и дополнительные ограничения на входящие переменные, чтобы условие стало верным. Считать, что все переменные стоят под кванторами всеобщности.

\z $\Dom~ (X \Union Y) \Iden \Dom X ~\Union~ \Dom Y$
\z $\Rng~ (X \Union Y) \Iden \Rng X ~\Union~ \Rng Y$
\z $\Dom~ (X \Upd Y) \Iden \Dom X ~\Upd~ \Dom Y$
\z $\Rng~ (X \Upd Y) \Iden \Rng X ~\Upd~ \Rng Y$
\z $X = Y ~\Impl~ \Dom X = \Dom Y$
\z $X \NEq Y ~\Impl~ \Dom X ~\NEq~ \Dom Y$
\z $X \NEq Y ~\Impl~ \Rng X ~\NEq~ \Rng Y$
\z $\Dom (X \backslash Y) ~\Iden~ (\Dom X) \backslash Y$
\z $\Dom (X / Y) ~\Iden~ Y$
\z $\Dom (X \Upd Y) ~\Iden~ \Dom X \Union Y$
\z $(X \Union Y) \Union Z ~\Iden~ X \Union (Y \Union Z)$
\z $(X \Upd Y) \Upd Z ~\Iden~ X \Upd (Y \Upd Z)$
\z $(X \Superp Y) \Superp Z ~\Iden~ X \Superp (Y \Superp Z)$
\z $X \Union Y ~\Iden~ Y \Union X$

\zhead{Записать на RSL следующие константы и определения типов}
\z Записать отображение -- перестановку первых $N$ натуральных чисел. Считать $N$ константой с sort-определением.
\z Записать отображение-<<сдвиг>> : [1 $\mapsto$ 2, 2 $\mapsto$ 3, ..., $N \mapsto$ 1]. Считать $N$ константой с sort-определением.
\z Записать отображение всех полных квадратов в своё основание. [1 $\mapsto$ 1, 4 $\mapsto$ 2, 9 $\mapsto$ 3, ...]
\z Записать отображение из любого натурального числа в его простой делитель.
\z Записать отображение любого натурального числа в большее его простое натуральное число. [1 $\mapsto$ 5, 2 $\mapsto$ 7, 3 $\mapsto$ 5, ...]
\z Записать отображение <<бесконечная перестановка>>.
\z Записать отображение любого натурального числа в своё <<зеркало>> -- число из цифр исходного числа, записанных в обратном порядке. [1 $\mapsto$ 1, ..., 12 $\mapsto$ 21, ..., 832 $\mapsto$ 238, ...]
\z Записать отображение любого текста в его реверсию. $[..., \mbox{\textrm{"стол"}} \mapsto \mbox{\textrm{"лотс"}}, \mbox{\textrm{"книга"}} \mapsto \mbox{\textrm{"агинк"}}, ...]$
\z Не меняя описания предыдущей константы, описать новое отображение любого текста, начинающегося с 'a', в его реверсию.
\z Записать тип <<Англо-русский словарь>> так, как Вы его представляете. Учтите, что слово может иметь несколько переводов.

%\zhead{Запишите спецификацию функций в явном виде}
%\z Подсчитать количество элементов в данном отображении, если оно
%    \begin{enumerate}
%    \item детерминированное
%    \item ${^\star}$ недетерминированное
%    \end{enumerate}
%\z По отображению \{[$a \mapsto b$]\} построить отображение \{[$a^2 \mapsto b^2$]\}.
%\z Дано отображение \Nat $\Map$ \Nat. Вернуть количество элементов, отображающих в 0.
%\z По данному отображению \{[$a \mapsto b$]\} построить отображение \{[$b \mapsto x$]\}, где $b$ - правая часть некоторого элемента исходного отображения, а $x$ - количество раз, которое $b$ встретилось в исходном отображении.
%\z Дано отображение \Nat $\Map$ \Nat. Вернуть количество различных элементов, в которые осуществляется отображение.
%\z Дано отображение \Nat $\Map$ \Real, представляющее основание и показатель степени в разложении числа на простые множители. Вернуть число, которое представлено таким отображением.
%\z Дано натуральное число. Построить по нему отображение \Nat $\Map$ \Real, представляющее основание и показатель степени в разложении его на простые сомножители.
%\z Дано отображение строк \{[$s \mapsto t$]\}. Оставить в нём только те элементы, левая часть которого начинается с $s_0$.
%\z Проверить, является ли данное отображение детерминированным.
%\z Проверить, является ли данное отображение конечным.
%\z Проверить, является ли данное отображение взаимнооднозначным.
%\z Проверить, есть ли в данном отображении элемент $x \mapsto y$, где $x$ -- наибольший из всех левых частей, а $y$ -- наименьший среди всех правых частей.
%\z Проверить, является ли данное отображение перестановкой.
%\z Проверить, является ли данное отображение перестановкой первых $N$ натуральных чисел.
%\z Дано отображение \{[$(x, y) \mapsto L$]\} ($L$ -- множество). Проверить, верно ли, что все элементы в $L$ не больше $y$ и не меньше $x$.
%\z Дано отображение. Построить его максимальное детерминированное подотображение.
%\z Реляционное отношение задано отображением $T \Map A \DP B \DP C$. Проверить, есть ли среди атрибутов $A$, $B$, $C$ возможные ключи. Домены атрибутов считать sort-определенными.
%\z Реализуйте функцию $lower$, переводящую символы в нижний регистр. Какова, по Вашему, будет сигнатура этой функции?


\section{Схемы сокращения записи}

Язык RSL обладает достаточно богатыми возможностями для записи выражений. В данном параграфе предлагается освоить ряд приемов по получению более краткой записи выражений за счёт использования различных предопределенных операций над множествами, списками и отображениями.

\paragraph{схема пересечения}

$$x~\Inter~ \{f(t) ~|~ t:T\}$$ вместо $$\{a ~|~ a: X ~\SuchAs~ a \Isin x ~\And~ ( \Exists t: T  ~\SuchAs~ x = f(t) ) \}$$

\paragraph{схема вычитания-1}

$$x ~\Minus~ \{f(t) ~|~ t:T\}$$ вместо $$\{a ~|~ a: X ~\SuchAs~ a \Isin x ~\And~  \Not( \Exists t: T  ~\SuchAs~ x = f(t) ) \}$$

\paragraph{схема вычитания-2}

$$\{f(t) ~|~ t:T\} ~\Minus~ x$$ вместо $$\{a ~|~ a: X ~\SuchAs~ a \NotIsin x ~\And~ ( \Exists t: T  ~\SuchAs~ x = f(t) ) \}$$

\paragraph{схема выборки по ключам (на примере)}
Из исходного отображения выделить подотображение с определенными ключами:
$$t / \{1, 2\}$$ вместо $$[a \mapsto t(a) ~|~ a:X ~\SuchAs~ a \Isin \Dom x ~\And~ a \Isin \{1, 2\} ]$$

\paragraph{схема выборки по значению}
Из исходного отображения выделить подотображение с определенными значениями:
$$[1 \mapsto 1,~ 2 \mapsto 2] \Superp t$$ вместо $$[a \mapsto t(a) ~|~ a:X ~\SuchAs~ a \Isin \Dom x ~\And~ t(a) \Isin \{1,2\} ]$$

%(( all x:X :- ~exists y1, y2: X-set :- y1 ~= y2 /\ x isin y1 inter y2 )) можно записать короче:
%(( ~exists y1, y2: X-set :- y1 ~= y2 /\ y1 inter y2 ~= {} ))
%
%all x:X :- ~exists y:X-set :- x isin y ::::::: ~exists y:X-set :- y ~={} ::::::: all y:X-set :- y = {}

\paragraph{схема соединения (join)}
Для компактной записи выражений, где нужно <<соединение>> двух отображений (join), следует использовать композицию отображений (это ее основное практическое применение).



\section*{Задачи}

\zhead{Записать следующие выражения}

При записи решений стараться выбирать наиболее короткую запись.

\z Дано непустое множество натуральных чисел m и натуральное число x. Записать логическое выражение, истинное тогда и только тогда, когда x равен максимальному числу во множестве m.

\textbf{Решение:}

%\begin{lstlisting}
%x isin m /\ (all y: Nat :- y isin m => y <= x)
%\end{lstlisting}
%
%а теперь более короткое решение:

\begin{lstlisting}
x isin m /\ {0..x} >>= m
\end{lstlisting}

\z Дано непустое множество целых чисел m и целое число x. Записать логическое выражение, истинное тогда и только тогда, когда x равен максимальному числу во множестве m.

\z Дано непустое множество натуральных чисел m и натуральное число x. Записать логическое выражение, истинное тогда и только тогда, когда x равен минимальному числу во множестве m.

\z Дано непустое множество натуральных чисел m. Записать сумму элементов этого множества.

\textbf{Решение:}
\begin{lstlisting}
card {(x,y)| x, y : Nat :- x isin m /\ y < x}
\end{lstlisting}

\z Дано непустое множество целых чисел m. Записать сумму элементов этого множества.

\z Дано непустое множество натуральных чисел m. Записать произведение элементов этого множества.

\z Дан непустой список t, натуральное число x и значение y того же типа, каков тип элементов в t. Записать логическое выражение, истинное тогда и только тогда, когда x является индексом первого вхождения y в t.

\z Дан непустой список t, натуральное число x и значение y того же типа, каков тип элементов в t. Записать логическое выражение, истинное тогда и только тогда, когда x является индексом последнего вхождения y в t.

\z Дан непустой список t, натуральные числа x1 и x2 (x2 > x1) и значение y того же типа, каков тип элементов в t. Записать логическое выражение, истинное тогда и только тогда, когда x1 и x2 являются индексами двух подряд вхождений y в t.

\z <<особые фамилии>>. Дано множество <<фамилий>> t. Записать множество фамилий из t, оканчивающихся на <<ов>>.

\textbf{Решение:}
\begin{lstlisting}[escapechar={@}]
t inter {z ^ @"ов"@ | z: Text}
\end{lstlisting}

\z Даны две строки t1 и t2. Записать логическое выражение, истинное тогда и только тогда, когда t2 является подстрокой строки t1.

\z Дана строка t. Записать выражение, равное реверсу строки t.

\z Дано отображение m некоторого типа в тот же тип. Запишите логическое выражение, истинное тогда и только тогда, когда это отображение является перестановкой.

\z Игровое поле игры <<крестики-нолики>> задано следующим способом:
\begin{lstlisting}
type Cell == empty | cross | toe
type Nat3 = {| n: Nat :- n isin {1..3} |}
type Field = (Nat3 >< Nat3) -m-> Cell
\end{lstlisting}
Дано f --- значение в типе Field. Записать
\begin{enumerate}
  \item логическое выражение, истинное тогда и только тогда, когда в отображении f есть информация обо всех клетках поля;
  \item выражение, равное числу пустых клеток.
\end{enumerate}

\z\label{z:correct_graph} Граф задан отображением вершин во множество инцидентных им вершин:
\begin{lstlisting}
type V, G = V -m-> V-set
\end{lstlisting}
Такое представление будет считаться <<корректным>>, если каждая вершина встречается среди первых компонент отображения (при отсутствии инцидентных вершин значение в отображении для такой вершины будет пустым множеством). Записать логическое выражение, истинное тогда и только тогда, когда данная переменная g типа G является <<корректным>> представлением графа.

\z Дано <<корректное>> представление g графа (см. задачу~\ref{z:correct_graph}) и список вершин p. Записать логическое выражение, истинное тогда и только тогда, когда p является путём в графе g.

\z Дано <<корректное>> представление g графа (см. задачу~\ref{z:correct_graph}) и его вершина v. Записать выражение, равное множеству вершин, достижимых из v через не более одну промежуточную вершину.

\textbf{Решение:}

\begin{lstlisting}
g(v) union (g#g)(v)
\end{lstlisting}

чуть более длинный вариант:
\begin{lstlisting}
g(v) union union rng (g/g(v))
\end{lstlisting}

\z Дано <<корректное>> представление g графа (см. задачу~\ref{z:correct_graph}) и его вершина v. Записать выражение, равное множеству вершин, которым инцидентна v.


\z В таксопарке есть следующая база:
\begin{lstlisting}[escapechar={@}]
type @Водитель@, @Машина@, @Водители@ = @Водитель@ -m-> @Машина@
\end{lstlisting}
Дана b --- база водителей с машинами.
\begin{enumerate}
  \item Дана машина c. Найти всех водителей машины c.
  \item Найти множество всех различных машин.
  \item У таксопарка есть доступ к базе машин:
\begin{lstlisting}[escapechar={@}]
type @Машина@, @Цвет@, @Машины@ = @Машина@ -m-> @Цвет@
\end{lstlisting}
Дана m --- база машин с их цветами. Найти водителей, которые ездят на 'красных' машинах.
\end{enumerate}


\zhead{Спецификация алгоритмов со структурами данных\footnote{Алгоритмы взяты из книги~\cite{structures_algorithms}}}

В этих задачах требуется переписать приведенные классические алгоритмы работы со структурами данных на RSL. Следите за тем, чтобы спецификация оставалась <<читабельной>>. Вам пригодится конструкция <<неявный let>>.

\z <<Алгоритм Дейкстры>>. Алгоритм предназначен для решения задачи нахождения кратчайших путей в ориентированном графе с неотрицательными пометками вершин. Длина пути --- это сумма пометок входящих в него дуг. В приведенном псевдокоде ищутся пути от вершины 1, остальные вершины графа пронумерованы числами от 2 до n, V --- это множество чисел от 1 до n. C[i,j] дает пометку дуги из i в j, или $\infty$, если такой дуги нет. Результат помещается в переменную S.

\begin{verbatim}
S := {1};
for i := 2 to n do
  D[i] := C[1,i];
for i := 1 to n-1 do
begin
  выбор из множества V\S такой вершины w,
     что значение D[w] минимально;
  добавить w к S;
  for каждая вершина v из множества V\S do
    D[v] := min(D[v], D[w]+C[w,v])
end
\end{verbatim}

% алгоритм Флойда

\z <<Алгоритм Прима>>. Алгоритм предназначен для решения задачи нахождения остовного дерева минимальной стоимости. Остовное дерево содержит все вершины исходного графа, но возможно не все его дуги. В алгоритме V --- это множество вершин (множество чисел от 1 до n). Результат формируется в дереве T.

\begin{verbatim}
T := пустое дерево;
U := {1};
while U не равно V do
begin
  (u,v) --- ребро наименьшей стоимости такое, что
    u принадлежит U и v принадлежит V\U;
  добавить в T (u,v);
  добавить в U v;
end
\end{verbatim}

% алгоритм Крускала

% алгоритм Прима

% разные остОвные подграфы

% поиск подслов


\section{Моделирование данных}

При определении типов данных используются встроенные типы и подтипы определенных ранее типов. Подтип наследует все операции своего \emph{максимального} типа (типа-<<предка>>), но множество его значений может быть уже множества значений максимального типа. Часто в виде максимальных типов задается структура данных без сложных внутренних семантических ограничений, а затем определяются подтипы этих типов, множество значений которых составляют уже только семантически корректные значения максимального типа.

Подтип может быть оформлен в разделе type следующим образом:
\begin{lstlisting}
type Nat3 = {| n : Nat :- n isin {1..3} |}
\end{lstlisting}

или с помощью аксиом:
\begin{lstlisting}
type Nat3 = Nat
axiom all n : Nat3 :- n isin {1..3}
\end{lstlisting}

Обратите внимание, что тип (или его подтип) --- не есть множество (-set).

Учтите, что модель данных не должна содержать <<реализационных решений>>, т.е. она должна отражать лишь то, что перечислено в требованиях к данным и операциям, и должно оставлять свободу для дальнейшего уточнения и принятия конструкторских решений при реализации системы в рамках спецификации.

При выборе модели следует руководствоваться следующими соображениями:
\begin{enumerate}
  \item \textbf{естественность}: модель должна выражать свойства так, как пришло бы в голову любому <<нормальному>> человеку;
  \item \textbf{удобство} описания функциональности, описания требований и последующее чтение этих требований с целью ознакомления, понимания;
  \item \textbf{отсутствие реализационных, проектных, решений}.
\end{enumerate}

\section*{Задачи}

\zhead{Промоделировать указанные данные}

\z <<Крестики-нолики>>. Промоделировать игровое поле 3х3 в игре <<крестики-нолики>>.

\textbf{Решение}

Рассуждаем о состоянии, о его частях и об отношениях этих частей (заметьте, что эти рассуждения носят не реализационный, а логический характер!). Игровое поле состоит из клеток, клетки рассматриваются как элементы строк и как элементы столбцов.

\begin{lstlisting}
type Cell == empty | cross | outh,
        Field = (Nat >< Nat) -m-> Cell
axiom all f: Field :-
   dom f = {(n1, n2)| n1 : Nat, n2: Nat :- {n1,n2} <<= {1..3}}
\end{lstlisting}

\z <<Крестики-нолики>>. Промоделировать игровое поле 3х3 в игре <<крестики-нолики>>, возможное во время игры.

\z <<Турнир по круговой схеме>>. Все участники играют одинаковое число партий (туров), встречаясь между собой по схеме <<каждый с каждым>>. По результатам каждой партии участнику начисляется определённое количество очков. Например, в шахматах традиционно начисляют 1 очко за выигрыш, 0 очков за проигрыш и 0,5 очка за ничью. Очки, набранные участниками в течение всего турнира, суммируются. Места распределяются по убыванию количества набранных очков.

\z <<Турнир по олимпийской системе (плей-офф)>>. Количество участников розыгрыша плей-офф обязательно должно быть степенью двойки (2, 4, 8, 16, 32 и так далее). Двоичный логарифм числа участников определяет число кругов розыгрыша (туров). Общее число игр на единицу меньше числа участников. Круги розыгрыша обычно называются по количеству пар участников: для 1 пары — <<финал>> (он определяет победителя), для 2 пар — <<полуфинал>>, для 4 пар — <<четвертьфинал>> и так далее. В каждом круге из участников составляются пары, играющие между собой (ничьих быть не может). Из каждой пары в следующий круг выходит победитель, а побеждённый выбывает из турнира. Участник, выигравший финальный круг, становится победителем, его последний соперник получает второе место. За третье место проводится дополнительный матч между двумя участниками, проигравшими в полуфинале.

\z <<Генеалогическое дерево>>. Каждый человек имеет не более двух родителей. Родители каждого человека имеют разный пол. Каждый человек младше каждого из своих родителей. Даты жизни родителей каждого человека пересекаются. В корне дерева стоит один человек.

\z <<Разбиения>>. Разбиение --- это непустая коллекция взаимноразличных, непустых коллекций значений типа A.
\begin{itemize}
  \item  <<Сильносвязное разбиение>> --- это множество множеств, любой элемент которого обладает не более чем одним значением, которое присутствует во всех остальных элементах;
  \item <<$n$--связное разбиение>> --- это множество множеств, любой элемент которого обладает не более чем одним значением, которое присутствует ровно в $n$ остальных элементах;
  \item <<Кольцевое разбиение>> --- это множество множеств, чьи элементы (разбиения) можно расположить в виде кольца, в котором совпадающими элементами обладают только соседние элементы разбиения.
\end{itemize}

\z <<Тезаурус>>. Это набор групп слов с похожим значением. В тезаурусе не может быть слов, которые появились бы более чем в одной коллекции.

\z <<Заказ билетов на поезд>>. Есть станции, поезда и маршруты (последовательности станций). Билеты можно заказывать как целиком на весь маршрут, так и на его часть. Все поезда, на которые можно заказывать билеты, должны быть известны системе (помещаться в структуре о поездах). Все места для заказа действительно присутствуют в поезде. Нельзя иметь два различных заказа одного и того же места в том же самом поезде для какой-либо части маршрута поезда.

\z\footnote{Задача взята из~\cite{ModellingSystems}} The system to be modelled is part of a controller for a robot that positions explosives such as dynamite and detonators in a store. The store is a rectangular building. Positions within the building are represented as coordinates with respect to one corner designated the origin. The store’s dimensions are represented as maximum x and y coordinates. Objects in the store are rectangular packages, aligned with the walls of the store. Each object has dimensions in the x and y directions. The position of an object is represented as the coordinates of its lower left corner. All objects must fit within the store and there must be no overlap between objects.

\z\footnote{Задача взята из~\cite{ModellingSystems}} Each message is a non-empty sequence of characters starting with the sequence “STR” and ending with the sequence “STP”. The total length of a message must not exceed 10000 characters.  A message is defined as high security if it contains an occurrence of the string “SECRET”. If it does not contain the string “SECRET” and it does contain the string “UNCLASSIFIED” then the message is treated as low-security. If neither string is present, then the message is classes as high-security.

\z <<Военная система>>. Подчиненные, единственный генерал, у солдат нет подчиненных. воинского подразделения. Иерархия должна удовлетворять следующим ограничениям:
\begin{itemize}
  \item военнослужащие могут иметь только следующие звания (в порядке возрастания старшинства):
    \begin{itemize}
        \item рядовой солдат (soldier);
        \item лейтенант (lieutenant);
        \item капитан (captain);
        \item майор (major);
        \item полковник (colonel);
        \item генерал (general)
    \end{itemize}
  \item у каждого военнослужащего, за исключением рядовых солдат, есть подчиненные;
  \item у каждого военнослужащего, за исключением генералов, есть командир, причем ровно один, звание которого выше звания военнослужащего;
  \item все непосредственные подчиненные одного военнослужащего имеют одинаковые звания;
  \item во главе подразделения стоит один военнослужащий -- у него нет командиров.
\end{itemize}

\z <<SMS-база>>. SMS обладает текстом и номером, кому она отправлена. Кроме того, у SMS есть идентификатор, он присваивается в момент регистрации SMS, чтобы идентифицировать SMS с одинаковым текстом и изначально его нет. Кроме того, у SMS есть статус (например, обработана/не обработана). Статус может меняться. Задача состоит в том, чтобы описать термины <<SMS>> и <<база SMS>> с учетом удобства формализации упомянутых операций.

\z <<Кэш-память>>. Кэш-память состоит из секций. Секции состоят из строк. Каждая строка кэш-памяти состоит из одних и тех же полей. Длина строки и количество строк в секции фиксированы для кэш-памяти. Среди полей есть поле <<тег>>. Для строк с одним и тем же номером в секции не должно быть одинаковых тегов. Задача состоит в том, чтобы описать кэш-память с учетом удобства поиска строки по тегу и изменения полей строки по тегу.

\z <<Код Хаффмана>>. Опишите корректную таблицу соответствия символов и их кодов, получаемых согласно алгоритму Хаффмана\footnote{определение взято из свободной энциклопедии Википедии}: на основе таблицы частот встречаемости символов в сообщении строится дерево кодирования Хаффмана (Н-дерево) следующим образом:
\begin{enumerate}
  \item Символы входного алфавита образуют список свободных узлов. Каждый лист имеет вес, который может быть равен либо вероятности, либо количеству вхождений символа в сжимаемое сообщение.
  \item Выбираются два свободных узла дерева с наименьшими весами.
  \item Создается их родитель с весом, равным их суммарному весу.
  \item Родитель добавляется в список свободных узлов, а двое его детей удаляются из этого списка.
  \item Одной дуге, выходящей из родителя, ставится в соответствие бит 1, другой — бит 0.
  \item Шаги, начиная со второго, повторяются до тех пор, пока в списке свободных узлов не останется только один свободный узел. Он и будет считаться корнем дерева.
\end{enumerate}

Чтобы определить код для каждого из символов, входящих в сообщение, мы должны пройти путь от листа дерева, соответствующего этому символу, до корня дерева, накапливая биты при перемещении по ветвям дерева. Полученная таким образом последовательность битов является кодом данного символа, записанным в обратном порядке.

\z <<Куча>> --- двоичное дерево с ключами в вершинах, в котором ключ вершины должен быть строго больше ключей ее непосредственных сыновей.

\z <<Дерево поиска>> --- двоичное дерево с ключами в вершинах, в котором ключ вершины должен быть строго больше ключей ее непосредственных сыновей левого поддерева и строго меньше ключей ее непосредственных сыновей правого поддерева.

\z <<Декартово дерево>> (Treap) --- дерево, в вершинах которого хранятся пары ключей (x, y), причем
по первым компонентам пар (<<ключам>>) дерево является деревом поиска, а по вторым компонентам пар (<<приоритетам>>) --- кучей. В русскоязычной литературе эту структуру данных также называют <<дерамидой>> (дерево + пирамида) или <<дучей>> (дерево + куча). Дерево именуется декартовым, поскольку его легко представить на декартовой плоскости, используя пары ключей как координаты вершин (абсцисса, ордината).

% еще можно набрать задач отсюда: http://informatics.mccme.ru/moodle/course/view.php?id=18

%%\z Формализуйте определения терминов, приведенных в этом тексте --- они выделены курсивом (он взят из~\cite{structures_algorithms}). \emph{Дерево} --- это совокупность элементов, называемых \emph{узлами} (один из которых определен как \emph{корень}), и отношений (<<родительских>>), образующих иерархическую структуру узлов. Узлы, так же, как и элементы списков, могут быть элементами любого типа. Мы часто будем изображать узлы буквами, строками или числами. Формально дерево можно рекуррентно определить следующим образом.
%%\begin{enumerate}
%%\item Один узел является деревом. Этот же узел также является корнем этого дерева.
%%\item Пусть $n$ --- это узел, а $T_1, T_2, ..., T_k$ --- деревья с корнями $n_1, n_2, ..., n_k$ соответственно. Можно построить новое дерево, сделав $n$ родителем узлов $n_1, n_2, ..., n_k$. В этом дереве $n$ будет корнем, а $T_1, T_2, ..., T_k$ --- \emph{поддеревьями} этого корня. Узлы $n_1, n_2, ..., n_k$ называются \emph{сыновьями} узла $n$.
%%\end{enumerate}
%%
%%Часто в это определение включают понятие \emph{нулевого дерева}, т.е. <<дерева>> без узлов.
%%

\zhead{Составление модели данных\footnote{Текст требований взят из методического пособия А.В.Чернова к практикуму по курсу <<Операционные системы>>}}

Составьте и формализуйте модель данных, достаточную для спецификации указанного набора операций. Обратите внимание, что <<за скобками>> требований к этим операциям остается та информация, которая позволяет описать функциональность этих операций, описать то, как они изменяют соответствующие данные. Ваша задача --- вычленить и должным образом оформить такие данные. Избегайте реализационных решений, помните об естественности и удобстве.

\z Операции распределения динамической памяти: malloc, realloc, free и разыменование указателя. Вот лишь ряд требований, которые должны естественно выражаться на искомой модели данных:
\begin{enumerate}
  \item malloc выделяет область памяти заданного размера и возвращает указатель на начало этой области памяти;
  \item при невозможности выделения памяти malloc возвращает специальное значение NULL;
  \item free освобождает ранее выделенный блок памяти и делает его доступным для повторного использования;
  \item переданный free указатель, должен быть получен от malloc или realloc; иначе результат работы этой функции неопределен;
  \item если блок памяти был уже освобожден, результат повторного его освобождения с помощью free не определен;
  \item после того, как блок памяти освобожден, с ним нельзя проводить никаких операций, даже разыменование;
  \item вызов free(NULL) безопасен и не приводит ни к каким действиям;
  \item free не требует указывать ей размер освобождаемой памяти, освобождается вся память, выделенная ранее с помощью malloc или realloc;
  \item realloc принимает на вход указатель на область памяти и (новый) размер;
  \item если realloc передан размер, равный нулю, то она работает как free, если передан указатель NULL, то она работает как malloc;
  \item в остальных случаях realloc выделяет в динамической памяти блок заданного размера и копирует в его начало данные по переданному ей указателю; старый блок памяти становится недоступным для операций с ним;
  \item если новый блок больше старого, оставшиеся данные не инициализируются;
  \item не гарантируется, что новый блок будет начинаться с того же адреса памяти, что и старый;
  \item если невозможно выделить новую память, realloc возвращает NULL; в этом случае память по старому адресу не изменяется и остается доступной.
\end{enumerate}

%\z Send, receive

\z Операции с файлами: open, read, write, close. Вот лишь ряд требований, которые должны естественно выражаться на искомой модели данных:
\begin{enumerate}
  \item \texttt{FILE open(name, mode)} открывает файл с именем name в режиме mode;
  \item если mode = read, то файл открывается для чтения; текущая позиция в файле устанавливается на начало файла;
  \item если mode = write, то файл открывается для записи; если файл не существовал, он создается; текущая позиция в файле устанавливается на начало;
  \item если файл открыт успешно, возвращается некая структура FILE, в противном случае константа NULL;
  \item \texttt{close(FILE)} закрывает файл; дальнейшие операции с ним невозможны;
  \item \texttt{int read(buffer, sizeofbuffer, FILE)} считывает данные из файла FILE в буфер buffer, не более sizeofbuffer байтов; возвращает количество успешно считанных байтов;
  \item \texttt{int write(buffer, sizeofbuffer, FILE)} записывает данные в файл FILE из буфера buffer, не более sizeofbuffer байтов; возвращает количество успешно записанных байтов.
\end{enumerate}

\z Операции с процессами: fork, exec, getpid, exit. Вот лишь ряд требований, которые должны естественно выражаться на искомой модели данных:
\begin{enumerate}
  \item \texttt{int fork()} создает новый процесс;
  \item созданный с помощью fork процесс отличается от создававшего только идентификатором процесса и идентификатором процесса-родителя;
  \item сыновний процесс продолжает выполнять тот же код, что и процесс-родитель;
  \item в сыновний процесс fork возвращает 0, в родительский --- идентификатор созданного потомка, если тот создался успешно, или -1, если сыновний процесс создать невозможно (нехватка ресурсов или превышение разрешенного числа процессов);
  \item \texttt{int getpid()} возвращает идентификатор текущего процесса;
  \item если при создании сыновнего процесса идентификатор достиг заданной верхней границы, счёт идентификаторов начинается с единицы;
  \item \texttt{int exec(path)} замещает тело процесса (содержимое кода, данных и стека) содержимым файла по пути path;
  \item загружаемая программа наследует идентификатор процесса;
  \item в случае ошибки exec возвращает -1;
  \item в случае успеха управление в первоначальную программу не возвращается;
  \item \texttt{exit(status)} завершает работу процесса с кодом завершения status;
  \item соглашение о взаимодействии процессов предполагает, что код завершения 0 означает успешное завершение процесса, а все прочие --- неуспешное.
\end{enumerate}


\section{Программные контракты}

Программный контракт операции состоит из ее предусловия и постусловия. Предусловие (по Майеру) --- это условие, определяющее те входные данные операции, на которых гарантируется выполнение заданного условия на входные и выходные данные операции --- её постусловие. Важно подчеркнуть, что программный контракт есть указание свойств результата операции, а не алгоритма его вычисления.

Для того, чтобы выразить на RSL предусловие некоторой операции, нужно определить подтип типа её входного аргумента. Например, в следующем примере для операции целочисленного деления указано предусловие, гарантирующее завершение вычисления этой операции:
\begin{lstlisting}
type TwoNumbers = Int >< Int
axiom all n: TwoNumbers :-
  let (n1,n2) = n in n2 ~= 0 end
value division: TwoNumbers -> Int
\end{lstlisting}

Обратите внимание, что этой функции дается \textbf{тотальное} определение, потому что для всех допустимых значений ее аргументов она должна завершаться и давать детерминированным образом результат.

При проектировании операций стоит учитывать, что не у всех их должны быть предусловия. <<Публичные>> функции, функции, которые можно вызывать из любых состояний и с любыми значениями входных параметров (и это записано в спецификации, что должна иметься возможность вызывать эту функцию при любых входных параметрах), не должны иметь предусловий. В них надо описать все случаи, когда функция должна себя вести неким определенным образом, описать условия на входные параметры, при которых возникает каждый из этих случаев, и описать результат функции во всех выделенных случаях.


\head{pre-выражения и post-выражения, explicit и implicit определения функций}

Explicit (явное) определение функции имеет вид (без указания побочного эффекта):
\begin{lstlisting}
value name : parameters -> parameters
name(parameters_names) is expression
\end{lstlisting}
 
Явное определение позволяет указать выражение для вычисления результата функции по входным данным. Оно полезно в тех случаях, когда результат описывается формулой небольшой длины от входных параметров функции.

Explicit (явное) определение функции c pre-выражением имеет вид:
\begin{lstlisting}
value name : parameters -> parameters
name(parameters_names) is expression
pre logic_expression
\end{lstlisting}

Для значений входных данных, на которых pre-выражение истинно, функция должна возвращать тот же результат, как и указанное выражение expression. Про результат работы функции при всех остальных значениях входных данных такое определение функции ничего не говорит: функция остается \emph{недоспецифицированной}. Можно написать несколько аксиом про результат работы функции при этих значениях входных данных, повторное определение функции с другим pre-выражением в RSL недопустимо.

post-выражение позволяет описать <<эффект>> вычисления некого выражения (как связаны состояние глобальных переменных до вычисления выражения, после вычисления выражения, значения переменных выражения и его значения). Синтаксис post-выражений следующий:
\begin{lstlisting}
expression [as binding] post logic_expression
\end{lstlisting}

post-выражение --- это тоже логическое выражение. Оно истинно тогда и только тогда, когда вычисление expression завершается детерминированным образом

Например:
\begin{lstlisting}
  (x := x + 1; x := x + 2) post (x = x' + 3)
\end{lstlisting}
После вычисления выражения (x := x + 1; x := x + 2) для нового значения переменной x (х) и старого значения переменной х (x') должно быть выполнено условие (x = x' + 3).

Еще пример:
\begin{lstlisting}
  (x := x + 1; x := x + 2) post (x > x')
\end{lstlisting}
Выражение слева от $\Post$ то же, что и в первом примере, но другое проверяемое условие.

post-выражение истинно, если выражение1 детерминировано завершилось и выполнено выражение2.
post-выражение может использоваться для указания области детерминированной завершимости функции: ...........

Implicit (неявное) задание функции имеет вид: .......... Оно является сокращением аксиомы ..........
Implicit (неявное) задание функции с pre-выражением имеет вид: ........ Как и для явного задания, pre-выражение ограничивает входные данные, на которых <<действует>> данное неявное задание.

Важно понимать, что \textbf{pre-выражение не задает предусловие операций}. Оно задает область, в которой нечто утверждается.

% если вызывается функция с аргументами, не попадающими в область своих типов, то как себя ведет функция ?
% -> если такое возможно в спецификации, то в ней найдена ошибка
% если вызывается функция с аргументами, не попадающими в пре-выражение, то как себя ведет функция ?
% -> как угодно, мы еще не специфицировали, как она должна себя вести на этих аргументах
%    если такое возможно в спецификации, то она неполна

\head{Советы по написанию постусловий}

RSL позволяет описывать меньший список через большой. Если f(x) меньше х, то описываем f(x) через перебор элементов х -- если f(x) больше x, то описываем x через перебор элементов f(x) (см. пример - вставка символа при повторе).

При спецификации функций, генерирующих одни множества по другим, полезно специфицировать пересечения и разницы этих множеств (как раз постоянная и меняющаяся часть).

Операторы inds, hd и tl используйте и тогда, когда не помните, с "1" или с "0" считаются индексы в списке. Плюс оператор inds дает дополнительную семантику переменной - что это индекс!

Композиция -- это способ построить выборку по двум критериям.

Не бояться использовать бесконечные сущности в спецификации.

 Применять схемы сокращения записи в случае требований выполнения/невыполнения нескольких условий одновременно.

Есть предположение, что если для структуры нужно делать поиск и добавление, то для ее моделирования лучше всего использовать отображение. Критерий поиска становится ключом, а добавляемые элементы - значениями.

Простая задачка: выстроить в каком угодно порядке элементы множества в список (каждый элемент в списке будет повторяться
  * а) любое число раз
  * б) всего 1 раз
value
    set2list: T-set -> T-list
    set2list( s ) as l
    post
    a)    elems l = s             -- недоспецификация (неизвестен порядок и количество)
    б)    elems l = s /\ len l = card s    -- тоже недоспецификация (неизвестен порядок)

\head{Советы по получению понятных спецификаций}

\begin{itemize}
    \item Выбирать <<говорящие>> имена для параметров, функций, имен переменных и типов.
    \item Строить дополнительные функции, позволяющие <<читать>> выражения, в которых они встречаются.
    \item Выбирать одну из наиболее коротких форм записи выражений.
\end{itemize}

Пример: специфицируется система <<Электронное школьное расписание>>, в ней есть операция добавления нового класса (класс --- это имя и некая дополнительная информация); надо проверить, что имя класса еще не встречалось. Неудачный вариант спецификации этой проверки:
\begin{lstlisting}
check: Class-set >< ClassName >< ClassInfo -~-> Class-set
check(cset, cn, ci) is cset union {(cn,ci)}
pre (all c: Class :- c isin cset =>  let (cn2, ci2) = c in cn ~= cn2 )
\end{lstlisting}

Тут есть две проблемы:
\begin{enumerate}
    \item нечитабельные имена;
    \item длинная запись условия в предикате.
\end{enumerate}

Улучшенная версия:
\begin{lstlisting}
check: Class-set >< ClassName >< ClassInfo -~-> Class-set
check(classes, classname, classinfo) is
    classes union {(classname,classinfo)}
pre classname ~isin names(classes),

names: Class-set -> ClassName-set
names(classes) is
    { name(class) | class : Class :- class isin classes },

name: Class -> ClassName
name((classname,_)) is classname
\end{lstlisting}

Выбраны <<говорящие>> имена для параметров и добавлены 2 новые функции, с помощью которых предусловие стало возможным <<читать>>.

Еще пример для того же <<электронного расписания>>: пусть есть тип <<База данных>>, в нем несколько согласованных частей (одна хранит классы учащихся, другая учителей, третья аудитории); специфицируется функция, вносящая изменение в одну из частей (добавление нового класса учащихся). Неудачный вариант спецификации этой функции:
\begin{lstlisting}
add_class: DB >< Class -> DB
add_class(db, class) is
   let (classes, teachers, rooms, ....... ) = db in
        (classes union {class}, teachers, rooms, .... )
   end
\end{lstlisting}

текста получается много, взгляд разбегается, не знает, за что ухватиться, самое главное не высвечено.

Удачный вариант спецификации этой функции:
\begin{lstlisting}
add_class: DB >< Class -> DB
add_class(db, class) as db2
post
    classes(db2) = classes(db) union {class} /\
    teachers(db2) = teachers(db) /\
    rooms(db2) = rooms(db) /\ ....
\end{lstlisting}

Здесь постусловие (вместо явного задания) и выбор дополнительных <<говорящих>> функций позволяет выделить важное и кратко их записать.

%
%
%\section*{Задачи}
%
%\zhead{Написать неявную спецификацию следующих функций}
% посмотреть живые примеры из http://homepages.cs.ncl.ac.uk/cliff.jones/ftp-stuff/Jones1990.pdf
% Поиск в графах и задача о минимальном потоке: http://habrahabr.ru/blogs/algorithm/61884/
%
%
%\z <<Система непересекающихся множеств (disjoint set union (DSU))>>. В этом задании надо сначала дать модель и спецификацию операций над системой непересекающихся множеств. Затем описать на RSL одну из эффективных реализаций этой структуры данных и операций. Обратите внимание на то, в каких случаях (для каких задач над программами) удобнее спецификация, нежели описание реализации.
%
%Пускай мы оперируем элементами N видов (для простоты, здесь и далее — числами от 0 до N-1). Некоторые группы чисел объединены в множества. Также мы можем добавить в структуру новый элемент, он тем самым образует множество размера 1 из самого себя. И наконец, периодически некоторые два множества нам потребуется сливать в одно. Предложите модель для такой системы непересекающихся множеств и опишите для нее функциональность следующих операций:
%\begin{itemize}
%\item MakeSet(X) --- внести в структуру новый элемент X, создать для него множество размера 1 из самого себя;
%\item Find(X) --- возвратить идентификатор множества, которому принадлежит элемент X. В качестве идентификатора мы будем выбирать один элемент из этого множества — представителя множества. Гарантируется, что для одного и того же множества представитель будет возвращаться один и тот же, иначе невозможно будет работать со структурой: не будет корректной даже проверка принадлежности двух элементов одному множеству if (Find(X) == Find(Y)).
%\item Unite(X, Y) — объединить два множества, в которых лежат элементы X и Y, в одно новое.
%\end{itemize}
%
%Теперь на RSL реализуйте систему непересекающихся множеств так, как это предложили сделать Bernard Galler и Michael Fischer в 1964 году. Хранить структуру данных предлагается в виде леса, то есть превратить DSU в систему непересекающихся деревьев. Все элементы одного множества лежат в одном соответствующем дереве, представитель дерева — его корень, слияние множеств суть просто объединение двух деревьев в одно. Как мы увидим, такая идея вкупе с двумя небольшими эвристиками ведет к поразительно высокому быстродействию получившейся структуры.
%
%Для начала потребуется массив p, хранящий для каждой вершины дерева её непосредственного предка (а для корня дерева X — его самого). С помощью одного только этого массива можно эффективно реализовать две первые операции DSU.
%
%Чтобы создать новое дерево из элемента X, достаточно указать, что он является корнем собственного дерева, и предка не имеет.
%
%\begin{lstlisting}
%public void MakeSet(int x)
%{
%    p[x] = x;
%}
%\end{lstlisting}
%
%Find(X) --- представителем дерева будем считать его корень. Тогда для нахождения этого представителя достаточно подняться вверх по родительским ссылкам до тех пор, пока не наткнемся на корень.
%
%Но это еще не все: такая наивная реализация в случае вырожденного (вытянутого в линию) дерева может работать за O(N), что недопустимо. Можно было бы попытаться ускорить поиск. Например, хранить не только непосредственного предка, а большие таблицы логарифмического подъема вверх, но это требует много памяти. Или хранить вместо ссылки на предка ссылку на собственно корень — однако тогда при слиянии деревьев (Unite) придется менять эти ссылки всем элементам одного из деревьев, а это опять-таки временные затраты порядка O(N).
%
%Вместо ускорения реализации будем просто пытаться не допускать чрезмерно длинных веток в дереве. Это первая эвристика DSU, она называется сжатие путей (path compression). Суть эвристики: после того, как представитель таки будет найден, для каждой вершины по пути от X к корню изменим предка на этого самого представителя. То есть фактически переподвесим все эти вершины вместо длинной ветви непосредственно к корню. Таким образом, реализация операции Find становится двухпроходной.
%
%На рисунке показано дерево до и после выполнения операции Find(3). Красные ребра — те, по которым мы прошлись по пути к корню. Теперь они перенаправлены. Заметьте, как после этого кардинально уменьшилась высота дерева.
%
%Исходный код операции Find в рекурсивной форме:
%
%\begin{lstlisting}
%public int Find(int x)
%{
%    if (p[x] == x) return x;
%    return p[x] = Find(p[x]);
%}
%\end{lstlisting}
%
%Unite(X, Y). Найдем для начала корни обоих сливаемых деревьев с помощью уже написанной функции Find. Теперь, помня, что наша реализация хранит только ссылки на непосредственных родителей, для слияния деревьев достаточно было бы просто подвесить один из корней (а с ним и все дерево) сыном к другому. Таким образом все элементы этого дерева автоматически станут принадлежать другому — и процедура поиска представителя будет возвращать корень нового дерева.
%
%Встает вопрос: какое дерево к какому подвешивать? Всегда выбирать какое-то одно, скажем, дерево X, не годится: легко подобрать пример, на котором после N объединений мы получим вырожденное дерево — одну ветку из N элементов. И тут в ход вступает вторая эвристика DSU, направленная на уменьшение высоты деревьев.
%
%Будем хранить помимо предков еще один массив Rank. В нем для каждого дерева будет храниться верхняя граница его высоты — то есть длиннейшей ветви в нем. Заметьте, не сама высота — в процессе выполнения Find длиннейшая ветвь может самоуничтожиться, а тратить еще итерации на нахождение новой длиннейшей ветви слишком дорого. Поэтому для каждого корня в массиве Rank будет записано число, гарантированно больше или равное высоте его дерева.
%
%Теперь легко принять решении о слиянии: чтобы не допустить слишком длинных ветвей в DSU, будем подвешивать более низкое дерево к более высокому. Если их высоты равны — не играет роли, кого подвешивать к кому. Но в последнем случае новоиспеченному корню надо не забыть увеличить Rank.
%
%\begin{lstlisting}
%public void Unite(int x, int y)
%{
%    x = Find(x);
%    y = Find(y);
%    if (rank[x] < rank[y])
%        p[x] = y;
%    else
%    {
%        p[y] = x;
%        if (rank[x] == rank[y])
%            rank[x] = rank[x] + 1;
%    }
%}
%\end{lstlisting}
%
%Однако на практике оказывается, что можно и не тратить дополнительные O(N) памяти на ранги. Достаточно выбирать корень для переподвешивания случайным образом --- как ни удивительно, но такое решение дает на практике скорость, вполне сравнимую с оригинальной ранговой реализацией.
%
%\z <<Декартово дерево>> (Treap) --- дерево, в вершинах которого хранятся пары ключей (x, y), причем
%по первым компонентам пар (<<ключам>>) дерево является деревом поиска, а по вторым компонентам пар (<<приоритетам>>) --- кучей.
%
%Реализуйте следующие операции Merge и Split над декартовыми деревьями. Операция Merge принимает на вход два декартовых дерева L и R. От нее требуется слить их в одно, тоже корректное, декартово дерево T. Следует заметить, что работать операция Merge может не с любыми парами деревьев, а только с теми, у которых все ключи одного дерева ( L ) не превышают ключей второго ( R ).
%
%На вход операции Split поступает корректное декартово дерево T и некий ключ x0. Задача операции — разделить дерево на два так, чтобы в одном из них ( L ) оказались все элементы исходного дерева с ключами, меньшими x0, а в другом ( R ) — с большими. Никаких особых ограничений на дерево не накладывается.
%
%Опишите сначала эти операции в неявном виде, не думая о том, как их реализовать (подумайте, как могла бы выглядеть алгебраическая спецификация --- оцените ее понятность и случаи, в которых она удобнее неявной спецификации). Готово? Теперь напишите такие их реализации на RSL.
%
%\begin{lstlisting}
%public static Treap Merge(Treap L, Treap R)
%{
%    if (L == null) return R;
%    if (R == null) return L;
%
%    if (L.y > R.y)
%    {
%        var newR = Merge(L.Right, R);
%        return new Treap(L.x, L.y, L.Left, newR);
%    }
%    else
%    {
%        var newL = Merge(L, R.Left);
%        return new Treap(R.x, R.y, newL, R.Right);
%    }
%}
%\end{lstlisting}
%
%\begin{lstlisting}
%public void Split(int x, out Treap L, out Treap R)
%{
%    Treap newTree = null;
%    if (this.x <= x)
%    {
%        if (Right == null)
%            R = null;
%        else
%            Right.Split(x, out newTree, out R);
%        L = new Treap(this.x, y, Left, newTree);
%    }
%    else
%    {
%        if (Left == null)
%            L = null;
%        else
%            Left.Split(x, out L, out newTree);
%        R = new Treap(this.x, y, newTree, Right);
%    }
%}
%\end{lstlisting}
%
%%%%%%%%%%%%%%%%%%%\zhead{Написать спецификацию функции без использования рекурсии}
%
%\z Вычислить максимум множества натуральных чисел
%
%\textbf{Решение:}
%\begin{lstlisting}
%type T = Nat
%value max: T-set -~-> T
%max(ns) as n
%post  n isin ns /\ (all x: T :- x isin ns => x <= n)
%pre   ns ~= {}
%\end{lstlisting}
%а теперь более короткое решение:
%\begin{lstlisting}
%value max:T-set -~-> T
%max(ns) as n
%post n isin ns /\ {0..n} >>= ns
%pre ns ~= {}
%\end{lstlisting}
%
%\z Вычислить минимум множества натуральных чисел
%%\begin{lstlisting}
%%value min:T-set -~-> T
%%min(ns) as n
%%post n isin ns /\ {0..n-1} inter ns = {}
%%pre ns ~= {}
%%\end{lstlisting}
%
%\z <<особые фамилии>>
%
%Отобрать фамилии из данного списка, заканчивающиеся на <<ов>>.
%
%%value f : Text-set -> Text-set
%%длинное решение:
%%f(x) is {y | y: Text :- y isin x /\ (exists z : Text :- y = z ^ "ов") }
%%короткое решение (применена "схема пересечения"):
%%f(x) is x inter {z ^ "ов" | z: Text}
%%
%%1. сортировка (++)
%%
%%type T = Real
%%value sort: T-list -> T-list
%%sort(x) as y
%%post
%%(all t:T :- <.tt|tt in x :- tt = t.> = <.tt|tt in y :- tt=t.>) /\
%%(all i,j : Nat :- i <= j  /\ {i,j} << inds y =>  y(i) <= y(j) )
%%
%%вариант первой строчки через отображения:
%%( exists m: T-m->T :- dom m = rng m /\ dom m = inds x /\ y(i) = m(x(i)) ) /\
%%
%%2. все подстроки (+)
%%
%%value allsubstr: Text -> Text-set
%%allsubstr(full) is
%%{ sub | sub : Text :- exists i : Nat :- i isin inds sub /\ (all k: Nat :- k < len sub => full(i+k) = sub(k+1)) }
%%запись внутреннего квантора короче:
%%{ s | s: Text :- exists i:Nat :- i < len full - len s /\  s = <.full(k)|k in <.i+1..i+1+len s.>.> }
%%или так:
%%{ s | s: Text :- exists i:Nat :- s is <.full(k)|k in <.i..i+len s.>.> }
%%более короткое решение:
%%{<.full(i)|i in <.1..len full.> :- b(i).> | b : Bool-list :- len b = len full }
%%
%%одна подстрока:
%%value substr: Text >< Text -> Bool
%%substr(sub, full) is
%%(exists i:Nat :- sub is <.full(k)|k in <.i..i+len sub.>.>)
%%
%%
%%[задача о рюкзаке]
%%
%%дано множество предметов, информация о них (вес (и стоимость)), ограничение на вес рюкзака
%%построить множество предметов из данного множества, дающих максимум стоимости
%%или: построить множество множеств предметов (распределение) так, чтобы минимизировать количество рюкзаков
%%// ничего сложного, просто много писанины
%%
%%value  rucksack: (T-set) >< (T-m-> Nat) >< Nat -> T-set-set
%%rucksack( objs, ws, w ) as rs
%%post
%%rs = {
%%
%%
%%3. объединение классов (задача взята из Software Engineering I, Dines Bjorner)  (++)
%%
%%type A, P = (A-set)-set
%%value mergeC: P >< A >< A -~-> P
%%mergeC(p1, a1, a2) as p2
%%post
%%(all s: A-set :- s isin p1 /\ s inter {a1, a2} = {} => s isin p2) /\  ////вариант: p1 inter p2 = { s | s : A-set :- s isin p1 /\ s inter {a1, a2} = {} } /\
%%card p2 = card p1 - 1 /\ (all s1, s2: A-set :- {s1, s2} <<= p1 /\ a1 isin s1 /\ a2 isin s2 => (s1 union s2) isin p2)
%%короче:
%%(exists s1, s2: A-set :- p1\p2 = {s1, s2} /\ s1 ~= s2 /\ a1 isin s1 /\ a2 isin s2 /\ p2\p1 = {s1 union s2})
%%pre
%%(exists s1,s2: A-set :- {s1,s2} <<= p1 /\ s1 ~= s2 /\ a1 isin s1 /\ a2 isin s2)
%%
%%4.  разметка текста-I (+)
%%
%%если встречается буква 'a', заменить ее на 'b'
%%
%%value replace1: Text >< Char >< Char -> Text
%%replace1(x, a, b) as y
%%post
%%len x = len y /\
%%(all i: Nat :- i isin inds x => y(i) = b /\ x(i) = a \/ y(i) = x(i) /\ x(i) ~= a)
%%
%%5. разметка текста-II
%%
%%если встречается слово "abc", заменить его на "def"
%%
%%type TextTuplet = {| tl:Text-list :- len(tl) = 2 |}
%%value
%%  replace2 : Text >< Text >< Text -> Text
%%  replace2(txt, str, res) as newtxt
%%  post
%%      if txt = "" then newtxt = ""
%%      else
%%         (exists lst : TextTuplet-list :-
%%            hd lst = <. txt, "" .> /\
%%   lst(len lst) = <."", newtxt.> /\
%%            (all i : Nat :- {i,i+1} << inds lst =>
%%if (exists t:Text :- lst(i)(1) = str ^ t)
%%then (exists t:Text :- lst(i)(1) = str ^ t /\ lst(i+1)(1) = t /\ lst(i+1)(2) = lst(i)(2) ^ res)
%%else lst(i+1)(1) = tl lst(i)(1) /\ lst(i+1)(2) = lst(i)(2) ^ <.hd lst(i)(1) .>
%%end
%%   )
%%         )
%%      end
%%
%%
%%
%%6. слияние (+)
%%
%%даны два упорядоченных списка чисел, построить упорядоченный список из объединения этих чисел
%%
%%type T = Real
%%value merge: T-list >< T-list -~-> T-list
%%merge(x,y) as z
%%post
%%(all i,j:Nat :- {i,j} <<= inds z => (i <= j => z(i) <= z(j))) /\
%%(all t: T :- <.tt|tt in x :- tt = t.> ^ <.tt|tt in y :- tt = t.>  = <.tt|tt in z :- tt = t.> )
%%pre
%%(all i,j:Nat :- {i,j} << inds x => (i <= j => x(i) <= x(j))) /\
%%(all i,j:Nat :- {i,j} << inds y => (i <= j => y(i) <= y(j)))
%%
%%7. выделение слов из текста (++)
%%
%%разделитель задается в качестве параметра
%%
%%value parse: Text >< Char -> Text-set
%%parse(t,d) is { w | w : Text :-
%%<.d.> ^ w ^ <.d.> isin allsubstr(<.d.> ^ t ^ <.d.>) /\ d ~isin elems w }
%%
%%8. факториал без рекурсии (++)
%%
%%value f: Nat -> Nat
%%f(x) as y
%%post
%%(exists n : Nat-list :- len n = x /\ hd n = 1 /\
%%(all i : Nat :- i < len n - 1 => n(i+2) = n(i+1)*(i+2)) /\ y = n(len n))
%%
%%9? количество раз, которое подстрока встречается в другой строке
%%
%%10 инъектирование (+)
%%
%%после каждого вхождения в строку заданного символа вставить другой символ
%%
%%value inject: Text >< Char >< Char -> Text
%%inject(t, c1, c2) as t2
%%post
%%if c1 ~= c2 then t = <. t2(i) | i in <.1 .. len t2.> :- ~(t2(i-1) = c1 /\ t2(i) = c2) .>  ////не работает при c1 = c2
%%else t = <. t2(i) | i in <.1 .. len t2.> :- t2(i) ~= c1 \/ (exists ll:Nat :- len <.t2(j)|j in <. i-ll+1 .. i .>.> = 1 /\ t2(i-ll) ~= c1 /\ ll \ 2 = 1 .>) end
%%
%%10и. Количество ноликов на игровом поле крестики-нолики: Cell == e|o|c, Field = (Nat3 >< Nat3) -m-> Cell
%%
%%11 представители (+)
%%
%%для каждого символа в строке оставить только первое его вхождение
%%
%%value m: Text -> Text
%%m(t) as t2
%%post
%%/////////elems t = elems t2 /\ card elems t2 = len t2 /\ сохраняется порядок первых вхождений ??????????
%%t2 = <. t(i) | i in <.1 .. len t.> :- t(i) ~isin {t(j)|j : Nat :- j isin {1..i-1}} .>
%%
%%12. Set Intersection—Returns a new array containing elements common to the two arrays, with no duplicates.
%%[ 1, 1, 3, 5 ] & [ 1, 2, 3 ] #=> [ 1, 3 ]
%%value intersection : T-list >< T-list -> T-list
%%intersection(a, b) as c
%%post elems c = elems a inter elems b /\ len c = card elems c
%%
%%13-14. Repetition—With a String argument, equivalent to self.join(str). Otherwise, returns a new array built by concatenating the int copies of self.
%%int_repetion: [ 1, 2, 3 ] * 3 #=> [ 1, 2, 3, 1, 2, 3, 1, 2, 3 ]
%%str_repetion: [ 1, 2, 3 ] * "," #=> "1,2,3"
%%value int_repetion: T-list >< Nat -> T-list
%%int_repetion( t, c ) as t2
%%post len t2 = len t * c /\ all m : Nat :- m isin inds t  => { t2[n*len t + m] | n : Nat :- n < c } = { t2[m] }
%%
%%value str: T -> Text,
%%str_repetion: T-list >< Text -> Text
%%str_repetion( t, c ) as t2
%%post  ????
%%
%%http://ruby-doc.org/core/classes/Array.html
%%
%%**** Проверить, что заданная строчка является правильным скобочным выражением.
%%value parmatch: Text -> Bool
%%parmatch(t) is elems t <<= elems "()" /\ ( t = "" \/ (exists t1, t2 : Text :- t = "("^t1^")"^t2 /\ parmatch(t1) /\ parmatch(t2)))
%%
%%
%%**) получение строкового представления числа
%%пишется именно что спецификация, а не реализация! т.е. как проверить данную строку. Плохой симптом, если постусловие пишется в стиле "ответ равен результату работы такого-то другого алгоритма". Иными словами, хотели проверить один алгоритм, а вместо этого пишем другой - и везде можем совершить ошибку. Вместо этого надо заниматься не вычислением, а определением, т.е. выделением набора характеристик и их сравнением.
%%
%%value
%%    digit : Char -m-> Int = ['0'+> 0, ...., '9' +> 9 ],
%%    itoa: Int -> Text
%%    itoa(x) as s
%%    post
%%        elems s <<= elems "-0123456789" /\ s ~= "" /\
%%        "-" ~isin tl s /\  ( x < 0  is  hd s = "-" ) /\
%%        let s1 = if x < 0 then tl s else s end, s2 = reverse(s1) in
%%            all i : Nat :- i isin inds s2 => digit(s2(i)) = (abs x \ 10**i) / 10**(i-1)
%%        end
%%
%%обратная задача: вернуть целое число из строки
%%    atoi : Text -~-> Int
%%    atoi(s) as x
%%    post
%%        ( x < 0  is  hd s = "-" ) /\
%%        let s1 = if x < 0 then tl s else s end, s2 = reverse(s1) in
%%            all i : Nat :- i isin inds s2 => digit(s2(i)) = (abs x \ 10**i) / 10**(i-1)
%%        end
%%    pre
%%        elems s <<= elems "-0123456789" /\ s ~= "" /\ "-" ~isin tl s
%%
%%=======================================================
%%
%%граф задан отображением V -m-> V-set
%%
%%задействованы операторы: \ dom rng () # /
%%не задействованы (1): !!
%%
%%12 поиск пути в графе (++)
%%
%%type G = {| g : V -m-> V-set :- all v : V :- v isin dom g => g(v) <<= dom g |}
%%type G = {| g : V -m-> V-set :- union rng g <<= dom g |} ///более короткая запись, но rsltc не поддерживает префиксный union:(
%%
%%value path : G >< V >< V -> V-list
%%path(g, v1, v2) as p
%%post
%%elems p <<= dom g /\ hd p = v1 /\ p(len p) = v2 /\
%%(all i:Nat :- i < len p - 1 => p(i+2) isin g(p(i+1)))
%%/// вариант последней строки: (all i: Nat :- {i, i+1} <<= inds p => p(i+1) isin g(p(i)))
%%
%%12a. построение гамильтонова пути (+)
%%
%%value gpath : G-> V-list
%%path(g) as p
%%post
%%elems p = dom g /\ len p = card elems p /\
%%(all i:Nat :- i < len p - 1 => p(i+2) isin g(p(i+1)))
%%
%%13. проверка, что граф является деревом (т.е. без циклов с одним корнем)
%%
%%value istree: G -> Bool
%%istree(g) is
%%// корень - это вершина, на которую никто не указывает
%%card { v | v : V :- v isin dom g =>  ~exists x: V :- x isin dom g /\ v isin g(x) } = 1 /\ ?????????? [[ без циклов ]]
%%короче:
%%card { v | v : V :- v isin dom g =>  [vs+>0|vs: V-set :- v isin vs] # g = [] } = 1 /\ ?????????? [[ без циклов ]]
%%еще короче:
%%card (dom g \ {v|v : V :- exists vs : V-set :- vs isin rng g /\ v isin vs }) = 1 /\
%%
%%~exists vs: V-list :- ( elems vs << dom g /\ len vs > 1 /\ vs(1) = vs(len vs) /\
%%all i:Nat :- i < len vs - 1 => vs(i+2) isin g(vs(i+1)) )                                                           ////переписать отсутствие цикла как-то более просто
%%//// ацикличность: недостижимость любой вершины из самой себя
%%
%%/// надо еще добавить, что граф должен быть связным! (с одной компонентой связности)
%%
%%14. ограниченная достижимость (++)
%%
%%построить множество вершин, достижимых из данной вершины с не более N промежуточными вершинами
%%value  med: G >< V >< Nat -~-> V-set
%%med(g, v, n) as vs
%%post
%%(exists r: (V-m->V-set)-list :- len r = n /\ hd r = g /\ (all i :- Nat :- i < n-1 => r(i+2) = g#r(i+1)) /\ vs =  union elems <. e(v) | e in r.>)
%%другой вариант на основе префиксного union (получилось короче?):
%%(exists r: (V-set)-list :- len r = n /\ hd r = g(v) /\ (all i: Nat :- i < n-1 => r(i+2) = union rng g/r(i+1)) /\ vs = union elems r)
%%или без композиции, но это более длинная спецификация:
%%(all a: V-set :- a isin dom g => (a isin vs = ( exists path: V-list :- elems path <<= dom g /\ len path <= n /\ hd path =  v /\ path(len path) = a /\ (all i:Nat :- {i,i+1} <<= inds path => path(i+1) isin g(path(i)) )) ))
%%
%%частный случай для n=1:
%%post  vs = g(v) union (g#g)(v)
%%или vs = g(v) union union rng (g/g(v))
%%или (переписан префиксный union) vs = g(v) union { v1| v1 : V :- v1 isin rng (g/g(v))}
%%pre v isin dom g
%%
%%15. добавление элемента в дерево поиска
%%
%%16. инвертирование дуг графа
%
%
%%%%%%%%%%%%%%%%%%%%%%%\zhead{По данной явной спецификации построить эквивалентную неявную спецификацию}
%
%\z \begin{lstlisting}
%variable lst: Int-list
%value f: Unit -> write lst Int-list
%  f() is local variable lst2:Int-list := <..> in
%    for e in lst do
%      if e ~isin elems lst2 then lst2 := lst2 ^ <.e.> end
%    end; lst2  end
%\end{lstlisting}
%
%\textbf{Решение:} Функция возвращает список первых вхождений в обратном порядке. Идея записи постусловия: для каждого элемента списка-результата:
%\begin{itemize}
%    \item все предыдущие элементы не должны встречаться перед первым его вхождением;
%    \item все последующие элементы должны встретиться перед первым его вхождением.
%\end{itemize}
%
%\begin{lstlisting}
%variable lst: Int-list
%value f: Unit -> write lst Int-list
%f() as lst2
%post lst = lst` /\
%  let lst2 = card elems lst /\ elems lst2 = elems lst /\
%  ( all i:Nat :- i isin inds lst2 =>
%    ( exists j: Nat :- j isin inds lst /\ lst(j) = lst2(i) /\
%               lst(j) ~isin { lst(k) | k:Nat :- k isin {1..j-1} } /\
%       (all p:Nat :- p isin inds lst2 /\ p < i =>
%         lst2(p) ~isin { lst(k) | k:Nat :- k isin {1..i-1} } ) /\
%       (all p:Nat :- p isin inds lst2 /\ p > i =>
%         lst2(p)  isin { lst(k) | k:Nat :- k isin {1..i-1} } ) ) )
%\end{lstlisting}
%
%\z \begin{lstlisting}
%variable lst: Int-list
%value f: Unit -> write lst Int-list
%   f() is
%    local variable lst2:Int-list := <..>, lst3: Int-list := lst in
%    for e in lst do
%        if lst3 ~= <..> then
%           lst3 := tl lst3;
%           if e ~isin elems lst3 then lst2 := lst2 ^ <.e.> end
%       end
%   end; lst2  end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f: Int-list -> Nat
%  f(lst) is local variable m:Nat := 0,
%         m2:Nat := 0, b:Bool := true in
%    for i in <.1 .. len lst.> do
%        m := 1; b := true;
%        for j in <.i+1 .. len lst.> do
%          if b /\ lst(j) >= lst(j-1)
%            then m := m + 1
%            else b := false end
%          end;
%          if m2 < m then m2 := m end
%       end; m2 end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f: Nat-list -> Nat
%  f(lst) is local variable lst2:Nat-list := lst,
%             k:Nat := 0, m:Nat := 0 in
%     for e in lst do
%        if e > k then m := m + 1; k := e end;
%    end; m end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int >< Int >< Int -> write x,y read z Int >< Int
%  f(a,b,c) is if x is 0-y then
%       (if c > b+1 then x:=y+1;0-c else x:=y;c end,
%        (if a+x < z then 0-c else x:=y+2; b*a end)-x)
%           else (y, x:=b; a+b) end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int >< Int -> write x, y, c Int >< Int >< Int
%     f (a, b) is local variable v : Int := x in
%       for i in <.a+ 1..x .> do v := v+2*(x:=i; y:=x*y; x+i)
%            end; (c*b, x:=x-v;a*b, v*v-b*c) end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int >< Int >< Int -> write x, y write z Int >< Int
%    f(a,b,c) is if b ~= 0 /\ a \ b = z then
%      (if a+b > c+b then y:=(z:=z+1;z);a else a/b end, x:=a*y;
%        (if c>y then y:=<.x+c,x-c.>(1); x else y:=x-c;0-c end)\b)
%         else ( z:=x;x, x:=a+b;z ) end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int >< Int -> write x, y, z Int >< Int >< Int
%   f (a, b) is x := 2; local variable v : Int := 1 in
%     for i in <. a..a-1 +b.> do
%      if x > 0 then v := v+1 end;
%        let u = v*v in v := i*(x:=x+u; i)*2 end
%          end; (y:= z; a, v:=v+1;x, b+v ) end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int >< Int >< Int -> write x, y, z Int >< Int
%  f(a,b,c) is if x ~= y then
%    (if a-b < c then y:=<.b*x,b*y.>(1); int real b
%     elsif a-y>c then x:=a*y; a+y
%     else x-y end,
%     (a+b)*(if x>0 then c else y:=c+1; 0-c end))
%    else (y, x:=a-b;y:=abs x+b;x) end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int >< Int -~-> write x,y,z Int >< Int >< Int
%  f (a, b) is local variable v : Int := 0*1-y in
%    for i in <.1+ a..b +2.> do if i > 3 then
%      x := card ( {x,x+1,x,x-1}\{x*x} ) end;
%      v := x + 2*(x:=v; x*i) end; (b+a, b-a, b-v) end
%pre a>= b-10
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Nat >< Nat >< Int -> write x, y read z, u Int >< Int
%   f(a,b,c) is if a+b = z+u => x + y = z+u then
%   (if a*y < a*c then y:=z+u;y else x:=y-x+1; c end,
%      y*(if x>a then x:=b+y; 0-y else y:=a+b; c end))
%      else (y+1, a-z+(x:=x+1;1)) end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f: Int >< Int >< Int -> write x,y,z Int >< Int >< Int >< Int
%      f(a,b,c) is local variable v:Int:=c in
%         y:=a; for t in <.a..b.> do
%       if abs t < 3 /\ a ~=v then y := card dom ([2+>2]#[a+>x,v+>y]) end;
%          v:= v+2*(x:=t;t)*(2+y)
%     end;
%      (a+b, x:=a-x;v, a+x, x:=a-x;a-b)
%     end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int-list -~-> Int >< Int
% f(lst) is local variable v: Int := hd lst, i: Int := 1, j: Int := 2 in
%       for e in tl lst do
%         if e > v then v := e; i := j end;
%               j := j + 1
%       end; (v, i) end
%pre lst ~= <..>
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int-list -~-> Int >< Int
% f(lst) is local variable v: Int := hd lst, i: Int := 1, j: Int := 2 in
%       for e in tl lst do
%         if e >= v then v := e; i := j end;
%               j := j + 1
%       end; (v, i) end
%pre lst ~= <..>
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int-list >< Int -~-> Int >< Int
% f(lst, x) is local variable i: Int := len lst, j: Int := len lst, s: Int := 0 in
%     while j > 0 do
%       if lst(j) = x then i := i - 1; s := j end;
%            j := j - 1
%      end; (i, s) end
% pre x isin elems lst
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int-list -~-> Int >< Int
%   f(lst) is local variable v: Int := lst(len lst), i: Int := 1, j: Int := 1 in
%       for e in <.len lst-i|i in <.1..len lst-1.>.>  do
%          if lst(e) > v then v := lst(e); i := j end;
%          j := j + 1
%       end; (v, i) end
%  pre lst ~= <..>
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int-list >< Int -~-> Int >< Int
%  f(lst, x) is local variable i: Int := 0, j: Int := len lst, s: Int := 0 in
%        while j > 0 do
%           if lst(j) = x then i := i + 1; s := j end;
%           j := j - 1
%       end; (i, s) end
%  pre x isin elems lst
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int-list -~-> Int >< Int
%  f(lst) is local variable v: Int := hd lst, i: Int := 1, j: Int := 2 in
%        for e in tl lst do
%         if e < v then v := e; i := j end;
%         j := j + 1
%      end; (v, i) end
%  pre lst ~= <..>
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int-list >< Int -~-> Int >< Int
%  f(lst, x) is local variable i: Int := len lst, j: Int := 0, s: Int := 0 in
%        for e in lst do
%          if e = x then i := i - 1; s := j end;
%          j := j + 1
%       end; (i, s) end
%  pre x isin elems lst
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int-list -~-> Int >< Int
%   f(lst) is local variable v: Int := lst(len lst), i: Int := 1, j: Int := 1 in
%    for e in <.len lst-i|i in <.1..len lst-1.>.>  do
%      if lst(e) < v then v := lst(e); i := j end;
%      j := j + 1
%   end; (v, i) end
% pre lst ~= <..>
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f : Int-list >< Int -~-> Int >< Int
%  f(lst, x) is local variable i: Int := 0, j: Int := 0, s: Int := 0 in
%       for e in lst do
%         if e = x then i := i + 1; s := j end;
%         j := j + 1
%      end; (s, i) end
%  pre x isin elems lst
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f: Int-list >< Int -> Int
%f(lst,x) is local variable i:Int := 0, j:Int := 1, k:Int := 0 in
%   for e in lst do
%      if e = x then
%         k := k+1;
%         if k = 2 then i := j end
%      end;
%      j := j + 1
%    end;
%    i
%  end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f: Int-list >< Int -> Int
%f(lst,x) is local variable i:Int := 0, j:Int := 1, k:Int := 0 in
%     for e in lst do
%         if e = x then i := k; k := j end;
%         j := j + 1
%     end;
%     i
%  end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f: Int-list >< Int -> Int
%f(lst,x) is local variable i:Int := 0, j:Int := 1, k:Int := 0 in
%     for e in <.len lst-i|i in <.0..len lst-1.>.> do
%       if lst(e) = x then
%           k := k+1;
%           if k = 2 then i := j end
%       end;
%       j := j + 1
%      end;
%      i
%end
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f: Int-list -~-> Int >< Int
%  f(lst) is local variable x:Int := len lst, y:Int := 1, m:Int := lst(x) in
%     while y ~= x do
%        local variable z: Int := 0 in
%        if x\2 = abs (len lst \ 2 - y \ 2)
%            then z := x + 1 else z := x - 1 end;
%        if lst(y) < m then m := lst(y) end;
%              x := y; y := z
%     end
%   end; (x,m)  end
%  pre lst ~= <..>
%\end{lstlisting}
%
%\z \begin{lstlisting}
%value f: Int-list -~-> Int >< Int
% f(lst) is local variable x:Int := 1, y:Int := len lst, m:Int := hd lst in
%     while y ~= x do
%         local variable z: Int := 0 in
%         if x\2 = abs (len lst \ 2 - y\2)
%          then z := x - 1 else z := x + 1 end;
%         if lst(y) > m then m := lst(y) end;
%         x := y; y := z
%     end
%   end; (x,m)  end
% pre lst ~= <..>
%\end{lstlisting}


%%%%%%%%%%%%%%%%%%\zhead{По данной алгебраической спецификации предложить модели типов и явные или неявные определения функций}
%Выделить наислабейшие предусловия для функций.
%
%% спецификация функций стандартной библиотеки Си: http://www.open-std.org/JTC1/SC22/wg14/www/docs/n1124.pdf
%
%% спецификация протоколов (формат сообщений и правила преобразования сообщений)
%
%% описание недетерминированности в детерминированных предусловиях (разное поведение, мы еще не выбрали из них окончательное)
%% --- как в играх ("крестики-нолики")
%
%










%%%\chapter{Поведенческие спецификации}
%%%TBD
%%






%%\chapter{Специфицирование систем реального размера}
%%Спецификация для функции append в <<исполнимой>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value append: L >< L -> L
%%    append(x, y) is x ^ y
%%\end{lstlisting}
%%
%%Спецификация для функции append в <<логической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value append: L >< L -> L
%%    append(x, y) as z
%%    post
%%        len z = len x + len y /\
%%        (all i: Nat :- i isin inds x => z(i) = x(i)) /\
%%        (all i: Nat :- i isin inds y => z(i+len x) = y(i))
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<исполнимой>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%    reverse(x) is
%%        local variable y : L :- y = <..> in
%%            for xi in x do
%%                y := <.xi.> ^ y
%%            end;
%%            y;
%%        end
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<логической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%  reverse(x) as y
%%  post len x = len y /\
%%    (all i: Nat :- i isin inds x => y(i) = x(len x + 1 - i))
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<алгебраической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%axiom
%%    reverse(<..>) is <..>,
%%    all x, y: L :- reverse(x^y) is reverse(y) ^ reverse(x)
%%\end{lstlisting}
%%
%%Что из этого короче? Что понятнее? Что лучше? (зависит от задачи)
%
%% задача - выбрать и правильно смоделировать самое главное в алгоритме:
%% gzip, протокол MESI, map/reduce, mp3, google chrome... (в зависимости от варианта задания--посмотреть,что интересует молодежь на Хабре) -- так, чтобы другой человек мог сам понять и получить это новое знание. В качестве примера, можно рассмотреть то, что я писал в диссертации - поймут студенты?
%% DOM:
%%http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-184E7107–???DOM Core 3
%%http://ru.wikipedia.org/wiki/Document_Object_Model-

\appendix
\include{rslprior}

\pagebreak
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{rslbooks}

\end{document}
