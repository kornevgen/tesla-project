% !Mode:: "TeX:UTF-8"
\documentclass[12pt]{extreport}
\usepackage{cmap}

\usepackage{fix-cm}
%\usepackage[cp1251]{inputenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{dsfont}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\pagestyle{plain}

\textheight 25.7cm % 29.7-2-2
\textwidth 16cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \headheight 0cm \headsep 0cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел


%
% Подправим команду \appendix : нумерация русскими буквами,
% а не латинскими.
\makeatletter
\renewcommand\appendix{\par
  \setcounter{chapter}{0}%
  \setcounter{section}{0}%
  \def\@chapapp{\appendixname}%
  \def\thechapter{\@Asbuk\c@chapter}}
\makeatother

%% Теперь "русифицируем" окружение enumerate:
%\makeatletter
%\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
%\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
%\def\labelenumii{\theenumii)}    % а не латинские буквы
%\def\p@enumii{\theenumi}         % а это для \ref
%\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
%\let\theenumiii\relax            % и отдельных ссылок на него не будет
%\def\p@enumiii{\theenumi\theenumii}
%\makeatother

\usepackage{rsl}

\usepackage{listingsutf8}
\lstloadlanguages{RSL}
\lstset{numbers=left, language=RSL, extendedchars=true}
%, inputencoding=utf8/latin1, commentstyle=\itshape, stringstyle=\bfseries}

\author{Евгений Корныхин}
\title{\huge{\textbf{\textsc{Задачи по формальной спецификации программ на RSL}}}}
\date{Москва --- 2010}

\newcommand{\head}[1]{\vspace{1cm}\subsubsection{#1}}

\begin{document}

\maketitle

\tableofcontents

\pagebreak

\section*{Введение}

Данный сборник задач написан в поддержку курса <<Формальной спецификации и верификации программ>>, который читается студентам последних курсов факультета ВМиК МГУ.

Под <<формальной>> спецификацией в первую очередь понимается строгое однозначное задание (описание) интерфейса или поведения программы. До сих пор необходимость доведения описаний до строгих однозначных форм ставится под сомнение, если речь идет о совершенно произвольных программах (как минимум, это сталкивается с высокой трудоемкостью формальной спецификации и особенной квалификацией тех, кто эту спецификацию составляет). Хотя полезность (и даже необходимость) строгого однозначного задания \emph{критичных} систем сомнений не вызывает. И тем не менее понижение трудоемкости и сближение формальных спецификаций с программистами-инженерами (т.е. существенное расширение области реального использования формальных спецификаций) является актуальной задачей в области технологий программирования (software engineering).

Однако дабы не попадать в дискуссионную область, курс следует иному принципу. Реалии таковы, что кроме написания программ необходимо, чтобы эти программы были корректными, чтобы они удовлетворяли стандартам. Для решения задач обеспечения таких характеристик применяются \emph{в том числе и} математические методы. Это означает, что программа выражается в математических терминах в виде \emph{математической теории}, или \emph{математической модели}, и задача уже решается в рамках этой математической теории с применением математического аппарата. Эта идея может показаться малоприменимой на практике, поскольку обычно математики и программисты-инженеры живут <<в разных мирах>>. На самом же деле математические методы решения задач над программами (их еще называют \emph{формальными методами}, подчеркивая, что <<обычный>> программист-инженер работает в своем <<неформальном>> мире представления о своей программе) исторически возникли практически сразу с возникновением практического программирования (это 50-е годы ХХ века) и развиваются по настоящее время.

Математическая теория, создаваемая для программы, это и есть формальная спецификация. От природы этой спецификации будут зависеть и математические методы, применяемые для решения задачи. Математическая теория не создается сама по себе --- она создается для конкретных целей, для решения определенных задач: формализация требований с целью, во-первых, их прояснения, во-вторых, для выяснения в них противоречий и неполных требований, автоматизация тестирования, чёткая документация, формальная верификация и даже разработка программ с помощью формальных моделей. Единожды проведя формализацию, можно существенно снизить <<человеческий>> фактор на последующих этапах жизненного цикла программы.

Эта часть курса посвящена тому, какие на данный момент придуманы виды моделей, какой природы математические теории используются для описания программ. Вторая часть курса (не вошедшая в этот сборник задач) посвящена одному из применений формальных спецификаций --- формальной верификации программ.

Читатели могут столкнуться с <<моделями программ>> не впервые. Студенты ВМиК МГУ слушают перед этим курсом курс по объектно-ориентированному анализу и проектированию программ и курс по верификации программ на моделях (model checking). Отличия этого курса от уже прослушанных заключаются в следующем. Курс ООАП также работает с моделями, но многие из этих моделей ориентированы только на последующее кодирование, а не на анализ программ. Грубо говоря, речь идет о моделировании структуры кода, а не семантики программы. Кроме того, строгий, формальный, подход практически никак не отражен в этом курсе. В курсе верификации на моделях рассматривается инструмент SPIN и моделирование на языке PROMELA. Остальные виды моделей программ в этом курсе не рассматриваются, но рассматриваются в данном курсе.

Согласно одной из принятых классификаций выделяют следующие основные виды моделей программ:
\begin{itemize}
  \item логико-алгебраические модели (interface specification: property-based / state-based);
  \item исполнимые модели (behavior specification);
\end{itemize}
Кроме того, выделяют модели, совмещающие в себя характеристики логико-алгебраических и исполнимых моделей.

Исполнимые спецификации дают модель в виде программы для некоторой виртуальной машины, может быть, достаточно абстрактной. В основном, это различные виды конечных автоматов и систем переходов (LTS). К таким моделям относятся модели на PROMELA, уже знакомые читателям. Кроме того, с конечными автоматами они сталкивались достаточно часто в предыдущих курсах. Поэтому в этом курсе исполнимые модели не будут рассматриваться подробно.

Логико-алгебраические модели рассматривают операции программы в математическом смысле, как отображения аргументов и пре-состояния на значения-результаты операций и пост-состояния\footnote{потому такие модели не являются исполнимыми в общем случае --- попробуйте для любой функции, заданной отображением, автоматически построить программу, которая ее исполняет!}. Чистые \emph{логические модели} представляют собой набор аксиом, из которых следуют эти отображения. \emph{Алгебраические модели} описывают эквивалентности суперпозиций операций (грубо говоря, эти модели состоят из требований эквивалентности разных цепочек действий). К неисполнимым спецификациями принадлежат и такие виды моделей как \emph{программные контракты} --- набор логических свойств, которые должны быть выполнены при корректных входных данных и вычисленных по ним выходных. Грубо говоря, для задания семантики программы в неисполнимом виде применяются два подхода: <<чистый операционный>> (функциональный) подход (property-based) и подход, основанный на моделировании состояния программы (model-based, state-based). В функциональном подходе состояние не моделируется! И тем не менее, семантику операций удается задать. Вторая глава задачника посвящена функциональному подходу. Третья глава --- подходу, основанному на моделировании состояния программы. А первая глава посвящена тому языку, на котором все эти модели можно выражать --- языку RSL. Авторы языка попытались создать язык, который был бы языком программирования и языком спецификации одновременно\footnote{На самом деле обе эти цели можно воспринимать как моделирование --- первое является исполнимым моделированием, а второе неисполнимым.}. Единый языка выражения программы и ее семантики позволяют легче провести верификацию программы на такой модели. Но вопросы верификации лежат уже за пределами данного сборника задач.

\chapter{RSL для императивного программирования}

\head{Описание сигнатуры функции на RSL:}

\begin{lstlisting}
value add: Int >< Int -> Int
\end{lstlisting}
Имеется одна функция \texttt{add} с двумя аргументами типа Int (аргументы разделяются символом $\Fn$), функция является тотальной (стрелка ->). Функция вычисляет одно значение и это значение типа Int (несколько значений так же разделяются символом $\times$). Функция не имеет побочного эффекта.

\head{Описание функции целиком:}
\begin{lstlisting}
value add: Int >< Int -> Int
add(x,y) is x+y
\end{lstlisting}
После сигнатуры идет тело функции. Вначале идет имя функции с формальными параметрами, затем символ $\Is$ и затем выражение. Вычислением функции является вычисление этого выражения (в данном случае, сложение двух чисел-аргументов).

\head{Встроенные типы}
Int, Nat (целые неотрицательные числа), Real, Bool, Char, Text (список Char'в), Unit (аналог \textit{void}).

\head{Операции над встроенными типами:} ........................................

\head{Выражения} -- ............... (последовательность, if, while )

\head{Побочный эффект в функции} -- ...........

\head{Тотальная функция}
Это функция, для которой выполнены все 3 свойства:
\begin{enumerate}
  \item она детерминирована (если функция вызывается в разное время с теми же аргументами и в том же состоянии глобальных переменных, то она возвращает одинаковые значения и одинаковым образом изменяет глобальные переменные);
  \item она всюду определена (функция возвращает какое-либо значение на каждом значении аргументов и глобальных переменных, согласно их типам);
  \item она завершима (т.е. не зацикливается ни при каком значении аргументов и глобальных переменных)
\end{enumerate}
Функция является \emph{нетотальной}, если для нее \textbf{неизвестно}, выполнены ли свойства тотальной функции\footnote{Позже мы будем говорить более точно о том, что для нетотальных функций выполнение этих трех свойств \emph{не специфицировано}. Но может быть специфицировано позднее.}. В сигнатуре нетотальной функции вместо стрелки $\Fn$ ставится стрелка $\NonDetermFn$.

Пример тотальной функции:
\begin{lstlisting}
value add: Int >< Int -> Int
add(x,y) is x+y
\end{lstlisting}

Пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
\end{lstlisting}
Эта функция не определена при y = 0.

Пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
\end{lstlisting}
Эта функция не определена при y = 0.

Еще один пример нетотальной функции:
\begin{lstlisting}
value some: Int -~-> Int
some(x) is
    local variable n:Int := x in
        while n ~= 1 do
            if n \% 2 = 0 then n := n/2 else n := 3*n+1 end
        end;
        n
    end
\end{lstlisting}
Про эту функцию именно что неизвестно, завершима ли она при любом целом значении аргумента.

И еще один пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x+y
\end{lstlisting}
Ничего не мешает объявить эту функцию как тотальную, но допустимо ее определение и как нетотальной (например, по причине того, что на момент написания функции неизвестно, должны ли для нее быть выполнены 3 свойства тотальной функции).

Для нетотальной функции может быть указано \emph{предусловие}\footnote{Именно <<может быть>>, но не обязательно, как считают авторы некоторых пособий по RSL в противоречие с авторами самого RSL.}. Оно задает ту область значений аргументов и глобальных переменных, на которых определяется функция. Вне этой области функция по определению считается незаданной (поэтому любая функция с нетождественным \texttt{true} предусловием будет нетотальной). Пример функции с предусловием:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
pre x > 2 /\ y > 4
\end{lstlisting}


\head{Массивы} -- ..........

\head{Структуры} ---

\section*{Задачи}


\chapter{Логико-алгебраические спецификации}

\section{Простейшая формальная спецификация на RSL}

Цель формальной спецификации информационной системы --- дать однозначное машинноинтерпретируемое описание системы. Оно включает в себя описание функций системы, функциональных требований, понятий и терминов.

Рассмотрим простейшую формальную спецификацию системы, которая складывает два числа.

\begin{lstlisting}
- - a first formal specification
scheme Addition = class
        value add: Int >< Int -> Int
end
\end{lstlisting}

Формальная спецификация на языке RSL представляет собой текст. Спецификация начинается с комментария <<a first formal specification>>. Комментарий однострочный, действует до ближайшего переноса строки. На второй строчке идет заголовок спецификации. Главным здесь является фиксация имени спецификации (Addition). Всё, что расположено между заголовком и соответствующим ему завершающим $\End$, есть тело спецификации. Оно содержит в себе описание понятий и операций информационной системы. В данном случае строчка 3 говорит, что речь идет об операции (ключевое слово $\Value$), что имя этой операции --- add, что у операции 2 входных параметра (они разделены знаком ><), их типы $\Int$ (что означает целочисленный тип), один параметр-результат, его тип тоже $\Int$ и что функция является \emph{тотальной} (значок ->). Тотальными являются функции, которые никогда не зацикливаются, являются детерминированными и <<в них не возникают исключительные ситуации>>. Более точно, это такие функции, которые одновременно
\begin{enumerate}
\item ни при одном значении входных параметров не зацикливаются;
\item вызовы при одних и тех же значениях входных параметров дают одни и те же значения выходных параметров;
\item при каждом значении входных параметров должны возвращать некое определенное значение.
\end{enumerate}

Далее, строчка 3 будет называться \emph{сигнатурой} функции по аналогии с сигнатурами функций в программах.

Итак, в этой спецификации говорится о системах (не о конкретной системе, а о целом \textbf{классе} систем --- ключевое слово $\Class$), которые обладают операцией с двумя целосленными входными параметрами и одним выходным, также целочисленным. Причем эта функция является тотальной. Сказано про функцию уже немало. Однако ее семантика (<<что эта функция делает>>) еще не задана. Скажем, к системе было предъявлено функциональное требование, что <<она должна давать возможность складывать>>. При формализации этого требования надо уточнить, а что, собственно, надо складывать? Яблоки в ящики, элементы конструктора лего или может быть складывать стихи? За одной фразой на естественном языке может скрываться не один смысл, а при формализации надо уметь вычленять такие случаи \emph{неоднозначности} и \emph{недоопределенности} и выяснять требования более точно. Скажем, от заказчика системы, <<которая должна давать возможность складывать>>, удалось узнать, что складывать надо целые числа, что и было отражено в определении функции.

Описанная такой спецификацией система может иметь самый различный вид. Например, это может быть веб-сайт с двумя полями и появляющейся подписью, это может быть консольная утилита. Все такие системы обладают общностью: к ним всем было предъявлено функциональное требование о том, что, грубо говоря, <<они должны давать возможность складывать>>.

Зададим теперь требование, что функция должна давать результат такой же, как и сложение двух чисел -- её параметров:

\begin{lstlisting}
- - a first formal specification
scheme Addition = class
        value add: Int >< Int -> Int
        axiom all x: Int, y: Int :- add(x,y) is x + y
end
\end{lstlisting}

В тело спецификации добавилась \emph{аксиома}. Она начинается с ключевого слова $\Axiom$. Затем идет \emph{выражение} булевского типа. Его запись в RSL максимально приближена к тому, как в математике записываются предикаты. Выражение состоит из двух частей, разделенных символом $\SuchAs$ (его можно читать как <<такой что>>, но понимать, что это лишь <<синтаксический сахар>>). Слева от этого символа идет кванторная приставка: для любых значений переменных x и y типа $\Int$ должно быть справедливо это выражение. Справа от символа $\SuchAs$ записано, что <<вызвать функцию add(x,y) --- это тоже самое, что воспользоваться предопределенным в RSL сложением целых чисел>>. Заметьте, что функции не запрещается \emph{иметь другой код}, отличный от простого сложения своих аргументов, но функции запрещается \emph{вычислять другую функцию}.

Если бы функция согласно функциональным требованиям должна была умножать числа, формальная спецификация будет следующей:
\begin{lstlisting}
- - a first formal specification
scheme Addition = class
        value add: Int >< Int -> Int
        axiom all x: Int, y: Int :- add(x,y) is x * y
end
\end{lstlisting}

Пусть теперь система должна выполнять две операции --- и обе с целыми числами. Первая операция \emph{должна быть равнозначна сложению} (обратите внимание на строение этого предложения, как в нем формулируется функциональное требование), вторая операция --- умножению. Тогда такая система (вернее, класс систем, в каждой из которых есть две операции, которые .... и т.д. по требованиям) описывается следующей формальной спецификацией:
\begin{lstlisting}
scheme AddMul = class
        value add: Int >< Int -> Int
        axiom all x: Int, y: Int :- add(x,y) is x + y

        value mul: Int >< Int -> Int
        axiom all x: Int, y: Int :- mul(x,y) is x * y
end
\end{lstlisting}

или так

\begin{lstlisting}
scheme AddMul = class
        value add: Int >< Int -> Int
        value mul: Int >< Int -> Int
        axiom all x: Int, y: Int :- add(x,y) is x + y
        axiom all x: Int, y: Int :- mul(x,y) is x * y
end
\end{lstlisting}

Для сокращения подряд идущие сигнатуры функций и аксиомы можно объединять так (обратите внимание на появившиеся запятые):
\begin{lstlisting}
scheme AddMul = class
        value
            add: Int >< Int -> Int ,
            mul: Int >< Int -> Int
        axiom
            all x: Int, y: Int :- add(x,y) is x + y ,
            all x: Int, y: Int :- mul(x,y) is x * y
end
\end{lstlisting}

Тем самым тело спецификации можно разделить на \emph{разделы}: раздел функций --- $\Value$, раздел аксиом --- $\Axiom$.

Повторяющиеся имена переменных в аксиомах тоже можно сократить с использованием $\Forall$:
\begin{lstlisting}
scheme AddMul = class
        value
            add: Int >< Int -> Int ,
            mul: Int >< Int -> Int
        axiom forall x: Int, y: Int :-
            add(x,y) is x + y ,
            mul(x,y) is x * y
end
\end{lstlisting}

Пусть теперь мы не знаем (или не хотим фиксировать), какое выражение вычисляет функция, но хотим зафиксировать, например, что число-результат операции add больше первого входного параметра, если второй параметр неотрицательный. Спецификация таких свойств будет выглядеть так:

\begin{lstlisting}
scheme Addition = class
  value add: Int >< Int -> Int
  axiom all x: Int, y: Int :- add(x,y) > x   pre y >= 0
end
\end{lstlisting}

Теперь аксиома состоит не из двух, а из \textbf{трех} частей. Первая часть осталась прежней --- <<для любых x и y типа $\Int$>>. Вторая часть --- <<add(x,y) > x>> фиксирует свойство, что результат работы функции add больше значения первого аргумента. Третья часть --- \textbf{pre} y $\geq$ 0 --- называется \emph{предусловием аксиомы}. Предусловие \emph{ограничивает область действия} выражения. После ключевого слова \textbf{pre} идет булевское выражение от переменных из первой части аксиомы. Данное предусловие заявляет, что говорить о том, что <<add(x,y) > x>> следует лишь тогда, когда y $\geq$ 0.

Ещё больше обобщим требования к операции add. Потребуем лишь, чтобы ее аргументы были одного \emph{типа} (тип понимается точно так же, как в языках программирования):
\begin{lstlisting}
scheme Addition = class
  type T
  value add: T >< T -> T
end
\end{lstlisting}

В спецификации появился раздел --- \emph{раздел типов} $\Type$ (и это еще не все разделы, которые есть в RSL). В нем говорится, что спецификация имеет дело с неким типом, которому мы лишь дали имя T. Даже сказав так мало про тип, можно говорить о \emph{значениях} в этом типе. При написании спецификации эти значения не известны, но в тексте программы тип T будет вполне конкретный и в нем будут вполне конкретные значения. Определение типа, в котором дается только его имя, называется \emph{sort}-определением.

В этой, казалось бы, крайне простой и небольшой спецификации тем не менее заданы несколько важных свойств об операции add:
\begin{enumerate}
  \item операция имеет 2 входных параметра и один выходной;
  \item типы входных параметров совпадают с типом выходного параметра;
  \item при всех значениях в типе T функция не должна зацикливаться, какие бы эти значения не были поданы ни в первый, ни во второй аргумент;
  \item при всех значениях в типе T функция реализует некий алгоритм, дающий и дающий однозначное значение для возвращаемого параметра.
\end{enumerate}

Однако определить аксиому про увеличение add относительного x нельзя --- сравнить <<на больше-меньше>> два значения в sort-типе нельзя (а вдруг в этом типе и вовсе несравнимые значения хранятся!). Поэтому придется потребовать дополнительные свойства относительно значений в типе T :
\begin{lstlisting}
scheme Addition = class
  type T
  value gr : T >< T -> Bool,
        add: T >< T -> T
  axiom all x:T, y:T :- gr( add(x,y), x )
end
\end{lstlisting}

В спецификацию добавлена тотальная функция gr с двумя входными параметрами и одним выходным параметром. Типы входных параметров --- T, тип выходного параметра --- $\Bool$ --- предопределенный тип в RSL для булевских значений и операций над ними.

Но в этой спецификации не хватает предусловия! Спецификация в том виде, в каком она есть сейчас, запрещает быть gr и add операциям сравнения на больше и сложения, поскольку аксиома не будет выполнена: найдутся такие значения x и y в типе T, для которых будет выполнено $\Not$gr( add(x,y), x ) (x = 0, y = -1). Операция $\Not$ --- это предопределенное в языке RSL \emph{булевское отрицание}. Кроме этого есть и булевская конъюнкция ($\And$), булевская дизъюнкция ($\Or$) и булевская импликация ($\Impl$).

Чтобы добавить предусловие, надо снова воспользоваться gr. Но раньше была константа 0, а теперь в sort-типе ни одной константы нет. В таком случае надо в спецификации записать, что в типе есть константа (назовем ее nul), для определения константы используется опять же раздел $\Value$:
\begin{lstlisting}
scheme Addition = class
  type T
  value nul: T,
        gr : T >< T -> Bool,
        add: T >< T -> T
  axiom all x:T, y:T :- gr( add(x,y), x ) pre gr(y, nul)
end
\end{lstlisting}

\subsection*{Систематизация нового знания}
Суммируем вышесказанное. Спецификация состоит из тела, обрамляемого заголовком ($\Scheme$ имя-спецификации = $\Class$) и ключевым словом $\End$. Тело состоит из разделов --- типов, функций и констант, аксиом. Разделов одного вида может быть несколько. Вложения одних разделов в другие невозможны. Есть предопределенные типы в RSL ($\Int$, $\Bool$) и можно объявлять свои типы. Функция представляет отдельную операцию специфицируемой системы. Спецификация функции начинается с её имени, затем идет двоеточие, затем типы входных параметров через знак ><, затем идет стрелка, затем тип выходного параметра. Функция со стрелкой -> называется тотальной. Это означает, что она должна быть всюду завершимой, определённой и детерминированной. Раздел аксиом описывает функциональные требования операций. Такие требования представляются в виде замкнутых булевских выражений, возможно с предусловиями.

Для типа $\Int$ предопределены операции сложения (x+y), вычитания (x-y), умножения (x*y), нахождение частного от деления (x/y), нахождение остатка от деления (x$\Minus$y), возведение в целочисленную степень (x**y), модуль числа ($\Abs$ x). Тип содержит все возможные целые числа, которые только могут существовать. Операции выполняются всегда точно (т.е. сложение, умножение понимаются не так, как в языках программирования --- с переполнениями и прочими особенностями, а как в математике). Операции деления \emph{не являются тотальными}, поскольку не определены при делителе, равным нулю. Пример выражения над целыми числами: x + y**z/x --- согласно приоритету операций (см. приложение~\ref{sec:priority}) это означает математическое выражение $x + \frac{y^z}{x}$.


\subsection*{Задачи\footnote{Большинство задач взяты из книги Н.Н.Непейводы <<Практическая логика>>}}

Формализовать требования и утверждения на RSL.

\textbf{Пример решения задачи}

<<Ни одному лысому не нужна расческа>>

\begin{lstlisting}
scheme Exmp = class
  type Lys, R4
  value need: Lys >< R4 -> Bool
  axiom all l:Lys, r:R4 :- ~need(l,r)
end
\end{lstlisting}

\begin{enumerate}
  \item Все мои тетки не справедливы.
\item  Ни один кошмарный сон не приятен.
\item  Все битвы сопровождаются страшным шумом.
\item Не все двоечники ленивы.
\item  Каждый, кто упорно работает, добивается успеха.
\item  Ни один бездельник не станет знаменитостью.
\item  Некоторые художники не бездельники.
\item  Некоторые бездельники не художники.
\item  Некоторые подушки мягкие.
\item  Тот, кто может укрощать крокодилов, заслуживает уважения.
\item  Ни одна лягушка не имеет поэтической внешности.
\item  Ни одна тачка не комфортабельна.
\item  Всякий орел умеет летать.
\item  Некоторые свиньи не умеют летать.
\item  Некоторые свиньи --- не орлы.
\item  Ни один судья не справедлив.
\item  Ни один ребенок не любит прилежно заниматься.
\item  Все шутки для того и предназначены, чтобы смешить людей.
\item  Ни один парламентский акт не шутка.
\item  Пауки ткут паутину.
\item  Все лекарства имеют отвратительный вкус.
\item  Ни у одной ящерицы нет волос.
\item  Все свиньи прожорливы.
\item  Все, что сделано из золота, драгоценно.
\item  Некоторые секретари --- птицы.
\item  Все секретари заняты полезным делом.
\item  Ничто разумное не ставит меня в тупик.
\item  Логика часто ставит меня в тупик.
\item  Некоторые цыплята --- не кошки.
\item Точки A, B, C являются вершинами равнобедренного треугольника.
\item Иванов, Петров, Васильев и Сидоров могут вытащить эту машину из ямы, если они трезвы и видят бутылку.
\item Иванов, Петров, Васильев и Сидоров не могут решать квадратные уравнения, даже если они трезвы, но видят бутылку.
\item Не все углы, синус которых больше 1/2, больше $\pi$/6.
\item Квадратные корни из некоторых рациональных чисел иррациональны.
\item Синус и косинус равны друг другу тогда и только тогда, когда равны тангенс и котангенс.
\item  Когда кто-то поет больше часа, он надоедает.
\item Все девочки боятся лягушек и мышей.
\item Кошки бывают только белые и серые.
\item  Все ораторы либо честолюбивы, либо скучны.
\item Число делится на 25 в том и только том случае, когда оно делится на 50 либо дает при делении на 50 остаток 25.
\item Все комплексные числа действительны или становятся действительными после умножения на i.
\item Не все студенты отличники или спортсмены.
\item Для того чтобы выполнялось равенство $x = \sqrt{x^2}$, необходимо и достаточно, чтобы $x$ было положительным действительным числом.
\item Не все, что рассказывал барон К. Ф. И. фон Мюнхгаузен, ложь.
\item Некоторые людоеды — плохие люди.
\item Некоторые финансисты — мошенники, но не все.
\item Прапорщики любят порядок, и не только они.
\item Милиционеры замешаны в преступлениях, но не все.
\item Некоторые замки не отпираются, но запираются.
\item Если будешь хорошо учиться, поступишь в вуз, а иначе
провалишься.
\item Ничего не вижу, ничего не слышу, ничего не знаю.
\item Молодо—зелено.
\item Взялся за гуж --- не говори, что не дюж.
\item Чтобы не быть собакой, достаточно быть кошкой.
\item Чтобы не быть человеком, необходимо быть свиньей.
\item Некоторые кошки поют по ночам.
\item Все компакты совершенно нормальны.
\item Некоторые мюмзики не куздры.
\item Три точки A, B, C лежат на одной окружности.
\item Три точки A, B, C не лежат на одной прямой.
\item Числа a и b имеют одинаковый знак.
\item Одно из чисел a, b равно 0.
\item Числа a и b имеют разные знаки.
\item Ромео и Джульетта любят друг друга.
\item Гамлет и Клавдий ненавидят друг друга.
\item Мери любила Печорина, но не взаимно.
\item Чтобы прийти на свадьбу, необходимо приглашение жениха или невесты.
\item Некоторые лентяи не оптимисты, но жизнелюбы.
\item Все замки отпираются и запираются.
\item Никто из нашего класса не поехал в Москву и Париж.
\item Все мои одноклассники поехали в Москву и Париж.
\item Некоторые числа четные.
\item Некоторые лекции невозможно понять.
\item Всякому в Москве не перекланяешься.
\end{enumerate}

Более сложные задачи:
\begin{enumerate}
\item Весна, и вы говорите: «Все парни и девушки сейчас влюблены друг в друга». Что это означает?
\item Когда Ясон кинул в середину войска, выросшего из зубов дракона, камень, все воины передрались и перебили друг друга.
Переведите это утверждение на формальный язык.
\item Ограниченная сверху и снизу на [a, b] функция непрерывна на нем.
\item Функция $f$ имеет разрыв 2-го рода в точке 0.
\item Функция, имеющая точку разрыва, не может быть непрерывной.
\item Монотонная на [a, b] функция ограничена снизу на [a, b].
\item Если последовательность ограничена, то она имеет предельную точку.
\item Чтобы установить рекорд, необходимо иметь способности, и прилежно тренироваться, и найти хорошего тренера.
\item Чтобы победить, нам необходимы и хорошие нападающие, и хорошие защитники, и хорошие вратари.
\item Если вчера Петров прогулял два занятия, то сегодня только одно.
\item Все члены Политбюро, избранного на XIV съезде ВКП(б), ненавидели друг друга.
\item Все философы критиковали друг друга.
\item Все рыцари сражались друг с другом на поединках.
\item Все начальники подсиживают друг друга.
\item Все мужчины --- подонки, а мой муж --- хороший человек.
\item Сдай экзамен на <<отлично>>, и поступишь в аспирантуру.
\end{enumerate}

\chapter{Моделе-ориентированные спецификации}

%\chapter{Поведенческие спецификации}
%TBD

\appendix
\include{rslprior}

\end{document}
