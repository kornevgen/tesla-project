% !Mode:: "TeX:UTF-8"
\documentclass[14pt, twoside]{extreport}
\usepackage{cmap}

\usepackage{fix-cm}
%\usepackage[cp1251]{inputenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{dsfont}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\usepackage{clrscode}

\pagestyle{headings}

\textheight 23cm % 29.7-2-2
\textwidth 16cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \evensidemargin 0cm  \headheight 0cm \headsep 1.5cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел


%
% Подправим команду \appendix : нумерация русскими буквами,
% а не латинскими.
\makeatletter
\renewcommand\appendix{\par
  \setcounter{chapter}{0}%
  \setcounter{section}{0}%
  \def\@chapapp{\appendixname}%
  \def\thechapter{\@Asbuk\c@chapter}}
\makeatother

%% Теперь "русифицируем" окружение enumerate:
%\makeatletter
%\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
%\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
%\def\labelenumii{\theenumii)}    % а не латинские буквы
%\def\p@enumii{\theenumi}         % а это для \ref
%\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
%\let\theenumiii\relax            % и отдельных ссылок на него не будет
%\def\p@enumiii{\theenumi\theenumii}
%\makeatother

\usepackage{rsl}

\usepackage{listingsutf8}
\lstloadlanguages{RSL}
\lstset{numbers=left, language=RSL, extendedchars=true, numberstyle=\tiny}
%, inputencoding=utf8/latin1, commentstyle=\itshape, stringstyle=\bfseries}

\author{Евгений Корныхин}
\title{\huge{\textbf{\textsc{Задачи по формальной спецификации программ на RSL}}}}
\date{Москва --- 2010}

\newcounter{problem_type}[chapter]
\newcounter{zadacha}[problem_type]
\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
\textit{\arabic{chapter}.\arabic{problem_type}.\arabic{zadacha}}~~  }

\newcommand{\head}[1]{\vspace{1cm}\subsubsection*{#1}}
\newcommand{\zhead}[1]{\head{#1} \refstepcounter{problem_type}}


\begin{document}

\maketitle

\tableofcontents

\pagebreak

\section*{Введение}

Данный сборник задач написан в поддержку курса <<Формальной спецификации и верификации программ>>, который читается студентам последних курсов факультета ВМиК МГУ.

Под <<формальной>> спецификацией в первую очередь понимается строгое однозначное задание (описание) интерфейса или поведения программы. До сих пор необходимость доведения описаний до строгих однозначных форм ставится под сомнение, если речь идет о совершенно произвольных программах (как минимум, это сталкивается с высокой трудоемкостью формальной спецификации и особенной квалификацией тех, кто эту спецификацию составляет). Хотя полезность (и даже необходимость) строгого однозначного задания \emph{критичных} систем сомнений не вызывает. И тем не менее понижение трудоемкости и сближение формальных спецификаций с программистами-инженерами (т.е. существенное расширение области реального использования формальных спецификаций) является актуальной задачей в области технологий программирования (software engineering).

Однако дабы не попадать в дискуссионную область, курс следует иному принципу. Реалии таковы, что кроме написания программ необходимо, чтобы эти программы были корректными, чтобы они удовлетворяли стандартам. Для решения задач обеспечения таких характеристик применяются \emph{в том числе и} математические методы. Это означает, что программа выражается в математических терминах в виде \emph{математической теории}, или \emph{математической модели}, и задача уже решается в рамках этой математической теории с применением математического аппарата. Эта идея может показаться малоприменимой на практике, поскольку обычно математики и программисты-инженеры живут <<в разных мирах>>. На самом же деле математические методы решения задач над программами (их еще называют \emph{формальными методами}, подчеркивая, что <<обычный>> программист-инженер работает в своем <<неформальном>> мире представления о своей программе) исторически возникли практически сразу с возникновением практического программирования (это 50-е годы ХХ века) и развиваются по настоящее время.

Математическая теория, создаваемая для программы, это и есть формальная спецификация. От природы этой спецификации будут зависеть и математические методы, применяемые для решения задачи. Математическая теория не создается сама по себе --- она создается для конкретных целей, для решения определенных задач: формализация требований с целью, во-первых, их прояснения, во-вторых, для выяснения в них противоречий и неполных требований, автоматизация тестирования, чёткая документация, формальная верификация и даже разработка программ с помощью формальных моделей. Единожды проведя формализацию, можно существенно снизить <<человеческий>> фактор на последующих этапах жизненного цикла программы.

Эта часть курса посвящена тому, какие на данный момент придуманы виды моделей, какой природы математические теории используются для описания программ. Вторая часть курса (не вошедшая в этот сборник задач) посвящена одному из применений формальных спецификаций --- формальной верификации программ.

Читатели могут столкнуться с <<моделями программ>> не впервые. Студенты ВМиК МГУ слушают перед этим курсом курс по объектно-ориентированному анализу и проектированию программ и курс по верификации программ на моделях (model checking). Отличия этого курса от уже прослушанных заключаются в следующем. Курс ООАП также работает с моделями, но многие из этих моделей ориентированы только на последующее кодирование, а не на анализ программ. Грубо говоря, речь идет о моделировании структуры кода, а не семантики программы. Кроме того, строгий, формальный, подход практически никак не отражен в этом курсе. В курсе верификации на моделях рассматривается инструмент SPIN и моделирование на языке PROMELA. Остальные виды моделей программ в этом курсе не рассматриваются, но рассматриваются в данном курсе.

Согласно одной из принятых классификаций выделяют следующие основные виды моделей программ:
\begin{itemize}
  \item логико-алгебраические модели (interface specification: property-based / state-based);
  \item исполнимые модели (behavior specification);
\end{itemize}
Кроме того, выделяют модели, совмещающие в себя характеристики логико-алгебраических и исполнимых моделей.

Исполнимые спецификации дают модель в виде программы для некоторой виртуальной машины, может быть, достаточно абстрактной. В основном, это различные виды конечных автоматов и систем переходов (LTS). К таким моделям относятся модели на PROMELA, уже знакомые читателям. Кроме того, с конечными автоматами они сталкивались достаточно часто в предыдущих курсах. Поэтому в этом курсе исполнимые модели не будут рассматриваться подробно.

Логико-алгебраические модели рассматривают операции программы в математическом смысле, как отображения аргументов и пре-состояния на значения-результаты операций и пост-состояния\footnote{потому такие модели не являются исполнимыми в общем случае --- попробуйте для любой функции, заданной отображением, автоматически построить программу, которая ее исполняет!}. Чистые \emph{логические модели} представляют собой набор аксиом, из которых следуют эти отображения. \emph{Алгебраические модели} описывают эквивалентности суперпозиций операций (грубо говоря, эти модели состоят из требований эквивалентности разных цепочек действий). К неисполнимым спецификациями принадлежат и такие виды моделей как \emph{программные контракты} --- набор логических свойств, которые должны быть выполнены при корректных входных данных и вычисленных по ним выходных. Грубо говоря, для задания семантики программы в неисполнимом виде применяются два подхода: <<чистый операционный>> (функциональный) подход (property-based) и подход, основанный на моделировании состояния программы (model-based, state-based). В функциональном подходе состояние не моделируется! И тем не менее, семантику операций удается задать. Вторая глава задачника посвящена функциональному подходу. Третья глава --- подходу, основанному на моделировании состояния программы. А первая глава посвящена тому языку, на котором все эти модели можно выражать --- языку RSL. Авторы языка попытались создать язык, который был бы языком программирования и языком спецификации одновременно\footnote{На самом деле обе эти цели можно воспринимать как моделирование --- первое является исполнимым моделированием, а второе неисполнимым.}. Единый языка выражения программы и ее семантики позволяют легче провести верификацию программы на такой модели. Но вопросы верификации лежат уже за пределами данного сборника задач.

\chapter{RSL для императивного программирования}

\head{Описание сигнатуры функции на RSL:}

\begin{lstlisting}
value add: Int >< Int -> Int
\end{lstlisting}
Имеется одна функция \texttt{add} с двумя аргументами типа Int (аргументы разделяются символом $\Fn$), функция является тотальной (стрелка ->). Функция вычисляет одно значение и это значение типа Int (несколько значений так же разделяются символом $\times$). Функция не имеет побочного эффекта.

\head{Описание функции целиком:}
\begin{lstlisting}
value add: Int >< Int -> Int
add(x,y) is x+y
\end{lstlisting}
После сигнатуры идет тело функции. Вначале идет имя функции с формальными параметрами, затем символ $\Is$ и затем выражение. Вычислением функции является вычисление этого выражения (в данном случае, сложение двух чисел-аргументов).

\head{Встроенные типы}
\textbf{Int}, \textbf{Nat}, \textbf{Real}, \textbf{Bool}, \textbf{Char}, \textbf{Text}, \textbf{Unit}.

Тип \textbf{Int} содержит в себе все возможные целые числа. Ограничений на их значения (типа MAXINT) нет.

Тип \textbf{Nat} содержит число 0 и все возможные положительные целые числа. Ограничений сверху на их значения нет. Тип поддерживает все операции, определенные для типа \textbf{Int}.

Тип \textbf{Real} содержит в себе все возможные вещественные числа. Важно понимать, что эти числа являются математической абстракцией тех вещественных чисел, которые представимы в архитектуре компьютера. Тип \textbf{Real} --- это те числа, с которыми работают математики. Следовательно, они включают и все вещественные числа, представимые в какой-угодно архитектуре компьютера. Например, в этом типе есть число <<квадратный корень из двух>>.

Тип \textbf{Bool} содержит булевские значения \textbf{true} и \textbf{false}.

Тип \textbf{Char} содержит все возможные отдельные символы. Этот тип не привязан ни к одной из кодировок (поскольку этот тип --- лишь математическая абстракция). Этот тип содержит все мыслимые символы. Поэтому не определена операция получения <<кода символа>>, привычная для многих языков программирования.

Тип \textbf{Text} является массивом символов (о массивах см.ниже).

Тип \textbf{Unit} является специальным и используется для ограниченного количества случаев (см.ниже). Основное применение --- то же, какое имеет ключевое слово \texttt{void} в сигнатурах функций языка Си.

\head{Операции над встроенными типами}
Арифметические:
\begin{lstlisting}
value
  +: Int >< Int -> Int,
  -: Int >< Int -> Int,
  *: Int >< Int -> Int,
  /: Int >< Int -~-> Int,
  \: Int >< Int -~-> Int,
  **: Int >< Int -~-> Int,
  abs: Int -> Nat,
  real: Int -> Real,

  +: Real >< Real -> Real,
  -: Real >< Real -> Real,
  *: Real >< Real -> Real,
  /: Real >< Real -~-> Real,
  **: Real >< Real -~-> Real,
  abs: Real -> Real,
  int: Real -> Int,

  <: Int >< Int -> Bool,
  <=: Int >< Int -> Bool,
  >: Int >< Int -> Bool,
  >=: Int >< Int -> Bool,
  
  <: Real >< Real -> Bool,
  <=: Real >< Real -> Bool,
  >: Real >< Real -> Bool,
  >=: Real >< Real -> Bool,

  ~: Bool       -> Bool,
  /\: Bool >< Bool -> Bool,
  \/: Bool >< Bool -> Bool,
  =>: Bool >< Bool -> Bool,
\end{lstlisting}

Для любого типа определены операции сравнения на равенство:
\begin{lstlisting}
type T
value
  = : T >< T -> Bool,
  ~= : T >< T -> Bool
\end{lstlisting}

Порядок вычисления операций строго определен: сначала первый аргумент, затем, если необходимо, второй и т.д.

Логика короткая. Это означает, например, что если первый аргумент конъюнкции равен \textbf{false}, то второй аргумент не вычисляется и вся конъюнкция принимает значение \textbf{false}.

\head{Глобальные переменные}
Кроме своих аргументов функция может оперировать глобальными переменными. Каждая глобальная переменная должна быть определена в разделе \textbf{variable}, а в сигнатуре функции должен быть указан режим работы функции с переменной: по чтению или по записи-чтению. Функции разрешено оперировать лишь с теми глобальными переменными, которые указаны в сигнатуре. Например,
\begin{lstlisting}
variable status : Text
value
  init : Unit -> write status Unit
  init() is (status := "initialized")	
\end{lstlisting}

Функция \texttt{init} не имеет аргументов --- для указания этого факта перед стрелкой в сигнатуре функции указан тип \textbf{Unit}. Также у функции нет и возвращаемого значения --- она лишь изменяет значение глобальной переменной \texttt{status}. Этот факт также указан типом \textbf{Unit} в качестве типа возвращаемого значения.

Еще пример:
\begin{lstlisting}[escapechar={|}]
variable status : Text
value
  |is\_initialized| : Unit -> read status Bool
  |is\_initialized|() is
	(status = "initialized")	
\end{lstlisting}

Здесь глобальная переменная лишь читается в функции, поэтому в сигнатуре переменная \texttt{status} указана с модификатором \textbf{read}.

Можно указать в сигнатуре, что функция может читать или изменять любую глобальную переменную. В этом случае вместо имени переменной в сигнатуре функции надо написать ключевое слово \textbf{any}.

\head{Выражения}
Тело функции является выражением того типа, какой должна возвращать функция. Например, функция
\begin{lstlisting}
value f: Int -> Int
      f(x) is
	       x+1
\end{lstlisting}
возвращает значение типа \textbf{Int}. Ее тело состоит из суммы целых чисел, а сумма возвращает значение типа Int. Этой \textbf{математической} функции соответствует, например, следующая функция на языке Си:
\begin{lstlisting}
int f( int x )
{
    return x+1;
}
\end{lstlisting}

Кроме возврата значения такого простого выражения язык RSL допускает более сложные управляющие структуры. Они составляются из более простых выражений. К таким простым выражениям относятся:
\begin{itemize}
\item встроенные операции:
\begin{lstlisting}
value f: Int -> Int
      f(x) is x+1
\end{lstlisting}

\item вызов другой функции (со статической проверкой типов аргументов):
\begin{lstlisting}
value g: Int -> Int
      g(x) is 2 * f(x-1)
\end{lstlisting}

\item условный оператор: \textbf{if} логическое выражение \textbf{then} выражение1 \textbf{else} выражение2 \textbf{end} --- типы выражений <<выражение1>> и <<выражение2>> должны совпадать --- условный оператор возвращает значение этого же типа (значение одного из выражений, в зависимости от значения логического выражения):
\begin{lstlisting}
value
   abs: Int -> Nat
   abs(x) is if x > 0 then x else -x end  
\end{lstlisting}

Условный оператор без \textbf{else} --- допустим только в случае, если <<выражение1>> имеет тип \textbf{Unit}:
\begin{lstlisting}
variable status: Text
value
   init: Bool -> write status Unit
   init(needed) is
     if needed then status := "initialized" end
\end{lstlisting}

Условный оператор с несколькими ветками:
\begin{lstlisting}
variable status: Text
value
   op: Int >< Int -> read status Int
   op(x,y) is
	if status = "sum" then
               x + y
        elsif status = "mul" then
               x * y
	else
		0
	end
\end{lstlisting}

\item оператор присваивания: используется для изменения значений глобальных переменных (аргументы функции переменными не являются, они лишь хранят значение)
\begin{lstlisting}
variable status : Text
value
  init : Unit -> write status Unit
  init() is (status := "initialized")	
\end{lstlisting}

Оператор присваивания имеет тип \textbf{Unit}.

\item последовательность операторов: через точку с запятой
\begin{lstlisting}
variable status : Text
value
  next : Int -> write status Int
  next() is 
	status := "moved";
	x+1	
\end{lstlisting}
В этой функции сначала изменяется значение переменной \texttt{status}, а затем вычисляется выражение x+1. Значением последовательности операторов является значение последнего оператора. А все остальные элементы должны иметь тип \textbf{Unit}. Поэтому, например, следующая запись будет некорректной:
\begin{lstlisting}
variable status : Text
value
  next : Int -> write status Int
  next() is 
        x+1;
	status := "moved"
\end{lstlisting}

\item операторы циклов: while, do-while и for
\begin{lstlisting}
variable a: Nat, b : Nat
value
  euclid: Unit -> Nat
  euclid() is
     while a > 0 /\ b > 0 do
        if a > b then a := a - b
        else b := b - a end
     end;
     if a = 0 then b else a end   
\end{lstlisting}

\begin{lstlisting}
variable sum : Nat
value
  sumN: Nat -> Unit
  sumN(n) is
	sum := 0;
        for i in <.1 .. n.> do
	  sum := sum + i
	end;
\end{lstlisting}

Способов прервать цикл типа break в RSL нет.

\item локальные переменные:
\begin{lstlisting}
variable a: Nat, b : Nat
value
  euclid: Unit -> Nat
  euclid() is
   local variable a1: Nat := a,
                  b1: Nat := b in
     while a1 > 0 /\ b1 > 0 do
        if a1 > b1 then a1 := a1 - b1
        else b1 := b1 - a1 end
     end;
     if a1 = 0 then b1 else a1 end
   end
\end{lstlisting}

\item выражение \textbf{let}: не вводит локальные переменные! а вводит новые синонимы значений; кроме того, выполняет сопоставление с образцами (pattern matching):
явный \textbf{let}:
\begin{lstlisting}
value simple:  Int -> Int
  simple(x) is
    let y = abs x in y-x end 
\end{lstlisting}

Выражение в \textbf{let} вычисляется один раз перед вычислением <<тела>> оператора \textbf{let}.

неявный \textbf{let}:
\begin{lstlisting}
value
  random: Nat -~-> Nat
  random(n) is
      let r : Nat :- r <= n in
	   r
      end	
\end{lstlisting}

\end{itemize}


\head{Тотальная функция}
Это функция, для которой выполнены все 3 свойства:
\begin{enumerate}
  \item она детерминирована (если функция вызывается в разное время с теми же аргументами и в том же состоянии глобальных переменных, то она возвращает одинаковые значения и одинаковым образом изменяет глобальные переменные);
  \item она всюду определена (функция возвращает какое-либо значение на каждом значении аргументов и глобальных переменных, согласно их типам);
  \item она завершима (т.е. не зацикливается ни при каком значении аргументов и глобальных переменных)
\end{enumerate}
Функция является \emph{нетотальной}, если для нее \textbf{неизвестно}, выполнены ли свойства тотальной функции\footnote{Позже мы будем говорить более точно о том, что для нетотальных функций выполнение этих трех свойств \emph{не специфицировано}. Но может быть специфицировано позднее.}. В сигнатуре нетотальной функции вместо стрелки $\Fn$ ставится стрелка $\NonDetermFn$.

Пример тотальной функции:
\begin{lstlisting}
value add: Int >< Int -> Int
add(x,y) is x+y
\end{lstlisting}

Пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
\end{lstlisting}
Эта функция не определена при y = 0.

Пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
\end{lstlisting}
Эта функция не определена при y = 0.

Еще один пример нетотальной функции:
\begin{lstlisting}
value some: Int -~-> Int
some(x) is
    local variable n:Int := x in
        while n ~= 1 do
            if n \ 2 = 0 then n := n/2
                else n := 3 * n + 1 end
        end;
        n
    end
\end{lstlisting}
Про эту функцию именно что неизвестно, завершима ли она при любом целом значении аргумента.

И еще один пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x+y
\end{lstlisting}
Ничего не мешает объявить эту функцию как тотальную, но допустимо ее определение и как нетотальной (например, по причине того, что на момент написания функции неизвестно, должны ли для нее быть выполнены 3 свойства тотальной функции).

Для нетотальной функции может быть указано \emph{предусловие}\footnote{Именно <<может быть>>, но не обязательно, как считают авторы некоторых пособий по RSL в противоречие с авторами самого RSL.}. Оно задает ту область значений аргументов и глобальных переменных, на которых определяется функция. Вне этой области функция по определению считается незаданной (поэтому любая функция с нетождественным \texttt{true} предусловием будет нетотальной). Пример функции с предусловием:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
pre x > 2 /\ y > 4
\end{lstlisting}


\head{Массивы}
Следующая функция использует массив целых чисел:
\begin{lstlisting}
value sort: Int* -> Int*
\end{lstlisting}

Массивы в RSL могут изменять длину (путем операции конкатенации). Элементы массивов проиндексированы, начиная с единицы:
\begin{lstlisting}
value
  sum: Int* -> Int
  sum(ls) is
    local variable s : Int := 0 in
       for i in <.1 .. len ls.> do
             s := s + ls(i)
       end;
       s
    end;     
\end{lstlisting}

Операция \textbf{len} возвращает текущую длину массива.

Эту же функцию, суммирующую элементы массива, можно записать и без использования индексов:
\begin{lstlisting}
value
  sum: Int* -> Int
  sum(ls) is
    local variable s : Int := 0 in
       for l in ls do
             s := s + l
       end;
       s
    end;     
\end{lstlisting}

Тип \textbf{Text} является массивом из \textbf{Char}.

Операция \textbf{tl} возвращает <<подмассив>> --- от второго элемента до последнего элемента исходного массива. Операция определена только для непустых массивов. Пустой список обозначается символом <..>. Тем самым функцию sum можно записать следующим образом с использованием рекурсии:
\begin{lstlisting}
value
  sum: Int* -> Int
  sum(ls) is
    if ls = <..> then 0
    else ls(1) + sum(tl ls) end
\end{lstlisting}


\head{Структуры}
\begin{lstlisting}
type FIO ::
         name : Text
         surname : Text
value
   hello: FIO -> Text
   hello(fio) is
      "Hello, " ^ name(fio) ^ 
           "  " ^ surname(fio) ^ "!"
\end{lstlisting}

Обращение к полю делается в виде вызова функции с именем поля.

\begin{lstlisting}
type FIO ::
         name : Text
         surname : Text
value
   new_fio: Text >< Text -> FIO
   new_fio(n,sn) is mk_FIO(n,sn)    
\end{lstlisting}

Создание структуры делается с помощью функции с предопределенным именем. Это имя начинается с <<mk\_>>, за которым идет имя типа структуры. В скобках подряд перечисляются выражения, дающие значения полям новой структуры.

\head{Перечисления (enumeration)}
\begin{lstlisting}
type Color == red | blue | white | green
value
  from_rus : Color -> Bool
  from_rus(c) is c = red \/ c = blue \/ c = white
\end{lstlisting}

\head{Указатели}
RSL не содержит встроенных механизмов для задания алгоритмов, работающих с указателями.

\section*{Задачи}

\input{alg/prog}


\chapter{Логико-алгебраические спецификации}

Логико-алгебраические модели --- набор свойств, утверждений, аксиом~\cite{kuliamin}. Из этих аксиом путем логического вывода получаются другие свойства.

\head{Логическая модель на RSL}
Это набор аксиом. Аксиомы помещаются в секцию \textbf{axiom}. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y: Int :-
            add(x,y) >= x,
            add(x,y) >= y,
            add(x,0) is x,
            add(10, 45) is 55,
            exists! z : Int :- add(0, z) is x
end
\end{lstlisting}

\head{Алгебраическая модель}
Это набор аксиом вида равенства термов. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y, z: Int :-
            add(add(x,y),z) is add(x, add(y, z)),
            add(x,y) is add(y,x),
            add(x,0) is x
end
\end{lstlisting}

Алгебраические модели тесно связаны с понятием \emph{абстрактных типов данных} (АТД). Собственно, алгебраические модели являются одним из способов определения АТД. Например, <<стек --- это нечто, удовлетворяющее принципу LIFO>>:
\begin{lstlisting}
scheme Addition = class
        type Stack, Elem
        value push: Stack >< Elem -> Stack,
                 pop: Stack -~-> Elem
        axiom forall s: Stack, e: Elem :-
                pop( push(s,e) ) is e
end
\end{lstlisting}

// аксиомы с предусловиями: ограничение области действия аксиомы

\head{Непротиворечивые алгебраические модели}

\head{Полные алгебраические модели}

// полнота и непротиворечивость модели

\head{Обсерверы, генераторы}

// обсерверы-генераторы и формальный метод построения полных алгебраических моделей (о, г, аксиомы, особые случаи, предусловия)

целевой тип - это состояние системы (абстрактный тип!)

обсерверы - это атрибуты состояния

генераторы - это переходы между состояниями

алгебраическая аксиома описывает атрибуты после перехода

Каждый формальный метод хорош в своем месте. Не надо применять то, что само противится этому применению. RAISE (c оттенками VDM) мы будем применять для последовательных детерминированных систем. Изначальная цель - сформулировать предметную область.

Итак, шаги следующие:

1. Выделить термины - оформить их как абстрактные типы.

2. Выделить видимые свойства и атрибуты терминов - оформить их как функции-обсерверы.

3. Выделить инварианты (сonstraint'ы) в терминах.

4. Выделить видимые преобразования терминов - оформить их как функции-генераторы.

шаги 1-4 подробно документировать: что, синтаксис, семантика

5. Описать ВСЕ аксиомы вида "обсервер(генератор)", рассуждая при этом так: как изменится такое-то свойство после такого-то воздействия. Например, как изменится длина при добавлении элемента - увеличится на единицу! Если результат изменения атрибута неизвестен из постановки задачи, это означает неполноту исходных требований - в этом случае результат узнается у заказчика ("как изменится профиль струи при таком-то на нее воздействии", например).

При этом может потребоваться выделение дополнительных атрибутов. Они тоже включаются в общий список и для них выполняется этап описания их изменения другими функциями.

6. Если позволяет постановка задачи, то специфицировать изменение атрибутов после пар операций, троек и т.д.


\head{Определение рекурсивных типов (деревьев)}
Алгебраические модели и АТД являются удобным способом задания рекурсивных типов и функций их обработки. Для этого представленный только что формальный метод построения полных алгебраических спецификаций прочитывается следующим способом:
\begin{enumerate}
  \item выделить и составить сигнатуры функций-конструкторов (пустое значение | составление нового <<узла дерева>>);
  \item выделить и составить сигнатуры функций-обработчиков;
  \item описать результат обработки для каждого конструктора.
\end{enumerate}
Например, спецификация функции, вычисляющей глубину бинарного дерева, согласно этому методу получается такой:
\begin{lstlisting}
scheme BTree = class
   type Node, Tree == empty | mk_tree(Node, Tree, Tree)
   value depth: Tree -> Nat
   axiom forall n: Node, left: Tree, right: Tree :-
            depth( empty ) is 0,
            depth( mk_tree(n, left, right) ) is
                  max( depth(left), depth(right) )
   value max: Nat >< Nat -> Nat
   max(x,y) is if x > y then x else y end
end
\end{lstlisting}
Важно понять, что функция-конструктор предназначена лишь для структурных целей, т.е. в данном примере то же определение дерева пойдет и для бинарного дерева произвольного вида, и для бинарного сбалансированного дерева, и для других бинарных деревьев. А уже менее тривиальные функции составления деревьев (например, чтобы не нарушалась сбалансированность) определяются в виде функций-обработчиков. Функции-конструкторы напоминают конструкторы объектов (\texttt{tree = new Tree(n, left, right)}).

\section*{Задачи}

\input{alg/formal}

\input{alg/calc}

\input{alg/find_errors}

\input{alg/unformal}

\zhead{Выбор генераторов}

\z Для стека, определенного таким образом:
\begin{lstlisting}
type E, S == empty | push(S, E) | pop(S, E)
\end{lstlisting}
дать алгебраическую спецификацию операции проверки наличия заданного элемента
\begin{lstlisting}
value include: S >< E -> Bool
\end{lstlisting}

\textbf{Решение:}
\begin{lstlisting}
type E, S == empty | push(S, E) | pop(S)
value include: S >< E -> Bool
axiom forall e,e1:E, s:S :-
  ~ include(e, empty),
  include(e, push(s,e1)) is e = e1 \/ include(e,s),
  include(e, pop(s)) is 
     if e = top(s) then count(e,s) > 1
             else count(e,s) > 0 end  pre s ~= empty
value count: E >< S -> Nat,
      top: S -~-> E
axiom forall e,e1:E, s:S :-
   count(e, empty) is 0,
   count(e, push(s,e1)) is count(e,s) + 
      if e = e1 then 1 else 0 end,
   count(e, pop(s)) is count(e,s) -
      if e = top(s) then 1 else 0 end pre s ~= empty,

   top(push(s,e1)) is e1,
   top(pop(s)) is last(s,2) pre size(s) >= 2

value last: S >< Nat -~-> E,
      size: S -> Nat
axiom forall s:S, e:E, n:Nat :-
   size(empty) is 0,
   size(push(s,e)) is size(s) + 1,
   size(pop(s)) is size(s) - 1 pre s ~= empty,

   last(push(s,e), n) is
      if n = 1 then e else last(s, n-1) end
        pre n > 0 /\ n <= size(s),
   last(pop(s), n) is last(s, n+1)
        pre s ~= empty /\ n > 0 /\ n < size(s)   
\end{lstlisting}

Обратите внимание, что
\begin{enumerate}
\item с помощью выбранных для описания стека генераторов значение стека будет иметь вид, например, push(push(pop(push(empty,1)),10),1); такое выражения значения в типе стек может казаться наиболее адекватным, ведь добавление и удаление элементов --- именно те операции, с помощью которых можно изменить значение (<<состояние>>) стека; однако посмотрите, насколько увеличивается спецификация и теряется ее наглядность, если в число генераторов включена лишняя функция (pop); сравните:
\begin{lstlisting}
type E, S == empty | push(S, E)
value include: S >< E -> Bool
axiom forall e,e1:E, s:S :-
  ~ include(e, empty),
  include(e, push(s,e1)) is e = e1 \/ include(e,s),
\end{lstlisting}

\item в этом примере синтаксически разные цепочки генераторов могут означать одинаковые значения типа, например, push(pop(push(empty,1)),2) и push(pop(push(empty,3)),2); в таких случаях надо быть внимательными при выписывании аксиом: помнить и понимать, сколько разных возможностей есть для рекурсивной части цепочки (речь идет о переменной <<s>> в примерах) --- например, в аксиоме с генератором, удаляющим элемент, надо в том числе предполагать, что этот элемент может появиться много раз до этого, добавляться и удаляться. 
\end{enumerate}

%% минимальный набор генераторов уменьшает спецификацию (оценить количество аксиом?)

%% при нескольких генераторах надо быть аккуратными

\z Для множества, определенного таким образом:
\begin{lstlisting}
type E, S == empty | add(S, E) | delete(S, E)
\end{lstlisting}
дать алгебраическую спецификацию операции проверки наличия заданного элемента
\begin{lstlisting}
value include: S >< E -> Bool
\end{lstlisting}


\zhead{Описание эффекта  на основе структуры цепочки}

Вы уже заметили, что основной принцип написания аксиомы --- понять, как вычисляется обсервер после последнего сработавшего генератора. При этом для выражения этой аксиомы используются аргументы, с которыми вызван обсервер и последний генератор. Однако не всегда просто описать эффект работы генератора на основе лишь аргументов последнего из них.

\z Дать алгебраическую спецификацию типа <<Ограниченная очередь>>. В эту очередь можно добавлять и удалять элементы, но только если количество хранящихся элементов не превышает заданную величину.

\textbf{Решение:}
\begin{lstlisting}
value capacity : Nat
type E, S == empty | add(E,S)
value delete: S -~-> E
axiom forall e:E, s:S :-
   delete(add(e,s)) is s
     pre size(s) < capacity

value size: S -> Nat
axiom forall e:E, s:S :-
   size(empty) is 0,
   size(add(e,s)) is size(s) + 1
       pre size(s) < capacity
\end{lstlisting}

Обратите внимание, что
\begin{enumerate}
\item пришлось добавить и описать дополнительный обсервер size;
\item существует множество способов реализации ограниченной очереди с помощью имеющихся в языках программирования средств (например, с помощью <<кольцевой очереди>>, реализованной с помощью массива и двух указателей), однако здесь предъявляется именно формализация функциональности операций, которая остается справедливой и неизменной для любой реализации <<ограниченной очереди>>;
\item данное описание не дает определения того, в каких случаях определена каждая операция в отдельности;
\item при написании аксиомы для рекурсивной части цепочки достаточно представлять только \emph{правильно построенные цепочки} --- такие цепочки, в которых все функции вызваны с аргументами правильных типов и в каждой функции выполнено ее предусловие; например, для аксиомы size(add(e,s)) не надо представлять, что она должна описывать и такую цепочку: size(add(e,add(e1,add(e2,empty)))) при capacity = 2.
\end{enumerate}

\z Дать алгебраическую спецификацию типа <<Исключающая очередь>>. В эту очередь элемент добавляется в том случае, если его не было, а если он там был, то он удаляется из очереди. Опишите операцию проверки наличия заданного элемента в такой очереди.


\zhead{<<Эффект>> операций}
%% приходится добавлять обсерверы, чтобы полностью описать эффект функции

\z В~\cite{tanenbaum_os} описаны операции с файлами, среди них описана операция Create следующим образом: <<\textsf{Create} (создание). Файл создается без данных. Этот системный вызов объявляет о появлении нового файла и позволяет установить некоторые его атрибуты.>> Напишите алгебраическую спецификацию файловой подсистемы с этой операцией. Естественно, вам понадобится сигнатура этой операции. Вот она:  \texttt{int creat(char *path, int mode)}, параметр \texttt{path} содержит полное или относительное имя файла, параметр \texttt{mode} устанавливает атрибуты прав доступа различных категорий пользователей к новому файлу при его создании (если файл уже существовал, то новый не создается), операция возвращает значение файлового дескриптора для открытого файла при нормальном завершении и значение -1 при возникновении ошибки.

Решение:
\begin{lstlisting}
scheme FS = class
  type Path, Mode, FID, FS
  value
        creat : Path >< Mode >< FS -~-> FS >< FID,
        size: FS >< FID -~-> Nat,
        known: FS >< Path -> Bool,
        access: FS >< FID -~-> Mode,
        first: FS >< FID -> FS
        first(a,b) is a
  axiom
    forall path: Path, mode: Mode, fs: FS :-
        size(creat( path, mode, fs )) is 0,
        known(first(creat( path, mode, fs )), path),
        access(creat( path, mode, fs)) is mode
end
\end{lstlisting}
Обратите внимание, что
\begin{enumerate}
  \item для описания эффекта функции \texttt{creat} были введены дополнительные операции-обсерверы;
  \item аксиомы напрямую выражают текст, описывающий операцию \texttt{creat} --- аксиомы формализуют \emph{требования} на эту операцию.
\end{enumerate}
Ответьте на следующие вопросы:
\begin{enumerate}
  \item эта спецификация неполная, почему? является ли она противоречивой? как, добавив 1 аксиому, полностью описать операцию known?
  \item имеют ли смысл сами по себе введенные дополнительные операции или они выполняют лишь вспомогательную для описания \texttt{creat} функцию?
  \item допустим, мы догадываемся, что Path = \textbf{Text}, а Mode = \textbf{Nat}; дополненная этим знанием спецификация, останется ли алгебраической ? станет ли полной ? останется ли непротиворечивой ? будет ли она соответствовать исходной постановке задачи ? не станет ли она допускать того, что не должно бы по условию ?
\end{enumerate}

\z В~\cite{tanenbaum_os} описаны операции с файлами, среди них описана операция Delete следующим образом: <<\textsf{Delete} (удаление). Когда файл уже более не нужен, его удаляют, чтобы освободить пространство на диске. Этот системный вызов присутствует в каждой операционной системе.>> Напишите алгебраическую спецификацию файловой подсистемы с этой операцией. Естественно, вам понадобится сигнатура этой операции. Вот она:  \texttt{void delete(int fid)}, параметр \texttt{fid} содержит значение файлового дескриптора.

\z В~\cite{tanenbaum_os} описаны операции с файлами, среди них описана операция Open следующим образом: <<\textsf{Open} (открытие). Прежде чем использовать файл, процесс должен его открыть. Системный вызов open позволяет системе прочитать в оперативную память атрибуты файла и список дисковых адресов для быстрого доступа к содержимому файла при последующих вызовах.>> Напишите алгебраическую спецификацию файловой подсистемы с этой операцией. Естественно, вам понадобится сигнатура этой операции. Вот она:  \texttt{void delete(int fid)}, параметр \texttt{fid} содержит значение файлового дескриптора.

\z про map !!!


%% не всегда просто понять, полна ли спецификация

%% понять, как описывать недопустимое поведение

%% понять, как работать с рекурсивными типами




\zhead{Конфлюэнтность}

Хотя специфицируются абстрактные типы данных, множество значений этих типов всё же можно выразить --- в виде множества термов. Например, для базы данных это может быть \texttt{add("Иванов", 200, add("Петров", 500, empty))}. Терм соответствует некоторому состоянию моделируемой системы. Проблема того, что два разных терма означают одно и то же состояние, неразрешима\footnote{Взяв первый терм, пытаемся вставить его на место аргументов в аксиомах и применить преобразование из этой аксиомы. Так получаем новый терм. К нему применяем то же правило --- получаем еще один терм. И так делаем до тех пор, пока не получив данный второй терм. Если процесс составления новых термов завершился, значит термы означали одинаковые состояния. А если процесс не завершится, то разные. Получается <<алгоритм>>, который должен зацикливаться. Естественно, это означает отсутствие алгоритма в правильном понимании этого слова.}. Хороши те системы аксиом, которые дают нормальные формы. Системы с такими аксиомами проще анализировать и проще понимать их смысл, поскольку есть понятная классификация состояний-термов. Например, для списка состоянием является последовательность элементов $\langle x_1, x_2, ..., x_n \rangle$ --- очевидно алгебраическое представление списка, обладающее нормальной формой: \texttt{cons($x_1$, cons($x_2$, ..., cons($x_n$, nil) ... ))}; поэтому для списка достаточно исследовать все свойства только на таких термах, а не на всех произвольных.

Итог: при выделении операций-генераторов надо постараться так, чтобы каждое значение целевого типа имело единственной представление в виде терма из этих операций (т.н. \emph{нормальная форма}). Если такие генераторы построить не удается, то нужны выделить и добавить аксиомы, определяющие эквивалентный переход от многих форм

Пример: множество -- не забыть аксиому add(a, add(b,c)) is add(b, add(a,c))   (нормальная форма: add(add(add с возрастающими аргументами)

аксиомы должны "работать" для всех форм, и нормальных, и не являющихся нормальными.

delete(x, add(y,s)) is if x = y then s else add(y, delete(x,s)) end -- логично? да. правильно ? нет, т.к. ...
delete(1, add(1, add(1, empty))) is add(1, empty) по этой аксиоме, но тогда
isin(1, delete(1, add(1, add(1, empty)))) is isin(1, add(1, empty)) is true, а должен быть false, т.к. 1 должны были удалить.

delete(x, add(y,s)) is if x = y then delete(x,s) else add(y, delete(x,s)) end -- теперь правильно

другое дело, что при выводе свойств достаточно рассматривать такие s, которые представлены нормальной формой.


попробовать описать такие функции для множества как длина, вложение, вхождение элемента во множество



\chapter{Моделе-ориентированные спецификации}

%\chapter{Поведенческие спецификации}
%TBD


Спецификация для функции append в <<исполнимой>> манере:
\begin{lstlisting}
type E, L = E*
value append: L >< L -> L
    append(x, y) is x ^ y
\end{lstlisting}

Спецификация для функции append в <<логической>> манере:
\begin{lstlisting}
type E, L = E*
value append: L >< L -> L
    append(x, y) as z
    post
        len z = len x + len y /\
        (all i: Nat :- i isin inds x => z(i) = x(i)) /\
        (all i: Nat :- i isin inds y => z(i+len x) = y(i))
\end{lstlisting}

Спецификация для функции reverse в <<исполнимой>> манере:
\begin{lstlisting}
type E, L = E*
value reverse: L -> L
    reverse(x) is
        local variable y : L :- y = <..> in
            for xi in x do
                y := <.xi.> ^ y
            end;
            y;
        end
\end{lstlisting}

Спецификация для функции reverse в <<логической>> манере:
\begin{lstlisting}
type E, L = E*
value reverse: L -> L
  reverse(x) as y
  post len x = len y /\
    (all i: Nat :- i isin inds x => y(i) = x(len x + 1 - i))
\end{lstlisting}

Спецификация для функции reverse в <<алгебраической>> манере:
\begin{lstlisting}
type E, L = E*
value reverse: L -> L
axiom
    reverse(<..>) is <..>,
    all x, y: L :- reverse(x^y) is reverse(y) ^ reverse(x)
\end{lstlisting}

Что из этого короче? Что понятнее? Что лучше? (зависит от задачи)


\appendix
\include{rslprior}

\pagebreak
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{rslbooks}

\end{document}
