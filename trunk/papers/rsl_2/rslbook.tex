% !Mode:: "TeX:UTF-8"
\documentclass[14pt, twoside]{extreport}
\usepackage{cmap}

\usepackage{fix-cm}
%\usepackage[cp1251]{inputenc}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{dsfont}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\pagestyle{headings}

\textheight 23cm % 29.7-2-2
\textwidth 16cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \evensidemargin 0cm  \headheight 0cm \headsep 1.5cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел


%
% Подправим команду \appendix : нумерация русскими буквами,
% а не латинскими.
\makeatletter
\renewcommand\appendix{\par
  \setcounter{chapter}{0}%
  \setcounter{section}{0}%
  \def\@chapapp{\appendixname}%
  \def\thechapter{\@Asbuk\c@chapter}}
\makeatother

%% Теперь "русифицируем" окружение enumerate:
%\makeatletter
%\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
%\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
%\def\labelenumii{\theenumii)}    % а не латинские буквы
%\def\p@enumii{\theenumi}         % а это для \ref
%\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
%\let\theenumiii\relax            % и отдельных ссылок на него не будет
%\def\p@enumiii{\theenumi\theenumii}
%\makeatother

\usepackage{rsl}

\usepackage{listingsutf8}
\lstloadlanguages{RSL}
\lstset{numbers=left, language=RSL, extendedchars=true, numberstyle=\tiny}
%, inputencoding=utf8/latin1, commentstyle=\itshape, stringstyle=\bfseries}

\author{Евгений Корныхин}
\title{\huge{\textbf{\textsc{Задачи по формальной спецификации программ на RSL}}}}
\date{Москва --- 2010}

\newcounter{problem_type}[chapter]
\newcounter{zadacha}[problem_type]
\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
\textit{\arabic{chapter}.\arabic{problem_type}.\arabic{zadacha}}~~  }

\newcommand{\head}[1]{\vspace{1cm}\subsubsection*{#1}}
\newcommand{\zhead}[1]{\head{#1} \refstepcounter{problem_type}}


\begin{document}

\maketitle

\tableofcontents

\pagebreak

\section*{Введение}

Данный сборник задач написан в поддержку курса <<Формальной спецификации и верификации программ>>, который читается студентам последних курсов факультета ВМиК МГУ.

Под <<формальной>> спецификацией в первую очередь понимается строгое однозначное задание (описание) интерфейса или поведения программы. До сих пор необходимость доведения описаний до строгих однозначных форм ставится под сомнение, если речь идет о совершенно произвольных программах (как минимум, это сталкивается с высокой трудоемкостью формальной спецификации и особенной квалификацией тех, кто эту спецификацию составляет). Хотя полезность (и даже необходимость) строгого однозначного задания \emph{критичных} систем сомнений не вызывает. И тем не менее понижение трудоемкости и сближение формальных спецификаций с программистами-инженерами (т.е. существенное расширение области реального использования формальных спецификаций) является актуальной задачей в области технологий программирования (software engineering).

Однако дабы не попадать в дискуссионную область, курс следует иному принципу. Реалии таковы, что кроме написания программ необходимо, чтобы эти программы были корректными, чтобы они удовлетворяли стандартам. Для решения задач обеспечения таких характеристик применяются \emph{в том числе и} математические методы. Это означает, что программа выражается в математических терминах в виде \emph{математической теории}, или \emph{математической модели}, и задача уже решается в рамках этой математической теории с применением математического аппарата. Эта идея может показаться малоприменимой на практике, поскольку обычно математики и программисты-инженеры живут <<в разных мирах>>. На самом же деле математические методы решения задач над программами (их еще называют \emph{формальными методами}, подчеркивая, что <<обычный>> программист-инженер работает в своем <<неформальном>> мире представления о своей программе) исторически возникли практически сразу с возникновением практического программирования (это 50-е годы ХХ века) и развиваются по настоящее время.

Математическая теория, создаваемая для программы, это и есть формальная спецификация. От природы этой спецификации будут зависеть и математические методы, применяемые для решения задачи. Математическая теория не создается сама по себе --- она создается для конкретных целей, для решения определенных задач: формализация требований с целью, во-первых, их прояснения, во-вторых, для выяснения в них противоречий и неполных требований, автоматизация тестирования, чёткая документация, формальная верификация и даже разработка программ с помощью формальных моделей. Единожды проведя формализацию, можно существенно снизить <<человеческий>> фактор на последующих этапах жизненного цикла программы.

Эта часть курса посвящена тому, какие на данный момент придуманы виды моделей, какой природы математические теории используются для описания программ. Вторая часть курса (не вошедшая в этот сборник задач) посвящена одному из применений формальных спецификаций --- формальной верификации программ.

Читатели могут столкнуться с <<моделями программ>> не впервые. Студенты ВМиК МГУ слушают перед этим курсом курс по объектно-ориентированному анализу и проектированию программ и курс по верификации программ на моделях (model checking). Отличия этого курса от уже прослушанных заключаются в следующем. Курс ООАП также работает с моделями, но многие из этих моделей ориентированы только на последующее кодирование, а не на анализ программ. Грубо говоря, речь идет о моделировании структуры кода, а не семантики программы. Кроме того, строгий, формальный, подход практически никак не отражен в этом курсе. В курсе верификации на моделях рассматривается инструмент SPIN и моделирование на языке PROMELA. Остальные виды моделей программ в этом курсе не рассматриваются, но рассматриваются в данном курсе.

Согласно одной из принятых классификаций выделяют следующие основные виды моделей программ:
\begin{itemize}
  \item логико-алгебраические модели (interface specification: property-based / state-based);
  \item исполнимые модели (behavior specification);
\end{itemize}
Кроме того, выделяют модели, совмещающие в себя характеристики логико-алгебраических и исполнимых моделей.

Исполнимые спецификации дают модель в виде программы для некоторой виртуальной машины, может быть, достаточно абстрактной. В основном, это различные виды конечных автоматов и систем переходов (LTS). К таким моделям относятся модели на PROMELA, уже знакомые читателям. Кроме того, с конечными автоматами они сталкивались достаточно часто в предыдущих курсах. Поэтому в этом курсе исполнимые модели не будут рассматриваться подробно.

Логико-алгебраические модели рассматривают операции программы в математическом смысле, как отображения аргументов и пре-состояния на значения-результаты операций и пост-состояния\footnote{потому такие модели не являются исполнимыми в общем случае --- попробуйте для любой функции, заданной отображением, автоматически построить программу, которая ее исполняет!}. Чистые \emph{логические модели} представляют собой набор аксиом, из которых следуют эти отображения. \emph{Алгебраические модели} описывают эквивалентности суперпозиций операций (грубо говоря, эти модели состоят из требований эквивалентности разных цепочек действий). К неисполнимым спецификациями принадлежат и такие виды моделей как \emph{программные контракты} --- набор логических свойств, которые должны быть выполнены при корректных входных данных и вычисленных по ним выходных. Грубо говоря, для задания семантики программы в неисполнимом виде применяются два подхода: <<чистый операционный>> (функциональный) подход (property-based) и подход, основанный на моделировании состояния программы (model-based, state-based). В функциональном подходе состояние не моделируется! И тем не менее, семантику операций удается задать. Вторая глава задачника посвящена функциональному подходу. Третья глава --- подходу, основанному на моделировании состояния программы. А первая глава посвящена тому языку, на котором все эти модели можно выражать --- языку RSL. Авторы языка попытались создать язык, который был бы языком программирования и языком спецификации одновременно\footnote{На самом деле обе эти цели можно воспринимать как моделирование --- первое является исполнимым моделированием, а второе неисполнимым.}. Единый языка выражения программы и ее семантики позволяют легче провести верификацию программы на такой модели. Но вопросы верификации лежат уже за пределами данного сборника задач.

\chapter{RSL для императивного программирования}

\head{Описание сигнатуры функции на RSL:}

\begin{lstlisting}
value add: Int >< Int -> Int
\end{lstlisting}
Имеется одна функция \texttt{add} с двумя аргументами типа Int (аргументы разделяются символом $\Fn$), функция является тотальной (стрелка ->). Функция вычисляет одно значение и это значение типа Int (несколько значений так же разделяются символом $\times$). Функция не имеет побочного эффекта.

\head{Описание функции целиком:}
\begin{lstlisting}
value add: Int >< Int -> Int
add(x,y) is x+y
\end{lstlisting}
После сигнатуры идет тело функции. Вначале идет имя функции с формальными параметрами, затем символ $\Is$ и затем выражение. Вычислением функции является вычисление этого выражения (в данном случае, сложение двух чисел-аргументов).

\head{Встроенные типы}
Int, Nat (целые неотрицательные числа), Real, Bool, Char, Text (список Char'в), Unit (аналог \textit{void}).

\head{Операции над встроенными типами:} ........................................

\head{Выражения} -- ............... (последовательность, if, while )

\head{Побочный эффект в функции} -- ...........

\head{Тотальная функция}
Это функция, для которой выполнены все 3 свойства:
\begin{enumerate}
  \item она детерминирована (если функция вызывается в разное время с теми же аргументами и в том же состоянии глобальных переменных, то она возвращает одинаковые значения и одинаковым образом изменяет глобальные переменные);
  \item она всюду определена (функция возвращает какое-либо значение на каждом значении аргументов и глобальных переменных, согласно их типам);
  \item она завершима (т.е. не зацикливается ни при каком значении аргументов и глобальных переменных)
\end{enumerate}
Функция является \emph{нетотальной}, если для нее \textbf{неизвестно}, выполнены ли свойства тотальной функции\footnote{Позже мы будем говорить более точно о том, что для нетотальных функций выполнение этих трех свойств \emph{не специфицировано}. Но может быть специфицировано позднее.}. В сигнатуре нетотальной функции вместо стрелки $\Fn$ ставится стрелка $\NonDetermFn$.

Пример тотальной функции:
\begin{lstlisting}
value add: Int >< Int -> Int
add(x,y) is x+y
\end{lstlisting}

Пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
\end{lstlisting}
Эта функция не определена при y = 0.

Пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
\end{lstlisting}
Эта функция не определена при y = 0.

Еще один пример нетотальной функции:
\begin{lstlisting}
value some: Int -~-> Int
some(x) is
    local variable n:Int := x in
        while n ~= 1 do
            if n \% 2 = 0 then n := n/2
                else n := 3 * n + 1 end
        end;
        n
    end
\end{lstlisting}
Про эту функцию именно что неизвестно, завершима ли она при любом целом значении аргумента.

И еще один пример нетотальной функции:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x+y
\end{lstlisting}
Ничего не мешает объявить эту функцию как тотальную, но допустимо ее определение и как нетотальной (например, по причине того, что на момент написания функции неизвестно, должны ли для нее быть выполнены 3 свойства тотальной функции).

Для нетотальной функции может быть указано \emph{предусловие}\footnote{Именно <<может быть>>, но не обязательно, как считают авторы некоторых пособий по RSL в противоречие с авторами самого RSL.}. Оно задает ту область значений аргументов и глобальных переменных, на которых определяется функция. Вне этой области функция по определению считается незаданной (поэтому любая функция с нетождественным \texttt{true} предусловием будет нетотальной). Пример функции с предусловием:
\begin{lstlisting}
value add: Int >< Int -~-> Int
add(x,y) is x/y
pre x > 2 /\ y > 4
\end{lstlisting}


\head{Массивы} -- ..........

\head{Структуры} ---

\section*{Задачи}



\chapter{Логико-алгебраические спецификации}

Логико-алгебраические модели --- набор свойств, утверждений, аксиом~\cite{kuliamin}. Из этих аксиом путем логического вывода получаются другие свойства.

\head{Логическая модель на RSL}
Это набор аксиом. Аксиомы помещаются в секцию \textbf{axiom}. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y: Int :-
            add(x,y) >= x,
            add(x,y) >= y,
            add(x,0) is x,
            add(10, 45) is 55,
            exists! z : Int :- add(0, z) is x
end
\end{lstlisting}

\head{Алгебраическая модель}
Это набор аксиом вида равенства термов. Пример:
\begin{lstlisting}
scheme Addition = class
        value add: Int >< Int -> Int
        axiom forall x, y, z: Int :-
            add(add(x,y),z) is add(x, add(y, z)),
            add(x,y) is add(y,x),
            add(x,0) is x
end
\end{lstlisting}

Алгебраические модели тесно связаны с понятием \emph{абстрактных типов данных} (АТД). Собственно, алгебраические модели являются одним из способов определения АТД. Например, <<стек --- это нечто, удовлетворяющее принципу LIFO>>:
\begin{lstlisting}
scheme Addition = class
        type Stack, Elem
        value push: Stack >< Elem -> Stack,
                 pop: Stack -~-> Elem
        axiom forall s: Stack, e: Elem :-
                pop( push(s,e) ) is e
end
\end{lstlisting}

// аксиомы с предусловиями: ограничение области действия аксиомы

\head{Непротиворечивые алгебраические модели}

\head{Полные алгебраические модели}

// полнота и непротиворечивость модели

\head{Обсерверы, генераторы}

// обсерверы-генераторы и формальный метод построения полных алгебраических моделей (о, г, аксиомы, особые случаи, предусловия)

целевой тип - это состояние системы (абстрактный тип!)

обсерверы - это атрибуты состояния

генераторы - это переходы между состояниями

алгебраическая аксиома описывает атрибуты после перехода

Каждый формальный метод хорош в своем месте. Не надо применять то, что само противится этому применению. RAISE (c оттенками VDM) мы будем применять для последовательных детерминированных систем. Изначальная цель - сформулировать предметную область.

Итак, шаги следующие:

1. Выделить термины - оформить их как абстрактные типы.

2. Выделить видимые свойства и атрибуты терминов - оформить их как функции-обсерверы.

3. Выделить инварианты (сonstraint'ы) в терминах.

4. Выделить видимые преобразования терминов - оформить их как функции-генераторы.

шаги 1-4 подробно документировать: что, синтаксис, семантика

5. Описать ВСЕ аксиомы вида "обсервер(генератор)", рассуждая при этом так: как изменится такое-то свойство после такого-то воздействия. Например, как изменится длина при добавлении элемента - увеличится на единицу! Если результат изменения атрибута неизвестен из постановки задачи, это означает неполноту исходных требований - в этом случае результат узнается у заказчика ("как изменится профиль струи при таком-то на нее воздействии", например).

При этом может потребоваться выделение дополнительных атрибутов. Они тоже включаются в общий список и для них выполняется этап описания их изменения другими функциями.

6. Если позволяет постановка задачи, то специфицировать изменение атрибутов после пар операций, троек и т.д.


\head{Определение рекурсивных типов (деревьев)}
Алгебраические модели и АТД являются удобным способом задания рекурсивных типов и функций их обработки. Для этого представленный только что формальный метод построения полных алгебраических спецификаций прочитывается следующим способом:
\begin{enumerate}
  \item выделить и составить сигнатуры функций-конструкторов (пустое значение | составление нового <<узла дерева>>);
  \item выделить и составить сигнатуры функций-обработчиков;
  \item описать результат обработки для каждого конструктора.
\end{enumerate}
Например, спецификация функции, вычисляющей глубину бинарного дерева, согласно этому методу получается такой:
\begin{lstlisting}
scheme BTree = class
   type Node, Tree == empty | mk_tree(Node, Tree, Tree)
   value depth: Tree -> Nat
   axiom forall n: Node, left: Tree, right: Tree :-
            depth( empty ) is 0,
            depth( mk_tree(n, left, right) ) is
                  max( depth(left), depth(right) )
   value max: Nat >< Nat -> Nat
   max(x,y) is if x > y then x else y end
end
\end{lstlisting}
Важно понять, что функция-конструктор предназначена лишь для структурных целей, т.е. в данном примере то же определение дерева пойдет и для бинарного дерева произвольного вида, и для бинарного сбалансированного дерева, и для других бинарных деревьев. А уже менее тривиальные функции составления деревьев (например, чтобы не нарушалась сбалансированность) определяются в виде функций-обработчиков. Функции-конструкторы напоминают конструкторы объектов (\texttt{tree = new Tree(n, left, right)}).

\section*{Задачи}

\input{alg/formal}

\input{alg/calc}

\input{alg/find_errors}

\input{alg/unformal}

%% минимальный набор генераторов уменьшает спецификацию (оценить количество аксиом?)

%% при нескольких генераторах надо быть аккуратными

%% не всегда просто описать эффект на основе лишь аргументов последней операции (ограниченный буфер)

%% приходится добавлять обсерверы, чтобы полностью описать эффект функции

\zhead{<<Эффект>> операций}

\z В~\cite{tanenbaum_os} описаны операции с файлами, среди них описана операция Create следующим образом: <<\textsf{Create} (создание). Файл создается без данных. Этот системный вызов объявляет о появлении нового файла и позволяет установить некоторые его атрибуты.>> Напишите алгебраическую спецификацию файловой подсистемы с этой операцией. Естественно, вам понадобится сигнатура этой операции. Вот она:  \texttt{int creat(char *path, int mode)}, параметр \texttt{path} содержит полное или относительное имя файла, параметр \texttt{mode} устанавливает атрибуты прав доступа различных категорий пользователей к новому файлу при его создании (если файл уже существовал, то новый не создается), операция возвращает значение файлового дескриптора для открытого файла при нормальном завершении и значение -1 при возникновении ошибки.

Решение:
\begin{lstlisting}
scheme FS = class
  type Path, Mode, FID, FS
  value
        creat : Path >< Mode >< FS -~-> FS >< FID,
        size: FS >< FID -~-> Nat,
        known: FS >< Path -> Bool,
        access: FS >< FID -~-> Mode,
        first: FS >< FID -> FS
        first(a,b) is a
  axiom
    forall path: Path, mode: Mode, fs: FS :-
        size(creat( path, mode, fs )) is 0,
        known(first(creat( path, mode, fs )), path),
        access(creat( path, mode, fs)) is mode
end
\end{lstlisting}
Обратите внимание, что
\begin{enumerate}
  \item для описания эффекта функции \texttt{creat} были введены дополнительные операции-обсерверы;
  \item аксиомы напрямую выражают текст, описывающий операцию \texttt{creat} --- аксиомы формализуют \emph{требования} на эту операцию.
\end{enumerate}
Ответьте на следующие вопросы:
\begin{enumerate}
  \item эта спецификация неполная, почему? является ли она противоречивой? как, добавив 1 аксиому, полностью описать операцию known?
  \item имеют ли смысл сами по себе введенные дополнительные операции или они выполняют лишь вспомогательную для описания \texttt{creat} функцию?
  \item допустим, мы догадываемся, что Path = \textbf{Text}, а Mode = \textbf{Nat}; дополненная этим знанием спецификация, останется ли алгебраической ? станет ли полной ? останется ли непротиворечивой ? будет ли она соответствовать исходной постановке задачи ? не станет ли она допускать того, что не должно бы по условию ?
\end{enumerate}

\z В~\cite{tanenbaum_os} описаны операции с файлами, среди них описана операция Delete следующим образом: <<\textsf{Delete} (удаление). Когда файл уже более не нужен, его удаляют, чтобы освободить пространство на диске. Этот системный вызов присутствует в каждой операционной системе.>> Напишите алгебраическую спецификацию файловой подсистемы с этой операцией. Естественно, вам понадобится сигнатура этой операции. Вот она:  \texttt{void delete(int fid)}, параметр \texttt{fid} содержит значение файлового дескриптора.

\z В~\cite{tanenbaum_os} описаны операции с файлами, среди них описана операция Open следующим образом: <<\textsf{Open} (открытие). Прежде чем использовать файл, процесс должен его открыть. Системный вызов open позволяет системе прочитать в оперативную память атрибуты файла и список дисковых адресов для быстрого доступа к содержимому файла при последующих вызовах.>> Напишите алгебраическую спецификацию файловой подсистемы с этой операцией. Естественно, вам понадобится сигнатура этой операции. Вот она:  \texttt{void delete(int fid)}, параметр \texttt{fid} содержит значение файлового дескриптора.

\z про map !!!


%% не всегда просто понять, полна ли спецификация

%% понять, как описывать недопустимое поведение

%% понять, как работать с рекурсиными типами




\zhead{Конфлюэнтность}

Хотя специфицируются абстрактные типы данных, множество значений этих типов всё же можно выразить --- в виде множества термов. Например, для базы данных это может быть \texttt{add("Иванов", 200, add("Петров", 500, empty))}. Терм соответствует некоторому состоянию моделируемой системы. Проблема того, что два разных терма означают одно и то же состояние, неразрешима\footnote{Взяв первый терм, пытаемся вставить его на место аргументов в аксиомах и применить преобразование из этой аксиомы. Так получаем новый терм. К нему применяем то же правило --- получаем еще один терм. И так делаем до тех пор, пока не получив данный второй терм. Если процесс составления новых термов завершился, значит термы означали одинаковые состояния. А если процесс не завершится, то разные. Получается <<алгоритм>>, который должен зацикливаться. Естественно, это означает отсутствие алгоритма в правильном понимании этого слова.}. Хороши те системы аксиом, которые дают нормальные формы. Системы с такими аксиомами проще анализировать и проще понимать их смысл, поскольку есть понятная классификация состояний-термов. Например, для списка состоянием является последовательность элементов $\langle x_1, x_2, ..., x_n \rangle$ --- очевидно алгебраическое представление списка, обладающее нормальной формой: \texttt{cons($x_1$, cons($x_2$, ..., cons($x_n$, nil) ... ))}; поэтому для списка достаточно исследовать все свойства только на таких термах, а не на всех произвольных.

Итог: при выделении операций-генераторов надо постараться так, чтобы каждое значение целевого типа имело единственной представление в виде терма из этих операций (т.н. \emph{нормальная форма}). Если такие генераторы построить не удается, то нужны выделить и добавить аксиомы, определяющие эквивалентный переход от многих форм

Пример: множество -- не забыть аксиому add(a, add(b,c)) is add(b, add(a,c))   (нормальная форма: add(add(add с возрастающими аргументами)

аксиомы должны "работать" для всех форм, и нормальных, и не являющихся нормальными.

delete(x, add(y,s)) is if x = y then s else add(y, delete(x,s)) end -- логично? да. правильно ? нет, т.к. ...
delete(1, add(1, add(1, empty))) is add(1, empty) по этой аксиоме, но тогда
isin(1, delete(1, add(1, add(1, empty)))) is isin(1, add(1, empty)) is true, а должен быть false, т.к. 1 должны были удалить.

delete(x, add(y,s)) is if x = y then delete(x,s) else add(y, delete(x,s)) end -- теперь правильно

другое дело, что при выводе свойств достаточно рассматривать такие s, которые представлены нормальной формой.


попробовать описать такие функции для множества как длина, вложение, вхождение элемента во множество



\chapter{Моделе-ориентированные спецификации}

%\chapter{Поведенческие спецификации}
%TBD

\appendix
\include{rslprior}

\pagebreak
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{rslbooks}

\end{document}
