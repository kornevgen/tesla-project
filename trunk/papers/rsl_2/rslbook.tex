% !Mode:: "TeX:UTF-8"
\documentclass[14pt, twoside]{extreport}
\usepackage{cmap}

%\usepackage{fix-cm}
\usepackage[utf8]{inputenx}
\usepackage[russian]{babel}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%\usepackage{pscyr}
%\usepackage[T1]{fontenc} %cm-super
%\usepackage{type1cm}
\usepackage{indentfirst}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsmath}
%\usepackage{dsfont}
\usepackage{xspace}
\usepackage[numbers,compress,sort]{natbib}
\usepackage{clrscode}

\pagestyle{headings}

\textheight 23cm % 29.7-2-2
\textwidth 16cm % 21-2.5-1.5
\hoffset 0.46cm %2.5-2.54 слева 3 см
\voffset -0.54cm %2-2.54 сверху 2 см
\oddsidemargin 0cm \evensidemargin 0cm  \headheight 0cm \headsep 1.5cm \topmargin 0cm

\usepackage{ccaption} % заменяем для рисунков ':' после номера рисунка на другой символ
\captiondelim{. } % разделитель точка и пробел

\usepackage{vaucanson-g}

\usepackage{ifpdf}

\ifpdf
% we are running pdflatex, so convert .eps files to .pdf
% run pdflatex with --shell-escape and thesis.aux
\usepackage[pdftex]{graphicx}
\usepackage{epstopdf}
\else
% we are running LaTeX, not pdflatex
\usepackage{graphicx}
\fi

% Подправим команду \appendix : нумерация русскими буквами,
% а не латинскими.
\makeatletter
\renewcommand\appendix{\par
  \setcounter{chapter}{0}%
  \setcounter{section}{0}%
  \def\@chapapp{\appendixname}%
  \def\thechapter{\@Asbuk\c@chapter}}
\makeatother

% "русифицируем" окружение enumerate:
\makeatletter
\def\labelenumi{\theenumi)}      % чтобы после номера шла скобка;
\def\theenumii{\@asbuk\c@enumii}   % чтобы на втором уровне шли русские,
\def\labelenumii{\theenumii)}    % а не латинские буквы
\def\p@enumii{\theenumi}         % а это для \ref
\def\labelenumiii{{\bf--}}       % а на третьем уровне пусть будут лишь тире,
\let\theenumiii\relax            % и отдельных ссылок на него не будет
\def\p@enumiii{\theenumi\theenumii}
\makeatother

\usepackage{rsl}

\usepackage{listingsutf8}
\lstloadlanguages{RSL}
\lstset{numbers=left, language=RSL, extendedchars=true, numberstyle=\tiny, inputencoding=utf8%,
%commentstyle=\itshape, stringstyle=\bfseries
}

\author{Евгений Корныхин}
\title{\huge{\textbf{\textsc{Семинарские занятия по формальной функциональной спецификации программ}}}}
%\date{Москва --- 2010}

\newcounter{problem_type}[chapter]
\newcounter{zadacha}[problem_type]
\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
\textit{\arabic{chapter}.\arabic{problem_type}.\arabic{zadacha}}~~  }

%\newcounter{problem_type}[section]
%\newcounter{zadacha}[problem_type]
%\newcommand{\z}{\vspace{0.5cm}\par\addtocounter{zadacha}{1}%
%\textit{\arabic{section}.\arabic{problem_type}.\arabic{zadacha}}~~  }

\newcommand{\head}[1]{\vspace{1cm}\subsubsection*{#1}}
\newcommand{\zhead}[1]{\head{#1} \refstepcounter{problem_type}}


\begin{document}

\maketitle

\tableofcontents

\input{intro}


%%%%%%%%%% Общая структура %%%%%%%%%%%
%%  0. "Введение". (см. igoogle) Создание формальной модели поведения системы как способ уточнения требований
%%  1. "Основные определения" (спецификация, модель, полнота, тотальность, непротиворечивость, явность).
%%      Нулевая задачка экзамена. Детерминированные функции, недетерминированные функции на примерах чисел.
%%      Первая задачка экзамена в том случае, когда всё состояние скрыто (т.е. про состояние пока что не думаем).
%%  2. "Языки спецификации". Сначала RSL (множества, списки, отображения). Потом ACSL (модель памяти, функции с указателями)
%%  3. "Модельные спецификации". Кроме самих данных, специфицируем состояние системы (модель состояния, инварианты).
%%      Первая задачка экзамена в полном объеме. Выделение ветвей функциональности при записи постусловий.
%%      Согласованность модельных спецификаций (инвариант не пуст после каждой функции, нет вызовов функций вне их предусловий)
%%  4. "Алгебраические спецификации". Понятие алгебраической спецификации (новая вторая задачка экзамена).
%%      Согласованность алгебраических спецификаций (бывшая вторая задачка экзамена).
%%  5. "Автоматные спецификации". Тут про третью задачку экзамена.
%%  6. ......... может быть сюда включить формальную верификацию...........

\chapter{Основные понятия}

\section{RSL для императивного программирования}

    \input{prog/about}

    \section*{Задачи}

    \input{prog/problems}

\section{Функции в языках спецификации}

    \input{basis/funcs}

    \section*{Задачи}

    \input{alg/formal}

    \input{basis/im2ex}




\chapter{Уточнение функциональных требований}

%\section{Операции и ветви функциональности}

%% спецификация логики работы системы и характерных особенностей данных

Данный курс посвящён формальной спецификации программно-ап-паратных систем (далее, просто <<систем>>) и их компонентов. С точки зрения пользователя система даёт возможность выполнить с её помощью ряд \emph{операций} (например, банкомат дает возможность снять деньги со счета). Аналогично, каждый отдельный компонент даёт возможность остальным компонентам выполнять с его помощью ряд операций. Операция обладает рядом \emph{аргументов} и \emph{результатов операции}, непосредственно доступных тому, кто запросил данную операцию (например, чтобы выполнить операцию снятия денег со счета при помощи банкомата надо указать сумму снимаемых денег - это один из аргументов, в качестве одного из результатов операции мы получим сами деньги). Во время выполнения операции система (или её отдельный компонент) ведут себя строго определённым образом в зависимости от значений аргументов, внутреннего состояния системы и состояния среды, в которой работает система (будем их называть \emph{входными параметрами} операции)\footnote{Пока что под состоянием среды понимается значение всех глобальных переменных}.

Предположим, что система ещё не реализована, для неё составляется набор требований, по которым будет осуществлена реализация. От того, насколько точно будут сформулированы эти требования, будет зависеть и качество реализованной системы. Основные проблемы в требованиях следующие:
\begin{itemize}
  \item несогласованность (противоречивость) требований: набор требований содержит как минимум несовместное подмножество требований;
  \item неполнота: набор требований ничего не говорит о том, каким должно быть поведение некоторой операции при некоторых значениях входных параметров;
  \item неоднозначность требований: некоторое требование можно трактовать несколькими способами.
\end{itemize}

Эти проблемы приводят в последствии к тому, что система в целом ведет себя не так, как этого хотел бы пользователем, что система вообще не может работать, поскольку при реализации её компонентов разработчики по-разному поняли требования, что срываются сроки, отведённые на реализацию, нарушается бюджет проекта и т.д. и т.п.

В качестве одного из методов обнаружения и избавления от таких проблем в данном курсе рассматриваются формальные спецификации. Идея заключается в том, чтобы описать логику выполнения операций на некотором уровне абстракции на формальном языке (в частности с использованием пре- и пост- выражений зафиксировать в виде формальной спецификации, что изменяется в системе, какой результат операции при этом верный, при каких входных аргументах операция допустима и т.д.). Кроме того, что при составлении таких формальных выражений разработчик лучше разбирается в требованиях, он может еще и применить строгие методики для анализа того, всё ли известно для реализации с точки зрения логики работы системы и нет ли внутренних конфликтов в сформулированных требованиях).

На профессиональном языке такое формальное описание логики выполнения операций называют \emph{формальной моделью поведения}. Поскольку можно выбирать разные уровни абстракции, акцентировать рассмотрение на некоторых характеристиках, игнорируя остальные, то и формальных моделей поведения системы может быть несколько. На самом деле лучше иметь несколько небольших обозримых формальных моделей поведения одной и той же системы, чем одну большую и тяжело воспринимаемую формальную модель. Следует придерживаться мысли о множестве небольших формальных моделей в рамках всего данного курса: получаемый навык заключается в умении формально (или строго) описать поведение системы с точки зрения некоторого (важного) аспекта и анализировать такие формальные описания, выводить новые факты о том, как себя ведет система, и насколько тщательно описаны требования на её поведение.

\section{Строгий подход к формализации поведения системы}

В двух словах, этот подход заключается в систематическом выделении фактов вида <<в 'такой-то' ситуации если выполнить при помощи системы 'такую-то' операцию, то пользователь получит в качестве результата 'то-то', а система перейдет в 'такое-то' состояние>>. На языке логики один такой факт выражается при помощи импликации $$\forall x~ ( ~p(x)~ \Rightarrow ~q(f(x)) ~)$$ а набор фактов --- конъюнкцией таких импликаций. Например, при выполнении операции перехода по ссылке в одном из табов веб-браузера открывается новый таб или открывается новое окно с одним табом, или не открывается ни одного окна, ни одного таба (операция перехода по ссылке выполнилась --- и мы видим \emph{эффект этой операции}: открытие таба или открытие окна, или неоткрытие таба и неоткрытие новых окон, эффект операции в формуле выше обозначен как $q$). В этой модели нас будут интересовать только работа с табами при выполнении различных операций.

Под <<ситуацией>> можно понимать совокупность значений входных параметров, некие условия, при которых эффект операции обладает заданной спецификой (ситуация обозначена в формуле выше как $p$). Например, в ситуации, когда достигнут максимальный предел одновременно показываемых табов, при переходе по ссылке всегда открывается одно новое окно с одним табом. В этом \emph{функциональном требовании} операцией является <<переход по ссылке>>, ситуацией --- <<достигнут предел максимально показываемых табов и потребовано открытие нового таба>>, эффектом операции является <<открыто новое окно с одним новым табом>> (по-хорошему, этот эффект требует дополнения).

Еще несколько примеров. <<При выполнении операции закрытия таба все остальные табы остаются без изменений>> --- ситуация <<таб открыт>>, операция <<закрытие таба>>, эффект <<все табы, кроме закрываемого, не изменились>> (не изменилось их содержимое, заголовок и т.п., в зависимости от того, какие из характеристик таба входят в формальную модель). Заметьте, этот почти очевидный факт неполный. Он позволяет при закрытии таба изменить порядок табов. Тем самым, формальная модель системы с требованием <<при выполнении операции закрытия таба все остальные табы остаются без изменений>> содержит логику выполнения операции по закрытию таба с сохранением порядка и без сохранения порядка. Этот важный вывод о поведении системы получен чисто путем анализа формальной модели. Например, из этого следует, что нельзя утверждать, что если один таб создан позже другого, то всегда будет сохранен их относительный порядок один после другого. Это замечание может оказаться важным при проектировании других операций с табами, которые будут предполагать сохранение относительного расположения табов.

Возникает вопрос, какие факты нужно выделять, сколько фактов нужно выделять (когда фактов достаточно). Если к выделению фактов подойти <<с особым рвением>>, то на каждое состояние системы и значения аргументов операций надо выписать отдельный факт: <<если система находится в 'таком-то' состоянии и аргументы равны 'тому-то', то при выполнении операции произойдет 'то-то'>> (например, если открыт один таб, то при выполнении операции закрытия табов в окне не останется ни одного таба - раз; если открыто два таба и закрывается первый таб, то при выполнении операции закрытия табов в окне остается бывший второй таб - два; если открыто два таба и закрывается второй таб, то при выполнении операции закрытия табов в окне остается бывший первый таб - три; уже получено три факта и это не предел!). Понятно, что так мельчить ситуации не имеет смысла как минимум, если эффект операции в этих ситуациях обладает некоторой общностью. Например, для операции закрытия таба может быть важно, в том же окне находится закрываемый таб, как и интересующие нас таб, или в другом (в первом случае, изменяется набор табов в окне, во втором случае не изменяется). Как минимум, следует выделить все ситуации для операции, в которых поведение системы обладает спецификой (чем-то важным отличается от поведения системы при выполнении операции в других ситуациях)\footnote{под поведением системы при выполнении операции понимается эффект операции}. Поскольку ситуации выражены на формальном языке, можно точно определить, покрывают ли эти ситуации все возможные ситуации, в которых будет выполняться операция. Например, если выделена только ситуация закрытия таба для своего окна, то <<для полноты картины>> нужна ситуация закрытия таба для другого окна (если <<другие окна>> обладают дополнительной спецификой, влияющей на эффект закрытия таба, то требуется выделение для них дополнительных ситуаций). Полное выделение ситуаций --- первый залог того, что поведение системы в спецификации описано полно.

Следующий важный момент --- это слежение за замкнутостью модели. Речь идет вот, о чем. В правильной спецификации не может быть такого, что в результате выполнения операции в некоторой ситуации система приходит в такое состояние, про которое неизвестно, как себя будут вести операции, выполняющиеся из полученного состояния. Грубо говоря, есть строго определенное множество допустимых состояний системы, или \emph{инвариант} состояния системы, за которые операции не имеют права выводить систему. Например, инвариантами могут быть следующие факты: <<количество табов в окне не должно превысить максимально допустимое>>, <<в каждом окне должен быть как минимум один таб>>. Однако при проектировании операций придерживаются более гибкого подхода и допускается пересматривание инварианта, но в этом случае приходится перепроверять уже спроектированные операции для выявления того, во всех ли ситуациях описано их поведение и не требуется ли дополнительно определить поведение системы при выполнении операции из новых состояний, вошедших теперь в инвариант.

В некоторых ситуациях операция не может быть выполнена (например, нельзя закрыть единственный таб в окне --- это приведет к нарушению инварианта (в окне не останется ни одного таба). Знание о том, когда операция невозможна, так же важны, как и знание эффекта операции там, где операция возможна.

Подводя итог, сформулируем следующий подход к формализации поведения системы.

\begin{enumerate}
    \item сформулировать уровень абстракции (например, ограничиваемся рассмотрением логики работы с табами);
    \item выделить множество операций и составить их сигнатуры (например, открытие нового окна, перехода по ссылке, закрытия таба);
    \item сформулировать наиболее общий инвариант на состояние системы (например, в каждом окне должно быть как минимум 1 таб);
    \item далее действовать итеративно до получения полного замкнутого описания поведения системы при выполнении всех операций во всех ситуациях:
        \begin{itemize}
          \item выделить набор ситуаций на очередную операцию и описать эффект операции в этих ситуациях (как минимум, выделить ситуации, в которых операция невозможна);
          \item проверить, что эффект всех операций согласуется с инвариантом;
          \item при необходимости уточнить (усилить) инвариант или расширить (ослабить) инвариант --- при этом снова проверить соответствие эффекта операций во всех ситуациях.
          
%              все функции вызываются в согласии с предусловием
        \end{itemize}
\end{enumerate}

%% следить за тем, чтобы каждая формальная фраза могла быть неформально интерпретирована: общение между людьми ведь осуществляется неформальными фразами

В рамках этого подхода фигурируют условия на состояние системы, аргументы и результаты операций. Чтобы суметь их записать в виде выражений некоторого формального языка, надо выразить на этом языке, какая информация входит в состояние системы в этой формальной модели (например, какие табы входят в какие окна в данный момент), и, используя конструкции языка, выразить необходимые условия. На этом моменте временно прервемся, чтобы познакомиться с самим языком, способами определения состояний и с конструкциями языка.


%понятие предусловия, постусловия:
%
%[Большая цитата из статьи В.Кулямина, 14(1)й том трудов ИСП]
%
%Программный контракт операции состоит из предусловия и постусловия. Первое фиксирует требования к корректному использованию этой операции со стороны окружения системы — при каких ограничениях на аргументы обращение к этой операции корректно. Второе определяет обязательства системы по отношению к результатам вызовов этой операции — какие ограничения на результаты работы операции должны быть выполнены при корректной работе системы, если обращение к ней было правильным. При нарушении предусловия операции обращение к ней может иметь любые последствия, поведение системы в этом случае не определено. Совместно пред- и постусловия строго определяют требования к работе системы.
%
%При анализе сложной системы с большим количеством интерфейсных операций крайне неудобно рассматривать их все вместе как однородный набор, необходимо разбиение этих операций на какие-то логические группы по реализуемым ими функциям. Эти группы почти всегда соответствуют компонентам или модулям системы, ответственным за реализацию этих функций. Часто такие компоненты имеют внутреннее состояние, недоступное для непосредственного наблюдения извне системы, но влияющее на поведение вызываемых операций компонента и изменяемое ими.
%
%Поэтому для описания ограничений в пред- и постусловиях необходимо как-
%то учитывать внутреннее состояние компонента, операции которого
%описываются. Чтобы сделать это возможным, контракты операций одного
%компонента объединяются в спецификацию этого компонента вместе с
%описанием структуры его модельного состояния.
%Структура модельного состояния компонента не обязана совпадать со
%структурой его реального состояния, зафиксированной в его коде, например,
%компонент, реализующий список, может использовать ссылочную структуру
%данных, в том время, как структура его модельного состояния в
%спецификациях может быть основана на массиве. В структуре модельного
%состояния могут совсем отсутствовать некоторые части реального состояния
%компонента, слабо связанные с его функциональностью, например,
%различного рода кэши и другие данные, используемые для увеличения
%производительности. Важно, что структура модельного состояния компонента
%должна содержать данные, достаточные для полного описания
%функциональности в пред- и постусловиях операций этого компонента. При
%этом предусловие зависит от аргументов вызова операции и данных
%модельного состояния при этом вызове, или пре-состояния. Постусловие
%зависит как от аргументов и пре-состояния, так и от результата и данных
%модельного состояния после вызова, или пост-состояния.
%Наличие сложной структуры модельного состояния приводит к
%необходимости учитывать в контрактах операций ограничения на его данные,
%которые должны выполняться в стабильных состояниях системы, когда ни
%одна из операций не выполняется. Такие ограничения оформляются в виде
%инвариантов модельного состояния. Инварианты являются общими частями
%пред- и постусловий всех операций, как-то затрагивающих соответствующие
%компоненты — они должны выполняться как в пре-состоянии любого вызова,
%так и в его пост-состоянии.
%
%
%Обычно постусловие операции описывает несколько разных режимов ее
%функционирования. Предусловие запрещает все комбинации значений
%параметров, при которых поведение операции не определено. Однако среди
%разрешаемых предусловием ситуаций могут остаться такие, в которых
%выполнить свою основную функцию операция не может. Вместо этого она
%должна вернуть некоторый код ошибки, создать исключительную ситуацию
%или как-то иначе сигнализировать о том, что ее основная задача не может
%быть решена в такой ситуации. Помимо режимов сигнализации о
%невозможности выполнить основную функцию, само ее выполнение может
%идти разными путями. Например, операция конкатенации двух строк может
%проверять, не является ли один из ее аргументов пустой строкой, и в этом
%случае просто возвращать копию другого аргумента, не выполняя никаких
%действий над ней. Если же оба аргумента не пусты, копия одного из них
%должна быть подвергнута модификации, чтобы получить результат операции.
%
%При написании постусловий удобно выделять такие разные режимы, иначе
%постусловие превращается в большую и сложную формулу, трудную для
%анализа и понимания, что противоречит основной цели создания формальных
%спецификаций. Различные режимы работы операции описываются в виде
%импликаций с несовместными посылками (постусловие при этом выглядит как формула
%(X1 => Y1) /\ (X2 => Y2) /\ ... (Xn => Yn)
%или в виде разных выражений для
%возвращаемого результата при разных исходных условиях, т.е. результат
%постусловия вычисляется в разных ветвях некоторого условного оператора
%или оператора выбора по-разному. Поэтому эти разные режимы называют
%ветвями функциональности (или функциональными ветвями) операции.

\section*{Задачи}

\zhead{Составить сигнатуры функций и выделить ветви функциональности каждой из них}

..............TODO


\section{Множества, списки, отображения}

.......TODO вступление, что для выражения свойств данных нужно промоделировать эти данные при помощи простейших средств типа множеств, списков, отображений....

\input{model/setlist}  % with problems

\section{Уточнение требований при помощи моделеориентированных спецификаций}

Как сказано в предыдущем разделе, уточнение требований выполняется путем выделения ветвей функциональности, т.е. классов значений входных параметров. В данном разделе предлагается использовать язык множеств, списков и отображений для описания типов параметров и выражений над значениями параметров. При этом для описания ветвей функциональности отдельных операций будет применяться явное или неявное описание. В данном случае оно называется \emph{моделеориентированным} описанием (потому что для параметров задается <<модель>> на языке множеств, списков и отображений).


.............TODO предусловие, запись в явном или неявном виде, замкнутое описание (включает ли выходное состояние....), инвариант.......

.....TODO первая задачка экзамена


\section{Уточнение требований при помощи алгебр}


\chapter{Аналитическая верификация}

\section{Методы Флойда}

\section*{Задачи}

Во всех задачах $x_1, x_2, ...$ --- входные переменные, $y_1, y_2, ...$ --- промежуточные переменные, $z_1, z_2, ...$ --- выходные переменные. Если не сказано противное, входные переменные обладают целыми неотрицательными значениями.

Если в алгоритмах не указано условие у оператора цикла, значит это условие --- тождественная истина (т.е. цикл бесконечный).

\zhead{Доказать частичную корректность следующих числовых алгоритмов\footnote{Часть задач взяты из~\cite{Shen}, часть задач составлены Алексеем Хорошиловым}}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = x_1 \cdot x_2)$

\begin{codebox}
\Procname{$\proc{Multiply}(x_1,x_2)$}
\li $y_1 \gets 0$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_2$
\li \Do $(y_1,~y_2) \gets (y_2 + x_1,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1)~is~true$, $post(x_1, z)~is~(z = x_1 \cdot (x_1 + 1))$

\begin{codebox}
\Procname{$\proc{Arithmetic}(x_1)$}
\li $y_1 \gets 0$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_1$
\li \Do $(y_1,~y_2) \gets (y_1 + 2y_2,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1)~is~true$, $post(x_1, z)~is~(z = x_1 \cdot (x_1 + 1) \cdot (2x_1 + 1))$

\begin{codebox}
\Procname{$\proc{SumSquare}(x_1)$}
\li $y_1 \gets 0$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_1$
\li \Do $(y_1,~y_2) \gets (y_1 + 6y_2\cdot y_2,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = x_1^{x_2})$

\begin{codebox}
\Procname{$\proc{Power}(x_1,x_2)$}
\li $y_1 \gets 1$
\li $y_2 \gets 1$
\li \While $y_2 \leq x_2$
\li \Do $(y_1,~y_2) \gets (y_1 * x_1,~y_2 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~(x_2 > 0)$, $post(x_1, x_2, z)~is~(z = x_1^{x_2})$

\begin{codebox}
\Procname{$\proc{Power}(x_1,x_2)$}
\li $y_1 \gets x_1$
\li $y_2 \gets 1$
\li \While $y_2 < x_2$
\li \Do \If $2y_2 \leq x_2$
\li \Then $(y_1,~y_2) \gets (y_1 * y_1,~2y_2)$
\li \Else $(y_1,~y_2) \gets (y_1 * x_1,~y_2 + 1)$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = x_1^{x_2})$

\begin{codebox}
\Procname{$\proc{Power}(x_1,x_2)$}
\li $y_1 \gets 1$
\li $y_2 \gets 0$
\li \While $y_2 < x_2$
\li \Do \If $y_2 = 0$
\li \Then $(y_1,~y_2) \gets (x_1,~1)$
\li \Else \If $2y_2 \leq x_2$
\li \Then $(y_1,~y_2) \gets (y_1 * y_1,~2y_2)$
\li \Else $(y_1,~y_2) \gets (y_1 * x_1,~y_2 + 1)$ \End \End \End
\li $z \gets y_1$
\end{codebox}

% НОД
\z (<<GCD>> -- greatest common divisor) $pre(x_1, x_2)~is~(x_1 + x_2 > 0)$, $post(x_1, x_2, z)~is~(z = \gcd(x_1,x_2))$

\begin{codebox}
\Procname{$\proc{GCD}(x_1,x_2)$}
\li \If $x_1 > x_2$
\li \Then $y_1 \gets x_1$
\li \Else $y_1 \gets x_2$ \End
\li \While $x_1 \mod y_1 \neq 0 ~\vee~ x_2 \mod y_1 \neq 0$
\li \Do $y_1 \gets y_1 - 1$ \End
\li $z \gets y_1$
\end{codebox}

\z (<<GCD>> -- greatest common divisor) $pre(x_1, x_2)~is~(x_1 + x_2 > 0)$, $post(x_1, x_2, z)~is~(z = \gcd(x_1,x_2))$

\begin{codebox}
\Procname{$\proc{GCD}(x_1,x_2)$}
\li $y_1 \gets x_1$
\li $y_2 \gets x_2$
\li \While $y_1 > 0 ~\wedge~ y_2 > 0$
\li \Do \If $y_1 \geq y_2$
\li     \Then $y_1 \gets y_1 - y_2$
\li     \Else $y_2 \gets y_2 - y_1$ \End \End
\li \If $y_1 = 0$
\li \Then $z \gets y_2$
\li \Else $z \gets y_1$ \End
\end{codebox}

\z (<<LCM>> -- least common multiple) $pre(x_1, x_2)~is~(x_1 + x_2 > 0)$, $post(x_1, x_2, z)~is~(z = 2\cdot \mbox{lcm}(x_1,x_2))$

\begin{codebox}
\Procname{$\proc{2LCM}(x_1,~x_2)$}
\li $(y_1,~y_2,~y_3,~y_4) \gets (x_1,~x_2,~x_2,~x_1)$
\li \While $y_1 \neq 0 ~\wedge~ y_2 \neq 0$
\li \Do \If $y_1 \geq y_2$
\li     \Then $(y_1,~y_4) \gets (y_1 - y_2,~y_3 + y_4)$
\li     \Else $(y_2,~y_3) \gets (y_2 - y_1,~y_3 + y_4)$ \End \End
\li \If $y_1 = 0$
\li \Then $z \gets y_4$
\li \Else $z \gets y_3$ \End
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z = x^2)$

\begin{codebox}
\Procname{$\proc{Square}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~0)$
\li \While $y_1 < x$
\li \Do $(y_1,~y_2,~y_3) \gets (y_1 + 1,~y_2 + 2,~y_2 + y_3)$ \End
\li $z \gets y_1 + y_3$
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z^2 \leq x < (z+1)^2)$

\begin{codebox}
\Procname{$\proc{Sqrt}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~1)$
\li \While
\li \Do $y_2 \gets y_2 + y_3$
\li \If $y_2 > x$
\li \Then break
\li \Else $(y_1,~y_3) \gets (y_1 + 1,~y_3 + 2)$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~(x_1 > 0)~\wedge~(x_2 > 0)$, $post(x_1, x_2, z_1, z_2)~is~(0 \leq z_2 < x_2)~\wedge~(x_1 = z_1 \cdot x_2 + z_2)$

\begin{codebox}
\Procname{$\proc{Division}(x_1, x_2)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~x_1)$
\li \While $y_3 \neq 0$
\li \Do $y_1 \gets if~(y_2 + 1 = x_2)~then~(y_1 + 1)~else~y_1$
\li     $y_2 \gets if~(y_2 + 1 = x_2)~then~0~else~(y_2 + 1)$
\li     $y_3 \gets y_3 - 1$ \End
\li $(z_1,~z_2) \gets (y_1,~y_2)$
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z = x^2)$

\begin{codebox}
\Procname{$\proc{Square}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~1,~1-x)$
\li \While $y_3 < x$
\li \Do \If $odd(y_2)$
\li     \Then $y_1 \gets y_1 + y_2$ \End
\li     $(y_2,~y_3) \gets (y_2 + 1,~y_3 + 1)$ \End
\li $z \gets y_1$
\end{codebox}

$odd(x)$ истинно тогда и только тогда, когда $x$ нечетно.

\z $pre(x)~is~true$, $post(x, z)~is~(z^3 \leq x < (z+1)^3)$

\begin{codebox}
\Procname{$\proc{Cubert}(x)$}
\li $(y_1,~y_2,~y_3) \gets (0,~0,~1)$
\li \While
\li \Do $y_2 \gets y_2 + y_3$
\li     \If $y_2 > x$
\li     \Then break
\li     \Else $y_1 \gets y_1 + 1$
\li             $y_3 \gets y_3 + 6y_1$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x)~is~(x < 102)$, $post(x, z)~is~(z = 91)$

\begin{codebox}
\Procname{$\proc{Century}(x)$}
\li $(y_1,~y_2) \gets (x,~1)$
\li \While $y_1 < 101 ~\vee~ y_2 \neq 1$
\li \Do \If $y_1 > 100$
\li     \Then $(y_1,~y_2) \gets (y_1 - 10,~y_2 - 1)$
\li     \Else $(y_1,~y_2) \gets (y_1 + 11,~y_2 + 1)$ \End \End
\li $z \gets y_1 - 10$
\end{codebox}

\z $pre(x)~is~(x > 1)$, $post(x, z)~is~(z = x^3)$

\begin{codebox}
\Procname{$\proc{Qube}(x)$}
\li $(y_1,~y_2,~y_3) \gets (x,~1,~x)$
\li \While
\li \Do \If $y_2 < y_3$
\li     \Then $(y_1,~y_2) \gets (y_1 + x,~y_2 + 1)$
\li     \Else \If $y_3 = x$
\li         \Then $y_3 \gets y_1$
\li         \Else break \End \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x)~is~true$, $post(x, z)~is~(z = x^2)$

\begin{codebox}
\Procname{$\proc{Square}(x)$}
\li $(y_1,~y_2) \gets (x,~1)$
\li \While $y_2 < x$
\li \Do \If $2y_2 \leq x$
\li     \Then $(y_1,~y_2) \gets (2y_1,~2y_2)$
\li     \Else $(y_1,~y_2) \gets (y_1 + x,~y_2 + 1)$ \End \End
\li $z \gets y_1$
\end{codebox}

\z $pre(x_1, x_2)~is~true$, $post(x_1, x_2, z)~is~(z = {x_1}^{x_2})$ ($0^0~is~1$)

\begin{codebox}
\Procname{$\proc{Power}(x)$}
\li $(y_1,~y_2,~y_3) \gets (x_1,~x_2,~1)$
\li \While $y_2 \neq 0$
\li \Do \If $odd(y_2)$
\li     \Then $(y_2,~y_3) \gets (y_2 - 1,~y_1 \cdot y_3)$
\li     \Else $(y_1,~y_2) \gets (y_1 \cdot y_1,~y_2 / 2)$ \End \End
\li $z \gets y_3$
\end{codebox}

$odd(x)$ истинно тогда и только тогда, когда $x$ нечетно.



% дискретное логарифмирование


%%%\chapter{Поведенческие спецификации}
%%%TBD
%%



%\chapter{Формальные спецификации в различных предметных областях}


%%\chapter{Специфицирование систем реального размера}
%%Спецификация для функции append в <<исполнимой>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value append: L >< L -> L
%%    append(x, y) is x ^ y
%%\end{lstlisting}
%%
%%Спецификация для функции append в <<логической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value append: L >< L -> L
%%    append(x, y) as z
%%    post
%%        len z = len x + len y /\
%%        (all i: Nat :- i isin inds x => z(i) = x(i)) /\
%%        (all i: Nat :- i isin inds y => z(i+len x) = y(i))
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<исполнимой>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%    reverse(x) is
%%        local variable y : L :- y = <..> in
%%            for xi in x do
%%                y := <.xi.> ^ y
%%            end;
%%            y;
%%        end
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<логической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%  reverse(x) as y
%%  post len x = len y /\
%%    (all i: Nat :- i isin inds x => y(i) = x(len x + 1 - i))
%%\end{lstlisting}
%%
%%Спецификация для функции reverse в <<алгебраической>> манере:
%%\begin{lstlisting}
%%type E, L = E*
%%value reverse: L -> L
%%axiom
%%    reverse(<..>) is <..>,
%%    all x, y: L :- reverse(x^y) is reverse(y) ^ reverse(x)
%%\end{lstlisting}
%%
%%Что из этого короче? Что понятнее? Что лучше? (зависит от задачи)
%
%% задача - выбрать и правильно смоделировать самое главное в алгоритме:
%% gzip, протокол MESI, map/reduce, mp3, google chrome... (в зависимости от варианта задания--посмотреть,что интересует молодежь на Хабре) -- так, чтобы другой человек мог сам понять и получить это новое знание. В качестве примера, можно рассмотреть то, что я писал в диссертации - поймут студенты?
%% DOM:
%%http://www.w3.org/TR/DOM-Level-3-Core/core.html#ID-184E7107–???DOM Core 3
%%http://ru.wikipedia.org/wiki/Document_Object_Model-

\appendix
\include{rslprior}

\pagebreak
\addcontentsline{toc}{chapter}{Литература}
\bibliographystyle{gost780s}
\bibliography{rslbooks}

\end{document}
