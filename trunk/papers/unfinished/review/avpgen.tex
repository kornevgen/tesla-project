Инструмент разработан около 1995 года в рамках проекта по тестированию процессора S/390.\cite{AVPGEN} На данный момент (середина 2008 года) инструмент не доступен в сети Интернет, что даёт право рассматривать сейчас эту работу лишь как теоретическую без возможности посмотреть этот инструмент в действии. Кроме генерации тестирующих программ, в \textsc{AVPGEN} входит и симулятор, чтобы кроме тестирующей программы получить сразу и ожидаемый результат исполнения тестирующей программы. Пользователю системы предлагается на специальном языке \textsc{SIGL} описать тестовый шаблон, затем выделить тестовые ситуации, реализовать для них solver'ы (в статье ничего не говорится о том, как это следует делать). Кроме того, в статье ничего не говорится по поводу того, как должен быть устроен симулятор. В опубликованной по инструменту работе слабо прослеживается методическая сторона решения задачи, поэтому скорее эту статью следует считать техническим обзором системы \textsc{AVPGEN}\footnote{однако это не помешало опубликовать статью в довольно известном журнале сообщества \textsc{IEEE} -- несколько авторов статьи являются его членами}.

Итак, основной блок системы \textsc{AVPGEN} (он называется \emph{супервизором}) читает данную ему программу на языке \textsc{SIGL} команду-за-командой, для каждой такой команды строит последовательность команд для процессора и тут же исполняет их на симуляторе. К сожалению, статья не даёт возможности понять все возможности языка \textsc{SIGL}. Команда языка \textsc{SIGL} либо содержит указание кода операции и простейших ограничений на ее аргументы и поведение, либо содержит недетерминированный выбор команд с конкретным кодом операции и простейшими ограничениями на ее аргументы и поведение. Примеры ограничений на аргументы: <<$x:R1$>> -- объявляет синоним имени $x$ и первого операнда команды, <<$R1 = x$>> -- объявляет равенство первого аргумента и значения, связанного с именем $x$ (это ограничение отлично от предыдущего, потому как имя $x$ должно быть определено до этого ограничения). Ограничение на поведение задается просто идентификатором из предопределенного списка идентификаторов, понимаемых solver'ом для этой команды. Команда обрабатывается следующим образом: для очередной команды на языке \textsc{SIGL} либо уже известны оба аргумента, либо известен только один, либо неизвестны оба аргумента. Если аргументы известны, остается проверить выполнение ограничений -- если они выполнены, аргументы передаются на симулятор, если не выполнены, построение теста считается неуспешным, управление передается в супервизор, который фиксирует этот факт и при построении следующего теста попытается избежать этой ситуации. В том случае, когда есть неизвестные аргументы, активизируется один из solver'ов. Он может либо подобрать конкретные аргументы, либо оставить их как есть -- дальнейшая работа будет производиться с аргументами \emph{в символьном виде} (до тех пор, пока это возможно). Biasing???  Ограничения настолько просты, что алгоритм получения значений, удовлетворяющих ограничениям, достаточно прост. Например, <<два значения в сумме приводят к переполнению>> -- значит, надо возвратить одно маленькое и одно большое число. Если используются операции, работающие с памятью, \emph{allocator} выделяет в своей модели памяти место и генерирует операции, необходимые для того, чтобы эта память была выделена при симуляции.

Таким образом, \textsc{AVPGEN} в простейшем виде содержит решение задачи генерации тестирующей программы: для арифметических команд используются простейшие ограничения, для команд, работающих с памятью, используется алгоритм выбора места в памяти для требуемого поведения команды. Остаётся довести эти идеи до той стадии, когда инструментов можно было бы пользоваться. 