В мире используется множество микропроцессоров. Каждый процессор создавался по сформулированным требованиям к нему: процессор должен понимать и выполнять заданным образом определенный набор инструкций. Но реалии таковы, что выходящий с производства процессор не всегда полностью соответствует тем требованиям, которые изначально к нему формулировались. Производители процессоров часто несут финансовые потери в связи с ошибками в выпущенных ими процессорах, обнаруженными уже у потребителя. Чтобы избежать таких ошибок, производители процессоров организовывают исследовательские группы, целью которых является максимально обнаружить ошибки еще в моделях процессоров (до начала серийного выпуска процессоров согласно подготовленным моделям). Зачастую научная сторона работы таких исследовательских групп не выходит за пределы компании-производителя, не получает разрешения на публикацию или такая публикация сильно ограничена. Даже имя возможности публикации, группа зачастую ограничивается разработкой прототипа тестирующей системы, поскольку задача, поставленная перед этой группой, выполнена!\footnote{И еще неизвестно, во что выльется моя работа - как бы она тоже не стала лишь прототипом, поскольку поставленная задача выполнена... А что надо сделать, чтобы она выросла в нечто большее? Дополнительные задачи? Дополнительный интерес со стороны старших? Дополнительная личная инициатива?} Читая каждую статью, нельзя не представлять себе данную ситуацию. Поэтому считаю, что сразу критиковать ту или иную работу за <<недоделанность>> нельзя (это мне с моей позиции (с позиции моей задачи) может казаться, что работа <<не доделана>>, а участники исследовательской группы были уверены, что их инструмент, если не самый лучший, то уж вполне приемлемый).

Если подходить к этому обзору с научной стороны, то нужно понять, в каких работах, в каких статьях эта научная сторона проявлена сильнее. В теоретической математике статья с теоремами и их обоснованиями считается научным результатом. Проверка этого результата выполняется умозрительно с использованием логических рассуждений. В программировании кроме текста с описанием алгоритма для получения результата (нужного качества) необходима и реализация. Один алгоритм можно запрограммировать множеством способов. По сути полезной работой в программировании (если она посвящена решению конкретной задачи) может считаться лишь та, которая обладает доступной реализацией. Зачастую именно из-за отсутствия доступной реализации приходится заново в программировании решать задачи, которые были до этого кем-то решены и неким образом описаны в статье. Современные задачи вышли на такой уровень, что зачастую эти статьи и не дают такой реализации. В них описываются концепции, применяющиеся техники, а для построения работающего прототипа приходится еще много думать. Но бывает и так, что работающего прототипа недостаточно - его либо сложно настроить (что проще написать новый инструмент), либо сложно даже понять, как им пользоваться (в иностранной литературе такая проблема называется <<usability>>). Например, для задачи, которой посвящена эта работа, уже давно применяют одну технику (constraint). Получается, что те, кто применил её не первым, уже не приносят научного вклада в решение задачи?

В чем состоит сама задача. Здесь и далее процессор будем воспринимать, как виртуальную машину. Для этой машины определён набор команд (задано название, количество аргументов, описано поведение команды) и некоторые структурные свойства (количество регистров, параметры кэширования и т.п.). Таким образом, определена \emph{модель процессора}. Задачей тестирования процессора является создание \emph{тестирующих программ} -- программ в кодах процессора (ассемблерных программ). Исходя из модели процессора, известно, какой результат должно дать исполнение тестирующей программы. Тестирование осуществляется запуском тех же тестирующих программ на конкретном процессоре (построенном согласно модели) и сравнением результата работы конкретного процессора с результатом модели. Такая постановка задачи совершенно ничего не говорит о тестирующей программе - <<лишь бы помогала находить ошибки>>. Для повышения вероятности нахождения ошибок (<<повышения качества тестирования>>) тестирующие программы строят целенаправленным образом. Каждая тестирующая программа нацелена на некоторый аспект функционирования процессора - она как бы \emph{покрывает} этот аспект, а все тестирующие программы вместе \emph{обеспечивают покрытие} по аспектам функциональности. Например, тестирующая программа, покрывающая некоторое специфическое поведение некоторой команды, должна быть сконструирована так, чтобы это специфическое поведение проявлялось при её исполнении. О каких <<аспектах функционирования>> идет речь? <<Возникновение переполнения>> у операции сложения - пример такого аспекта функционирования: команда сложения с конкретными аргументами может исполниться так, что процессор сгенерирует сигнал об арифметическом переполнении. Команда, работающая с памятью (по сути, с кэшем) на конкретных аргументах может исполниться так, что процессор сгенерирует сигнал о <<промахе в кэше>> (когда адрес памяти, к которому происходит обращение, не находится в кэше). Это всё примеры аспектов функционирования. Все они должны быть описаны при задании модели процессора. Кроме того, аспекты функционирования могут быть сформулированы, исходя из значений аргументов или состояния процессора. Примерами таких аспектов могут быть <<поведение функции вычитания на одинаковых аргументах>>, <<поведение функции умножения, когда в регистре X находится число 0>> и т.п. Из этих аспектов функционирования можно составлять более сложные, используя логические операции <<И>>, <<ИЛИ>>, <<НЕ>>. Например, <<поведение команды деления, когда аргументы малы и регистр X имеет значение 0>>. Общее название для таких аспектов -- \emph{тестовая ситуация}. Тестовые ситуации составляются перед осуществлением тестирования и являются его целью. Кроме того для оценки качества тестирования вводят метрику -- считают количество покрытых тестовых ситуаций. Это количество делят на общее количество тестовых ситуаций и получают \emph{процент покрытия тестовых ситуаций}, или просто \emph{покрытие}. Тестирующие программы строят таким образом, чтобы получить как можно большее покрытие. Напомню, что это требование к тестирующим программам не является обязательным, но оно является желательным для осуществления как можно более качественного тестирования.

Все инструменты, рассматриваемые далее, предназначены для построения тестирующих программ. Некоторые инструменты разделяют эту задачу на две подзадачи. Первая -- построение тестирующей программы без констант в качестве значений аргументов команд (в этом случае всё равно для каждой команды задается то, как она должна быть выполнена), а вторая -- подбор значения для аргументов каждой команды, согласно требуемому поведению этой конкретной команды. Первую задачу ещё называют задачей построения \emph{тестового шаблона}. Исходя из этого, многие инструменты строятся по следующей схеме: откуда-то берется тестовый шаблон, откуда-то берется описание команд процессора, эти описания транслируются в некоторое промежуточное представление, а дальше применяется алгоритм получения тестовых данных (зачастую это технология ограничений, constraints). Причем тестовый шаблон может быть задан с разной степенью детальности: от последовательности конкретных команд до указаний лишь количества, типа и связей команд внутри одного тестового шаблона.