Hello, dear collegues. My talk is devoted to the core-level verification. It is a part of the whole research about core-level verification. Today talk is devoted to the testing of cache memory only but it contains some our base concepts about test program generation.

This testing is performed using a lot of special assembler programs. They are called as test programs also. Each test program is loaded into the memory, executed on the microprocessor. Each program has the right execution. If real execution on the microprocessor differs from this right execution, then error in microprocessor is found. But this process requires many test programs. How can they be generated ?

They can be generated by the following way based on the model of microprocessor. Exhaustive selection of instructions in interesting for testing situations and dependencies between arguments gets the abstract form of the test programs. This abstract form contains instructions sequence with test situations only. Test program must contain additional instructions for move the microprocessor to the appropriate pre-state before test template execution. ### The rest of the talk is devoted to the method for generation of this appropriate initial state of microprocessor for the given test template. ###
The next I want to draw attention to the some technical features about cache behavior before getting the mathematical model of the problem.

Cache memory contains some data. Each data corresponds to the specific physical address. Memory access instructions (for example, LOAD on the slide) use cache for operating with memory. If desired address is presented in the current state of cache, then corresponding data is loading into the register 'val'. This situation is called 'cache hit' situation.
Another situation is absence of data with desired physical address in the cache. This situation is called 'cache miss' situation. In this situation, value is loaded from the next levels of the cache or in the memory. State of cache is changed by replacing lru cell by loaded value with address 'addr'. lru cell is least recently used cell. It can be defined by access counters. Each acess to address increments its counter. An address is lru if its counter has the minimum value among another counters at this time.

I want to remind the main problem of my talk. There is a test template, i.e. a sequence of the memory access instructions with a sequence of cache situations. Each instruction changes a state of cache. The second arguments of the instructions are addresses, the first arguments are registers for values for storing to or loading from memory. The first instruction (it has cache-hit) increments lru counter of address 'y'. The second instruction (it has cache-miss) removes cell with minimum lru counter from cache and adds address 'z' to the cache. We interests in the initial state of cache and registers such as all situations can be satisfied.

The first idea is using the exhaustive or random searching. It is enough to select values for each registers and addresses of the data in the cache and execute test template from this state. But space of this searching is huge. So this idea is impossible for practical using. Some constraints technics are desirable.

Lets try to express each situation on cache by some equalities and inequalities with functions. Cache-hit is existence non-zero index of element with specific address and incrementing a counter of this address. It can be expressed by function index and function inc_counter. Cache-miss is absence of element in the cache. Function 'index' returns zero for this address. Also functions for removing and adding addresses to the cache can be used to express behavior of the cache-miss. Building of this functional model is simple. But problem of finding values for 'x, y, z, u, and L' such as all these equations and inequations are satisfied is very complex, because most of these functions  are recursive. So this model is also impossible for practical using. ### Idea of constraints using seems to be prospective. But may be another kind of equations are more suitable?

I propose to use equations on the set of addresses to express relations between values of variables. Physical addresses will be variables in this equations. Addresses from the initial state of the cache will be variables also. And test situations will be expressed as relations on the variables.

I want to start from the simple form of the cache. It is called fully associative cache. It contains special amounts of cells - 'N' - for the whole memory. 'N' is called cache associativity. Searching for desired data is performed in-parallel for the whole cache. Because all addresses in the cache are different, current state of the cache will be expressed as the set - 'x, y, z, etc'.

Cache-hit is a property of presence an address in the cache. We access to the cache with address 't'. So if 't' is included in the current state of cache, then cache-hit is occured. So cache-hit will be expressed as including constraint: 't is included in x, y, z, etc'.
Cache-miss is a property of absence an address in the cache. We access to the cache with address 't'. So if 't' is not included in the current state of cache, then cache-miss is occured. So cache-miss will be expressed as not-including constraint: 't' isn't included in x, y, z, etc'. After cache-miss occuring cache is changed by putting 't' to the cache and displacing lru cell from cache. It has to introduce a new variable 'u' for displaced address. It is included into the current state of the cache: 'u is in set of 'x, y, z, etc' and 'u is lru'. ##### I want to emphasize that cache state is presented by set of addresses it contains. Cache-hit is presenting the given address in the cache. So cache-hit is including equation. Cache-miss is absence the given address in the cache. This address is added into the cache and the least recently used address is removed. And how can a property to be of the least recently used address be expressed via sets?

It is expessed by selecting the last access to the address. Consider 'x2' as the last access to the address 'u'. This address will be the least recently used address, if all another cells from the rest of the cache are accessed in range between the last access and removing.  The rest of the cache is 'L without u'. And it must be equal to the set of 'x3 and x5'. If this pair of equations are carry out, then the last memory access instruction removes 'u' (because all other cells has newer access) and adds 't' to the cache.

But we can select 'x1' as the last access to 'u'. This corresponds to another case of the equations' system. And there are another cases when the last access to 'u' was in the initial state of the cache. ##### I want to draw attention that lru constraint is expressed without any counters, any minimizations. Only selection the last access to the displaced address and collecting addresses from test template between the last access and removing.

Lets consider the following example. Consider the already known test template for 3-associativity cache memory. So 'alpha, beta, gamma' will be the initial state of the cache. The first situation is cache hit on address 'y', so the first equation is 'y is included in the set of alpha, beta, gamma'. The second situation is cache miss on address 'z'. So the next equation is not-including constraint: z is not included in alpha, beta, gamma. Address 'z0' is displaced from cache, so it is included in the current state of the cache. Lets beta is the last access to the z0. So the 4th and the 5th equations express the lru property of z0. And the last situation is cache hit on address y. So 'y' is included in the current state of cache. Notice that 'z0' is removed from the  previous cache state and 'z' is added to it.

Then lets solve the set of equations on the right side of the slide. It is not complex and has many solutions. You can see one solution on the left side of the slide. Values for 'alpha, beta, gamma' must be loaded into the cache before test template execution. Registers 'y' and 'z' must be assigned by values 0 and 3 respectively before test template execution. ##### I have demonstrated the whole process of the test data generation. It is started from the equation extraction for each test situation. Each cache hit produces one equation and cache-miss produces 4 equations. Then this equations system for 3-associativity cache has been solved.

Consider the common case of cache memory organization. Whole memory is divided into some regions. And cache memory contains fully associative caches for each region. Cache access is started from identifing corresponding region for given address. Then this address is checked in-parallel among cells of cache memory for this region. Cache-hit situation is occured when the address is presenting in the corresponding to the region part of cache. Cache-miss situation is occured when the address is absent in the corresponding to the region part of cache.
So cache hits and misses can be expressed by the like equations as for the fully associative cache. Current state of cache 'L' is the set of addresses. Cache-hit is including constraint. Cache-miss is not-including constraint with constraints for displaced address. I notice about new equation for cache miss definition. The third equation is equality of regions.

LRU constraint can be expressed by the following way as for fully associative cache. We select the last access to the displaced address. Lets 'x2' is the last access to 'u'. And after the last access to 'u' test template must contain access to the rest of region of the cache. But accesses to the same region must be selected among all addresses accessed between 'x2'and the last miss. It can be expresed by the following equation with intersection the set of addresses with region of 'u'.

The following system of equations can be generated for the whole test template. It contains the including constraints, not-including constraints, equality constraints, equality of the regions of the addreses. But whether resolving of this system is simple?

Yes, it can be reached using special kind of SAT-solver which has special knowledge about bit-vectors theory. It is called SMT-solver (SAT modulo theory). SAT-solver is a tool which gives a predicate and returns answer whether this predicate is satisfiable. Otherwords, whether arguments of the predicate can values for which this predicate is true. SMT-solver gets the predicate also and returns answer whether this predicate is satisfiable. But their predicates can be more interesting. It can contain not only boolean variables but also integers, arrays, terms and bit-vectors.
We use Yices as SMT-solver for our experiments. Equations on sets are transformed to the predicates on pair equality of the addresses. #### I remind of the process for test data generation. At the first special equations on addresses' sets are generated for the test template. Then this equations are transformed to the predicates. And at the finally SMT-solver gets values for addresses and cache contents when generated predicates are satisfied.