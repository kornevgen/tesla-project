My talk is devoted to the core-level verification. More clearer it is devoted to the testing of cache memory.

This testing is performed using a lot of special assembler programs. They are called as test programs also. Each test program is loaded into the memory, executed on the microprocessor. Each program has the right execution. If real execution on the microprocessor differs from this right execution, then error in microprocessor is found. But this process requires many test programs. How can they be generated ?

They can be generated by the following way based on the model of microprocessor. Exhaustive selection of instructions in interesting for testing situations and dependencies between arguments gets the abstract form of the test programs. This abstract form contains instructions sequence with test situations only. Test program must contain additional instructions for move the microprocessor to the appropriate pre-state before test template execution. The rest of the talk is devoted to the method for generation of this appropriate initial state of microprocessor for the given test template.
The next I want to pay attention to the some technical features about cache behavior before getting the mathematical model of the problem.

Cache memory contains some data. Each data corresponds to the specific physical address. Memory access instructions (for example, LOAD on the slide) use cache for operating with memory. If desired address is presented in the current state of cache, then corresponding data is loading into the register 'val'. This situation is called 'cache hit' situation.
Another situation is absence of data with desired physical address in the cache. This situation is called 'cache miss' situation. In this situation value is loaded from the next levels of the cache or in the memory. State of cache is changed by replacing lru cell by loaded value with address 'addr'. lru cell is least recently used cell. It can be defined by access counters. Each acess to address increments its counter. An address is lru if its counter has the minimum value among another counters at this time.

I want to remind the main problem of my talk. There is a test template, i.e. sequence of memory access instructions with sequence of cache situations. Each instruction changes a state of cache. And we interests of the initial state of cache and registers.

The first idea is using the exhaustive or random searching. It is enough to select values for each registers and addresses of the data in the cache and execute test template from this state. But space of this searching is huge. So this idea is impossible for practical using. Some constraints technics are desirable.

Lets try to express each situation on cache by some equalities and inequalities with functions.
Функция index вычисляет номер элемента с данным адресом в кэш-памяти или 0, если такого элемента в кэш-памяти нет. Функция inc_counter возвращает новое состояние кэш-памяти, в котором увеличен счетчик адреса. Кэш-попадание может быть легко выражено в виде ограничений с использованием этих функций. Для определения кэш-промаха потребуются функции, добавляющие и удаляющие ячейку с заданным адресом, а также   .... . Построение такой модели сделать легко, но она очень сложна для resolving. Например, для последнего ограничения надо выразить L''' через L, y, z  ...   So this model is also impossible for practical using. May be another constraints would be more perspective? Another kind of equations?

####
So we can try to use for cache behavior the same methods as for the software. We have to introduce some functions to describe changes of the cache state and relations between values for variables. But this functions for cache behavior is very hard. They contain optimization problems and functions with cycles.
######

I propose to use equations on the set of addresses to express relations between values of variables. Physical addresses will be variables in this equations. Addresses from the initial state of the cache will be variables also. And test situations will be expressed as relations on the variables.

I want to start with the simple form of the cache - fully associative cache. It contains special amounts of cells - 'N' - for the whole memory. Searching for desired data is performed in-parallel for the whole cache. Because all addresses in the cache are different, current state of the cache will be expressed as the set - 'x, y, z, etc'.

Cache-hit is a property of presence an address in the cache. We access to the cache with address 't'. So if 't' is included in the current state of cache, then cache-hit is occured. So cache-hit will be expressed as including constraint: 't is included in x, y, z, etc'.

Cache-miss is a property of absence an address in the cache. We access to the cache with address 't'. So it 't' is not included in the current state of cache, then cache-miss is occured. So cache-miss will be expressed as not-including constraint: 't' isn't included in x, y, z, etc'. After cache-miss occuring cache is changed by putting 't' to the cache and displacing lru cell from cache. This logic can be expressed by the following expression for the next state of cache: 'x, y, z, etc' with 't' and without what?

A new variable 'u' have to be introduced. It is included into the current state of the cache: 'u is in set of 'x, y, z, etc' and 'u is lru'. How a property of least recently used address can be expressed ?

Lets select the last access to the address 'u' (lets it would be 'x2'). And after the last access test template must contain access to the rest of the cache. The rest of the cache is 'L without u'. And it is equal to the set of 'x3 and x5'. If this pair of equations are carry out, then the last memory access instruction removes 'u' (because all other cells has newer access) and adds 't' to the cache.

But we can select 'x1' as the last access to 'u'. This corresponds to another case of the equations' system. And there are another cases when the last access to 'u' was in the initial state of the cache.

Lets consider the following example. Consider the already known test template for 3-associativity cache memory. So 'alpha, beta, gamma' will be the initial state of the cache. The first situation is cache hit on address 'y', so the first equation is 'y is included in the set of alpha, beta, gamma'. The second situation is cache miss on address 'z'. So the next equation is not-including constraint: z is not included in alpha, beta, gamma. Address 'z0' is displaced from cache, so it is included in the current state of the cache. Lets beta is the last access to the z0. So the 4th and the 5th equations express the lru property of z0. And the last situation is cache hit on address y. So 'y' is included in the current state of cache. Notice that 'z0' is removed from the  previous cache state and 'z' is added to it.

Then lets solve the set of equations on the right side of the slide. It is not complex and has many solutions. You can see one solution on the left side of the slide. Values for 'alpha, beta, gamma' must be loaded into cache before test template execution. Registers 'y' and 'z' must be assigned by these values before test template execution.

In the common case of cache whole memory is divided into some regions. And cache contains fully associative cache for each region.

For the common case of cache hits and misses can be expressed by the like equations as for the fully associative cache. Current state of cache 'L' is the set of addresses. Cache-hit is including constraint. Cache-miss is not-including constraint with constraints for displaced address.

LRU constraint can be expressed by the following way as for fully associative cache. We select the last access to the displaced address. Lets 'x2' is the last access to 'u'. And after the last access to 'u' test template must contain access to the rest of region of the cache. But accesses to the same region must be selected among all addresses accessed between 'x2'and the last miss. It can be expresed by the following equation with intersection the set of addresses with region of 'u'.

The following system of equations can be generated for the whole test template. It contains the including constraints, not-including constraints, equality constraints, equality of the regions of the addreses. But whether resolving of this system is simple?

Yes, it can be reached by using special kind of SAT-solver which has special knowledge about bit-vectors theory. This solver is SMT-solver. SMT is acronym for SAT Modulo Theory. We use Yices for our experiments. Equations on sets are transformed to the pair equality and inequality of the addresses. Solver gets  values for the variables on which all constraints are satisfied. Otherwords,  it can generate desired values of addresses and initial state of cache.