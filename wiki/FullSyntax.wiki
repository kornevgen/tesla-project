#summary Грамматика языка описания тестовых ситуаций
#labels Featured
{{{
program :
	( 'VAR' ('RESULT' | 'READONLY' | 'OPTIONAL')? ID ':' INTEGER )-list[ ';' ]
	( 'ASSERT' boolexpr | ID '<-' expr | procedure )-list[ ';' ]
	;

procedure
        : 'LoadMemory(' ID ',' INTEGER ',' addr = ID ',' vAddr = ID ',' ('DATA'|'INSTRUCTION') ')'
        | 'StoreMemory(' ID ',' INTEGER ',' addr = ID ',' vAddr = ID ',' ('DATA'|'INSTRUCTION') ')'
        | 'AddressTranslation(' ID ',' ID ',' ('DATA'|'INSTRUCTION') ',' ('LOAD'|'STORE') ')'
        ;
	
boolexpr : boolexpr_brackets-list[ 'AND', 'OR' ] ;
// AND имеет более высокий приоритет, чем OR
	
boolexpr_brackets 
	: ID '(' ID-list[','] ')'
	| '(' boolexpr ')'
	| expr ( '>-' | '<-' | '>=-' | '<=-' | '>+' | '<+' | '>=+' | '<=+' | '=' | '#' ) expr
	;

expr : bit_expr-list[ '+', '-', '><+', '><-' ] ;
// умножение (><+ и ><-) имеет выше приоритет, чем сложение и вычитание

bit_expr 
	: bit_term
	| '(' INTEGER ')' bit_expr  // знаковое расширение
	| bit_expr '||' bit_expr 	// конкатенация
	| bit_term '[' INTEGER ']'
	| bit_term '[' INTEGER .. INTEGER ']'
	| bit_term '^' INTEGER
	;
// "знаковое расширение" имеет здесь самый низкий приоритет
// затем следующий приоритет у конкатенации
// все остальные операции имеют одинаковый самый высокий здесь приоритет

bit_term 
	: ID | INTEGER | '(' expr ')' ;

ID	: ('a'..'z'| 'A'..'Z' ) ('a'..'z' | '_' | 'A'..'Z' | '0'..'9')*;
INTEGER :  ('0' .. '9' )+;

возможны многострочные комментарии и однострочные в стиле Java
}}}

= Семантические правила языка описания тестовых ситуаций =
  # количество указанных для команды аргументов должно совпадать с количеством указанных переменных RESULT и READONLY (в сумме) в описании тестовой ситуации
  # количество указанных для команды дополнительных аргументов не должно превышать количество указанных переменных OPTIONAL в описании тестовой ситуации
  # битовые длины указанных для команды аргументов и дополнительных аргументов должны совпадать с битовыми длинами соответствующих переменных в описании тестовой ситуации
  # имена аргументов команды, соответствующих переменным-результатам тестовой ситуации (т.е. помеченным словом RESULT), должны быть разными (для одного элемента тестового шаблона)
  # переменные не могут менять свои битовые длины - битовая длина переменной, возникающей в операторе присваивания, вычисляется по битовой длине присваиваемого выражения
  # переменная, помеченная в сигнатуре статусом READONLY, не может быть изменена оператором присваивания
  # переменная, помеченная в сигнатуре статусом RESULT, считается изменяемой, даже если это не сказано явно
  # битовые длины сравниваемых, складываемых, умножаемых выражений должны совпадать - битовая длина результата сложения и вычитания равна битовой длине выражений-операндов 
  # в операторе получения битового диапазона левая константа не должна быть меньше правой константы

= Замечания по языку описания тестовых ситуаций =
  # каждая необъявленная явно переменная получает свое определение (имя и размер) при первом присваивании и не меняет их в течение всей тестовой ситуации (значение она менять может)
  # отсутствует логический оператор отрицания
  # отсутствуют логические константы
  # числа представляются в виде списка битовых частей числа (конкатенация которых дает полное число) - все битовые части имеют одинаковый размер, что является параметром работы решателя; известен пример семейства схем тестовых воздействий, все схемы в котором разных размеров, на котором подмножество успешно решаемых схем зависит от размера битовой части в представлении чисел! Из-за конструктивных особенностей системы ECLiPSe этот размер не может превышать 51.
  # сложение чисел выполняется в модульной арифметике по модулю 2^битовая длина операндов
  # умножение выполняется точно (полностью)
  # нет лексического способа задать константу с отрицательным значением; однако ее можно получить операцией вычитания
  # процедура получения случайного значения из множества возможных не всегда дает ответ за приемлимое время; встроенная в ECLiPSe процедура получения всегда одного значения работает быстрее, но при разных запусках дает одно и то же значение