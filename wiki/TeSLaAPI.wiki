#summary описание API решателя TeSLa
#labels Featured

= Описание интерфейса TeSLa =

Основная процедура для вызова решателя:
{{{
( new ru.teslaprj.Solver( sourcepath, libpath ) ).solve( scheme, cacheLevels );
}}}
  * sourcepath - `java.io.File` - директория файловой системы, в которой лежат описания тестовых ситуаций (причем описания тестовых ситуаций, относящихся к одной команде, должны находиться в одной поддиректории с именем этой команды)
  * libpath - `java.io.File` - директория файловой системы, в которой лежат логические модули (их надо скачать - имя архива с ними начинается на clp); в данную директорию должна быть разрешена запись

Для вызова необходимо построить параметры:
  * scheme - схема тестовой программы
  * cacheLevels - список уровней кэша
Возвращает эта процедура объект класса `ru.teslaprj.Solver.Verdict` . (см.ниже)

При выполнении процедуры `solve` могут возникнуть исключительные ситуации:
  * `com.parctechnologies.eclipse.Fail` - ответа не существует, т.е. невозможно подобрать начальные значения регистров, значения констант и состояние кэша так, чтобы реализовать заданное в схеме тестовое воздействие
  * `java.io.IOException` - всевозможные ошибки ввода/вывода (в основном, это ошибки на несуществование файлов (например, описаний тестовых ситуаций) или директорий)
  * `com.parctechnologies.eclipse.EclipseException` - ошибка при запуске логического интерпретатора с ограничениями ECLiPSE (при возникновении надо проверить, установлена ли переменная среды `eclipse.directory` и в правильную ли директорию)
  * `org.antlr.runtime.RecognitionException` - синтаксическая ошибка в описании тестовой ситуации (проверьте соответствие описания синтаксису, приведенному на этом сайте)
  * `ru.teslaprj.syntax.SemanticException` - семантическая ошибка в описании тестовой ситуации (проверьте выполнение всех семантических требований на описание тестовой ситуации)

Процедура может работать очень долго. Обычно выполнение более 20 секунд можно считать несуществованием ответа, поскольку в некоторых случаях доказательство этого факта требует просмотра всей области значений всех переменных (что и может проходить слишком долго).

== Задание схемы тестовой программы ==

1. Создание пустой схемы тестовой программы:
{{{
ru.teslaprj.scheme.Scheme s = new ru.teslaprj.scheme.Scheme();
}}}
Схему можно наполнять определением регистров, констант, командами и зависимостями между переменными.

2. Каждый задействованный регистр должен иметь определение в схеме. Его определение добавляется так:
{{{
ru.teslaprj.scheme.Scheme s = ... ;
s.addDefinition( new ru.teslaprj.scheme.RegisterDefinition( "имя регистра", битовая-длина ) );
}}}
Например, `s.addDefinition( new RegisterDefinition( "r1", 64 ) );`
Определения разных регистров независимы друг от друга. Все регистры в рамках данной схемы должны иметь различные имена (в противном случае, при попытке добавить регистр с уже имеющимся именем будет сгенерирована исключительная ситуация).

3. Каждая задействованная константа (например, смещение адреса в команде обращения в память) должна быть так же определена в схеме. Ее определение добавляется следующим образом:
{{{
s.addDefinition( new ru.teslaprj.scheme.ConstDefinition( "имя константы", битовая длина ) );
}}}
Например, `s.addDefinition( new ConstDefinition( "offset", 16 ) );`
Определения разных констант независимы друг от друга. Все константы в рамках данной схемы должны иметь различные имена (в противном случае, при попытке добавить константу с уже имеющимся именем будет сгенерирована исключительная ситуация).
Имена регистров и констант не могут совпадать (в противном случае, при попытке добавить константу/регистр с уже известным в этой схеме именем будет сгенерирована исключительная ситуация).

4. Необходимо в заданном порядке наполнить схему командами.
Общий вид команды: 
{{{
КОП параметры [; доп.параметры] @ тестовая ситуация[( параметры тестовой ситуации )]
}}}
Примеры: 

`ADD x, y, z @ noexception`

`LW r1, r2, r3 ; v, p, p1 @ noexception( LoadMemory: l1Miss, l2Hit ; AddressTranslation: mtlbHit )`
{{{
ru.teslaprj.scheme.Command command = new ru.teslaprj.scheme.Command( КОП, параметры, доп.параметры, тестовая ситуация, параметры тестовой ситуации ); 
}}}
  * КОП - String - код операции (по сути, имя папки, где располагается описание тестовой ситуации на TeSLa); например, "LW"
  * параметры - List<String> - имена параметров в том порядке, в каком они должны идти в команде; каждый параметр должен иметь свое определение (см.пред.пункты); параметры-результаты не должны быть одинаковыми переменными; пример - <"x", "y", "z">
  * доп.параметры - List<String> | null - имена доп.параметров в том порядке, в каком они должны идти в команде. Если доп.параметров нет, можно передать либо пустой список, либо null; все доп.параметры должны иметь разные имена; пример - <"v", "p", "p1">
  * тестовая ситуация - String - имя тестовой ситуации (по сути, имя файла с описанием тестовой ситуации на TeSLa); например, "noexception"
  * параметры тестовой ситуации - Map< String, Set<String> > - отображение имени операции (которая встречается в описании тестовой ситуации) в множество идентификаторов, задающих ее исполнение; например, < "LoadMemory" +> <"l1Miss", "l2Hit">, "AddressTranslation" +> <"mtlbHit"> >
Определение заданной в команде тестовой ситуации берется из файла, расположенного в sourcepath\КОП\тестоваяситуация.tsl . Например, для команды `ADD x, y, z @ overflow` будет задействован файл sourcepath\ADD\overflow.tsl . Если такой файл не будет найден, будет сгенерирована исключительная ситуация.
Как только команда построена, ее можно добавлять в схему:
{{{
ru.teslaprj.scheme.Scheme s = ...; ...
s.addCommand( command );
}}}

5. Кроме команд, в схему можно добавлять произвольное количество ограничений на переменные, встретившиеся в качестве параметров команд или доп.параметров команд.
Общий вид ограничения:
{{{
параметры @ имя ограничения
}}}
Примеры:

`p, p1 @ sameSet`

`x, y @ less`
{{{
ru.teslaprj.scheme.Assert asrt = new ru.teslaprj.scheme.Assert( параметры, имя ограничения );
}}}
  * параметры - List<String> - имена параметров в том порядке, в каком они нужны в ограничении; например, <"x", "y">
  * имя ограничения - String - имя файла с описанием ограничения на TeSLa; например, "less"

== Вердикт работы решателя ==
Процедура solve возвращает объект класса `ru.teslaprj.Solver.Verdict`, который содержит результат его работы. Основные его методы:
  * `Map<Definition, BigInteger> getDefinitionValues()` - возвращает начальные значения имен, которым давались определения (т.е. значения констант и начальные значения регистров - "начальные" значит "перед исполнением тестовой программы"); например, < Definition("x",32) +> 20 , Definition("offset",16) +> -579 > Значение константы достаточно просто встроить в команду при генерации тестовой программы. Начальное значение регистра надо преобразовать в команды загрузки значений в регистры и разместить их перед тестовой программой.
  * `List< Map<Long, List<Long>> > getCacheInitialization()` - возвращает список (по уровням кэшей) отображений номеров set'ов в список тегов, которые в нем должны быть; например, < < 1 +> <56,80,174,20> > , <> > По этому объекту необходимо перед тестовой программой добавить несколько команд, дающих в указанных set'ах указанные теги (причем они отсортированы по lru)